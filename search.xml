<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker Network（网络）使用指南</title>
      <link href="/2025/09/03/Docker/docker_network/"/>
      <url>/2025/09/03/Docker/docker_network/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#docker-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86">Docker 为什么需要网络管理</a></li><li><a href="#docker-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B">Docker 网络架构简介</a><ul><li><a href="#1-cnmcontainer-network-model">1. CNM（Container Network Model）</a></li><li><a href="#2-libnetwork">2. Libnetwork</a></li><li><a href="#3-%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8drivers">3. 网络驱动（Drivers）</a></li></ul></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B">常见网络类型</a><ul><li><a href="#1-bridge-%E7%BD%91%E7%BB%9C%E9%BB%98%E8%AE%A4%E7%BD%91%E7%BB%9C">1. <strong>Bridge 网络（默认网络）</strong></a></li><li><a href="#2-host-%E7%BD%91%E7%BB%9C">2. <strong>Host 网络</strong></a></li><li><a href="#3-container-%E7%BD%91%E7%BB%9C">3. <strong>Container 网络</strong></a></li><li><a href="#4-none-%E7%BD%91%E7%BB%9C">4. <strong>None 网络</strong></a></li><li><a href="#5-overlay-%E7%BD%91%E7%BB%9C">5. <strong>Overlay 网络</strong></a></li></ul></li><li><a href="#docker-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">docker 网络管理命令</a><ul><li><a href="#%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95">命令清单</a></li><li><a href="#docker-network-create">docker network create</a></li><li><a href="#docker-network-inspect">docker network inspect</a></li><li><a href="#docker-network-connect">docker network connect</a></li><li><a href="#docker-network-disconnect">docker network disconnect</a></li><li><a href="#docker-network-prune">docker network prune</a></li><li><a href="#docker-network-rm">docker network rm</a></li><li><a href="#docker-network-ls">docker network ls</a></li><li><a href="#%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB">指令汇总</a></li></ul></li><li><a href="#%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3">网络详解</a><ul><li><a href="#docker-bridge-%E7%BD%91%E7%BB%9C">docker Bridge 网络</a></li><li><a href="#docker-host-%E7%BD%91%E7%BB%9C">docker Host 网络</a></li><li><a href="#docker-container-%E7%BD%91%E7%BB%9C">docker Container 网络</a></li><li><a href="#docker-none-%E7%BD%91%E7%BB%9C">docker none 网络</a></li></ul></li></ul><!-- tocstop --><h2><span id="docker-为什么需要网络管理">Docker 为什么需要网络管理</span></h2><p>容器的网络默认与宿主机及其他容器相互隔离，这样能够确保容器运行环境的独立性与安全性。但在实际应用中，我们往往不仅仅需要“隔离”，还会遇到一系列与网络相关的需求与挑战，例如：</p><ul><li><strong>容器间通信</strong>：当应用被拆分为多个微服务部署在不同容器中时，这些容器必须能够彼此通信，例如 Web 服务需要调用数据库容器。</li><li><strong>容器与宿主机通信</strong>：开发、调试或日志收集场景下，往往需要容器与宿主机建立交互通道。</li><li><strong>容器与外部主机通信</strong>：如果容器中运行的是 Web 应用、Nginx、数据库等服务，就必须让外部客户端能够访问容器内部的网络应用。</li><li><strong>容器网络隔离与共享</strong>：有些容器需要完全独立的网络空间以确保安全，而另一些容器则可能需要共享网络（如与宿主机使用同一个网络栈）以实现更直接的通信。</li><li><strong>无网络模式</strong>：部分场景下，容器完全不需要网络访问，此时可以选择禁用网络以进一步提升安全性与轻量化。</li><li><strong>定制化网络需求</strong>：在复杂的分布式架构或集群环境中，我们可能需要构建定制化的网络，例如跨主机的容器集群网络、虚拟局域网 (VLAN)、服务发现与负载均衡等。</li></ul><p>正是因为存在以上多样化的需求，Docker 提供了灵活的 <strong>网络管理机制</strong>。通过不同的网络模式（如 <strong>bridge、host、none、overlay、自定义网络</strong> 等），我们能够针对不同的应用场景选择合适的方案：</p><ul><li>使用 <strong>bridge 网络</strong> 解决单机多容器通信问题；</li><li>使用 <strong>host 网络</strong> 让容器与宿主机共享网络栈；</li><li>使用 <strong>none 网络</strong> 禁止网络访问，提升安全性；</li><li>使用 <strong>overlay 网络</strong> 跨主机搭建集群网络；</li><li>使用 <strong>自定义网络</strong>，实现更精细的网络控制与隔离。</li></ul><p>因此，容器网络不仅仅是基础设施的一部分，更是 <strong>容器编排、服务治理和系统安全的核心环节</strong>。合理的网络管理，能够让 Docker 容器真正成为灵活、可扩展的微服务运行环境。</p><hr><h2><span id="docker-网络架构简介">Docker 网络架构简介</span></h2><p>Docker 容器网络是容器虚拟化环境中至关重要的一环。它让应用程序能够在隔离的网络环境中运行，拥有独立的 <strong>网络设备、IP 协议栈、端口套接字、路由表、防火墙规则以及 DNS 配置</strong>。通过这种方式，容器可以与宿主机网络解耦，同时实现灵活的网络通信与隔离。</p><p>为了实现这一目标，Docker 网络架构主要由三大核心部分组成：<strong>CNM（Container Network Model）、Libnetwork 和 网络驱动（Drivers）</strong>。</p><hr><h3><span id="1-cnmcontainer-network-model">1. CNM（Container Network Model）</span></h3><p>CNM 是 Docker 采用的容器网络设计规范，它定义了容器网络的基础组成元素和交互方式。CNM 包含三个核心组件：</p><ul><li><p><strong>Sandbox（沙箱）</strong><br>Sandbox 提供容器的虚拟网络栈，包括端口、套接字、IP 地址、路由表、防火墙、DNS 配置等。它的主要作用是将容器网络与宿主机网络隔离开，确保每个容器拥有独立的网络环境。</p></li><li><p><strong>Network（网络）</strong><br>Network 可以理解为 Docker 内部的虚拟子网，它将多个容器组织在同一个逻辑网络空间内，使其能够直接通信。一个 Network 就像传统网络中的一个局域网。</p></li><li><p><strong>Endpoint（端点）</strong><br>Endpoint 是连接 Sandbox 与 Network 的接口，相当于虚拟网卡。一个容器如果需要加入多个网络，就必须拥有多个 Endpoint。<br>例如，容器 B 有两个 Endpoint，分别接入 Network A 和 Network B。那么容器 A 和 B 可以通过 Network A 通信，而容器 B 和 C 可以通过 Network B 通信，但容器 A 和 C 不能通过 B 的两个 Endpoint 间接通信。</p></li></ul><p>通过 CNM 的定义，Docker 能够以模块化的方式管理容器的网络栈，实现 <strong>灵活的连接方式</strong> 与 <strong>清晰的网络拓扑结构</strong>。</p><hr><h3><span id="2-libnetwork">2. Libnetwork</span></h3><p><strong>Libnetwork</strong> 是 CNM 的官方标准实现。它是一个开源库，由 Go 语言编写，Docker 网络的核心逻辑均基于此实现。</p><p>Libnetwork 完整实现了 CNM 的三个组件（Sandbox、Network、Endpoint），并在此基础上提供了更多高级功能：</p><hr><p><img src="/img/Docker/network/cnm.png" alt="cnm"></p><hr><ul><li><strong>本地服务发现</strong>：容器之间可以通过名字互相访问，而不必依赖固定的 IP 地址。</li><li><strong>负载均衡（Ingress）</strong>：对接入同一服务的多个容器自动分配请求，实现内置的负载均衡机制。</li><li><strong>网络管理与控制层</strong>：提供对容器网络的统一管理接口，使得用户能够通过 Docker CLI 或 API 灵活操作网络。</li></ul><p>Libnetwork 的出现让 Docker 网络不再是一个“黑盒”，而是一个 <strong>可扩展、可编排的网络平台</strong>。</p><hr><h3><span id="3-网络驱动drivers">3. 网络驱动（Drivers）</span></h3><p>驱动是 Docker 网络的实际执行者，负责 <strong>数据层</strong> 的实现，例如容器之间的连通性、网络隔离、安全策略等。不同驱动对应不同的网络模式，Docker 内置了多种原生驱动：</p><ul><li><p><strong>Bridge Driver（桥接网络）</strong><br>默认网络驱动，在单机环境下最常用。容器之间通过虚拟网桥（docker0）互联，外部访问则通过端口映射实现。</p></li><li><p><strong>Host Driver（主机网络）</strong><br>容器与宿主机共享同一个网络命名空间，没有额外的虚拟层，性能较好，但隔离性较差。</p></li><li><p><strong>Overlay Driver（覆盖网络）</strong><br>用于跨主机容器通信，依赖 VXLAN 技术构建虚拟的二层网络，是 Docker Swarm 和 Kubernetes 集群中常用的网络模式。</p></li><li><p><strong>Macvlan Driver（MACVLAN 网络）</strong><br>为容器分配独立的 MAC 地址，使其像真实物理机一样接入物理网络。适合需要直接暴露在局域网中的应用。</p></li><li><p><strong>Ipvlan Driver（IPVLAN 网络）</strong><br>与 Macvlan 类似，但容器共享父接口的 MAC 地址，仅分配独立 IP。性能更高，适合大规模网络场景。</p></li><li><p><strong>None Driver（无网络）</strong><br>容器启动后完全没有网络接口，适用于安全需求极高或只需本地计算的场景。</p></li></ul><p>除了内置驱动外，Docker 还支持通过插件机制扩展网络驱动，例如接入 <strong>Calico、Weave、Flannel</strong> 等第三方网络方案，以满足云原生和大规模分布式场景的需求。</p><hr><p>Docker 网络架构通过 <strong>CNM 规范 → Libnetwork 实现 → 驱动执行</strong> 的层层分工，构建出一个既灵活又可扩展的网络系统。</p><ul><li>CNM 定义了模型，提供抽象；</li><li>Libnetwork 作为实现，负责管理；</li><li>驱动作为底层，保障网络连通性与隔离性。</li></ul><p>这种分层设计让 Docker 网络既能满足 <strong>单机开发环境的简单需求</strong>，也能扩展到 <strong>分布式集群的复杂网络场景</strong>，为容器化应用的广泛落地奠定了坚实的基础。</p><hr><h2><span id="常见网络类型">常见网络类型</span></h2><p>Docker 提供了多种网络模式，以满足不同场景下的通信与隔离需求。常见的网络类型如下：</p><hr><h3><span id="1-bridge-网络默认网络">1. <strong>Bridge 网络（默认网络）</strong></span></h3><ul><li><p><strong>原理</strong>：Bridge 驱动会在宿主机上创建一个 Linux 网桥（默认是 <code>docker0</code>）。同一主机上的容器如果加入同一个 bridge 网络，就可以直接互相通信。</p></li><li><p><strong>特点</strong>：</p><ul><li>容器拥有独立的 IP 地址（由 Docker 分配）。</li><li>容器与外部通信时需要通过端口映射 (<code>-p</code>)。</li><li>默认创建容器时，如果不指定 <code>--network</code>，就会加入 <code>bridge</code> 网络。</li></ul></li><li><p><strong>适用场景</strong>：多个容器运行在同一台宿主机上，需要互相通信时使用。</p></li><li><p><strong>示例命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器并加入默认 bridge 网络</span></span><br><span class="line">docker run -d --name web1 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自定义 bridge 网络</span></span><br><span class="line">docker network create --driver bridge my_bridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器并加入自定义网络</span></span><br><span class="line">docker run -d --name web2 --network my_bridge nginx</span><br></pre></td></tr></table></figure></li></ul><p>在宿主机上，<code>docker0</code> 网桥可以通过 <code>ifconfig</code> 或 <code>ip addr</code> 查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br></pre></td></tr></table></figure><p>这里的 <code>172.17.0.1</code> 就是宿主机在容器内部网络中的网关地址。</p><hr><h3><span id="2-host-网络">2. <strong>Host 网络</strong></span></h3><ul><li><p><strong>原理</strong>：容器直接使用宿主机的网络栈，没有独立的 IP 地址和网卡。</p></li><li><p><strong>特点</strong>：</p><ul><li>容器与宿主机共享网络命名空间。</li><li>端口不再需要映射，容器内暴露的端口即宿主机端口。</li><li>性能较好，但容器间隔离性降低。</li></ul></li><li><p><strong>适用场景</strong>：需要高性能网络访问，或需要让容器直接暴露在宿主机网络中的场景（如运行监控代理）。</p></li><li><p><strong>示例命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name web --network host nginx</span><br></pre></td></tr></table></figure></li></ul><hr><h3><span id="3-container-网络">3. <strong>Container 网络</strong></span></h3><ul><li><p><strong>原理</strong>：新容器共享已有容器的网络命名空间（包括 IP、端口）。</p></li><li><p><strong>特点</strong>：</p><ul><li>新容器不会分配新的 IP，而是直接与目标容器共享网络栈。</li><li>两个容器之间通过 <code>lo</code>（回环接口）通信。</li><li>除了网络共享外，文件系统、进程等依旧隔离。</li></ul></li><li><p><strong>适用场景</strong>：运行调试工具容器（如 tcpdump、curl），直接进入目标容器的网络环境。</p></li><li><p><strong>示例命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先运行一个容器</span></span><br><span class="line">docker run -d --name web nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新容器共享 web 的网络</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --network container:web busybox sh</span><br></pre></td></tr></table></figure></li></ul><hr><h3><span id="4-none-网络">4. <strong>None 网络</strong></span></h3><ul><li><p><strong>原理</strong>：容器拥有独立的 Network Namespace，但不做任何网络配置。</p></li><li><p><strong>特点</strong>：</p><ul><li>容器没有网卡、IP、路由等信息。</li><li>处于完全网络隔离状态。</li></ul></li><li><p><strong>适用场景</strong>：对安全性要求极高，或容器仅需执行纯计算、文件处理而无需网络时。</p></li><li><p><strong>示例命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network none nginx</span><br></pre></td></tr></table></figure></li></ul><hr><h3><span id="5-overlay-网络">5. <strong>Overlay 网络</strong></span></h3><ul><li><p><strong>原理</strong>：基于 VXLAN 技术，在多个 Docker 主机之间创建虚拟的二层网络。</p></li><li><p><strong>特点</strong>：</p><ul><li>允许运行在不同主机上的容器进行通信。</li><li>常用于 Docker Swarm、Kubernetes 等容器编排场景。</li><li>需要启用集群管理（Swarm 或其他插件）。</li></ul></li><li><p><strong>适用场景</strong>：跨主机容器集群通信、多服务协同工作。</p></li><li><p><strong>示例命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 Swarm</span></span><br><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 overlay 网络</span></span><br><span class="line">docker network create -d overlay my_overlay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在集群中运行服务并加入 overlay 网络</span></span><br><span class="line">docker service create --name web --network my_overlay nginx</span><br></pre></td></tr></table></figure></li></ul><hr><p><img src="/img/Docker/network/Libnetwork.png" alt="libnetwork"></p><hr><ul><li><strong>bridge</strong>：单机容器间通信的默认选择。</li><li><strong>host</strong>：高性能，直接复用宿主机网络。</li><li><strong>container</strong>：共享已有容器的网络环境。</li><li><strong>none</strong>：完全隔离，无网络。</li><li><strong>overlay</strong>：跨主机通信，是集群和分布式系统的核心网络方案。</li></ul><p>通过这些网络模式的灵活组合，Docker 能够同时支持 <strong>单机开发、生产部署、分布式集群</strong> 等不同应用场景。</p><hr><h2><span id="docker-网络管理命令">docker 网络管理命令</span></h2><h3><span id="命令清单">命令清单</span></h3><table><thead><tr><th>命令</th><th>别名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>docker network create</td><td></td><td>创建网络</td><td></td></tr><tr><td>docker network connect</td><td></td><td>连接网络</td><td></td></tr><tr><td>docker network disconnect</td><td></td><td>断开网络</td><td></td></tr><tr><td>docker network ls</td><td>docker network list</td><td>列出网络</td><td></td></tr><tr><td>docker network prune</td><td></td><td>删除不使用的网络</td><td></td></tr><tr><td>docker network inspect</td><td></td><td>查看网络详情</td><td></td></tr><tr><td>docker network rm</td><td>docker network remove</td><td>删除 1 个或多个网络</td><td></td></tr></tbody></table><h3><span id="docker-network-create">docker network create</span></h3><p><code>docker network create</code> 用于创建自定义网络，便于容器间通信和网络隔离。通过不同的选项，可以灵活配置网络类型、子网、网关等参数。</p><p>该指令功能如下：</p><ul><li>创建自定义 Docker 网络</li><li>支持多种网络驱动（如 <code>bridge</code>、<code>overlay</code> 等）</li><li>可以指定子网、网关等，满足不同应用场景</li></ul><h4><span id="语法">语法</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create [OPTIONS] NETWORK</span><br></pre></td></tr></table></figure><h4><span id="常用参数">常用参数</span></h4><ul><li><code>-d, --driver</code>：指定网络驱动（默认是 <code>bridge</code>）</li><li><code>--subnet</code>：CIDR 格式的子网（例如 <code>192.168.0.0/16</code>）</li><li><code>--gateway</code>：指定网关地址</li><li><code>--ipv6</code>：启用 IPv6 支持</li><li><code>--attachable</code>：允许独立容器连接到 Swarm 网络</li></ul><h4><span id="示例">示例</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 br0 的 bridge 网络，并指定子网和网关</span></span><br><span class="line">docker network create \</span><br><span class="line">  --driver=bridge \</span><br><span class="line">  --subnet=192.168.0.0/16 \</span><br><span class="line">  --gateway=192.168.0.1 \</span><br><span class="line">  br0</span><br></pre></td></tr></table></figure><ul><li>创建成功后，可以使用 <code>docker network ls</code> 查看网络列表。</li><li>新建容器时通过 <code>--network br0</code> 参数指定容器加入该网络。</li></ul><hr><h3><span id="docker-network-inspect">docker network inspect</span></h3><p><code>docker network inspect</code> 用于查看一个或多个 Docker 网络的详细信息，包括网络 ID、驱动类型、子网、网关以及与其连接的容器等内容。</p><hr><h4><span id="基本语法">基本语法</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect [OPTIONS] NETWORK [NETWORK...]</span><br></pre></td></tr></table></figure><hr><h4><span id="常用参数">常用参数</span></h4><ul><li><code>-f, --format</code>：以 Go 模板的方式指定输出格式，便于只提取需要的信息。</li></ul><hr><h4><span id="使用示例">使用示例</span></h4><ol><li>查看某个网络的详细信息：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect mynetwork</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>--format</code> 参数过滤输出，只显示容器信息：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect --format=&#x27;&#123;&#123;json .Containers&#125;&#125;&#x27; mynetwork</span><br></pre></td></tr></table></figure><hr><p>通过 <code>docker network inspect</code>，不仅可以了解网络本身的属性，还能查看网络中与容器之间的关联关系，便于调试与排错。</p><hr><h3><span id="docker-network-connect">docker network connect</span></h3><p><code>docker network connect</code> 用于将已有的容器连接到指定的网络（可以是网络名称或 ID）。<br>连接成功后，容器就能与该网络中的其他容器进行通信。</p><hr><h4><span id="基本语法">基本语法</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect [OPTIONS] NETWORK CONTAINER</span><br></pre></td></tr></table></figure><hr><h4><span id="常用参数">常用参数</span></h4><ul><li><code>--ip</code>：指定容器在该网络中的 IPv4 地址。</li><li><code>--ip6</code>：指定容器在该网络中的 IPv6 地址。</li></ul><hr><h4><span id="使用示例">使用示例</span></h4><ol><li><strong>将正在运行的容器连接到网络</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect multi-host-network my_container1</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>容器启动时直接连接到网络</strong><br>使用 <code>--network</code> 选项可以在容器启动时直接加入某个网络：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --network=multi-host-network busybox-container</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>指定容器的 IP 地址</strong><br>连接容器时，可以手动分配其在网络中的 IP 地址：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect --ip 10.10.36.122 multi-host-network container2</span><br></pre></td></tr></table></figure><hr><p>通过 <code>docker network connect</code>，可以灵活地将容器加入到多个网络，从而实现更复杂的网络拓扑结构和容器间通信管理。</p><hr><h3><span id="docker-network-disconnect">docker network disconnect</span></h3><p><code>docker network disconnect</code> 用于将容器从指定网络中断开连接。<br>断开后，该容器将无法再与该网络中的其他容器进行通信。</p><hr><h4><span id="基本语法">基本语法</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect [OPTIONS] NETWORK CONTAINER</span><br></pre></td></tr></table></figure><hr><h4><span id="常用参数">常用参数</span></h4><ul><li><code>-f</code>：强制断开，即使容器当前正在使用该网络。</li></ul><hr><h4><span id="使用示例">使用示例</span></h4><ol><li><strong>普通断开容器与网络的连接</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect multi-host-network my_container1</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>强制断开容器与网络的连接</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect -f multi-host-network my_container1</span><br></pre></td></tr></table></figure><hr><p>通过 <code>docker network disconnect</code>，可以灵活管理容器的网络连接，避免不必要的通信，也能在容器生命周期中动态调整网络拓扑结构。</p><hr><h3><span id="docker-network-prune">docker network prune</span></h3><p><code>docker network prune</code> 用于清理并删除当前未被任何容器使用的网络。<br>该命令常用于释放系统资源，保持 Docker 环境整洁。</p><hr><h4><span id="基本语法">基本语法</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network prune [OPTIONS]</span><br></pre></td></tr></table></figure><hr><h4><span id="常用参数">常用参数</span></h4><ul><li><code>-f, --force</code>：跳过确认提示，直接删除未使用的网络。</li></ul><hr><h4><span id="使用示例">使用示例</span></h4><ol><li><strong>交互式删除未使用的网络（会提示确认）</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network prune</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>强制删除未使用的网络（无确认提示）</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network prune -f</span><br></pre></td></tr></table></figure><hr><p>通过 <code>docker network prune</code>，可以快速清理掉未使用的网络，避免累积占用存储空间或影响环境整洁。</p><hr><h3><span id="docker-network-rm">docker network rm</span></h3><p><code>docker network rm</code> 用于删除一个或多个 Docker 网络。<br>删除前，确保网络没有被任何容器使用，否则需要使用强制参数。</p><hr><h4><span id="基本语法">基本语法</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm NETWORK [NETWORK...]</span><br></pre></td></tr></table></figure><hr><h4><span id="常用参数">常用参数</span></h4><ul><li><code>-f</code>：强制删除网络，即使有容器当前连接该网络。</li></ul><hr><h4><span id="使用示例">使用示例</span></h4><ol><li><strong>删除单个网络</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm br0</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>强制删除网络</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm -f br0</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>一次删除多个网络</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm net1 net2 net3</span><br></pre></td></tr></table></figure><hr><p><code>docker network rm</code> 可以灵活地删除不再需要的网络，结合 <code>-f</code> 参数可以处理仍被容器使用的网络，从而便于网络管理和环境清理。</p><hr><h3><span id="docker-network-ls">docker network ls</span></h3><h4><span id="功能说明">功能说明</span></h4><p><code>docker network ls</code> 用于列出 Docker 主机上的所有网络，包括默认网络和用户创建的网络。<br>它可以快速查看网络名称、ID、驱动类型以及作用范围。</p><hr><h4><span id="基本语法">基本语法</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls [OPTIONS]</span><br></pre></td></tr></table></figure><ul><li>别名：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network list</span><br></pre></td></tr></table></figure><hr><h4><span id="常用参数">常用参数</span></h4><ul><li><code>-f, --filter</code>：按照条件过滤网络，例如按驱动类型或名称过滤。</li><li><code>--format</code>：指定输出格式，如 <code>table</code>、<code>json</code> 等。</li><li><code>--no-trunc</code>：显示完整的网络 ID，不截断。</li><li><code>-q, --quiet</code>：只显示网络 ID，适合脚本使用。</li></ul><hr><h4><span id="使用示例">使用示例</span></h4><ol><li><strong>列出所有网络</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>仅显示网络 ID</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls -q</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>按驱动类型过滤</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls -f driver=bridge</span><br></pre></td></tr></table></figure><hr><p>通过 <code>docker network ls</code>，可以快速查看 Docker 网络信息，配合过滤和格式化选项，便于网络管理和自动化脚本使用。</p><hr><h3><span id="指令汇总">指令汇总</span></h3><table><thead><tr><th>命令</th><th>功能说明</th><th>常用参数&#x2F;选项</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td><code>docker network create</code></td><td>创建自定义网络</td><td><code>-d/--driver</code> 指定驱动类型<br><code>--subnet</code> 指定子网<br><code>--gateway</code> 指定网关</td><td><code>docker network create mynetwork</code></td><td>创建自定义网络，可为容器提供隔离或自定义拓扑</td></tr><tr><td><code>docker network ls</code></td><td>列出所有网络</td><td><code>-f/--filter</code> 过滤<br><code>--format</code> 指定输出格式<br><code>-q/--quiet</code> 只显示 ID</td><td><code>docker network ls</code> <br> <code>docker network ls -q</code></td><td>支持别名 <code>docker network list</code></td></tr><tr><td><code>docker network inspect</code></td><td>查看网络详情</td><td><code>-f/--format</code> 格式化输出</td><td><code>docker network inspect mynetwork</code></td><td>可以查看网络配置、子网、容器连接信息</td></tr><tr><td><code>docker network connect</code></td><td>将容器连接到网络</td><td><code>--ip</code> 指定 IPv4<br><code>--ip6</code> 指定 IPv6</td><td><code>docker network connect multi-host-network my_container1</code></td><td>容器连接后可以与该网络内其他容器通信</td></tr><tr><td><code>docker network disconnect</code></td><td>将容器从网络断开</td><td><code>-f</code> 强制断开</td><td><code>docker network disconnect multi-host-network my_container1</code></td><td>动态管理容器网络连接，避免不必要的通信</td></tr><tr><td><code>docker network rm</code></td><td>删除 1 个或多个网络</td><td><code>-f</code> 强制删除</td><td><code>docker network rm br0</code> <br> <code>docker network rm -f br0</code></td><td>删除前请确保网络未被容器使用</td></tr><tr><td><code>docker network prune</code></td><td>删除未被容器使用的网络</td><td><code>-f/--force</code> 跳过确认提示</td><td><code>docker network prune</code> <br> <code>docker network prune -f</code></td><td>清理无用网络，释放资源</td></tr></tbody></table><h2><span id="网络详解">网络详解</span></h2><h3><span id="docker-bridge-网络">docker Bridge 网络</span></h3><h4><span id="网络介绍">网络介绍</span></h4><p>Docker Bridge 网络采用内置的 bridge 驱动，bridge 驱动底层采用的是 Linux 内核中 Linux bridge 技术。就网络而言，bridge 网络是在网络段之间转发流量的链路层设备，而网桥可以是在主机内核中运行的硬件设备或软件设备；就 Docker 而言，桥接网络使用软件网桥 docker0，它允许连接到同一网桥网络的容器进行通信，同时提供与未连接到该网桥网络容器的隔离。Docker Container 的 bridge 桥接模式可以参考下图：</p><p><img src="/img/Docker/network/bridge.png" alt="network"></p><p>默认情况下，创建的容器在没有使用–network 参数指定要加入的 docker 网络时，默认都是加入 Docker 默认的单机桥接网络，即下面的 name 为 bridge 的网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker 支持的网络</span></span><br><span class="line">docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">0cb86abb53fb   bridge    bridge    local</span><br><span class="line">bdd23adf8d35   host      host      local</span><br><span class="line">6a68de0c74cb   none      null      local</span><br></pre></td></tr></table></figure><p>默认的 bridge 网络会被映射到内核中为 docker0 的网桥上。Docker 默认的 bridge 网络和 Linux 内核中的 docker0 网桥是一一对应的关系。bridge 是 Docker 对网络的命名，而 docker0 是内核中网桥的名字。</p><p><img src="/img/Docker/network/top_net.png" alt="cnet"></p><p>说人话，就是 docker0 和 回环网络、宿主机网络坐一桌，他是你在安装 Docker 时自动创建的网络。</p><h4><span id="操作案例">操作案例</span></h4><h5><span id="容器间的网络通信">容器间的网络通信</span></h5><p>回忆一下之前学到网络知识：多台主机是如何通过网络中进行通信的？如果是两台主机可以直接通过连接网线的两端进行通信。那多台主机通信怎么处理呢？这就需要新增路由器&#x2F;交换机，把多台主机连接到路由器&#x2F;交换机上， 通过路由器&#x2F;交换机来达到交换数据， 即通信的目的。</p><p><img src="/img/Docker/network/host_connect.png" alt="host connect"></p><p>其实容器之间的通信也和上面主机通信的方式如出一辙， 之前我们提到了安装 Docker 的时候会默认 docker0 这个网桥软件设备， 这个 docker0 设备可以类比成上图的交换机&#x2F;路由器设备，当我们创建好容器之后， 如果不手动指定网络模式，默认会使用 bridge 网络， 容器会自动连接到 docker0 这个网桥设备， 然后通过这个网桥来进行容器间的通信。</p><p>下面我们来做一个实验验证一下：</p><p><strong>1. 容器创建与默认网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name c1 busybox:stable-glibc</span><br><span class="line">docker run -itd --name c2 busybox:stable-glibc</span><br></pre></td></tr></table></figure><ul><li>使用 <code>-itd</code> 参数：以交互模式、终端分配、后台运行方式创建容器</li><li>未指定 <code>--network</code> 参数：容器自动连接到 Docker 的<strong>默认 bridge 网络</strong>（docker0）</li><li>两个容器共享同一个网络命名空间下的默认网络环境</li></ul><p><strong>2. 网络接口信息检查</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">exec</span> -it c1 ip a</span><br><span class="line">docker container <span class="built_in">exec</span> -it c2 ip a</span><br></pre></td></tr></table></figure><p>输出显示：</p><ul><li><strong>c1 容器</strong>：IP 地址 <code>172.17.0.2/16</code></li><li><strong>c2 容器</strong>：IP 地址 <code>172.17.0.3/16</code></li><li>网络接口：均为 <code>eth0</code>，通过 veth pair 与宿主机 docker0 网桥连接</li><li>子网掩码：<code>/16</code>（255.255.0.0），属于 B 类私有地址范围</li></ul><p><strong>3. 容器间网络连通性测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">exec</span> -it c1 ping 172.17.0.3  <span class="comment"># c1 ping c2</span></span><br><span class="line">docker container <span class="built_in">exec</span> -it c2 ping 172.17.0.2  <span class="comment"># c2 ping c1</span></span><br></pre></td></tr></table></figure><p>测试结果：</p><ul><li>双向 ping 通成功，平均延迟约 0.07ms</li><li>10 个数据包零丢包，证明网络连接稳定</li><li>确认容器在同一个子网内可直接通信</li></ul><p><strong>4. 网络配置详细分析</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p>网络配置信息揭示：</p><ul><li><strong>子网范围</strong>：<code>172.17.0.0/16</code>（Docker 自动分配的默认子网）</li><li><strong>网关地址</strong>：<code>172.17.0.1</code>（docker0 网桥的 IP 地址）</li><li><strong>容器连接</strong>：明确显示 c1 和 c2 都连接到该网络</li><li><strong>MAC 地址</strong>：每个容器有唯一的 MAC 地址（<code>e2:12:71:88:b8:12</code> 和 <code>a6:67:b2:49:c6:e2</code>）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络配置的容器相关信息</span></span><br><span class="line"> &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;1a85c7a4042e55ca7bfe387e783690e9896473c3177cd7c153367e9b0c0ab787&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;829b047a4dacae8e6586d6538e8876d654ead877625d6c350d3fddf3e94444fa&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;a6:67:b2:49:c6:e2&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;a762babced39202b7a637f2c674d24d5d3a6f729cd555e8029377504525f1424&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;8eda16569ac629bca03d2192be481ebc37170cc4f5600f06d65eba38f7169768&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;e2:12:71:88:b8:12&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><p><strong>5. 网络状态动态变化演示</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container stop c1</span><br><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p>状态变化：</p><ul><li>停止 c1 容器后，网络配置中的 Containers 部分仅剩 c2</li><li>演示了 Docker 网络的动态管理特性：容器退出时自动从网络中解除连接</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只剩下容器 c2</span></span><br><span class="line">&quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;1a85c7a4042e55ca7bfe387e783690e9896473c3177cd7c153367e9b0c0ab787&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;c2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;829b047a4dacae8e6586d6538e8876d654ead877625d6c350d3fddf3e94444fa&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;a6:67:b2:49:c6:e2&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><hr><h5><span id="创建自定义-bridge">创建自定义 bridge</span></h5><p>本实验展示了如何在 Docker 中创建一个自定义桥接网络（bridge），并在该网络上启动容器。下面是实验的详细过程解析及实际验证数据。</p><hr><ol><li><strong>创建自定义桥接网络</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge bridge1</span><br></pre></td></tr></table></figure><ul><li><code>-d bridge</code> 指定网络驱动为桥接（bridge）。</li><li><code>bridge1</code> 是自定义网络的名称。</li><li>命令返回网络 ID：<br><code>45518f3ee838699c7fcad67939d4164d05293c938345fdec30596af98a1707d4</code></li></ul><hr><ol start="2"><li><strong>查看自定义网络详情</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge1</span><br></pre></td></tr></table></figure><p>输出结果（核心字段）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;45518f3ee838699c7fcad67939d4164d05293c938345fdec30596af98a1707d4&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;EnableIPv4&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;EnableIPv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;IPAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Containers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>Subnet</code> 和 <code>Gateway</code> 显示自定义网络的 IPv4 地址段。</li><li><code>Containers</code> 为空，说明当前网络没有容器连接。</li></ul><hr><ol start="3"><li><strong>在自定义网络上启动容器</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -itd --name c1 --network bridge1 busybox:stable-glibc</span><br></pre></td></tr></table></figure><ul><li><code>--network bridge1</code> 指定容器连接到自定义桥接网络。</li><li>容器启动后分配到该网络的 IP 地址为 <code>172.18.0.2</code>。</li><li>容器 ID：<code>07dd0135e6aa3328064a5e5379f175faaba4585cba3fe1d1ab421d1299752465</code></li></ul><hr><ol start="4"><li><strong>验证容器网络配置</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect c1 | grep &quot;Networks&quot; -A 17</span><br></pre></td></tr></table></figure><p>输出核心部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Networks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bridge1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;MacAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4a:94:20:87:ff:f6&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;NetworkID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;45518f3ee838699c7fcad67939d4164d05293c938345fdec30596af98a1707d4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;EndpointID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;132b5f7e178cc1208768bed4f6b0c22db979c46673e74493824d86f3377dacff&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPPrefixLen&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DNSNames&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;c1&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>可以看到容器 <code>c1</code> 已连接到 <code>bridge1</code> 网络。</li><li><code>IPAddress</code> 为 <code>172.18.0.2</code>，<code>Gateway</code> 为 <code>172.18.0.1</code>。</li><li><code>MacAddress</code> 与 <code>EndpointID</code> 显示网络接口的唯一标识。</li></ul><hr><ol start="5"><li><strong>验证网络容器列表</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge1 | grep &quot;Containers&quot; -A 20</span><br></pre></td></tr></table></figure><p>输出核心部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Containers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;07dd0135e6aa3328064a5e5379f175faaba4585cba3fe1d1ab421d1299752465&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;EndpointID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;132b5f7e178cc1208768bed4f6b0c22db979c46673e74493824d86f3377dacff&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MacAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4a:94:20:87:ff:f6&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPv4Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.18.0.2/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IPv6Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>Containers</code> 字段可以确认容器 <code>c1</code> 已成功连接到自定义桥接网络。</li><li><code>IPv4Address</code> 与前面 <code>inspect</code> 输出一致，验证了网络分配的正确性。</li></ul><hr><ul><li>Docker 允许用户创建自定义桥接网络，通过 <code>docker network create -d bridge &lt;name&gt;</code> 实现。</li><li>容器连接到自定义桥接网络后，可以在该网络内部进行通信，IP 地址由 Docker 自动分配。</li><li>使用 <code>docker network inspect &lt;network&gt;</code> 可以查看网络拓扑、IP 段以及连接的容器信息。</li></ul><hr><h5><span id="dns-解析实验">DNS 解析实验</span></h5><p>本实验旨在验证 Docker 容器内部的 DNS 解析功能，以及默认网桥（bridge）网络下的 DNS 行为。实验通过在自定义 bridge 和默认 bridge 网络上启动容器并尝试通过容器名互相 ping，观察 DNS 是否可用。下面是详细实验过程解析及事实依据。</p><hr><ol><li><strong>创建自定义桥接网络</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge bridge1</span><br></pre></td></tr></table></figure><ul><li><code>-d bridge</code> 指定网络类型为桥接。</li><li><code>bridge1</code> 是自定义网络名称。</li><li>创建成功返回网络 ID：<br><code>7901308cf3c5b1af9a1dd6bb6a147c6b7e5ee582d72f2484ba610a8d495190ed</code></li></ul><hr><ol start="2"><li><strong>在自定义网络上启动容器</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container run -itd --name c1 --network bridge1 busybox:stable-glibc</span><br><span class="line">docker container run -itd --name c2 --network bridge1 busybox:stable-glibc</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge1 | grep &quot;Containers&quot; -A 20</span><br><span class="line">&quot;Containers&quot;: &#123;</span><br><span class="line">    &quot;11483dc55da7ec1caad1f1034c59713a5b58a82b2ba1eb2c2e98bba2e40c6711&quot;: &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;c2&quot;,</span><br><span class="line">        &quot;EndpointID&quot;: &quot;6d570105ac556afb400c09664bb9d9b43b9a58641d29e1b1b3b1f3e1f64ef869&quot;,</span><br><span class="line">        &quot;MacAddress&quot;: &quot;c2:8b:1b:c7:38:d7&quot;,</span><br><span class="line">        &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,</span><br><span class="line">        &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;6aacf832a36e81f5081aa65e120bddab119c2e8c775667f89a0f293e8574df30&quot;: &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;c1&quot;,</span><br><span class="line">        &quot;EndpointID&quot;: &quot;cd17740ebed4d03176a47e148472539aa64acd3c82970f10aa69e61839151754&quot;,</span><br><span class="line">        &quot;MacAddress&quot;: &quot;86:5f:df:c0:c4:92&quot;,</span><br><span class="line">        &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">        &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>容器 <code>c1</code> 和 <code>c2</code> 连接到自定义网络 <code>bridge1</code>。</p></li><li><p>分配 IP 地址分别为：</p><ul><li><code>c1</code> → <code>172.18.0.2</code></li><li><code>c2</code> → <code>172.18.0.3</code></li></ul></li></ul><hr><ol start="3"><li><strong>验证容器互通（自定义网络）</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it c1 ping c2</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PING c2 (172.18.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.086 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.090 ms</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it c2 ping c1</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PING c1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.069 ms</span><br></pre></td></tr></table></figure><ul><li>结论：在自定义桥接网络中，容器可以通过名称相互解析 IP 并通信，DNS 解析可用。</li></ul><hr><ol start="4"><li><strong>在默认 bridge 网络上启动容器</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container run -itd --name c3 busybox:stable-glibc</span><br><span class="line">docker container run -itd --name c4 busybox:stable-glibc</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge | grep &quot;Containers&quot; -A 20</span><br><span class="line">&quot;Containers&quot;: &#123;</span><br><span class="line">    &quot;12f82693d0ff14dc42898759dc0c9ee834180b43459ef437eb82ac07a2972e59&quot;: &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;c4&quot;,</span><br><span class="line">        &quot;EndpointID&quot;: &quot;e1f56c1067c73ac70d8f3f178bae22d3aac8942fccc47946de4f50ea1f34811d&quot;,</span><br><span class="line">        &quot;MacAddress&quot;: &quot;8a:c7:39:b2:a2:d9&quot;,</span><br><span class="line">        &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">        &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;c8bf0c6d3fa3c36a3fefb4307083b89af9be3c531e1a3f2fb48345d0e095ab67&quot;: &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;c3&quot;,</span><br><span class="line">        &quot;EndpointID&quot;: &quot;d7a05b4995fe7e8b11e212f66ac3293df3a6ba7e4582b7b610416b18cfdd6b64&quot;,</span><br><span class="line">        &quot;MacAddress&quot;: &quot;1a:26:32:dc:09:5d&quot;,</span><br><span class="line">        &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">        &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&quot;Options&quot;: &#123;</span><br><span class="line">    &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">    &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">    &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">    &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br></pre></td></tr></table></figure><ul><li><p>容器 <code>c3</code> 和 <code>c4</code> 默认连接到 Docker 默认 <code>bridge</code> 网络。</p></li><li><p>分配 IP 地址分别为：</p><ul><li><code>c3</code> → <code>172.17.0.2</code></li><li><code>c4</code> → <code>172.17.0.3</code></li></ul></li></ul><hr><ol start="5"><li><strong>验证容器互通（默认网络）</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it c3 ping c4</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping: bad address &#x27;c4&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it c4 ping c3</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping: bad address &#x27;c3&#x27;</span><br></pre></td></tr></table></figure><ul><li>结论：在 Docker 默认桥接网络下，容器名无法进行 DNS 解析，必须使用 IP 地址通信。</li></ul><hr><p><strong>总结：</strong></p><ol><li>自定义桥接网络（bridge1）支持容器通过名称互相 DNS 解析。</li><li>Docker 默认桥接网络（bridge）不支持容器名 DNS 解析，只能通过 IP 地址通信。</li><li>实验通过 <code>ping</code> 验证和 <code>docker network inspect</code> 输出数据为实验事实依据，展示了 DNS 行为的差异。</li></ol><hr><h3><span id="docker-host-网络">docker Host 网络</span></h3><h4><span id="网络介绍">网络介绍</span></h4><p>Docker 容器运行默认都会分配独立的 Network Namespace 隔离子系统， 但是如果基于 host 网络模式，容器将不会获得一个独立的 Network Namespace，而是和宿主机共用同一个 Network Namespace，容器将不会虚拟出自己的网卡，IP 等，而是直接使用宿主机的 IP 和端口。</p><p><img src="/img/Docker/network/host.png" alt="host"></p><p>连接到 host 网络的容器共享宿主机的网络栈，容器的网络配置与宿主机完全一样。我们可以通过 –network&#x3D;host 指定使用 host 网络</p><p>下面我们通过实验来验证 host 网络的行为。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 Host 方式创建并启动容器 c1</span></span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/lib] - [2169]</span><br><span class="line">└─[$] docker container run -itd --name c1 --network=host busybox:stable-glibc</span><br><span class="line">ffd86b4df415e69582595858f038ab72cd219da6cb47f0433253652243434fa3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器的网络信息</span></span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/lib] - [2170]</span><br><span class="line">└─[$] docker exec -it c1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq qlen 1000</span><br><span class="line">    link/ether 52:54:00:57:45:ed brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.16.15/22 brd 10.0.19.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe57:45ed/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: lxcbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue qlen 1000</span><br><span class="line">    link/ether 00:16:3e:00:00:00 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.3.1/24 brd 10.0.3.255 scope global lxcbr0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::216:3eff:fe00:0/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">7: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 56:3e:0d:4b:c9:bc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::543e:dff:fe4b:c9bc/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器的网络信息和宿主机网络信息完全一样</span></span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/lib] - [2171]</span><br><span class="line">└─[$] ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:57:45:ed brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp0s5</span><br><span class="line">    altname ens5</span><br><span class="line">    inet 10.0.16.15/22 brd 10.0.19.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe57:45ed/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: lxcbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000</span><br><span class="line">    link/ether 00:16:3e:00:00:00 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.3.1/24 brd 10.0.3.255 scope global lxcbr0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::216:3eff:fe00:0/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">7: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    link/ether 56:3e:0d:4b:c9:bc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::543e:dff:fe4b:c9bc/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h4><span id="使用场景">使用场景</span></h4><p>• 之前我们提到 bridge 网络在通信的时候需要进行端口转发以及 NAT 地址转换，这势必会消耗掉一些资源以及性能。<br>• 那么直接使用 host 网络最大的好处就是性能好，如果容器对网络传输效率有较高的要求，建议选择 host 网络。当然也会牺牲一些东西，比如要考虑端口冲突问题，其它服务已经被占用的端口就不能再使用了</p><h3><span id="docker-container-网络">docker Container 网络</span></h3><h4><span id="网络介绍">网络介绍</span></h4><p>Docker Container 的 other container 网络模式是 Docker 中一种较为特别的网络的模式。之所以称为“other container 模式”，是因为这个模式下的 Docker Container，会使用其他容器的网络环境。之所以称为“特别”，是因为这个模式下容器的网络隔离性会处于 bridge 桥接模式与 host 模式之间。Docker Container 共享其他容器的网络环境，则至少这两个容器之间不存在网络隔离，而这两个容器又与宿主机以及除此之外其他的容器存在网络隔离。</p><p>Docker Container 的 other container 网络模式可以参考下图：</p><p><img src="/img/Docker/network/container.png" alt="container"></p><h4><span id="docker-container-的-networkcontainerltother_containergt-模式实现逻辑">Docker Container 的 <code>--network=container:&lt;other_container&gt;</code> 模式实现逻辑</span></h4><p>在 Docker 中，容器可以使用其他容器的网络命名空间（network namespace），实现共享网络配置的效果。这种模式通常使用 <code>--network=container:&lt;other_container&gt;</code> 指定。其实现逻辑如下：</p><ol><li><p><strong>查找目标容器的网络命名空间</strong></p><ul><li>Docker 会首先定位 <code>&lt;other_container&gt;</code> 容器的 network namespace。</li><li>network namespace 是 Linux 内核提供的机制，用于隔离容器的网络栈，包括 IP 地址、路由表、端口等。</li></ul></li><li><p><strong>将新容器绑定到目标网络命名空间</strong></p><ul><li>新创建的容器不会创建自己的网络 namespace。</li><li>相反，它会共享 <code>&lt;other_container&gt;</code> 的 network namespace，包括 IP、端口映射、路由等。</li><li>这样，两个容器就像共享同一个网络接口，可以互相访问，并且对外表现为同一个网络实体。</li></ul></li><li><p><strong>实现效果</strong></p><ul><li>新容器与 <code>&lt;other_container&gt;</code> 容器拥有完全相同的网络环境。</li><li>新容器内使用 <code>ifconfig</code> 或 <code>ip a</code> 查看 IP 时，会显示与 <code>&lt;other_container&gt;</code> 一致。</li><li>端口占用也是共享的，如果 <code>&lt;other_container&gt;</code> 已绑定端口，新容器不能再绑定同样的端口。</li></ul></li></ol><ul><li>在这个模式下，<code>new_container</code> 并没有独立的 IP 地址，它完全依赖 <code>other_container</code> 的网络配置。</li><li>常用于 sidecar 容器模式，例如日志收集或代理容器需要与主业务容器共享网络。</li></ul><p>这个模式与普通 bridge 或 host 网络模式不同，它本质上是直接复用已有容器的网络命名空间，而不是创建新的网络栈或桥接。</p><h4><span id="操作案例">操作案例</span></h4><p>在本实验中，验证了 Docker 容器共享网络命名空间的行为及其对容器生命周期的依赖。实验步骤与数据如下：</p><ol><li><strong>创建第一个容器 c1</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name c1 busybox:stable-glibc</span><br></pre></td></tr></table></figure><p>输出容器 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0908b5475c78a131c558880d921838df028a44ed5950ae0e4eba4d78127b35dc</span><br></pre></td></tr></table></figure><p>查看 c1 的网络信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it c1 ip a</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">   link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">   inet 127.0.0.1/8 scope host lo</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">   inet6 ::1/128 scope host</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0@if183: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">   link/ether fa:03:a5:9a:33:41 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">   inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建第二个容器 c2，使用 c1 的网络 namespace</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name c2 --network container:c1 busybox:stable-glibc</span><br></pre></td></tr></table></figure><p>输出容器 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e18ed7418a91b1ae782502c13cb7a666822904fca5945f20d92ba0e2806a51f0</span><br></pre></td></tr></table></figure><p>查看 c2 网络信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it c2 ip a</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">   <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">   inet 127.0.0.1/8 scope host lo</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">   inet6 ::1/128 scope host</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0@if183: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">   <span class="built_in">link</span>/ether fa:03:a5:9a:33:41 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">   inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>可以看到，c1 与 c2 的 <code>eth0</code> IP 信息完全一致，说明 c2 成功共享了 c1 的网络 namespace。</p><ol start="3"><li><strong>停止 c1 容器</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop c1</span><br></pre></td></tr></table></figure><p>查看 c2 网络信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it c2 ip a</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">   <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">   inet 127.0.0.1/8 scope host lo</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">   inet6 ::1/128 scope host</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>c1 停止后，c2 的 <code>eth0</code> 消失，说明共享网络命名空间依赖于源容器的运行状态。</p><ol start="4"><li><strong>重新启动 c1</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start c1</span><br></pre></td></tr></table></figure><p>查看 c2 网络信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it c2 ip a</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">   <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">   inet 127.0.0.1/8 scope host lo</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">   inet6 ::1/128 scope host</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>即便 c1 已重启，c2 仍然没有 <code>eth0</code>，共享网络未自动恢复。</p><ol start="5"><li><strong>重启 c2 容器</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart c2</span><br></pre></td></tr></table></figure><p>查看网络信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it c2 ip a</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">   <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">   inet 127.0.0.1/8 scope host lo</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">   inet6 ::1/128 scope host</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0@if185: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">   <span class="built_in">link</span>/ether 4e:2b:53:0a:a9:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">   inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>重启 c2 后，<code>eth0</code> 恢复，与 c1 再次共享网络 namespace，实验验证了 Docker 的容器网络共享逻辑。</p><hr><p><strong>实验结论：</strong></p><ol><li>使用 <code>--network container:&lt;other_container&gt;</code> 时，目标容器和新容器完全共享网络 namespace，包括 IP 和端口映射。</li><li>源容器停止会导致共享容器网络接口丢失。</li><li>源容器重启不会自动恢复共享网络，必须重启共享容器以重新绑定网络 namespace。</li></ol><h3><span id="docker-none-网络">docker none 网络</span></h3><h4><span id="网络介绍">网络介绍</span></h4><p>none 网络就是指没有网络。挂在这个网络下的容器除了 lo(本地回环)，没有其他任何网卡</p><p>如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/lib] - [2190]</span><br><span class="line">└─[$] docker container run -itd --name c1 --network=none busybox:stable-glibc</span><br><span class="line">064824ac172793be62616e267e7d2edaf24108e853be2abace4d522178183761</span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/lib] - [2191]</span><br><span class="line">└─[$] docker <span class="built_in">exec</span> -it c1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h4><span id="使用场景">使用场景</span></h4><p>• 针对一些对安全性要求比较高并且不需要联网的应用， 可以使用 none 网络， 比如生成随机密码， 避免生成密码被第三方获取。<br>• 一些第三方的应用可能需要 docker 帮忙创建一个没有网络的容器， 网络由第三方自己来配置</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端工具 </category>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Volume（存储卷）使用指南</title>
      <link href="/2025/09/02/Docker/docker_volume/"/>
      <url>/2025/09/02/Docker/docker_volume/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E5%8D%B7">什么是存储卷？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%98%E5%82%A8%E5%8D%B7">为什么需要存储卷？</a><ul><li><a href="#1-%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98">1. 数据丢失问题</a></li><li><a href="#2-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98">2. 性能问题</a></li><li><a href="#3-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8D%E4%BE%BF">3. 宿主机与容器之间的数据交互不便</a></li><li><a href="#4-%E5%A4%9A%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E5%9B%B0%E9%9A%BE">4. 多容器之间的数据共享困难</a></li></ul></li><li><a href="#%E5%AD%98%E5%82%A8%E5%8D%B7%E7%9A%84%E5%88%86%E7%B1%BB">存储卷的分类</a><ul><li><a href="#1-volume%E5%8D%B7">1. Volume（卷）</a></li><li><a href="#2-bind-mount%E7%BB%91%E5%AE%9A%E6%8C%82%E8%BD%BD">2. Bind Mount（绑定挂载）</a></li><li><a href="#3-tmpfs-mount%E5%86%85%E5%AD%98%E6%8C%82%E8%BD%BD">3. tmpfs Mount（内存挂载）</a></li></ul></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E5%AD%98%E5%82%A8%E5%8D%B7">创建和管理存储卷</a><ul><li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E9%80%9A%E8%BF%87-volume-%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C">方式一：通过 Volume 命令操作</a></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li><li><a href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%9C%A8%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E6%97%B6%E6%8C%82%E8%BD%BD%E5%8D%B7">方式二：在运行容器时挂载卷</a></li><li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%89dockerfile-%E5%8C%BF%E5%90%8D%E5%8D%B7">方式三：Dockerfile 匿名卷</a></li></ul></li><li><a href="#%E4%B8%89%E7%A7%8D%E5%AD%98%E5%82%A8%E5%8D%B7%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B">三种存储卷操作实例</a><ul><li><a href="#docker-%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E5%8D%B7">Docker 命令创建管理卷</a></li><li><a href="#docker-v-%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E5%8D%B7">Docker -v 创建管理卷</a></li><li><a href="#docker-mount-%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E5%8D%B7">Docker –mount 创建管理卷</a></li><li><a href="#%E7%BB%91%E5%AE%9A%E5%8D%B7-bind-mount">绑定卷 bind mount</a></li><li><a href="#%E4%B8%B4%E6%97%B6%E5%8D%B7-tmpfs">临时卷 tmpfs</a></li><li><a href="#%E5%8D%B7%E4%BD%BF%E7%94%A8%E7%89%B9%E6%AE%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">卷使用特殊注意事项</a></li></ul></li><li><a href="#mysql%E7%81%BE%E9%9A%BE%E6%81%A2%E5%A4%8D%E5%AE%9E%E9%AA%8C">MySQL灾难恢复实验</a><ul><li><a href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4">实验步骤</a></li><li><a href="#%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90">原理解析</a></li><li><a href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E8%AE%BA">实验结论</a></li></ul></li></ul><!-- tocstop --><h2><span id="什么是存储卷">什么是存储卷？</span></h2><p>  在 Docker 中，存储卷（Volume）是容器持久化数据的核心机制。简单来说，存储卷就是将<strong>宿主机文件系统中的某个目录</strong>与<strong>容器文件系统中的某个目录</strong>建立绑定关系。这样一来，当容器内部程序在该目录下写入数据时，数据会<strong>直接写入宿主机的绑定目录</strong>。</p><p>  在宿主机上，这个与容器绑定的目录就被称为存储卷。卷的本质就是宿主机上的一个文件或目录，它绕过了默认的联合文件系统（Union File System），能够直接存在于宿主机上。这样做的好处是数据不会随着容器的删除而丢失，同时还能实现宿主机与容器之间的数据共享。</p><p>举个例子：<br>  如果将宿主机的 <code>/data/web</code> 目录与容器内部的 <code>/container/data/web</code> 目录绑定，那么当容器内的进程往 <code>/container/data/web</code> 中写入数据时，实际上数据是写在宿主机的 <code>/data/web</code> 目录里。反之亦然——宿主机中对 <code>/data/web</code> 的操作，也会同步到容器内部目录。这使得容器和宿主机之间的数据读写保持一致，实现了跨环境的数据共享。</p><hr><p>  我们可以把存储卷类比为“房子外的地下室”。容器就像是房子，卷就是地下室。当我们把卷绑定到容器里，就好比我们拥有了地下室的钥匙，可以把房子以外的空间也利用起来。</p><p>  假设有一天龙卷风来了，房子被摧毁了，但地下室依然完好无损。这就好比容器被删除了，但存储卷中的数据依然存在，不会受到影响。等新房子（新的容器）建好以后，依然可以用同一把钥匙进入地下室继续使用原来的数据。<br>  此外，地下室（存储卷）还可以被多个房子（容器）共享使用。这样，不同的房子可以通过地下室来交换物品，实现数据的共享和协作。  </p><hr><h2><span id="为什么需要存储卷">为什么需要存储卷？</span></h2><p>  容器天生适合运行无状态应用，但在实际生产中，很多业务都需要持久化数据。如果仅依赖容器自身的文件系统，就会遇到很多问题。存储卷的出现，正是为了解决这些痛点。</p><h3><span id="1-数据丢失问题">1. 数据丢失问题</span></h3><p>  容器从业务角度可以分为两类：</p><ul><li><strong>无状态容器</strong>：数据无需持久化，例如 Nginx、前端应用等。</li><li><strong>有状态容器</strong>：数据需要持久化，例如 MySQL、Kafka、Redis 等。</li></ul><p>  容器文件系统的本质，是在镜像层之上临时创建一个读写层。运行中容器对文件的所有修改，都发生在这个读写层。但当容器被删除时，读写层也会随之消失，导致数据无法保留。</p><p>  虽然容器的设计初衷是尽量保持无状态，方便快速部署和迁移，但实际业务离不开持久化需求。因此，Docker 引入了卷（Volume）的概念，专门用于解决数据持久化的问题。</p><h3><span id="2-性能问题">2. 性能问题</span></h3><p>  容器默认的联合文件系统（UnionFS）在处理<strong>文件修改和删除</strong>操作时性能较低。如果是对 I&#x2F;O 性能要求较高的应用（如 Redis 持久化、数据库写入操作），UnionFS 的效率会成为瓶颈。而卷直接绕过 UnionFS，与宿主机文件系统交互，极大提升了读写性能。</p><h3><span id="3-宿主机与容器之间的数据交互不便">3. 宿主机与容器之间的数据交互不便</span></h3><p>  如果没有卷，宿主机和容器之间的数据传输需要通过 <code>docker cp</code> 等命令完成。这种方式繁琐、效率低，也不利于应用自动化管理。而通过卷，宿主机和容器可以直接共享同一份数据，交互更加自然。</p><h3><span id="4-多容器之间的数据共享困难">4. 多容器之间的数据共享困难</span></h3><p>  在复杂业务场景下，往往有多个容器需要访问同一份数据。例如，一个应用容器需要与一个日志采集容器共享日志文件。如果不借助卷，容器之间共享数据会变得非常困难。而卷可以轻松解决这个问题，让多个容器挂载同一个目录，从而实现高效的数据共享。</p><h2><span id="存储卷的分类">存储卷的分类</span></h2><p>  在 Docker 中，存储卷是实现数据持久化与共享的关键机制。目前，Docker 提供了三种主要的方式将宿主机的数据挂载到容器中：</p><h3><span id="1-volume卷">1. Volume（卷）</span></h3><ul><li><p><strong>特点</strong>：由 Docker 引擎统一管理，默认存放在宿主机的 <code>/var/lib/docker/volumes</code> 目录下。</p></li><li><p><strong>使用方式</strong>：用户只需在容器中指定挂载点，至于宿主机上的实际目录位置，由 Docker 自动创建或使用已有目录完成绑定。</p></li><li><p><strong>优点</strong>：</p><ul><li>简化了用户操作，不需要手动管理宿主机目录。</li><li>与宿主机文件系统的耦合度低，容器迁移更方便。</li><li>可以配合 Volume Driver（如 NFS、云存储插件）扩展功能。</li></ul></li><li><p><strong>缺点</strong>：用户无法直接指定宿主机目录位置，可见性和可控性相对较低。</p></li><li><p><strong>适用场景</strong>：适合大多数需要持久化数据的容器，尤其在生产环境下使用最为普遍。</p></li></ul><h3><span id="2-bind-mount绑定挂载">2. Bind Mount（绑定挂载）</span></h3><ul><li><p><strong>特点</strong>：将宿主机上的<strong>指定目录或文件</strong>与容器内目录直接绑定。</p></li><li><p><strong>使用方式</strong>：需要在宿主机和容器中同时指定路径，建立明确的映射关系。</p></li><li><p><strong>优点</strong>：</p><ul><li>灵活性强，用户可以精确控制宿主机与容器共享的目录。</li><li>容器可以直接访问宿主机上的已有文件和目录。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>与宿主机文件系统耦合度高，不利于容器在不同环境间迁移。</li><li>如果宿主机路径错误，可能导致容器挂载失败或不可用。</li></ul></li><li><p><strong>适用场景</strong>：常用于开发调试阶段，例如代码热更新、日志调试等场景，或者需要指定目录来存储数据的场景，如 <code>MySQL</code> 等需要独立的大块空间。</p></li></ul><h3><span id="3-tmpfs-mount内存挂载">3. tmpfs Mount（内存挂载）</span></h3><ul><li><p><strong>特点</strong>：将数据直接挂载到宿主机的内存中，而不是持久化到磁盘。</p></li><li><p><strong>使用方式</strong>：通过 <code>--mount type=tmpfs</code> 指定挂载点，数据只存在于内存里。</p></li><li><p><strong>优点</strong>：</p><ul><li>读写速度快，性能极高。</li><li>数据不会落盘，安全性更高（适合存放敏感数据）。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>容器停止后数据即会丢失，无法持久化。</li></ul></li><li><p><strong>适用场景</strong>：适合需要高性能临时存储的场景，例如存放缓存文件、临时会话数据等。</p></li></ul><hr><p><img src="/img/Docker/volume/compare.png" alt="compare"></p><hr><p>下面是对三种存储方式的一个表格直观对比：</p><table><thead><tr><th>特性</th><th>Volume（卷）</th><th>Bind Mount（绑定挂载）</th><th>tmpfs Mount（内存挂载）</th></tr></thead><tbody><tr><td><strong>管理方式</strong></td><td>由 Docker 引擎统一管理，默认存放在 <code>/var/lib/docker/volumes</code></td><td>用户手动指定宿主机目录或文件</td><td>数据存放在宿主机内存中</td></tr><tr><td><strong>宿主机耦合度</strong></td><td>低，目录位置由 Docker 管理，迁移方便</td><td>高，依赖宿主机具体路径</td><td>无（只依赖宿主机内存）</td></tr><tr><td><strong>是否持久化</strong></td><td>✅ 是，容器删除后数据仍在</td><td>✅ 是，容器删除后数据仍在</td><td>❌ 否，容器停止后数据丢失</td></tr><tr><td><strong>性能</strong></td><td>中等（绕过 UnionFS，性能较好）</td><td>中等（直接访问宿主机目录）</td><td>高（纯内存读写，最快）</td></tr><tr><td><strong>优点</strong></td><td>简单、解耦、适合生产环境，可支持 Volume Driver</td><td>灵活，可直接使用宿主机已有目录或文件</td><td>高速读写，数据不落盘，安全性好</td></tr><tr><td><strong>缺点</strong></td><td>无法自定义宿主机目录，透明度较低</td><td>与宿主机耦合度高，迁移不便，易出错</td><td>数据不可持久化，容量受内存限制</td></tr><tr><td><strong>适用场景</strong></td><td>数据库、持久化业务（MySQL、Kafka 等）</td><td>开发调试、代码热更新、日志共享、指定目录</td><td>缓存、会话、临时文件、高性能应用</td></tr></tbody></table><hr><h2><span id="创建和管理存储卷">创建和管理存储卷</span></h2><p>Docker 提供了一套命令来专门管理卷（Volume）。这些命令可以帮助我们创建、查看、删除以及清理卷。下面我们详细看一下。</p><hr><h3><span id="方式一通过-volume-命令操作">方式一：通过 Volume 命令操作</span></h3><h4><span id="1-创建卷docker-volume-create">1. 创建卷：<code>docker volume create</code></span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my_volume</span><br></pre></td></tr></table></figure><ul><li><p><strong>功能</strong>：创建一个新的存储卷。</p></li><li><p><strong>关键参数</strong>：</p><ul><li><code>-d, --driver</code>：指定存储驱动，默认是 <code>local</code>。</li><li><code>--label</code>：为卷添加元数据标签，方便管理。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个默认卷</span></span><br><span class="line">docker volume create my_volume  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个带标签的卷</span></span><br><span class="line">docker volume create --label project=blog_data blog_volume</span><br></pre></td></tr></table></figure><p>创建完成后，可以在宿主机 <code>/var/lib/docker/volumes/</code> 目录下找到对应的卷。</p><hr><h4><span id="2-查看卷信息docker-volume-inspect">2. 查看卷信息：<code>docker volume inspect</code></span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect my_volume</span><br></pre></td></tr></table></figure><ul><li><p><strong>功能</strong>：查看卷的详细信息，例如挂载点、驱动、标签等。</p></li><li><p><strong>关键参数</strong>：</p><ul><li><code>-f</code>：指定输出格式，例如 <code>json</code>。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看卷的详细信息</span></span><br><span class="line">docker volume inspect my_volume  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 只输出卷的挂载路径</span></span><br><span class="line">docker volume inspect -f <span class="string">&#x27;&#123;&#123; .Mountpoint &#125;&#125;&#x27;</span> my_volume</span><br></pre></td></tr></table></figure><p>输出结果通常会包含卷的具体路径（Mountpoint），我们可以确认卷和宿主机之间的真实绑定位置。</p><hr><h4><span id="3-列出卷docker-volume-ls">3. 列出卷：<code>docker volume ls</code></span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>功能</strong>：显示当前所有的卷。</p></li><li><p><strong>关键参数</strong>：</p><ul><li><code>--format</code>：指定输出格式，例如 <code>json</code>、<code>table</code>。</li><li><code>--filter, -f</code>：按条件过滤卷，例如驱动类型或标签。</li><li><code>-q</code>：仅显示卷的名称（安静模式）。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示卷的名称</span></span><br><span class="line">docker volume <span class="built_in">ls</span> -q  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤出使用 local 驱动的卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span> -f driver=<span class="built_in">local</span></span><br></pre></td></tr></table></figure><hr><h4><span id="4-删除卷docker-volume-rm">4. 删除卷：<code>docker volume rm</code></span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> my_volume</span><br></pre></td></tr></table></figure><ul><li><p><strong>功能</strong>：删除指定卷（前提是该卷没有被任何容器使用）。</p></li><li><p><strong>关键参数</strong>：</p><ul><li><code>-f, --force</code>：强制删除正在使用的卷。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除一个卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> my_volume  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> -f blog_volume</span><br></pre></td></tr></table></figure><p>⚠️ 注意：如果卷被容器使用，直接删除会失败。除非使用 <code>-f</code> 强制删除，但这可能导致容器数据丢失。</p><hr><h4><span id="5-清理未使用的卷docker-volume-prune">5. 清理未使用的卷：<code>docker volume prune</code></span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><ul><li><p><strong>功能</strong>：清理掉所有未被容器使用的卷。</p></li><li><p><strong>关键参数</strong>：</p><ul><li><code>--filter</code>：按条件过滤要删除的卷。</li><li><code>-f, --force</code>：跳过确认提示，直接删除。</li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有未使用的卷（执行前会有确认提示）</span></span><br><span class="line">docker volume prune  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除所有未使用的卷</span></span><br><span class="line">docker volume prune -f  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除创建时间早于 24 小时的卷</span></span><br><span class="line">docker volume prune --filter <span class="string">&quot;until=24h&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令在日常开发中非常有用，尤其是反复测试创建容器后会产生很多孤立卷，通过 <code>prune</code> 可以一键清理，避免宿主机磁盘空间被占满。</p><hr><h3><span id="小结">小结</span></h3><p>通过这些命令，我们可以完成存储卷的<strong>生命周期管理</strong>：</p><ul><li><code>create</code> → 创建卷</li><li><code>inspect</code> → 查看卷信息</li><li><code>ls</code> → 列出所有卷</li><li><code>rm</code> → 删除指定卷</li><li><code>prune</code> → 清理未使用卷</li></ul><p>📌 建议在开发调试时，定期使用 <code>docker volume ls</code> 和 <code>docker volume prune</code>，保持宿主机的磁盘空间整洁。</p><hr><h3><span id="方式二在运行容器时挂载卷">方式二：在运行容器时挂载卷</span></h3><p>除了通过 <code>docker volume create</code> 命令手动创建卷外，我们还可以在运行容器时直接指定挂载，这样会自动创建并绑定卷。Docker 提供了两种常见方式：<code>-v</code> 和 <code>--mount</code>。</p><hr><h4><span id="1-使用-v-参数">1. 使用 <code>-v</code> 参数</span></h4><p><code>-v</code> 是 Docker 早期提供的挂载方式，语法相对简洁。</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v [卷名或宿主机路径]:[容器内路径][:选项] ...</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数说明</strong>：</p><ul><li>第一个参数：卷名称（如 <code>myvol</code>）或宿主机目录（如 <code>/data/logs</code>）。</li><li>第二个参数：容器内挂载目录。</li><li>第三个参数（可选）：挂载选项，例如 <code>ro</code> 表示只读。</li></ul></li></ul><p><strong>示例 1：挂载命名卷</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v myvol2:/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>这条命令会自动创建一个名为 <code>myvol2</code> 的卷，并挂载到容器的 <code>/app</code> 目录。</p><p>通过 <code>docker inspect devtest</code> 可以看到挂载详情：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;myvol2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/myvol2/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/app&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：挂载宿主机目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name devtest2 \</span><br><span class="line">  -v /home/user/logs:/var/log/nginx \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>这里将宿主机的 <code>/home/user/logs</code> 目录映射到容器的 <code>/var/log/nginx</code>，日志会直接写入宿主机目录。</p><p><strong>示例 3：只读挂载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name devtest3 \</span><br><span class="line">  -v myvol3:/data:ro \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>这里的卷挂载到容器内 <code>/data</code>，但容器只能读取，无法写入。</p><hr><h4><span id="2-使用-mount-参数">2. 使用 <code>--mount</code> 参数</span></h4><p><code>--mount</code> 是 Docker 较新的推荐方式，语法比 <code>-v</code> 更加<strong>明确和可读</strong>。</p><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount <span class="built_in">type</span>=&lt;类型&gt;,<span class="built_in">source</span>=&lt;卷名或宿主机路径&gt;,target=&lt;容器内路径&gt;[,选项]</span><br></pre></td></tr></table></figure><ul><li><p><strong>关键参数</strong>：</p><ul><li><code>type</code>：挂载类型（<code>volume</code>、<code>bind</code> 或 <code>tmpfs</code>）。</li><li><code>source</code> &#x2F; <code>src</code>：卷名或宿主机目录。</li><li><code>destination</code> &#x2F; <code>dst</code> &#x2F; <code>target</code>：容器内的挂载路径。</li><li><code>readonly</code> &#x2F; <code>ro</code>：只读挂载。</li></ul></li></ul><p><strong>示例 1：挂载命名卷</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=myvol2,target=/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>输出 <code>docker inspect devtest</code> 的结果与 <code>-v</code> 类似：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;myvol2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/myvol2/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/app&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：挂载宿主机目录（bind mount）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name devtest2 \</span><br><span class="line">  --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/home/user/logs,target=/var/log/nginx \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>这和 <code>-v /home/user/logs:/var/log/nginx</code> 等价，但语法更清晰。</p><p><strong>示例 3：只读挂载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name devtest3 \</span><br><span class="line">  --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=myvol3,target=/data,<span class="built_in">readonly</span> \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>容器内 <code>/data</code> 目录为只读。</p><hr><h4><span id="3-v-与-mount-的区别">3. <code>-v</code> 与 <code>--mount</code> 的区别</span></h4><table><thead><tr><th>对比项</th><th><code>-v</code> 参数</th><th><code>--mount</code> 参数</th></tr></thead><tbody><tr><td><strong>语法</strong></td><td>简洁，但容易出错（顺序重要）</td><td>结构化，语义更清晰</td></tr><tr><td><strong>功能覆盖</strong></td><td>支持 <code>volume</code> 和 <code>bind</code></td><td>支持 <code>volume</code>、<code>bind</code>、<code>tmpfs</code></td></tr><tr><td><strong>可读性</strong></td><td>相对较差</td><td>更好，推荐生产环境使用</td></tr><tr><td><strong>常见用途</strong></td><td>开发测试、快速挂载</td><td>生产环境，复杂挂载场景</td></tr></tbody></table><p>📌 建议：</p><ul><li>在 <strong>开发阶段</strong> 可以图方便用 <code>-v</code>。</li><li>在 <strong>生产环境</strong> 建议统一使用 <code>--mount</code>，避免出错，也方便团队成员理解配置。</li></ul><hr><h3><span id="方式三dockerfile-匿名卷">方式三：Dockerfile 匿名卷</span></h3><p>通过 Dockerfile 的 VOLUME 可以创建 docker 管理卷，我将在后面的 Dockerfile 章节中详细介绍</p><hr><h2><span id="三种存储卷操作实例">三种存储卷操作实例</span></h2><h3><span id="docker-命令创建管理卷">Docker 命令创建管理卷</span></h3><h4><span id="1-创建存储卷">1. 创建存储卷</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create test_volume</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_volume</span><br></pre></td></tr></table></figure><hr><h4><span id="2-使用卷运行容器">2. 使用卷运行容器</span></h4><p>将刚才创建的卷挂载到 Nginx 容器中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run --name nginx1 -d -p 5566:80 \</span><br><span class="line">  -v test_volume:/usr/share/nginx/html \</span><br><span class="line">  nginx:1.22.1</span><br></pre></td></tr></table></figure><p>同样，我们也可以运行另一个容器，挂载到同一个卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run --name nginx2 -d -p 5577:80 \</span><br><span class="line">  -v test_volume:/usr/share/nginx/html \</span><br><span class="line">  nginx:1.22.1</span><br></pre></td></tr></table></figure><p>这样两个容器共享同一个卷，数据会同步。</p><hr><h4><span id="3-查看存储卷列表">3. 查看存储卷列表</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     test_volume</span><br></pre></td></tr></table></figure><hr><h4><span id="4-查看卷的详细信息">4. 查看卷的详细信息</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect test_volume</span><br></pre></td></tr></table></figure><p>输出结果（部分）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-09-02T12:23:12+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/data/var/lib/docker/volumes/test_volume/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test_volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>Mountpoint</code> 对应宿主机上的真实目录。</p><hr><h4><span id="5-查看宿主机目录">5. 查看宿主机目录</span></h4><p>进入卷对应的目录，可以看到 Nginx 默认的网页文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/var/lib/docker/volumes/test_volume/_data</span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total 16</span><br><span class="line">drwxr-xr-x 2 root root 4096 Mar 16 12:32 ./</span><br><span class="line">drwx-----x 3 root root 4096 Mar 16 12:16 ../</span><br><span class="line">-rw-r--r-- 1 root root  497 Oct 19 16:02 50x.html</span><br><span class="line">-rw-r--r-- 1 root root  615 Oct 19 16:02 index.html</span><br></pre></td></tr></table></figure><hr><h4><span id="6-查看容器挂载信息">6. 查看容器挂载信息</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect nginx1</span><br></pre></td></tr></table></figure><p>输出结果（部分）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test_volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/data/var/lib/docker/volumes/test_volume/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>说明 <code>test_volume</code> 已经挂载到容器的 <code>/usr/share/nginx/html</code> 目录中。</p><hr><h4><span id="7-修改宿主机文件并同步到容器">7. 修改宿主机文件并同步到容器</span></h4><p>修改宿主机上的 <code>index.html</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/var/lib/docker/volumes/test_volume/_data</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello Volume&quot;</span> &gt; index.html</span><br></pre></td></tr></table></figure><p>然后通过浏览器访问 <code>http://宿主机IP:5566</code>，即可看到更新后的内容，证明宿主机和容器数据同步：</p><p><img src="/img/Docker/volume/volume_url.png" alt="volume_url"></p><hr><h4><span id="8-停止并删除容器">8. 停止并删除容器</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx1</span><br><span class="line">docker <span class="built_in">rm</span> nginx1</span><br></pre></td></tr></table></figure><p>卷不会随着容器的删除而消失，数据依然存在。</p><hr><p>通过以上实验可以得出：</p><ul><li><strong>宿主机和容器之间数据是实时同步的</strong>。</li><li><strong>容器删除后，卷仍然保留，数据不会丢失</strong>。</li></ul><h3><span id="docker-v-创建管理卷">Docker -v 创建管理卷</span></h3><p>下面演示如何使用 <code>-v</code> 参数创建和挂载存储卷，并验证 <strong>只读模式 (ro)</strong> 的效果。</p><hr><h4><span id="1-使用-v-创建卷并启动容器">1. 使用 -v 创建卷并启动容器</span></h4><p>通过 <code>-v</code> 指定一个新卷 <code>test_volume2</code>，挂载到 Nginx 容器的 <code>/usr/share/nginx/html</code> 目录，并设置为只读模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run --name nginx2 -d -p 5566:80 \</span><br><span class="line">  -v test_volume2:/usr/share/nginx/html:ro \</span><br><span class="line">  nginx:1.22.1</span><br></pre></td></tr></table></figure><hr><h4><span id="2-查看卷信息">2. 查看卷信息</span></h4><p>使用 <code>docker inspect</code> 查看卷对应的宿主机目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect test_volume2</span><br></pre></td></tr></table></figure><p>输出结果（部分）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-09-02T12:23:35+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/data/var/lib/docker/volumes/test_volume2/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test_volume2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>进入宿主机目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/var/lib/docker/volumes/test_volume2/_data</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50x.html  index.html</span><br></pre></td></tr></table></figure><hr><h4><span id="3-修改宿主机中的文件">3. 修改宿主机中的文件</span></h4><p>在宿主机上修改 <code>index.html</code> 内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello Volume -v&quot; &gt; index.html</span><br><span class="line">cat index.html</span><br></pre></td></tr></table></figure><p>通过浏览器访问 <code>http://宿主机IP:5566</code>，可以看到页面内容已更新：</p><p><img src="/img/Docker/volume/volume_v.png" alt="volume_v"></p><hr><h4><span id="4-在容器中尝试修改文件">4. 在容器中尝试修改文件</span></h4><p>进入容器，尝试删除 <code>index.html</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it nginx2 bash</span><br><span class="line">cd /usr/share/nginx/html/</span><br><span class="line">rm index.html</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;index.html&#x27;</span>: Read-only file system</span><br></pre></td></tr></table></figure><p>说明容器内的该目录是只读的，无法修改文件。</p><hr><h4><span id="5-清理释放空间">5. 清理释放空间</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx2</span><br><span class="line">docker rm nginx2</span><br></pre></td></tr></table></figure><hr><ul><li>使用 <code>-v</code> 挂载卷时，如果添加 <code>:ro</code> 参数，则表示挂载目录为 <strong>只读模式</strong>。</li><li>在 <strong>宿主机</strong> 上可以修改文件；但在 <strong>容器内</strong> 无法修改，保证了数据的安全性。</li></ul><hr><h3><span id="docker-mount-创建管理卷">Docker –mount 创建管理卷</span></h3><p>下面演示如何使用 <code>--mount</code> 参数创建并挂载存储卷，验证宿主机和容器的数据同步效果。</p><hr><h4><span id="1-使用-mount-创建卷并启动容器">1. 使用 –mount 创建卷并启动容器</span></h4><p>通过 <code>--mount</code> 指定一个新卷 <code>test_volume3</code>，并挂载到 Nginx 容器的 <code>/usr/share/nginx/html</code> 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run --name nginx3 -d -p 5566:80 \</span><br><span class="line">  --mount type=volume,source=test_volume3,target=/usr/share/nginx/html \</span><br><span class="line">  nginx:1.22.1</span><br></pre></td></tr></table></figure><hr><h4><span id="2-查看卷是否创建成功">2. 查看卷是否创建成功</span></h4><p>使用 <code>docker volume ls</code> 查看已创建的卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>示例输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     test_volume3</span><br><span class="line"><span class="built_in">local</span>     myvoltest1</span><br><span class="line"><span class="built_in">local</span>     myvoltest2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到 <code>test_volume3</code> 已经在卷列表中。</p><hr><h4><span id="3-查看卷的挂载点">3. 查看卷的挂载点</span></h4><p>使用 <code>docker volume inspect</code> 查看卷对应的宿主机目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect test_volume3</span><br></pre></td></tr></table></figure><p>输出结果（部分）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-09-03T00:05:13+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/data/var/lib/docker/volumes/test_volume3/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test_volume3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><hr><h4><span id="4-修改宿主机中的文件内容">4. 修改宿主机中的文件内容</span></h4><p>进入卷目录并修改 <code>index.html</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data/var/lib/docker/volumes/test_volume3/_data</span><br><span class="line">echo &quot;Hello Volume - mount&quot; &gt; index.html</span><br><span class="line">cat index.html</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Volume - mount</span><br></pre></td></tr></table></figure><p>此时浏览器访问 <code>http://宿主机IP:5566</code>，即可看到页面内容已更新：</p><p><img src="/img/Docker/volume/volume_mount.png" alt="volume_mount"></p><hr><h4><span id="5-清理释放空间">5. 清理释放空间</span></h4><p>实验完成后，可以停止并删除容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx3</span><br><span class="line">docker rm nginx3</span><br></pre></td></tr></table></figure><hr><ul><li>使用 <code>--mount</code> 创建卷时，可以显式指定 <code>type</code>、<code>source</code> 和 <code>target</code>，比 <code>-v</code> 更加清晰和可读。</li><li>卷中的数据会在宿主机和容器之间实时同步，适合持久化存储场景。</li></ul><hr><h3><span id="绑定卷-bind-mount">绑定卷 bind mount</span></h3><p>绑定卷（bind mount）是将宿主机的一个目录直接挂载到容器内，与管理卷不同，它直接使用宿主机指定的目录，而不是由 Docker 自动管理。</p><hr><h4><span id="1-使用-v-创建绑定卷">1. 使用 -v 创建绑定卷</span></h4><p><strong>功能：</strong> 将宿主机目录映射到容器目录，实现数据共享。</p><p><strong>语法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v &lt;宿主机目录&gt;:&lt;容器目录&gt;[:options] ...</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数说明</strong>：</p><ul><li>第一个参数：宿主机目录（与管理卷不同，需要手动指定路径）</li><li>第二个参数：容器内挂载目录</li><li>第三个参数（可选）：挂载选项，如 <code>ro</code> 表示只读</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>说明：宿主机当前目录下的 <code>target</code> 会挂载到容器的 <code>/app</code>，容器可以直接访问宿主机的文件。</p><hr><h4><span id="2-使用-mount-创建绑定卷">2. 使用 –mount 创建绑定卷</span></h4><p><strong>功能：</strong> 与 <code>-v</code> 类似，但语法更清晰，推荐在生产环境使用。</p><p><strong>语法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount type=bind,source=&lt;宿主机目录&gt;,target=&lt;容器目录&gt;[,readonly]</span><br></pre></td></tr></table></figure><ul><li><p><strong>关键参数：</strong></p><ul><li><code>type</code>：<code>bind</code> 表示绑定卷</li><li><code>source</code> &#x2F; <code>src</code>：宿主机目录（与管理卷不同，需要指定路径）</li><li><code>target</code> &#x2F; <code>dst</code>：容器挂载路径</li><li><code>readonly</code> &#x2F; <code>ro</code>：只读挂载（可选）</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>说明：效果与 <code>-v</code> 类似，但参数更直观，适合团队协作和复杂挂载场景。</p><hr><ul><li><strong>管理卷 (volume)</strong>：由 Docker 管理，适合数据持久化和容器间共享。</li><li><strong>绑定卷 (bind mount)</strong>：直接使用宿主机目录，灵活，但需要手动管理路径。</li><li>对比来看，绑定卷更适合开发调试或访问宿主机已有数据，管理卷更适合生产环境和数据持久化。</li></ul><hr><h3><span id="临时卷-tmpfs">临时卷 tmpfs</span></h3><p>临时卷（tmpfs）是将数据存储在 <strong>内存中</strong>，不落在宿主机或容器文件系统上，因此速度非常快，但有一定局限性：</p><ul><li><p><strong>局限性</strong></p><ul><li>不同于卷和绑定卷，<strong>不能在容器之间共享 tmpfs 挂载</strong></li><li>仅在 Linux 系统上运行 Docker 时可用</li></ul></li></ul><hr><h4><span id="1-使用-tmpfs-创建临时卷">1. 使用 <code>--tmpfs</code> 创建临时卷</span></h4><p><strong>功能：</strong> 将容器目录映射到内存中，实现高速临时存储</p><p><strong>语法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--tmpfs &lt;容器目录&gt;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it \</span><br><span class="line">  --name tmptest \</span><br><span class="line">  --tmpfs /app \</span><br><span class="line">  nginx:1.22.1</span><br></pre></td></tr></table></figure><p>说明：容器内的 <code>/app</code> 目录完全位于内存中，容器停止后数据会消失。</p><hr><h4><span id="2-使用-mount-创建临时卷">2. 使用 <code>--mount</code> 创建临时卷</span></h4><p><strong>功能：</strong> 与 <code>--tmpfs</code> 类似，但语法更灵活，可指定更多参数</p><p><strong>语法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount type=tmpfs,destination=&lt;容器目录&gt;[,tmpfs-size=&lt;大小&gt;,tmpfs-mode=&lt;权限&gt;]</span><br></pre></td></tr></table></figure><ul><li><p><strong>关键参数</strong>：</p><ul><li><code>type</code>：<code>tmpfs</code></li><li><code>destination</code> &#x2F; <code>target</code>：挂载到容器的目录</li><li><code>tmpfs-size</code>：tmpfs 容量（以字节为单位），默认无限制</li><li><code>tmpfs-mode</code>：文件权限（八进制），默认 1777</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it \</span><br><span class="line">  --name tmptest \</span><br><span class="line">  --mount type=tmpfs,destination=/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>说明：<code>/app</code> 目录位于内存中，高速且临时，容器停止后数据会丢失。</p><hr><ul><li><strong>临时卷 tmpfs</strong> 适合存放<strong>高速临时数据</strong>，如缓存、会话文件等</li><li>数据存放在内存中，<strong>容器停止或重启后会消失</strong></li><li>不适合需要持久化或跨容器共享的场景</li></ul><hr><h3><span id="卷使用特殊注意事项">卷使用特殊注意事项</span></h3><h4><span id="1-普通卷volume">1. 普通卷（Volume）</span></h4><ul><li><p><strong>行为说明</strong>：</p><ul><li>当使用 <code>-v</code> 或 <code>--mount</code> 指定卷名时，如果该卷已经存在，容器直接挂载这个卷。</li><li>如果卷不存在，Docker 会自动在管理目录下创建该卷，并<strong>将容器挂载点的初始文件内容复制到卷目录中</strong>。</li></ul></li><li><p><strong>注意点</strong>：保证卷一开始不是空的，方便数据持久化和初始化。</p></li></ul><hr><h4><span id="2-绑定卷bind-mount">2. 绑定卷（Bind mount）</span></h4><ul><li><p><strong>行为说明</strong>：</p><ul><li>使用 <code>-v</code> 指定宿主机目录不存在时，Docker 会自动创建这个目录，但目录内容为空，不会复制容器挂载点的文件。</li><li>使用 <code>--mount type=bind</code> 指定不存在的宿主机目录时，会报错，需要手动创建。</li></ul></li><li><p><strong>注意点</strong>：绑定卷依赖宿主机目录结构，适合直接访问宿主机已有文件。</p></li></ul><hr><h4><span id="3-临时卷tmpfs">3. 临时卷（tmpfs）</span></h4><ul><li><p><strong>行为说明</strong>：</p><ul><li>容器内挂载目录是空目录，数据完全存储在内存中。</li><li>容器停止或删除后，数据会完全丢失。</li></ul></li><li><p><strong>注意点</strong>：适合高速临时数据存储，不能持久化，也不能跨容器共享。</p></li></ul><hr><h4><span id="卷类型特殊行为总结表">卷类型特殊行为总结表</span></h4><table><thead><tr><th>卷类型</th><th>容器挂载时是否存在数据</th><th>宿主机目录不存在时处理</th><th>是否复制容器目录初始内容</th><th>数据持久化</th><th>跨容器共享</th></tr></thead><tbody><tr><td>普通卷 Volume</td><td>如果卷已存在，则继承</td><td>Docker 自动创建卷</td><td>会复制</td><td>是</td><td>是</td></tr><tr><td>绑定卷 Bind</td><td>直接使用宿主机目录</td><td>-v：自动创建空目录</td><td>不会复制</td><td>否</td><td>否</td></tr><tr><td></td><td></td><td>–mount：报错</td><td></td><td></td><td></td></tr><tr><td>临时卷 tmpfs</td><td>总是空目录</td><td>不适用</td><td>不适用</td><td>否</td><td>否</td></tr></tbody></table><h2><span id="mysql灾难恢复实验">MySQL灾难恢复实验</span></h2><p>本实验旨在验证使用Docker部署MySQL时，如何通过挂载宿主机目录实现数据的持久化存储，以及在容器异常删除后如何依旧能够完成数据恢复。</p><h3><span id="实验步骤">实验步骤</span></h3><ol><li><p><strong>初始化前准备</strong><br>在宿主机上创建一个空目录作为MySQL数据挂载点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mydata/datadir</span><br><span class="line">ll /mydata/datadir</span><br></pre></td></tr></table></figure><p>此时目录下无任何文件。</p></li><li><p><strong>运行MySQL容器并挂载目录</strong><br>使用<code>-v</code>参数将宿主机目录挂载到容器的<code>/var/lib/mysql</code>路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql3 -v /mydata/datadir:/var/lib/mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=ljx@docker -d mysql:8.0.41</span><br></pre></td></tr></table></figure><p>启动后，可以看到<code>/mydata/datadir</code>目录中立即生成了MySQL系统数据库文件和相关配置。</p></li><li><p><strong>向数据库中插入数据</strong><br>进入容器并操作数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql3 bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>创建数据库和表，并插入一条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database test;</span><br><span class="line">use test;</span><br><span class="line"><span class="keyword">create table</span> t1(name <span class="type">varchar</span>(<span class="number">50</span>), age <span class="type">int</span>);</span><br><span class="line"><span class="keyword">insert into</span> t1 <span class="keyword">values</span>(<span class="string">&#x27;ljx&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure><p>查询结果显示数据已成功写入。</p></li><li><p><strong>模拟容器被异常中断和删除</strong><br>模拟类似公司突然断电的情况，直接删除容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop mysql3</span><br><span class="line">docker <span class="built_in">rm</span> mysql3</span><br></pre></td></tr></table></figure></li><li><p><strong>重新创建新容器并挂载同一目录</strong><br>重新运行MySQL容器，仍挂载之前的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql4 -v /mydata/datadir:/var/lib/mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=ljx@docker -d mysql:8.0.41</span><br></pre></td></tr></table></figure><p>登录数据库后，发现数据依旧存在：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line">use test;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure><p>可以看到之前插入的数据<code>(&#39;ljx&#39;, 19)</code>仍然保留。</p></li></ol><h3><span id="原理解析">原理解析</span></h3><ul><li><p><strong>为什么空目录会被写入数据？</strong><br>这是因为MySQL官方镜像在启动时会检查挂载的目录是否为空。如果为空，它会自动进行<strong>初始化</strong>，将系统数据库（如<code>mysql</code>、<code>sys</code>、<code>performance_schema</code>）从镜像内置的模板复制到挂载目录中，以保证MySQL能够正常启动。</p></li><li><p><strong>数据持久化的原因</strong><br>数据实际存储在宿主机的<code>/mydata/datadir</code>目录中，而不是容器内部。当容器被删除时，宿主机上的数据不会受到影响。因此，只要再次挂载同一目录，新容器就能直接读取并继续使用原有数据。</p></li></ul><h3><span id="实验结论">实验结论</span></h3><p>通过本实验可以看出：</p><ul><li><strong>挂载宿主机目录</strong>是实现MySQL数据持久化的关键。</li><li>即使容器因故障被删除，只要数据目录未丢失，创建新的MySQL容器并挂载同一目录，即可实现数据恢复。</li><li>这为生产环境下的<strong>灾难恢复</strong>提供了保障，也是容器化数据库部署中必须重视的操作方式。</li></ul><p>在实际生产环境中，仅依赖宿主机目录挂载虽然能够实现数据持久化，但仍然存在一定风险，例如：宿主机磁盘损坏、误操作删除目录、迁移时路径不一致等。因此在部署MySQL时，可以结合以下最佳实践来增强可靠性和可维护性：</p><ol><li><p><strong>优先使用Volume</strong><br>Docker原生的Volume由引擎统一管理，解耦了容器与宿主机的路径关系，迁移和跨环境使用更方便。如果需要指定存储位置，可以通过Volume Driver（如NFS、Ceph、云盘插件）实现，将卷存储到独立的存储介质上。</p></li><li><p><strong>定期备份数据库</strong><br>即使数据存储在持久化目录中，也难以完全避免硬件损坏、误删或勒索软件攻击。应通过 <code>mysqldump</code>、<code>mysqlpump</code> 或者物理备份工具（如 <code>xtrabackup</code>）进行定期备份，并将备份文件存放到独立存储设备或远程服务器。</p></li><li><p><strong>数据与容器分离</strong><br>养成“无状态化容器”的习惯，应用容器和数据存储应彻底分离。容器随时可以销毁重建，而数据应稳定存在于卷或外部存储中。</p></li><li><p><strong>多副本与高可用</strong><br>在关键业务中，单节点的挂载和持久化并不足以保障数据安全。建议部署MySQL主从复制（Replication）、MGR（Group Replication）或借助Kubernetes StatefulSet，结合PV（Persistent Volume）实现多副本存储与自动恢复。</p></li></ol><p>通过以上措施，可以在容器化环境中既保持MySQL的高性能和灵活性，又确保数据安全与可恢复性，从而满足生产环境对可靠性的要求。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端工具 </category>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 存储卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Container（容器）使用指南</title>
      <link href="/2025/08/31/Docker/docker_container/"/>
      <url>/2025/08/31/Docker/docker_container/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8">什么是容器</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%B9%E5%99%A8">为什么需要容器</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">容器的生命周期</a><ul><li><a href="#%E5%AE%B9%E5%99%A8-oom">容器 OOM</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA">容器异常退出</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E6%9A%82%E5%81%9C">容器暂停</a></li></ul></li><li><a href="#docker-container-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">Docker Container 常用命令</a><ul><li><a href="#docker-create">docker create</a></li><li><a href="#docker-start">docker start</a></li><li><a href="#docker-run">docker run</a></li><li><a href="#docker-ps">docker ps</a></li><li><a href="#docker-logs">docker logs</a></li><li><a href="#docker-attach">docker attach</a></li><li><a href="#docker-exec">docker exec</a></li><li><a href="#docker-restart">docker restart</a></li><li><a href="#docker-stop">docker stop</a></li><li><a href="#docker-kill">docker kill</a></li><li><a href="#docker-top">docker top</a></li><li><a href="#docker-stat">docker stat</a></li><li><a href="#docker-container-inspect">docker container inspect</a></li><li><a href="#docker-port">docker port</a></li><li><a href="#docker-cp">docker cp</a></li><li><a href="#docker-diff">docker diff</a></li><li><a href="#docker-commit">docker commit</a></li><li><a href="#docker-pause-%E5%92%8C-docker-unpause">docker pause 和 docker unpause</a></li><li><a href="#docker-rm">docker rm</a></li><li><a href="#docker-export-%E5%92%8C-docker-import">docker export 和 docker import</a></li><li><a href="#docker-wait">docker wait</a></li><li><a href="#docker-rename">docker rename</a></li><li><a href="#docker-container-prune">docker container prune</a></li><li><a href="#docker-update">docker update</a></li></ul></li></ul><!-- tocstop --><h2><span id="什么是容器">什么是容器</span></h2><p>通俗地讲，容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。即容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态。<br>虽然容器的本质是主机上运行的一个进程，但是容器有自己独立的命名空间隔离和资源限制。也就是说，在容器内部，无法看到主机上的进程、环境变量、网络等信息，这是容器与直接运行在主机上进程的本质区别。<br>容器是基于镜像创建的可运行实例，并且单独存在，一个镜像可以创建出多个容器。运行容器化环境时，实际上是在容器内部创建该文件系统的读写副本。这将添加一个容器层，该层允许修改镜像的整个副本。</p><p><img src="/img/Docker/container/base.png" alt="base"></p><h2><span id="为什么需要容器">为什么需要容器</span></h2><p>镜像是静态文件，是只读的，它并不能提供服务，就好比我有一个 <code>Linux</code> 的光盘，它里面有操作系统的所有文件，但我无法直接从光盘上运行这些文件。为了让这些文件发挥作用，我需要将它们加载到内存中并运行。这就是容器的作用，它为镜像提供了一个可运行的环境。</p><h2><span id="容器的生命周期">容器的生命周期</span></h2><p>容器的生命周期指的是容器可能处于的不同状态，通常分为以下几类：</p><p>1、created：容器已创建，但尚未启动。<br>2、running：容器正在运行中。<br>3、stopped：容器已停止运行。<br>4、paused：容器已暂停。<br>5、deleted：容器已被删除。</p><p>各生命周期之间的转换关系如图所示：</p><p><img src="/img/Docker/container/status.png" alt="status"></p><p><strong>名词解释如下</strong>：</p><ul><li><strong><code>docker create</code></strong>：创建容器后，不立即启动运行，容器进入初建状态；</li><li><strong><code>docker run</code></strong>：创建容器，并立即启动运行，进入运行状态；</li><li><strong><code>docker start</code></strong>：容器转为运行状态；</li><li><strong><code>docker stop</code></strong>：容器将转入停止状态；</li><li><strong><code>docker kill</code></strong>：容器在故障（死机）时，执行 kill（断电），容器转入停止状态，这种操作容易丢失数据，除非必要，否则不建议使用；</li><li><strong><code>docker restart</code></strong>：重启容器，容器转入运行状态；</li><li><strong><code>docker pause</code></strong>：容器进入暂停状态；</li><li><strong><code>docker unpause</code></strong>：取消暂停状态，容器进入运行状态；</li><li><strong><code>docker rm</code></strong>：删除容器，容器转入删除状态。</li></ul><p><strong>异常终止状态说明</strong>：</p><ul><li>killed by out-of-memory（因内存不足被终止）</li></ul><p>宿主机内存被耗尽，也被称为 OOM。属于<strong>非计划终止</strong>，这时需要杀死最吃内存的容器。</p><ul><li>container process exited（异常终止）</li></ul><p>出现容器被终止后，将进入 <code>Should restart?</code> 选择操作：</p><ul><li><strong>yes</strong>：需要重启，容器执行 <code>start</code> 命令，转为运行状态。</li><li><strong>no</strong>：不需要重启，容器转为停止状态。</li></ul><p>针对容器的 OOM、异常退出以及暂停，我们来作进一步的深入分析。</p><h3><span id="容器-oom">容器 OOM</span></h3><p>Docker 在处理 OOM 事件时分为三种情况：</p><p>（1）容器内存超限触发 OOM<br>如果容器中的应用耗尽了主机系统分配给容器的内存限额，就会触发 OOM 事件。例如，在容器当中部署了一个 web 服务。假设主机分配给此容器的内存上限为 1G，当脚本申请的内存大于 1G 时，此容器就会触发 OOM 事件。而在这种情况下，此容器将会被强制关闭。</p><p>但需要注意的是，此时关闭容器的并非是 Docker Daemon，而是宿主机操作系统。因为一个容器其实就是一组运行在宿主机操作系统中的进程，宿主机操作系统通过 cgroups 对这组进程设定资源上限，当这些进程申请的资源到达上限时，触发的是宿主机操作系统的内核 OOM 事件，因此最终是由宿主机内核来关闭这些进程。</p><p>（2）禁用 OOM-Killer 的情况<br>如果用户不想关闭这个容器，那么可以选择 <code>--oom-kill-disable</code> 来禁用 OOM-Killer。使用此参数时，仍需要注意：如果使用 <code>-m</code> 设置了此容器内存上限，那么当容器到达内存资源上限时，主机不会关闭容器，但也不会继续向此容器继续分配资源，此时容器将处于 hung 状态。只需要将最坏的情况封闭在一定范围之内，而不至于蔓延出去。</p><p>（3）禁用 OOM-Killer 但未设置内存上限<br>如果用户使用了 <code>--oom-kill-disable</code>，但也没有使用 <code>-m</code> 来设定上限，因而此时此容器将会尽可能地使用主机内存资源。换言之，主机内存有多大，它就将用多大。</p><h3><span id="容器异常退出">容器异常退出</span></h3><p>每个容器内部都存在一个 Init 进程，容器中其他所有进程都是此进程的子进程。运行的容器是因为 Init 进程在运行，如果一个子进程因为某种原因造成了退出，那么其父进程也会同步退出，直至 Init 进程也退出。当 Init 进程退出时，也就代表着此容器被关闭。</p><p>Docker 目前没有办法知道此时的进程退出属于正常退出还是异常退出。当出现容器关闭情况时，Docker Daemon 会尝试再次重新将此容器由 Stopped 状态转为 Running 状态。只有设置了 <code>--restart</code> 参数的容器，Docker Daemon 才会去尝试启动，否则容器会保持停止状态。</p><h3><span id="容器暂停">容器暂停</span></h3><p>Docker”剥夺”了此容器的 CPU 资源。而其他资源，如 Memory 资源、Network 资源等还保留未动。如此一来，失去了 CPU 资源的进程，是不会被主机内核系统所调度的，所以此容器就处于”冰封”状态，底层实现上，实际上就是不给该容器的进程分配时间片。</p><h2><span id="docker-container-常用命令">Docker Container 常用命令</span></h2><h3><span id="docker-create">docker create</span></h3><p><code>docker create</code> 命令用于<strong>创建一个新的容器</strong>，但<strong>并不会立即启动它</strong>。</p><p>语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>你可以把它想象成买了一辆新车（从镜像创建容器），把它停在了车库裡，但还没有插入钥匙启动引擎。此时，车辆的所有配置（颜色、型号、内饰）都已就绪，只差最后一步——点火。</p><h4><span id="docker-create-与-docker-run-的区别"><code>docker create</code> 与 <code>docker run</code> 的区别</span></h4><p>我们可以用一个简单的类比来区分：</p><ul><li><p><strong><code>docker run = docker create + docker start</code></strong></p><ul><li><code>docker run nginx:latest</code>：这条命令会直接拉取镜像（如果本地没有）、创建容器、并立刻启动它，让你马上看到一个运行中的 Nginx 服务。</li></ul></li><li><p><strong><code>docker create</code></strong>：它只完成 <code>docker run</code> 的前半部分工作。</p><ul><li><code>docker create --name my-nginx nginx:latest</code>：这条命令会基于 <code>nginx:latest</code> 镜像创建好一个容器，配置好一切，然后将其置于<strong>已创建（Created）</strong> 状态。此时，容器存在，但内部的进程（如 Nginx 主进程）还没有启动。</li></ul></li></ul><p><strong>核心区别在于</strong>：<code>docker create</code> 让容器在运行前有一个“停滞”的状态，这为我们提供了检查和修改配置的机会。</p><h4><span id="docker-create-的核心工作流程"><code>docker create</code> 的核心工作流程</span></h4><ol><li><strong>查找镜像</strong>：首先，Docker 会在本地查找指定的镜像（如 <code>nginx:latest</code>）。如果找不到，它会尝试从配置的仓库（如 Docker Hub）拉取。</li><li><strong>创建容器层</strong>：在镜像的只读层（Read-only Layers）之上，添加一个可写的容器层（Container Layer），为未来的文件系统更改做准备。</li><li><strong>配置网络</strong>：根据命令参数或默认配置，为容器设置网络模式（如桥接网络 <code>bridge</code>）。</li><li><strong>初始化配置</strong>：处理所有通过 <code>-e</code>（环境变量）、<code>-v</code>（数据卷）、<code>-p</code>（端口映射）等参数传递的配置。</li><li><strong>准备执行</strong>：设置好默认要运行的命令（即 Dockerfile 中的 <code>CMD</code> 或 <code>ENTRYPOINT</code>），但<strong>不执行它</strong>。</li><li><strong>输出容器 ID</strong>：最终，命令会返回一个唯一的长 ID（如 <code>f39a6aadc79f...</code>）和容器名称，表示创建成功。</li></ol><h4><span id="常用参数和示例">常用参数和示例</span></h4><p><code>docker create</code> 的参数与 <code>docker run</code> 几乎完全一致，因为它需要为容器设定所有运行时的配置。</p><p><strong>基本示例 1：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 `my_web` 的 Nginx 容器，但不启动它</span></span><br><span class="line">docker create --name my_web nginx:latest</span><br></pre></td></tr></table></figure><p><strong>基本示例 2（包含常用参数）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个复杂的容器</span></span><br><span class="line">docker create \</span><br><span class="line">  --name my_app \                  <span class="comment"># 为容器指定一个名称</span></span><br><span class="line">  -p 8080:80 \                     <span class="comment"># 将主机的 8080 端口映射到容器的 80 端口</span></span><br><span class="line">  -v /host/path:/container/path \  <span class="comment"># 挂载主机目录到容器中</span></span><br><span class="line">  -e ENV_VAR=<span class="string">&quot;my_value&quot;</span> \          <span class="comment"># 设置环境变量</span></span><br><span class="line">  --restart=unless-stopped \       <span class="comment"># 设置重启策略</span></span><br><span class="line">  nginx:latest                     <span class="comment"># 使用的镜像</span></span><br></pre></td></tr></table></figure><p>执行上述命令后，你会得到一个容器 ID，表示容器已创建成功。可以使用 <code>docker ps -a</code> 查看所有容器（包括已停止的），你会发现 <code>my_app</code> 的状态是 <code>Created</code>。</p><h4><span id="docker-create-的典型应用场景"><code>docker create</code> 的典型应用场景</span></h4><ol><li><strong>预先配置</strong>：在复杂部署前，先创建容器以确保所有配置（如卷挂载、环境变量）正确无误，之后再统一启动。</li><li><strong>CI&#x2F;CD 流水线</strong>：在持续集成&#x2F;部署中，可以先创建容器镜像，然后在一个部署阶段统一启动所有容器，保证服务同时上线。</li><li><strong>调试和检查</strong>：创建后，可以使用 <code>docker inspect &lt;container_id&gt;</code> 命令详细检查容器的所有配置，确保其符合预期，然后再启动。</li><li><strong>作为模板</strong>：我们可以先创建一个配置好的容器，如果需要多个相同配置的实例，可以基于这个已创建的容器来提交新的镜像，或者作为参考模板。</li></ol><h3><span id="docker-start">docker start</span></h3><p>创建容器后，通常会需要启动它：</p><p>语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个已创建的容器</span></span><br><span class="line">docker start my_web</span><br></pre></td></tr></table></figure><p>这条命令会将容器从 <code>Created</code> 状态转为 <code>Running</code> 状态，启动容器内的主进程（如 Nginx 服务）。</p><h3><span id="docker-run">docker run</span></h3><p>如果说 Docker 镜像是一个静态的、可执行的软件包（包含代码、运行时、库、环境变量和配置文件），那么 <code>docker run</code> 就是让这个软件包<strong>活起来</strong>的魔法咒语。它是 Docker 中最核心、最常用的命令，是创建和启动容器的唯一入口。理解 <code>docker run</code>，就掌握了开启容器化之旅的钥匙。</p><hr><p><code>docker run</code> 命令用于<strong>从指定的镜像创建并启动一个新的容器</strong>。</p><p>它的工作流程可以拆解为两个核心步骤：</p><ol><li><strong>创建</strong>：基于指定的镜像，创建一个新的可写容器层（Container Layer）。</li><li><strong>启动</strong>：执行镜像中定义的默认命令（如 <code>CMD</code> 或 <code>ENTRYPOINT</code>），让容器内的应用进程运行起来。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><ul><li><code>IMAGE</code>：用于创建容器的镜像名称（如 <code>nginx:latest</code>、<code>ubuntu:20.04</code>）。</li><li><code>[COMMAND] [ARG...]</code>：（可选）覆盖镜像中定义的默认启动命令。</li><li><code>[OPTIONS]</code>：<strong>这是命令的灵魂</strong>，用于配置容器的几乎所有方面，包括网络、存储、资源限制等。</li></ul><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>应用标准化部署</strong>：只需一个包含所有依赖的镜像和一条 <code>docker run</code> 命令，就能在任何安装了 Docker 的环境中一致地运行应用，彻底解决“在我这儿是好的”的环境问题。</li><li><strong>资源隔离与安全</strong>：通过选项轻松为应用分配和限制 CPU、内存等资源，并通过隔离机制保证安全性。</li><li><strong>极致的可配置性</strong>：通过丰富的选项，可以灵活配置容器的网络、存储、日志、重启策略等，满足各种复杂场景的需求。</li></ol><h4><span id="核心选项options分类详解">核心选项（OPTIONS）分类详解</span></h4><p><code>docker run</code> 的威力体现在其数十个选项上，以下是其中最常用和关键的几类：</p><p><strong>1. 容器运行模式与交互：</strong></p><ul><li><p><strong><code>-d</code>， <code>--detach</code></strong>：在<strong>后台</strong>运行容器（守护进程模式）。这是运行后台服务（如 Nginx、MySQL）的标准方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d nginx</span><br></pre></td></tr></table></figure></li><li><p><strong><code>-it</code></strong>：<strong>组合使用</strong>，用于启动一个<strong>交互式</strong>容器。<code>-i</code>（保持标准输入打开）和 <code>-t</code>（分配一个伪终端） together 让你可以像使用普通 Shell 一样与容器交互。这是运行临时工具容器（如 Ubuntu、Alpine）的标准方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 名称与标识：</strong></p><ul><li><p><strong><code>--name</code></strong>：为容器指定一个自定义名称，而不是使用 Docker 随机生成的名字。这对于后续的管理操作（如 <code>docker stop</code>、<code>docker logs</code>）至关重要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my_web -d nginx</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. 网络配置：</strong></p><ul><li><p><strong><code>-p</code>， <code>--publish</code></strong>：<strong>映射端口</strong>，将容器的端口发布到宿主机的端口上。这是从外部访问容器内服务的基础。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器的80端口映射到宿主机的8080端口</span></span><br><span class="line">docker run -p 8080:80 nginx</span><br></pre></td></tr></table></figure></li><li><p><strong><code>--network</code></strong>：指定容器的网络模式（如 <code>bridge</code>、<code>host</code>、<code>none</code> 或自定义网络），实现容器间的隔离或通信。</p></li></ul><p><strong>4. 存储与数据持久化：</strong></p><ul><li><p><strong><code>-v</code>， <code>--volume</code></strong>：<strong>挂载数据卷</strong>或<strong>绑定宿主机目录</strong>。这是实现数据持久化的核心方法，避免数据随着容器的删除而丢失。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绑定挂载：将宿主机的 /host/data 挂载到容器的 /container/data</span></span><br><span class="line">docker run -v /host/data:/container/data nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命名的数据卷</span></span><br><span class="line">docker run -v my_volume:/container/data nginx</span><br></pre></td></tr></table></figure></li></ul><p><strong>5. 环境变量配置：</strong></p><ul><li><p><strong><code>-e</code>， <code>--env</code></strong>：设置容器内的环境变量。常用于传递配置参数（如密码、运行模式）给容器内的应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e MODE=production -e DB_HOST=db.example.com my_app</span><br></pre></td></tr></table></figure></li></ul><p><strong>6. 资源管理：</strong></p><ul><li><p><strong><code>--cpus</code></strong>：限制容器能使用的 CPU 核心数。</p></li><li><p><strong><code>-m</code>， <code>--memory</code></strong>：限制容器能使用的最大内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --cpus=<span class="string">&quot;1.5&quot;</span> -m <span class="string">&quot;512m&quot;</span> my_app</span><br></pre></td></tr></table></figure></li></ul><p><strong>7. 重启策略：</strong></p><ul><li><p><strong><code>--restart</code></strong>：配置容器的自动重启策略，如 <code>no</code>（不重启）、<code>on-failure</code>（失败时重启）、<code>always</code>（总是重启）。这是保证服务高可用的关键配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart unless-stopped my_app</span><br></pre></td></tr></table></figure></li></ul><h4><span id="实战示例组合使用选项">实战示例：组合使用选项</span></h4><p>一个典型的后台 Web 服务启动命令可能结合了上述所有选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \                  <span class="comment"># 后台运行</span></span><br><span class="line">  --name my-app \                <span class="comment"># 指定容器名</span></span><br><span class="line">  -p 80:80 \                     <span class="comment"># 端口映射</span></span><br><span class="line">  -v /app/config:/etc/config \   <span class="comment"># 挂载配置文件目录</span></span><br><span class="line">  -e DATABASE_URL=postgresql://... \ <span class="comment"># 设置环境变量</span></span><br><span class="line">  --cpus=2 \                     <span class="comment"># 资源限制</span></span><br><span class="line">  -m=1g \</span><br><span class="line">  --restart on-failure \         <span class="comment"># 重启策略</span></span><br><span class="line">  my-app-image:latest           <span class="comment"># 镜像名</span></span><br></pre></td></tr></table></figure><h4><span id="最佳实践与注意事项">最佳实践与注意事项</span></h4><ol><li><strong>总是使用 <code>--name</code></strong>：为容器命名是良好的习惯，这让管理变得更加简单和清晰。</li><li><strong>理解前台与后台运行</strong>：交互式工具用 <code>-it</code>，后台服务用 <code>-d</code>。</li><li><strong>数据持久化是必须的</strong>：任何需要保留的数据都必须通过 <code>-v</code> 挂载到宿主机或数据卷中，<strong>切勿依赖容器的可写层</strong>。</li><li><strong>使用特定版本标签</strong>：尽量不要使用 <code>latest</code> 标签，而应使用明确的版本（如 <code>nginx:1.25-alpine</code>），以保证部署的一致性。</li><li><strong>优先使用 <code>docker compose</code></strong>：当选项变得复杂时（需要启动多个关联容器），使用 <code>docker compose</code> 来管理这些配置是更佳实践。</li></ol><hr><p><code>docker run</code> 远不止是一个启动命令，它是<strong>容器生命的起点</strong>，是<strong>应用环境的编织者</strong>。</p><ul><li><strong>它是 Docker 功能的集大成者</strong>，通过数十个选项将镜像、网络、存储、资源等模块串联起来。</li><li><strong>它的灵活性</strong>使得同一个镜像可以通过不同的参数，轻松适应开发、测试、生产等各种环境。</li><li><strong>掌握其常用选项</strong>是熟练使用 Docker 的必经之路。</li></ul><p>从一条简单的 <code>docker run hello-world</code> 到复杂的企业级应用部署，<code>docker run</code> 贯穿始终，是每个 Docker 用户必须深刻理解和掌握的核心命令。</p><h3><span id="docker-ps">docker ps</span></h3><p>该命令在之前的文章中已经介绍过，用于查看当前运行的容器，若需要了解请展开：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <h4><span id="功能">功能</span></h4><p>列出容器。这是 Docker 中最常用的监控和管理命令之一，用于查看当前容器运行状态。</p><h4><span id="语法">语法</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><h4><span id="别名">别名</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line">docker container list</span><br><span class="line">docker container ps</span><br></pre></td></tr></table></figure><h4><span id="关键参数详解">关键参数详解</span></h4><h5><span id="显示范围控制">显示范围控制</span></h5><ul><li><p><strong><code>-a, --all</code></strong>：显示所有容器，包括停止的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p><strong><code>-f, --filter</code></strong>：根据条件过滤显示结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f <span class="string">&quot;name=web&quot;</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=running&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>-n, --last</code></strong>：显示最近创建的 n 个容器（包括所有状态）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -n 3</span><br></pre></td></tr></table></figure></li></ul><h5><span id="显示格式控制">显示格式控制</span></h5><ul><li><p><strong><code>-q, --quiet</code></strong>：只显示容器 ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -q</span><br></pre></td></tr></table></figure></li><li><p><strong><code>--no-trunc</code></strong>：显示完整信息，不截断输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps --no-trunc</span><br></pre></td></tr></table></figure></li><li><p><strong><code>--format</code></strong>：使用 Go 模板格式化输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>-s, --size</code></strong>：显示容器文件大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -s</span><br></pre></td></tr></table></figure></li></ul><h5><span id="时间显示">时间显示</span></h5><ul><li><p><strong><code>-l, --latest</code></strong>：显示最近创建的容器（包括所有状态）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l</span><br></pre></td></tr></table></figure></li></ul><h4><span id="输出列说明">输出列说明</span></h4><p>执行 <code>docker ps</code> 后显示的表格包含以下重要列：</p><table><thead><tr><th>列名</th><th>说明</th></tr></thead><tbody><tr><td><strong>CONTAINER ID</strong></td><td>容器的唯一标识符（通常显示前 12 位）</td></tr><tr><td><strong>IMAGE</strong></td><td>创建容器所使用的镜像名称</td></tr><tr><td><strong>COMMAND</strong></td><td>容器启动时运行的命令</td></tr><tr><td><strong>CREATED</strong></td><td>容器创建时间</td></tr><tr><td><strong>STATUS</strong></td><td>容器状态（Up 表示运行中，Exited 表示已退出）</td></tr><tr><td><strong>PORTS</strong></td><td>端口映射信息</td></tr><tr><td><strong>NAMES</strong></td><td>容器名称</td></tr></tbody></table><h4><span id="过滤器常用用法">过滤器常用用法</span></h4><p>过滤器是 <code>docker ps</code> 的强大功能，支持多种过滤条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按名称过滤</span></span><br><span class="line">docker ps -f <span class="string">&quot;name=web&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按状态过滤</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=running&quot;</span>   <span class="comment"># 运行中的容器</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=exited&quot;</span>    <span class="comment"># 已停止的容器</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=created&quot;</span>   <span class="comment"># 已创建但未运行的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按镜像过滤</span></span><br><span class="line">docker ps -f <span class="string">&quot;ancestor=nginx&quot;</span>   <span class="comment"># 使用nginx镜像的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按退出代码过滤</span></span><br><span class="line">docker ps -a -f <span class="string">&quot;exited=0&quot;</span>      <span class="comment"># 正常退出的容器</span></span><br><span class="line">docker ps -a -f <span class="string">&quot;exited=1&quot;</span>      <span class="comment"># 异常退出的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按标签过滤</span></span><br><span class="line">docker ps -f <span class="string">&quot;label=environment=production&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合多个过滤器</span></span><br><span class="line">docker ps -f <span class="string">&quot;name=db&quot;</span> -f <span class="string">&quot;status=running&quot;</span></span><br></pre></td></tr></table></figure><h4><span id="格式化输出示例">格式化输出示例</span></h4><p>使用 <code>--format</code> 参数可以自定义输出格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示ID和名称</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示ID、名称、状态和端口</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以JSON格式输出</span></span><br><span class="line">docker ps --format <span class="string">&quot;&#123;&#123;json .&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义表格标题</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span> --format <span class="string">&quot;ID\tNAME\tSTATUS&quot;</span></span><br></pre></td></tr></table></figure><h4><span id="使用示例">使用示例</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器（包括已停止的）</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最近创建的2个容器</span></span><br><span class="line">docker ps -n 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示运行中容器的ID</span></span><br><span class="line">docker ps -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看名称包含&quot;web&quot;的容器</span></span><br><span class="line">docker ps -f <span class="string">&quot;name=web&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有异常退出的容器</span></span><br><span class="line">docker ps -a -f <span class="string">&quot;exited=1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示容器大小信息</span></span><br><span class="line">docker ps -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义格式输出</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4><span id="实际应用场景">实际应用场景</span></h4><ol><li><p><strong>快速查看容器状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日常监控</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p><strong>查找特定容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找MySQL容器</span></span><br><span class="line">docker ps -f <span class="string">&quot;name=mysql&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>批量操作容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有运行中的容器</span></span><br><span class="line">docker stop $(docker ps -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有已停止的容器</span></span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q -f <span class="string">&quot;status=exited&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>故障排查</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看异常退出的容器</span></span><br><span class="line">docker ps -a -f <span class="string">&quot;exited=1&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>资源监控</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器占用空间</span></span><br><span class="line">docker ps -s</span><br></pre></td></tr></table></figure></li></ol><h4><span id="注意事项">注意事项</span></h4><ol><li>默认情况下 <code>docker ps</code> 只显示运行中的容器</li><li>使用 <code>-a</code> 参数可以查看所有状态的容器</li><li>过滤器功能非常强大，可以组合多个条件进行精确查询</li><li>格式化输出适合编写脚本和自动化工具</li><li>容器 ID 的前几个字符通常就足够唯一标识一个容器</li></ol>    </div></div><h3><span id="docker-logs">docker logs</span></h3><p>当我们启动一个容器后，一个很自然的问题是：<strong>我的应用程序在里面运行得怎么样？它输出了什么？有没有报错？</strong> 容器是一个隔离的环境，我们无法直接像操作普通进程一样看到它的终端输出。这时，<code>docker logs</code> 命令就成了我们窥探容器内部运行时状态的 <strong>“万能窗口”</strong>。</p><p><code>docker logs</code> 命令用于<strong>获取容器的日志</strong>。它会抓取并输出目标容器在其生命周期内，其内部主进程（PID 1）写入到<strong>标准输出（STDOUT）</strong> 和<strong>标准错误（STDERR）</strong> 的所有数据。</p><p>简单来说，你在容器内应用程序中用 <code>console.log()</code>、<code>print()</code>、<code>cout</code>、<code>System.out.println()</code> 等语句输出的内容，以及产生的错误信息，都可以通过这个命令查看到。</p><h4><span id="docker-的日志处理机制">Docker 的日志处理机制</span></h4><p>要理解 <code>docker logs</code>，首先要知道 Docker 是如何处理容器日志的。</p><ol><li><strong>默认的日志驱动（JSON File）</strong>：Docker 默认使用 <code>json-file</code> 日志驱动。这意味着容器内主进程的 STDOUT 和 STDERR 流会被 Docker 守护进程（Docker Daemon）捕获。</li><li><strong>持久化存储</strong>：Docker Daemon 会将捕获到的每一条日志，以 JSON 格式追加写入到主机磁盘上的一个文件中（通常位于 <code>/var/lib/docker/containers/&lt;container_id&gt;/&lt;container_id&gt;-json.log</code>）。</li><li><strong>命令读取</strong>：当你执行 <code>docker logs</code> 时，Docker 客户端会与 Daemon 通信，Daemon 则去读取对应的 JSON 日志文件，并将格式化后的内容返回给你。</li></ol><p>这种机制的好处在于，<strong>即使容器已经停止（Exited）</strong>，只要日志文件没有被手动清理（例如通过 <code>docker rm</code> 删除容器），你依然可以查看其历史日志。</p><h4><span id="基本语法和常用参数">基本语法和常用参数</span></h4><p><code>docker logs</code> 的功能非常强大，通过添加不同的参数，可以满足各种查看需求。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>其中 <code>CONTAINER</code> 可以是容器名称 (<code>--name</code> 指定的) 或容器 ID（通常取前几位即可）。</p><p><strong>最常用的参数（Flags）：</strong></p><table><thead><tr><th align="left">参数</th><th align="left">全称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>-f</code></td><td align="left"><code>--follow</code></td><td align="left"><strong>持续跟踪</strong>日志输出。类似于 <code>tail -f</code>，会实时显示新产生的日志，是监控容器行为的利器。</td></tr><tr><td align="left"><code>-t</code></td><td align="left"><code>--timestamps</code></td><td align="left">显示<strong>时间戳</strong>。每条日志前都会加上其产生的时间，对于调试和排序非常有用。</td></tr><tr><td align="left"><code>-n</code></td><td align="left"><code>--tail</code></td><td align="left">仅显示<strong>最后 N 条</strong>日志。例如 <code>--tail 100</code> 显示最后 100 行。</td></tr><tr><td align="left"><code>--since</code></td><td align="left"></td><td align="left">显示从某个时间点开始的日志。例如 <code>--since 2024-08-31</code> 或 <code>--since 1h</code>（过去 1 小时）。</td></tr><tr><td align="left"><code>--until</code></td><td align="left"></td><td align="left">显示在某个时间点之前的日志。</td></tr><tr><td align="left"><code>--details</code></td><td align="left"></td><td align="left">显示更多的细节（额外的属性）。</td></tr></tbody></table><h4><span id="实战示例">实战示例</span></h4><p>假设我们有一个正在运行的名为 <code>my_web_app</code> 的容器。</p><ol><li><p><strong>查看最新日志：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看最后10条日志（默认）</span></span><br><span class="line">docker logs my_web_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最后100条日志</span></span><br><span class="line">docker logs --<span class="built_in">tail</span> 100 my_web_app</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">docker logs -n 100 my_web_app</span><br></pre></td></tr></table></figure></li><li><p><strong>实时跟踪日志（最常用）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时查看最新日志，常用于调试和监控</span></span><br><span class="line">docker logs -f my_web_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时查看并带上时间戳</span></span><br><span class="line">docker logs -ft my_web_app</span><br></pre></td></tr></table></figure><p><em>按下 <code>Ctrl+C</code> 可以退出跟踪模式。</em></p></li><li><p><strong>查看某个时间段内的日志：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看过去30分钟内的日志</span></span><br><span class="line">docker logs --since 30m my_web_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看2024年1月1日之后的日志，并显示时间戳</span></span><br><span class="line">docker logs -t --since 2024-01-01 my_web_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看今天早上8点到9点之间的日志</span></span><br><span class="line">docker logs --since 2024-08-31T08:00:00 --<span class="keyword">until</span> 2024-08-31T09:00:00 my_web_app</span><br></pre></td></tr></table></figure></li><li><p><strong>查看已停止容器的日志：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 即使容器已停止，只要没被删除，日志依然可查</span></span><br><span class="line">docker logs my_stopped_container</span><br></pre></td></tr></table></figure></li></ol><h4><span id="高级用法与最佳实践">高级用法与最佳实践</span></h4><ol><li><p><strong>日志驱动（Logging Driver）</strong>：<br>Docker 支持多种日志驱动（如 <code>json-file</code>, <code>syslog</code>, <code>journald</code>, <code>fluentd</code>, <code>awslogs</code> 等）。<code>docker logs</code> 命令<strong>仅适用于 <code>json-file</code>、<code>journald</code> 和 <code>local</code> 等少数几种驱动</strong>。如果你将日志驱动设置为 <code>syslog</code> 或第三方工具（如 Fluentd），则 <code>docker logs</code> 将无法工作，你需要使用相应日志系统的工具（如 <code>journalctl</code>）来查看日志。</p></li><li><p><strong>避免在容器内写日志文件</strong>：<br>一个常见的反模式是在容器内将日志写入文件（如 <code>/app/logs/app.log</code>）。这会导致：</p><ul><li>日志失去 Docker 的自动管理功能。</li><li>使用 <code>docker logs</code> 看不到这些日志。</li><li>容器文件层变大，且日志清理困难。<br><strong>最佳实践是始终将日志输出到 STDOUT&#x2F;STDERR</strong>，让 Docker 来统一处理。</li></ul></li><li><p><strong>日志大小轮替（Log Rotation）</strong>：<br>使用默认的 <code>json-file</code> 驱动时，需要注意日志文件会不断增长。可以通过 <code>docker run</code> 时设置 <code>--log-opt</code> 参数来控制日志大小和轮替，防止撑爆磁盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-opt max-size=10m --log-opt max-file=3 my_image</span><br><span class="line"><span class="comment"># 含义：最多保存3个日志文件，每个文件最大10MB</span></span><br></pre></td></tr></table></figure></li></ol><h3><span id="docker-attach">docker attach</span></h3><p>在 Docker 的交互命令工具箱里，<code>docker attach</code> 是一个特殊的存在。如果说 <code>docker exec</code> 像是通过 SSH 远程登录到一台服务器，那么 <code>docker attach</code> 就更像是<strong>直接坐在那台服务器的显示器前，接管了它的键盘和屏幕</strong>。先说明一个个人的观点：<code>docker attach</code> 并不是一个常用命令，除非你非常清楚它的行为和风险，否则不建议随意使用。</p><hr><p><code>docker attach</code> 命令用于<strong>将你的终端附加到一个正在运行的容器的主进程（PID 1）上</strong>。</p><p>它的核心作用是：</p><ul><li>将你终端的<strong>标准输入（STDIN）</strong>、<strong>标准输出（STDOUT）</strong> 和<strong>标准错误（STDERR）</strong> 连接到容器的主进程。</li><li>让你能够<strong>看到</strong>主进程产生的输出，并<strong>向</strong>主进程发送输入。</li></ul><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><h4><span id="docker-attach-的核心特性与工作机制"><code>docker attach</code> 的核心特性与工作机制</span></h4><p>要理解 <code>attach</code>，必须理解它的几个关键特性：</p><ol><li><p><strong>附加到主进程，而非新进程</strong>：</p><ul><li><code>docker exec</code>：在容器内<strong>启动一个新进程</strong>（如 <code>/bin/bash</code>）。</li><li><code>docker attach</code>：<strong>连接到一个已存在的进程</strong>（主进程）。你看到的就是主进程自己的输出，你输入的内容也会直接发送给主进程。</li></ul></li><li><p><strong>输入输出流的重定向</strong>：<br>假设你这样启动一个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my_container -it alpine /bin/sh</span><br></pre></td></tr></table></figure><p>此时，<code>/bin/sh</code> 就是主进程。<code>docker attach my_container</code> 会直接将你的终端连接到这个 <code>/bin/sh</code> 进程的输入输出流。</p></li><li><p><strong>退出行为的危险性（最需要注意！）</strong>：</p><ul><li>在 <code>attach</code> 的模式下，如果你按下 <code>Ctrl+C</code>（发送 SIGINT 信号），这个信号会直接传递给容器的主进程。</li><li>如果主进程因此终止，<strong>容器也会随之停止（Exited）</strong>。</li><li>同理，输入 <code>exit</code> 或 <code>Ctrl+D</code>（EOF）也会导致主进程退出，从而停止容器。</li></ul></li></ol><h4><span id="实战示例与场景">实战示例与场景</span></h4><p><strong>场景 1：查看交互式容器的输出</strong>：</p><p>假设你有一个 Python 应用在容器中运行，它会每秒打印一次日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设容器已通过 `docker run -d --name my_app my_python_image` 运行</span></span><br><span class="line">docker attach my_app</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Current <span class="keyword">time</span>: 19:25:01</span><br><span class="line">Current <span class="keyword">time</span>: 19:25:02</span><br><span class="line">Current <span class="keyword">time</span>: 19:25:03</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时，你就像在 <code>tail -f</code> 日志一样。<strong>但要小心！</strong> 如果你不小心按了 <code>Ctrl+C</code>，Python 程序会被中断，容器也就停止了。</p><p><strong>场景 2：与交互式程序通信</strong>：</p><p>有些容器运行的是交互式程序，比如一个简单的 CLI 工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个容器，运行一个要求输入名字的程序</span></span><br><span class="line">docker run -it --name asker my_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># （在另一个终端）附加到它</span></span><br><span class="line">docker attach asker</span><br></pre></td></tr></table></figure><p>你现在就可以直接向那个程序输入内容了。</p><h4><span id="如何安全地退出-docker-attach">如何安全地退出 <code>docker attach</code>？</span></h4><p>由于直接退出会停止容器，Docker 提供了一个<strong>序列来脱离（detach）终端，而不停止容器</strong>：</p><p><strong>按顺序按下：<code>Ctrl+P</code>, 然后 <code>Ctrl+Q</code></strong>，需要注意的是，通过这种方式脱离终端需要你再启动该容器的时候给该容器指定了 <code>-it</code> 参数。</p><p>这个按键序列会<strong>将你的终端从容器主进程上分离出来，但让容器继续在后台运行</strong>。这是使用 <code>attach</code> 时必须掌握的“安全逃生”技巧。</p><p>当然，<code>docker attach</code> 也提供了一种<strong>安全脱离</strong>的方式，避免意外停止容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach --sig-proxy=<span class="literal">false</span> my_container</span><br></pre></td></tr></table></figure><h4><span id="docker-attach-与-docker-exec-的对比"><code>docker attach</code> 与 <code>docker exec</code> 的对比</span></h4><table><thead><tr><th align="left">特性</th><th align="left"><code>docker attach</code></th><th align="left"><code>docker exec</code></th></tr></thead><tbody><tr><td align="left"><strong>目标进程</strong></td><td align="left">附加到<strong>现有的主进程（PID 1）</strong></td><td align="left"><strong>启动一个新的子进程</strong>（如 bash）</td></tr><tr><td align="left"><strong>作用</strong></td><td align="left">连接主进程的输入输出流</td><td align="left">在容器内执行额外命令</td></tr><tr><td align="left"><strong>退出后果</strong></td><td align="left"><code>Ctrl+C</code> 会<strong>停止主进程和容器</strong></td><td align="left"><code>exit</code> 只退出 Shell，<strong>容器照常运行</strong></td></tr><tr><td align="left"><strong>安全退出</strong></td><td align="left"><code>Ctrl+P</code> + <code>Ctrl+Q</code>（分离而不停止）</td><td align="left"><code>exit</code> 或 <code>Ctrl+D</code></td></tr><tr><td align="left"><strong>典型用途</strong></td><td align="left">查看主进程原始输出流、与交互式主进程通信</td><td align="left">调试、排查、管理容器（主要手段）</td></tr></tbody></table><h4><span id="最佳实践和适用场景">最佳实践和适用场景</span></h4><p><strong>什么时候使用 <code>docker attach</code>？</strong></p><ol><li><strong>查看实时输出</strong>：当你需要查看一个<strong>前台运行</strong>的容器的原始、未经过滤的实时输出流，并且这个容器没有将日志重定向到其他地方时。</li><li><strong>与交互式应用程序通信</strong>：容器的主进程本身就是一个等待用户输入的程序（例如一个自定义的 CLI 工具、一个 REPL 环境）。</li></ol><p><strong>什么时候避免使用 <code>docker attach</code>？</strong></p><ol><li><strong>绝大多数调试和管理任务</strong>：这是 <code>docker exec</code> 的主场。你需要的是一个稳定的、不会意外停止容器的 Shell 环境。</li><li><strong>生产环境调试</strong>：在生产环境中使用 <code>attach</code> 非常危险，一个误操作就可能导致服务中断。</li><li><strong>容器主进程是非交互式的</strong>：例如，附加到一个 Nginx 或 MySQL 容器，你只会看到它们的访问日志或错误日志疯狂滚动，而你无法输入任何有意义的命令。按 <code>Ctrl+C</code> 会立刻终止服务。</li></ol><hr><p><code>docker attach</code> 是一个<strong>强大但具有破坏性</strong>的工具。它提供了与容器主进程最直接的连接方式，但这份力量也带来了风险。</p><ul><li><strong>它的本质是“连接”而非“执行”</strong>。</li><li><strong>牢记 <code>Ctrl+C</code> 的破坏性</strong>，并熟练掌握安全脱离序列 <code>Ctrl+P</code> + <code>Ctrl+Q</code>。</li><li><strong>对于 99% 的日常操作，<code>docker exec -it</code> 是更安全、更灵活的选择</strong>。我们应该优先使用它来进入容器 Shell。</li></ul><p>再次强调，该指令在实践中请务必谨慎使用。</p><h3><span id="docker-exec">docker exec</span></h3><p>在 Docker 的日常运维中，我们经常会遇到这样的场景：一个容器正在运行，但我们需要检查其配置文件、查看日志文件、安装调试工具，或者简单地看看容器内部的环境。由于容器是隔离的环境，我们无法像登录物理服务器一样直接进入。这时，<code>docker exec</code> 命令就如同一位万能锁匠，为我们打开了进入运行中容器的大门，是 Docker 运维中<strong>使用最频繁、最重要的诊断和调试工具</strong>。</p><hr><p><code>docker exec</code>（execute 的缩写）命令用于<strong>在正在运行的容器内部启动一个新的进程</strong>。</p><p>它与容器启动时运行的主进程（PID 1）<strong>并行运行</strong>，互不干扰。这意味着你可以安全地在容器内执行任何命令，而无需担心影响主应用程序的正常运行。这就像是在一台正在提供服务的服务器上，新开了一个 SSH 会话进行操作，完全不会影响正在运行的网站或数据库服务。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINER</code>: 目标容器的<strong>名称</strong>或 <strong>ID</strong>（通常取前几位即可）。</li><li><code>COMMAND</code>: 要在容器内执行的命令及其参数，例如 <code>/bin/bash</code>, <code>ls</code>, <code>ps</code>, <code>cat</code> 等。</li></ul><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>实时诊断与调试</strong>：当容器行为异常时（如服务不可用、报错），<code>exec</code> 是排查问题的第一选择。你可以直接进入容器查看日志、进程状态、网络连接等。</li><li><strong>交互式探索</strong>：对于不熟悉的镜像，可以启动一个 Shell 来探索其文件系统结构、预装软件和环境变量，从而更好地理解它的行为。</li><li><strong>执行管理任务</strong>：在不重新构建镜像的情况下，临时安装软件（如 <code>curl</code>, <code>vim</code>, <code>net-tools</code>）来进行测试或调试。</li><li><strong>安全且非侵入</strong>：由于是在新进程中操作，你的调试行为不会影响主进程，极大地提升了操作的安全性。</li></ol><h4><span id="核心选项options详解">核心选项（OPTIONS）详解</span></h4><p><code>docker exec</code> 的强大功能通过其选项来实现，其中最关键是 <code>-i</code> 和 <code>-t</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">全称</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><strong><code>-i</code></strong></td><td align="left"><code>--interactive</code></td><td align="left">保持标准输入（STDIN）打开。允许你向容器内的进程发送命令。</td><td align="left"><code>docker exec -i ...</code></td></tr><tr><td align="left"><strong><code>-t</code></strong></td><td align="left"><code>--tty</code></td><td align="left">分配一个伪终端（pseudo-TTY）。它会格式化输出，提供完整的终端体验，支持命令补全、颜色显示等。</td><td align="left"><code>docker exec -t ...</code></td></tr><tr><td align="left"><strong><code>-it</code></strong></td><td align="left"></td><td align="left"><strong>几乎总是组合使用</strong>。提供交互式的终端体验，是进入容器 Shell 的标准方式。</td><td align="left"><code>docker exec -it ...</code></td></tr><tr><td align="left"><strong><code>-e</code></strong></td><td align="left"><code>--env</code></td><td align="left">设置环境变量。这对于临时改变程序行为非常有用。</td><td align="left"><code>docker exec -e MY_VAR=value ...</code></td></tr><tr><td align="left"><strong><code>-u</code></strong></td><td align="left"><code>--user</code></td><td align="left">指定以哪个用户身份执行命令。可以是用户名或 UID。</td><td align="left"><code>docker exec -u root ...</code> <br> <code>docker exec -u 1000 ...</code></td></tr><tr><td align="left"><strong><code>-w</code></strong></td><td align="left"><code>--workdir</code></td><td align="left">设置命令在容器内的工作目录。</td><td align="left"><code>docker exec -w /app ...</code></td></tr></tbody></table><h4><span id="实战示例从入门到精通">实战示例：从入门到精通</span></h4><p>假设我们有一个名为 <code>my_web</code> 的 Nginx 容器在运行。</p><p><strong>1. 进入容器的交互式 Shell（最常用）</strong><br>这是 <code>docker exec</code> 最经典的用法，让你获得一个容器内的终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 bash（如果镜像基于 Ubuntu、CentOS 等）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it my_web /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 sh（更通用，Alpine 等精简镜像也支持）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it my_web /bin/sh</span><br></pre></td></tr></table></figure><p>成功执行后，命令行提示符会变化，表示你已“进入”容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@a1b2c3d4e5f6:/#</span><br></pre></td></tr></table></figure><p>现在，你可以像操作普通 Linux 系统一样执行任何命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 探索文件系统</span></span><br><span class="line"><span class="built_in">ls</span> -la /etc/nginx/</span><br><span class="line"><span class="built_in">cat</span> /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps aux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装软件（但不推荐持久化这样做）</span></span><br><span class="line">apt update &amp;&amp; apt install -y vim net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查网络</span></span><br><span class="line">netstat -tulpn</span><br><span class="line">curl localhost</span><br></pre></td></tr></table></figure><p><strong>退出时，只需输入 <code>exit</code> 或按 <code>Ctrl+D</code>。容器会继续正常运行。</strong></p><p><strong>2. 执行单条命令并获取结果</strong><br>你不需要总是启动一个完整的 Shell 会话，可以直接执行命令并返回结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器内的当前工作目录</span></span><br><span class="line">docker <span class="built_in">exec</span> my_web <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看环境变量</span></span><br><span class="line">docker <span class="built_in">exec</span> my_web <span class="built_in">env</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Nginx 访问日志的最后10行</span></span><br><span class="line">docker <span class="built_in">exec</span> my_web <span class="built_in">tail</span> -10 /var/log/nginx/access.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试配置文件语法是否正确（非常实用的调试命令）</span></span><br><span class="line">docker <span class="built_in">exec</span> my_web nginx -t</span><br></pre></td></tr></table></figure><p><strong>3. 以特定用户身份执行命令</strong><br>为了安全，最佳实践是不以 root 身份运行应用。<code>exec</code> 允许你指定用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设你的 Nginx 以 &#x27;www-data&#x27; 用户运行</span></span><br><span class="line"><span class="comment"># 以该用户身份查看它有权访问的文件</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -u www-data my_web /bin/sh</span><br><span class="line"><span class="built_in">whoami</span> <span class="comment"># 会显示 &#x27;www-data&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但如果需要调试，可以临时切换回 root</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -u root my_web /bin/bash</span><br></pre></td></tr></table></figure><p><strong>4. 在特定目录下执行命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接列出容器内 /app 目录下的文件</span></span><br><span class="line">docker <span class="built_in">exec</span> -w /app my_web <span class="built_in">ls</span> -la</span><br></pre></td></tr></table></figure><h4><span id="最佳实践与注意事项">最佳实践与注意事项</span></h4><ol><li><p><strong>容器必须处于运行状态</strong>：<code>docker exec</code> 只能用于状态为 <code>Up</code> 的容器。如果容器已停止（<code>Exited</code>），你需要先使用 <code>docker start</code> 启动它。</p></li><li><p><strong>选择正确的 Shell</strong>：基于 Alpine 的镜像非常流行，但它们不包含 <code>bash</code>，只包含 <code>sh</code>（通常是 <code>ash</code>）。因此，使用 <code>/bin/sh</code> 是更通用、更安全的选择。</p></li><li><p><strong>修改是临时的</strong>：通过 <code>exec</code> 在容器内进行的任何修改（如安装软件、创建文件）都发生在容器的<strong>可写层</strong>中。<strong>一旦容器被删除并重新创建（这是常事），这些修改会全部丢失</strong>。持久化配置应通过 Docker <strong>数据卷（Volumes）</strong> 或<strong>绑定挂载（Bind Mounts）</strong> 来实现。</p></li><li><p><strong>区分 <code>exec</code> 与 <code>attach</code></strong>：</p><ul><li><strong><code>docker exec</code></strong>：<strong>启动新进程</strong>，用于调试和管理，退出不会影响容器。</li><li><strong><code>docker attach</code></strong>：<strong>连接主进程</strong>，直接与主进程交互，误操作可能导致容器停止。<strong>绝大多数情况下，应优先使用 <code>exec</code></strong>。</li></ul></li></ol><hr><p><code>docker exec -it &lt;container&gt; /bin/sh</code> 是 Docker 运维的<strong>瑞士军刀</strong>，是每个开发者和运维人员必须熟练掌握的核心命令。</p><ul><li><strong>它是你的诊断控制台</strong>，让你可以实时洞察容器内部状态。</li><li><strong>它是你的调试工具</strong>，帮助快速定位和解决应用问题。</li><li><strong>它是你的探索工具</strong>，用于学习和理解第三方镜像的构建方式。</li></ul><h3><span id="docker-restart">docker restart</span></h3><p>在容器化应用的日常运维中，重启是一个高频操作。无论是应用配置更新、依赖项变更，还是简单地应对一些难以定位的偶发性问题，我们常常需要重启容器。Docker 提供了 <code>docker restart</code> 命令来满足这一需求，但它背后的行为远比表面上的“重启”二字要复杂。理解它，能帮助你更安全、更优雅地管理你的容器。</p><hr><p><code>docker restart</code> 命令用于<strong>重启一个或多个正在运行或已停止的容器</strong>。</p><p>它的核心工作流程可以简单概括为：<br><strong><code>docker stop</code> + <code>docker start</code></strong></p><p>也就是说，<code>restart</code> 并不是让容器内的进程原地“热重启”，而是先执行一个停止流程，然后再重新启动容器。这使得它的行为非常明确和可预测。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>你可以同时重启多个容器，只需将它们的名称或 ID 用空格隔开。</p><h4><span id="docker-restart-的工作流程与生命周期"><code>docker restart</code> 的工作流程与生命周期</span></h4><p>要深入理解 <code>restart</code>，我们需要跟踪一个容器在重启过程中的状态变化：</p><ol><li><p><strong>发起重启请求</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart my_container</span><br></pre></td></tr></table></figure></li><li><p><strong>停止阶段（<code>docker stop</code>）</strong>：</p><ul><li>Docker Daemon 会向容器内的<strong>主进程（PID 1）</strong> 发送 <strong>SIGTERM</strong> 信号。</li><li>这是一个“优雅终止”的信号，通知应用程序：“你即将被关闭，请做好收尾工作”（如保存数据、关闭网络连接、释放资源等）。</li><li>系统会等待一个“宽限期”（默认为 <strong>10 秒</strong>）。如果进程在此时限内自行退出，则停止流程完成。</li></ul></li><li><p><strong>强制终止（如果必要）</strong>：</p><ul><li>如果 10 秒后容器进程仍然没有停止，Docker Daemon 会发送 <strong>SIGKILL</strong> 信号。</li><li>这个信号无法被捕获或忽略，会立即强制终止进程。<strong>这是一种强制手段，可能会造成数据丢失或状态不一致</strong>。</li></ul></li><li><p><strong>启动阶段（<code>docker start</code>）</strong>：</p><ul><li>停止完成后，Docker 会立即基于容器最初的配置（镜像、命令、网络、卷等）重新启动它。</li><li>容器重新进入运行（Up）状态，其内部的文件系统也会回退到镜像的原始状态（除非有数据卷或绑定挂载）。</li></ul></li></ol><h4><span id="核心选项options">核心选项（OPTIONS）</span></h4><p><code>docker restart</code> 的选项相对简单，但非常实用：</p><table><thead><tr><th align="left">选项</th><th align="left">全称</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><strong><code>-t</code></strong></td><td align="left"><code>--time</code></td><td align="left"><strong>改变停止超时时间</strong>。这是最重要的选项。你可以指定一个不同于默认 10 秒的等待时间（单位：秒）。</td><td align="left"><code>docker restart -t 30 my_container</code> <br> （给予应用 30 秒的时间进行优雅关闭）</td></tr></tbody></table><h4><span id="实战示例与场景">实战示例与场景</span></h4><p><strong>1. 重启单个容器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启名为 &#x27;nginx&#x27; 的容器</span></span><br><span class="line">docker restart nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启指定ID的容器（取前几位即可）</span></span><br><span class="line">docker restart a1b2c3d4</span><br></pre></td></tr></table></figure><p><strong>2. 重启多个容器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时重启整个应用栈的所有容器</span></span><br><span class="line">docker restart nginx web_app database cache</span><br></pre></td></tr></table></figure><p><strong>3. 延长优雅停止时间：</strong><br>对于数据库、有状态服务等需要较长时间进行收尾工作的应用，默认的 10 秒可能不够。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给予数据库容器60秒的时间来完成事务、刷新缓存和关闭连接</span></span><br><span class="line">docker restart -t 60 mysql_db</span><br></pre></td></tr></table></figure><h4><span id="最佳实践与注意事项">最佳实践与注意事项</span></h4><ol><li><p><strong>理解“无状态”与“有状态”</strong>：</p><ul><li><strong>无状态服务（如 Web 服务器、API）</strong>：<code>docker restart</code> 通常非常安全，是更新配置和应对问题的标准操作。</li><li><strong>有状态服务（如数据库、消息队列）</strong>：需要格外小心。虽然 <code>-t</code> 选项可以增加优雅停止的时间，但重启仍然可能导致正在进行的客户端连接中断。对于生产环境的有状态服务，应有更完善的高可用和故障转移方案，而不是简单地重启。</li></ul></li><li><p><strong>数据持久化是前提</strong>：<br>务必确保容器内需要保留的任何数据（如数据库文件、上传的内容、日志）都通过 <strong>Docker 数据卷（Volumes）</strong> 或<strong>绑定挂载（Bind Mounts）</strong> 存储在容器之外。否则，重启后容器内的所有更改都会丢失（因为文件系统会回退到镜像初始状态）。</p></li><li><p><strong>与 <code>docker stop</code> + <code>docker start</code> 的区别</strong>：<br>从结果上看，<code>restart</code> 等价于先后执行 <code>stop</code> 和 <code>start</code>。但使用单一命令更简洁，并且在一些编排工具中更容易管理。<strong><code>restart</code> 的优势在于其原子性和便利性。</strong></p></li><li><p><strong>监控重启后的状态</strong>：<br>重启后，务必检查容器是否真正成功启动并健康运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器状态</span></span><br><span class="line">docker ps -a | grep my_container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器启动日志，排查任何启动错误</span></span><br><span class="line">docker logs my_container</span><br></pre></td></tr></table></figure></li><li><p><strong>不要滥用重启</strong>：<br>重启是解决“症状”的快速方法，但不应替代对“根因”的排查。如果某个容器需要频繁重启，你应该深入调查其背后的根本原因，如内存泄漏、配置错误或资源不足。</p></li></ol><h4><span id="restart-vs-stopx2fstart-vs-run-restart"><code>restart</code> vs <code>stop</code>&#x2F;<code>start</code> vs <code>run --restart</code></span></h4><ul><li><strong><code>docker restart</code></strong>：<strong>手动</strong>重启特定容器。</li><li><strong><code>docker stop</code> &amp;&amp; <code>docker start</code></strong>：手动将停止和启动操作分开执行，提供更精细的控制。</li><li><strong><code>docker run --restart &lt;policy&gt;</code></strong>：<strong>自动重启策略</strong>。这是在容器<strong>退出后</strong>由 Docker Daemon 自动触发的行为（如总是重启、失败时重启等），与手动的 <code>restart</code> 命令有本质区别。</li></ul><hr><p><code>docker restart</code> 是一个简单却强大的命令，是容器生命周期管理中的“重启按钮”。</p><ul><li><strong>它的本质是“优雅停止”后“重新启动”</strong>，遵循标准的生命周期。</li><li><strong><code>-t</code> 选项</strong>允许你为重要应用定制优雅停止的时长，是安全重启的关键。</li><li>它最适合用于<strong>无状态服务</strong>，对于有状态服务需谨慎评估影响。</li><li>确保<strong>数据持久化</strong>是安全使用任何重启操作的前提。</li></ul><p>掌握 <code>docker restart</code> 的正确使用场景和方法，能让你在保证服务可用性的同时，更加从容地进行应用管理和故障排除。</p><h3><span id="docker-stop">docker stop</span></h3><p>在 Docker 的运维世界里，我们不仅需要知道如何让容器跑起来，更需要懂得如何让它们优雅地停下来。<code>docker stop</code> 便是完成这一使命的关键命令。它远非简单的“杀死”进程，而是一个遵循标准流程、旨在保护数据完整性的<strong>优雅终止（Graceful Shutdown）</strong> 操作。理解 <code>docker stop</code>，就是理解容器生命末期如何实现“善终”。</p><hr><p><code>docker stop</code> 命令用于<strong>停止一个或多个正在运行的容器</strong>。</p><p>其核心目标是在尽可能保证应用程序数据一致性的前提下，安全地终止容器。它通过向容器内进程发送特定的系统信号（Signal）来实现这一目标。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><h4><span id="docker-stop-的工作流程一个两阶段的优雅过程"><code>docker stop</code> 的工作流程：一个两阶段的优雅过程</span></h4><p><code>docker stop</code> 的执行并非一蹴而就，而是一个包含等待和协商的过程：</p><ol><li><p><strong>阶段一：友好协商（SIGTERM）</strong></p><ul><li>当您执行 <code>docker stop my_container</code> 时，Docker Daemon 会首先向容器内的<strong>主进程（PID 1）</strong> 发送一个 <strong>SIGTERM</strong> 信号。</li><li><strong>SIGTERM</strong> 是一个“礼貌”的终止信号，它通知应用程序：“你即将被关闭，请做好收尾工作”。收到此信号后，一个设计良好的应用程序应当执行一系列清理操作，例如：<ul><li>停止接受新的连接请求。</li><li>完成正在进行的任务或事务。</li><li>将内存中的数据刷新到磁盘（如数据库提交事务、缓存持久化）。</li><li>释放占用的资源（关闭文件描述符、网络连接等）。</li><li>最终自行退出。</li></ul></li></ul></li><li><p><strong>阶段二：强制终止（SIGKILL）</strong></p><ul><li>系统不会无限期地等待。默认情况下，Docker 会给予进程 <strong>10 秒</strong>的“宽限期”来完成上述清理工作。</li><li>如果 10 秒后容器进程仍然没有自行终止，Docker Daemon 便会失去耐心，发送 <strong>SIGKILL</strong> 信号。</li><li><strong>SIGKILL</strong> 信号非常强大且粗暴，它无法被应用程序捕获或忽略，会立即从内核层面强制终止进程。<strong>这是一种保底手段，但可能会导致数据丢失或状态损坏</strong>。</li></ul></li></ol><h4><span id="核心选项-t-time">核心选项：-t, –time</span></h4><p>此选项是 <code>docker stop</code> 命令的灵魂，它允许您自定义第一阶段“友好协商”的超时时间。</p><ul><li><p><strong>作用</strong>：改变默认的 10 秒等待时间。</p></li><li><p><strong>使用场景</strong>：对于数据库、消息队列等需要较长时间进行收尾工作的<strong>有状态服务</strong>，默认的 10 秒可能远远不够。使用 <code>-t</code> 可以给予它们充足的时间完成优雅关闭。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给予容器30秒的时间进行优雅关闭，30秒后才会强制终止</span></span><br><span class="line">docker stop -t 30 mysql_container</span><br></pre></td></tr></table></figure></li></ul><h4><span id="最佳实践与精要注意事项">最佳实践与精要注意事项</span></h4><ol><li><p><strong>区分“有状态”与“无状态”服务</strong>：</p><ul><li><strong>无状态服务（Stateless）</strong>：如 Web 服务器、API 微服务。它们通常可以快速关闭，对 <code>docker stop</code> 不敏感，使用默认超时即可。</li><li><strong>有状态服务（Stateful）</strong>：如 MySQL、Redis、Kafka。它们是 <code>docker stop</code> 操作的重点关注对象。<strong>务必使用 <code>-t</code> 选项设置一个足够长的超时时间</strong>，以确保它们能完成数据持久化等关键操作。</li></ul></li><li><p><strong>应用程序的信号处理是前提</strong>：<br><code>docker stop</code> 的优雅与否，最终取决于<strong>容器内主进程是否正确地处理了 SIGTERM 信号</strong>。如果您的自定义应用程序会运行为主进程，请确保它实现了 SIGTERM 信号处理逻辑。一个对 SIGTERM 毫无反应的进程，最终都难逃被 SIGKILL 强制终结的命运。</p></li><li><p><strong>数据持久化是安全停靠的港湾</strong>：<br>再次强调，任何有价值的数据都不应只存在于容器的可写层中。必须通过 <strong>Docker 数据卷（Volumes）</strong> 或<strong>绑定挂载（Bind Mounts）</strong> 将数据存储在容器之外。这样，无论容器是优雅停止还是被强制杀死，您的数据都是安全的。</p></li><li><p><strong>停止 vs 杀死</strong>：<br>与 <code>docker stop</code> 的优雅形成鲜明对比的是 <code>docker kill</code> 命令。<code>docker kill</code> 默认发送 <strong>SIGKILL</strong> 信号（也可指定其他信号），实现的是强制立即终止，相当于直接拔掉电源。<strong>除非容器已完全无响应，否则应优先使用 <code>docker stop</code>。</strong></p></li></ol><hr><p><code>docker stop</code> 远不止是一个停止容器的指令，它体现了 Docker 设计中对应用生命周期的尊重。</p><ul><li><strong>它不是杀手，而是信使</strong>：它先礼（SIGTERM）后兵（SIGKILL），致力于协商而非破坏。</li><li><strong><code>-t</code> 选项是其灵魂</strong>：通过自定义超时时间，您可以将优雅终止的控制权掌握在自己手中，尤其对于有状态服务至关重要。</li><li><strong>优雅是双向的</strong>：Docker 提供了优雅停止的机制，但最终效果需要容器内的应用程序协同配合。</li></ul><h3><span id="docker-kill">docker kill</span></h3><p>在 Docker 的管理工具箱中，如果 <code>docker stop</code> 是遵循流程、彬彬有礼的“交涉官”，那么 <code>docker kill</code> 就是果断坚决、毫无余地的“行刑队”。它不进行协商，不给予宽限期，它的任务只有一个：<strong>立即终止容器</strong>。理解何时以及如何使用这个“最终手段”，是应对紧急情况的关键。</p><hr><p><code>docker kill</code> 命令用于<strong>向一个或多个容器的主进程发送一个特定的系统信号（Signal）</strong>，默认情况下，这个信号是 <strong>SIGKILL</strong>。</p><p>它的核心特点是<strong>强制性和即时性</strong>。它绕过了 <code>docker stop</code> 的优雅终止流程，旨在以最快的方式让容器停止运行。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><h4><span id="docker-kill-的核心机制信号的力量"><code>docker kill</code> 的核心机制：信号的力量</span></h4><p><code>docker kill</code> 的威力源于 Linux 的系统信号机制。与 <code>docker stop</code> 固定先 SIGTERM 再 SIGKILL 的流程不同，<code>docker kill</code> 允许你<strong>直接指定发送任何信号</strong>，赋予了操作者极大的灵活性和控制力。</p><p><strong>最关键的选项：<code>-s</code> (–signal)</strong><br>这是 <code>docker kill</code> 的灵魂所在，它允许你指定要发送的信号。</p><table><thead><tr><th align="left">信号</th><th align="left">值</th><th align="left">作用</th><th align="left">使用示例</th></tr></thead><tbody><tr><td align="left"><strong>SIGKILL</strong></td><td align="left">9</td><td align="left"><strong>强制终止</strong>。无法被捕获、阻塞或忽略，进程会立即被操作系统内核终止。这是<strong>默认信号</strong>。</td><td align="left"><code>docker kill my_container</code></td></tr><tr><td align="left"><strong>SIGTERM</strong></td><td align="left">15</td><td align="left"><strong>优雅终止</strong>。通知进程终止，允许其进行清理工作。</td><td align="left"><code>docker kill -s SIGTERM my_container</code></td></tr><tr><td align="left"><strong>SIGHUP</strong></td><td align="left">1</td><td align="left"><strong>挂起</strong>。通常用于通知守护进程重新加载其配置。</td><td align="left"><code>docker kill -s SIGHUP nginx</code></td></tr><tr><td align="left"><strong>其他信号</strong></td><td align="left"></td><td align="left">如 SIGINT (2), SIGUSR1 (10) 等，可用于与进程进行特定交互。</td><td align="left"><code>docker kill -s SIGUSR1 my_app</code></td></tr></tbody></table><p><strong>工作流程：</strong></p><ol><li>你执行 <code>docker kill [OPTIONS] CONTAINER</code>。</li><li>Docker Daemon 直接向指定容器的主进程发送你通过 <code>-s</code> 指定的信号（默认为 SIGKILL）。</li><li>进程根据收到的信号做出反应（对于 SIGKILL，就是立即被终结）。</li><li>容器状态变为 <code>Exited</code>。</li></ol><h4><span id="为什么需要它应用场景">为什么需要它？应用场景</span></h4><p><code>docker kill</code> 的存在不是为了替代 <code>docker stop</code>，而是为了处理 <code>docker stop</code> 无法有效解决的极端情况。它的应用场景非常明确：</p><ol><li><p><strong>容器完全无响应（死机）</strong>：这是最经典的场景。当容器内的主进程陷入死循环、死锁或因为其他原因完全卡住，不再响应任何请求（包括 SIGTERM 信号）时，<code>docker stop</code> 会在等待超时后失败。此时，<code>docker kill -s SIGKILL</code> 是唯一能强制结束它的方法。</p></li><li><p><strong>立即释放关键资源</strong>：当某个失控的容器正在疯狂消耗主机资源（如 CPU、内存、磁盘 I&#x2F;O），导致系统即将崩溃时，你没有时间等待 10 秒的优雅退出。必须使用 <code>docker kill</code> 立即“拔掉电源”，以保护主机和其他容器。</p></li><li><p><strong>与进程进行特定通信</strong>：通过 <code>-s</code> 选项，它可以成为一个高级管理工具。例如，通知 Nginx 重新加载配置而不重启进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向nginx容器发送SIGHUP信号，使其重新加载配置文件</span></span><br><span class="line">docker <span class="built_in">kill</span> -s SIGHUP nginx</span><br></pre></td></tr></table></figure><p>在这种情况下，它非但不会终止容器，反而是一种“管理”指令。</p></li></ol><h4><span id="最佳实践与严厉警告">最佳实践与严厉警告</span></h4><p><strong>⚠️ 警告：核武器选项</strong></p><p>默认的 <code>SIGKILL</code> 是容器世界里的“核武器”。使用时必须清楚其后果：</p><ul><li><strong>数据丢失风险极高</strong>：进程没有机会执行任何清理操作。正在进行的写操作会中断，内存中的数据会丢失。<strong>绝对不要将其作为停止数据库或有状态服务的常规手段。</strong></li><li><strong>可能导致状态不一致</strong>：强制终止可能会使应用程序留下残缺的临时文件、孤立的锁文件或处于中间状态的数据，为下次启动埋下隐患。</li></ul><p><strong>最佳实践：</strong></p><ol><li><p><strong>始终优先使用 <code>docker stop</code></strong>：将其作为停止容器的默认和首选命令。只有在 <code>docker stop</code> 失效或情况万分紧急时，才诉诸于 <code>docker kill</code>。</p></li><li><p><strong>明确的升级流程</strong>：建立自己的操作流程：<code>docker stop -&gt; (等待) -&gt; 如果超时或无响应) -&gt; docker kill</code>。</p></li><li><p><strong>尝试“软”杀死</strong>：在发送最终的 <code>SIGKILL</code> 之前，可以尝试先手动发送 <code>SIGTERM</code>，给它最后一次机会：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> -s SIGTERM my_stuck_container</span><br><span class="line"><span class="comment"># 等待几秒...</span></span><br><span class="line">docker <span class="built_in">kill</span> my_stuck_container <span class="comment"># 默认发送SIGKILL</span></span><br></pre></td></tr></table></figure></li><li><p><strong>记录与复盘</strong>：每次使用 <code>docker kill</code> 后，都应记录原因并复盘。一个需要频繁被强制杀死的容器，其本身一定存在需要修复的缺陷（如内存泄漏、死锁 bug）。</p></li></ol><hr><p><code>docker kill</code> 是一个强大但危险的命令，是 Docker 管理员武器库中的“最后手段”。</p><ul><li><strong>它的核心是直接发送信号</strong>，默认是立即终止的 <code>SIGKILL</code>。</li><li><strong>它的设计目的是处理故障和紧急情况</strong>，而非日常操作。</li><li><strong><code>-s</code> 选项赋予了它灵活性</strong>，使其不仅能强制终止，还能用于特定的进程管理。</li><li><strong>最大的风险是数据丢失</strong>，使用时必须心怀敬畏。</li></ul><h3><span id="docker-top">docker top</span></h3><p>当我们运行一个 Docker 容器时，它就像是一个黑盒——我们知道它在运行，但很难直观地看到里面究竟发生了什么。<code>docker top</code> 命令正是为了打破这种信息壁垒而生的。它就像一台<strong>X 光机</strong>，能够让我们无需进入容器内部，就能清晰地洞察其内部运行的进程信息，是容器监控和故障排查中一个轻量级却极其实用的工具。</p><hr><p><code>docker top</code> 命令用于<strong>显示一个运行中容器内部的进程信息</strong>。</p><p>它的功能类似于在宿主机上执行 <code>ps</code>（process status）命令，但它的查看对象是容器内部的进程树。这个命令执行速度极快，因为它直接从 Docker 守护进程获取信息，而无需通过容器的 Shell 环境。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINER</code>: 目标容器的名称或 ID。</li><li><code>[ps OPTIONS]</code>: （可选）任何标准的 <code>ps</code> 命令选项，用于格式化输出内容。</li></ul><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>快速诊断与排查</strong>：当容器行为异常（如 CPU&#x2F;内存占用过高）时，<code>docker top</code> 是第一步的排查工具。你可以立即看到是容器内的哪个（或哪些）进程在消耗资源，而无需先 <code>exec</code> 进入容器。</li><li><strong>验证容器内容</strong>：确认容器内运行的主进程是否符合预期。例如，你运行了一个 Nginx 镜像，可以用 <code>docker top</code> 来验证 Nginx 主进程及其 worker 进程是否都已启动。</li><li><strong>获取进程 PID</strong>：容器内进程的 PID 在宿主机上有其对应的 PID。<code>docker top</code> 可以显示这些映射关系，这对于一些高级调试和监控场景非常有用。</li><li><strong>轻量级且非侵入</strong>：它不需要在容器内安装任何额外的工具（如 <code>htop</code>, <code>ps</code> 本身），几乎所有容器都可以直接使用，对容器本身零影响。</li></ol><h4><span id="实战示例从基础到高级">实战示例：从基础到高级</span></h4><p>假设我们有一个名为 <code>my_web</code> 的 Nginx 容器在运行。</p><p><strong>1. 基础用法：查看容器内进程</strong><br>最基本的命令，显示容器内所有进程的基本信息，默认输出格式与 <code>ps</code> 相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top my_web</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UID    PID    PPID   C   STIME   TTY   TIME        CMD</span><br><span class="line">root   12345  12316  0   10:00   ?     00:00:00   nginx: master process nginx -g daemon off;</span><br><span class="line">systemd+ 12367 12345  0   10:00   ?     00:00:00   nginx: worker process</span><br><span class="line">systemd+ 12368 12345  0   10:00   ?     00:00:00   nginx: worker process</span><br></pre></td></tr></table></figure><p>从输出可以清晰地看到：</p><ul><li><strong>主进程 (PID 12345)</strong>：<code>nginx: master process</code>。</li><li><strong>子进程 (PPID 12345)</strong>：两个 <code>nginx: worker process</code>，它们的父进程 ID (PPID) 指向主进程的 PID。</li></ul><p><strong>2. 高级用法：自定义输出格式</strong><br>通过传递标准的 <code>ps</code> 选项，可以获取更详细或更具体的信息。这是 <code>docker top</code> 最强大的地方。</p><ul><li><p><strong>显示完整的命令及其参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker top my_web -e</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker top my_web -args</span><br></pre></td></tr></table></figure></li><li><p><strong>查看进程的 UID 和用户名</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top my_web -e -o uid,user,pid,cmd</span><br></pre></td></tr></table></figure></li><li><p><strong>以森林模式显示进程层级关系</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top my_web -e -o pid,ppid,user,cmd --forest</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PID    PPID   USER    COMMAND</span><br><span class="line">12345  12316  root    nginx: master process nginx -g daemon off;</span><br><span class="line">12367  12345  systemd+  \_ nginx: worker process</span><br><span class="line">12368  12345  systemd+  \_ nginx: worker process</span><br></pre></td></tr></table></figure><p>这种方式可以非常直观地看到进程的父子关系。</p></li><li><p><strong>查看进程资源占用（CPU、内存）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top my_web -o pid,user,%cpu,%mem,cmd --<span class="built_in">sort</span> -%cpu</span><br></pre></td></tr></table></figure><p>此命令按 CPU 使用率降序排列，快速定位最耗资源的进程。</p></li></ul><h4><span id="最佳实践与注意事项">最佳实践与注意事项</span></h4><ol><li><strong>容器必须处于运行状态</strong>：<code>docker top</code> 只能用于状态为 <code>Up</code> 的容器。对于已停止的容器，该命令无法工作。</li><li><strong>理解 PID 映射</strong>：<code>docker top</code> 显示的第一个 PID 列是<strong>进程在宿主机命名空间中的真实 PID</strong>，而不是在容器内部的 PID。这对于在宿主机上使用 <code>strace</code>, <code>gdb</code> 等工具调试容器进程至关重要。</li><li><strong>功能的局限性</strong>：<code>docker top</code> 是一个<strong>诊断工具</strong>，而非<strong>管理工具</strong>。你可以用它来查看进程，但不能用它来直接管理（如杀死、改变优先级）进程。要管理进程，你需要使用 <code>docker exec</code> 在容器内执行命令，或使用宿主机的 <code>kill</code> 命令配合从 <code>docker top</code> 获取的宿主 PID。</li><li><strong>结合其他命令使用</strong>：<code>docker top</code> 通常与 <code>docker stats</code>（查看整体资源使用）和 <code>docker logs</code>（查看进程输出）结合使用，形成完整的排查链条：<ul><li><code>docker stats</code> 发现某个容器 CPU 高 -&gt;</li><li><code>docker top</code> 该容器找到具体的异常进程 -&gt;</li><li><code>docker exec</code> 进入容器或 <code>docker logs</code> 查看该进程的日志进行深度排查。</li></ul></li></ol><hr><p><code>docker top</code> 是一个简单却极其强大的原生调试命令，是每一位 Docker 使用者都应该掌握的“显微镜”。</p><ul><li><strong>它是洞察容器内部进程状态的窗口</strong>，提供了无需侵入即可观察的能力。</li><li><strong>它通过支持原生 <code>ps</code> 选项</strong>，提供了强大的信息过滤和格式化功能。</li><li><strong>它是性能排查和故障诊断的起点</strong>，能快速将问题定位到具体进程。</li><li><strong>它揭示了容器与宿主机之间的进程映射关系</strong>，为高级调试铺平了道路。</li></ul><p>将其加入你的日常运维工具箱，你会发现排查容器问题的效率得到了显著的提升。</p><h3><span id="docker-stat">docker stat</span></h3><p>当我们在一台主机上运行多个 Docker 容器时，一个核心的运维问题是：<strong>我的系统资源（CPU、内存、网络…）都被谁吃掉了？哪个容器是“资源大户”？</strong> 靠手动登录每个容器查看显然不现实。这时，<code>docker stats</code> 命令就如同一个<strong>统一的实时资源仪表盘</strong>，让你能够一目了然地监控所有容器的性能指标，是保障容器化环境健康运行的必备工具。</p><hr><p><code>docker stats</code> 命令用于<strong>实时显示一个或多个容器的资源使用情况统计信息</strong>。</p><p>它会动态刷新一个表格，其中包含了每个容器在 CPU、内存、网络 I&#x2F;O 和磁盘 I&#x2F;O 等方面的关键性能指标。这些数据直接来源于 Linux 内核的控制组（cgroups），因此非常准确和高效。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats [OPTIONS] [CONTAINER...]</span><br></pre></td></tr></table></figure><p>如果不指定任何容器，默认会显示所有运行中（Up）容器的统计信息。</p><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>实时性能监控</strong>：提供容器级别的实时资源消耗视图，帮助快速发现异常（如内存泄漏、CPU 爆满）。</li><li><strong>资源瓶颈定位</strong>：当主机出现高负载时，可以快速定位是哪个（或哪些）容器导致的，从而进行针对性处理。</li><li><strong>容量规划与优化</strong>：通过观察常态下的资源使用情况，可以为容器设置更合理的资源限制（<code>-m</code>, <code>--cpus</code>），避免资源浪费或竞争。</li><li><strong>零成本、零侵入</strong>：该命令是 Docker CLI 自带的，无需在容器内安装任何代理或监控软件，对容器本身毫无影响。</li></ol><h4><span id="解读监控面板每一列的含义">解读监控面板：每一列的含义</span></h4><p>执行 <code>docker stats</code> 后，你会看到一个类似这样的动态更新的表格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O          BLOCK I/O        PIDS</span><br><span class="line">a1b2c3d4e5f6   redis     0.12%     45.21MiB / 1.5GiB     2.94%     1.45kB / 0B      0B / 0B          4</span><br><span class="line">f6e5d4c3b2a1   nginx     0.05%     12.5MiB /  unlimited    -        25.6kB / 120kB   0B / 0B          3</span><br><span class="line">c3b2a1f6e5d4   web-app   125.7%    512.4MiB / 512MiB     100.0%    450kB / 1.2MB    12.3MB / 0B      27</span><br></pre></td></tr></table></figure><p>每一列都代表一个关键指标：</p><ul><li><strong>CONTAINER ID &amp; NAME</strong>: 容器的标识符和名称。</li><li><strong>CPU %</strong>: <strong>CPU 使用率百分比</strong>。显示容器正在使用的宿主 CPU 总时间的百分比。<strong>如果有多核心 CPU，这个值可以超过 100%</strong>。例如，125% 表示容器使用了 1.25 个 CPU 核心的计算能力。</li><li><strong>MEM USAGE &#x2F; LIMIT</strong>: <strong>内存使用量 &#x2F; 内存限制</strong>。这是两个最关键的数字之一，直观显示了“用量”和“上限”。</li><li><strong>MEM %</strong>: <strong>内存使用率百分比</strong>。即 <code>MEM USAGE / LIMIT * 100%</code>。如果未设置内存限制（<code>unlimited</code>），此列会显示为 <code>-</code>。</li><li><strong>NET I&#x2F;O</strong>: <strong>网络输入&#x2F;输出流量</strong>。显示容器自启动以来累计接收和发送的数据量。这是排查网络流量异常的重要依据。</li><li><strong>BLOCK I&#x2F;O</strong>: <strong>块设备输入&#x2F;输出量</strong>。显示容器读写磁盘的数据量。对于数据库等磁盘密集型应用，这个指标非常重要。</li><li><strong>PIDS</strong>: <strong>进程数量</strong>。显示容器内当前存在的进程和线程数。一个异常的激增可能预示着某些问题。</li></ul><h4><span id="实战示例从概览到聚焦">实战示例：从概览到聚焦</span></h4><p><strong>1. 监控所有容器（全局概览）</strong><br>最基本的命令，给你一个主机上所有运行容器的资源大盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure><p>按 <code>Ctrl+C</code> 退出监控。</p><p><strong>2. 监控特定容器（精准聚焦）</strong><br>如果你只关心某几个容器，可以在命令后指定它们的名称或 ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控指定的容器</span></span><br><span class="line">docker stats nginx redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用容器ID（取前几位即可）</span></span><br><span class="line">docker stats a1b2c3 f6e5d4</span><br></pre></td></tr></table></figure><p><strong>3. 使用选项格式化输出</strong><br><code>docker stats</code> 提供了一些有用的选项来定制输出。</p><ul><li><p><strong><code>--no-stream</code></strong>：<strong>只输出一次当前状态，然后退出</strong>。适用于编写脚本或快速获取某个时间点的快照，而不是持续监控。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats --no-stream</span><br></pre></td></tr></table></figure></li><li><p><strong><code>--format</code></strong>：<strong>按照 Go 模板自定义输出格式</strong>。这是高级用法，可以让你只显示关心的列，或者用于自动化脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示容器名、CPU百分比和内存使用量</span></span><br><span class="line">docker stats --format <span class="string">&quot;table &#123;&#123;.Name&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以纯JSON格式输出一次（非常适合由其他程序解析）</span></span><br><span class="line">docker stats --no-stream --format <span class="string">&quot;&#123;&#123;json .&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4><span id="最佳实践与注意事项">最佳实践与注意事项</span></h4><ol><li><p><strong>它只是一个实时工具</strong>：<code>docker stats</code> 显示的是<strong>实时数据流</strong>，而非历史数据。它不会保存任何历史记录。对于长期趋势分析、告警和数据持久化，你需要更专业的监控方案，如 <strong>Prometheus + Grafana</strong>（通常通过 <code>cAdvisor</code> 来收集 Docker 指标）。</p></li><li><p><strong>结合 <code>docker top</code> 进行深度排查</strong>：<code>docker stats</code> 告诉你<strong>哪个容器</strong>出了问题（如 CPU 100%），而 <code>docker top</code> 可以进一步告诉你该容器内<strong>是哪个进程</strong>导致了问题。这两个命令是黄金搭档。</p></li><li><p><strong>理解“ unlimited”</strong>：如果运行容器时未使用 <code>-m</code> 或 <code>--memory-swap</code> 设置内存限制，<code>MEM LIMIT</code> 会显示为 <code>unlimited</code>，<code>MEM %</code> 会显示为 <code>-</code>。在生产环境中，<strong>强烈建议为所有容器设置内存限制</strong>，以防止某个容器耗尽整个主机内存导致系统崩溃（OOM）。</p></li><li><p><strong>性能影响极小</strong>：由于数据直接来自内核的 cgroups，运行 <code>docker stats</code> 的开销非常小，可以放心使用。</p></li></ol><hr><p><code>docker stats</code> 是 Docker 原生提供的、最简单高效的实时监控工具。</p><ul><li><strong>它是容器资源的实时仪表盘</strong>，让你对系统状态了如指掌。</li><li><strong>它是故障排查的起点</strong>，能快速将性能问题定位到具体容器。</li><li><strong>它简单易用且零成本</strong>，是每个 Docker 用户都应该掌握的第一个监控命令。</li><li><strong>对于更高级的需求</strong>，它是指引你走向更强大监控系统（如 Prometheus）的敲门砖。</li></ul><p>无论是日常运维还是应急排查，熟练使用 <code>docker stats</code> 都能让你更加从容地管理和维护你的容器化应用。</p><h3><span id="docker-container-inspect">docker container inspect</span></h3><p>在 Docker 的生态中，我们经常需要了解一个容器的详细信息：它的配置是什么？它的网络是如何设置的？它挂载了哪些数据卷？虽然我们可以通过 <code>docker ps</code> 看到容器的概览，但要获取其全部底层细节，就需要一个更强大的工具——<code>docker container inspect</code>。这个命令就像是为容器生成的一份<strong>全方位的“体检报告”</strong>，揭示了从创建到运行的每一个技术细节。</p><hr><p><code>docker container inspect</code> 命令用于<strong>获取 Docker 容器底层配置和运行时状态的详细信息（元数据）</strong>。</p><p>它会返回一个庞大的 JSON 对象，这个对象包含了容器生命周期的几乎所有信息，从最初的创建配置（<code>docker create</code>&#x2F;<code>docker run</code> 时指定的所有参数）到当前的运行时状态（如 IP 地址、端口映射、进程 ID 等）。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>你也可以使用它的传统缩写形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect CONTAINER</span><br></pre></td></tr></table></figure><p>两者功能完全一致。</p><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>故障排查与调试</strong>：当容器行为异常时，<code>inspect</code> 是查明根本原因的第一站。你可以检查网络配置、卷挂载、环境变量等是否正确。</li><li><strong>发现连接信息</strong>：快速查找容器的 IP 地址、网关以及端口映射关系，这对于容器间的网络通信或从外部访问服务至关重要。</li><li><strong>审计与验证</strong>：验证容器的运行配置是否与预期一致，例如资源限制、重启策略、安全选项等。</li><li><strong>信息提取用于自动化</strong>：其结构化（JSON）的输出格式非常适合被脚本或其他工具（如 <code>jq</code>）解析，以实现自动化运维。</li><li><strong>学习与理解</strong>：通过查看容器元数据，可以更深入地理解 Docker 是如何构建和管理容器环境的。</li></ol><h4><span id="解读体检报告json-输出中的关键信息">解读“体检报告”：JSON 输出中的关键信息</span></h4><p><code>docker container inspect</code> 的输出是一个深度嵌套的 JSON 对象，主要包含两大块：<strong>容器配置（Config）</strong> 和<strong>容器状态（State）</strong>。</p><p>执行以下命令查看原始格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect my_container</span><br></pre></td></tr></table></figure><p>输出内容非常丰富，以下是一些最常用和关键的字段：</p><p><strong>1. 网络设置（NetworkSettings）：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;NetworkSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Networks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 网络模式，可能是 bridge, host, 或自定义网络名</span></span><br><span class="line">      <span class="attr">&quot;IPAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.2&quot;</span><span class="punctuation">,</span> <span class="comment">// **容器的IP地址**</span></span><br><span class="line">      <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MacAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02:42:ac:11:00:02&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Ports&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// **端口映射**</span></span><br><span class="line">    <span class="attr">&quot;80/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8080&quot;</span> <span class="comment">// **宿主机的映射端口**</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>用途</strong>：查找容器 IP 以进行连接测试，确认端口映射是否正确。</li></ul><p><strong>2. 挂载信息（Mounts）：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span> <span class="comment">// 类型可以是 volume（数据卷）, bind（绑定挂载）, tmpfs</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_volume&quot;</span><span class="punctuation">,</span> <span class="comment">// 卷名</span></span><br><span class="line">    <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/my_volume/_data&quot;</span><span class="punctuation">,</span> <span class="comment">// **在宿主机上的源路径**</span></span><br><span class="line">    <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/app/data&quot;</span><span class="punctuation">,</span> <span class="comment">// **在容器内的目标路径**</span></span><br><span class="line">    <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// 读写权限</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><ul><li><strong>用途</strong>：确认数据卷和绑定挂载是否正确配置，并找到数据在宿主机上的实际存储位置。</li></ul><p><strong>3. 配置信息（Config）：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx:latest&quot;</span><span class="punctuation">,</span> <span class="comment">// 使用的镜像</span></span><br><span class="line">  <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// **环境变量**</span></span><br><span class="line">    <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;NGINX_VERSION=1.25.3&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;nginx&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span> <span class="string">&quot;daemon off;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 启动命令</span></span><br><span class="line">  <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 标签</span></span><br><span class="line">    <span class="attr">&quot;maintainer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NGINX Docker Maintainers&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>用途</strong>：检查容器运行时的核心配置，如启动命令、环境变量等。</li></ul><p><strong>4. 状态信息（State）：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;State&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;running&quot;</span><span class="punctuation">,</span> <span class="comment">// 状态：running, paused, exited, restarting</span></span><br><span class="line">  <span class="attr">&quot;Running&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Paused&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Restarting&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Pid&quot;</span><span class="punctuation">:</span> <span class="number">1234</span><span class="punctuation">,</span> <span class="comment">// **容器主进程在宿主机上的PID**</span></span><br><span class="line">  <span class="attr">&quot;StartedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-08-31T10:00:00.123456789Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;FinishedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>用途</strong>：确认容器的精确状态和运行时长，获取 PID 用于高级调试。</li></ul><h4><span id="实战示例使用格式化和过滤">实战示例：使用格式化和过滤</span></h4><p>原始 JSON 输出信息量巨大，我们通常需要借助选项来提取特定信息。</p><p><strong>1. 使用 <code>--format</code> 或 <code>-f</code> 提取特定字段（Go 模板）</strong><br>这是最强大的功能，可以精准获取你需要的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取容器的IP地址</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> my_container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器状态</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.State.Status&#125;&#125;&#x27;</span> my_container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器使用的镜像</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.Config.Image&#125;&#125;&#x27;</span> my_container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取宿主机映射的端口（例如映射到容器80端口的主机端口）</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;(index (index .NetworkSettings.Ports &quot;80/tcp&quot;) 0).HostPort&#125;&#125;&#x27;</span> my_container</span><br></pre></td></tr></table></figure><p><strong>2. 使用 <code>jq</code> 工具解析输出（更灵活）</strong><br><code>jq</code> 是一个强大的命令行 JSON 处理器，与 <code>docker inspect</code> 是绝配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先确保系统安装了 jq: apt-get install jq</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有挂载点的源和目标</span></span><br><span class="line">docker inspect my_container | jq <span class="string">&#x27;.[].Mounts[] | .Source, .Destination&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以更漂亮的格式输出整个JSON，便于阅读</span></span><br><span class="line">docker inspect my_container | jq .</span><br></pre></td></tr></table></figure><p><strong>3. 一次检查多个容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect nginx redis</span><br></pre></td></tr></table></figure><h4><span id="最佳实践与注意事项">最佳实践与注意事项</span></h4><ol><li><strong>适用于所有状态的容器</strong>：与许多命令不同，<code>docker container inspect</code> 不仅可以用于运行中的容器，也可以用于已停止（<code>exited</code>）的容器。这对于排查为什么容器启动失败非常有用。</li><li><strong>信息是只读的</strong>：该命令仅用于查看信息，无法用于修改任何容器配置。要修改配置，需要重新创建容器。</li><li><strong>掌握 <code>--format</code> 和 <code>jq</code></strong>：学习基础的 Go 模板语法和 <code>jq</code> 的使用，能让你从信息海洋中高效地捞出所需的数据，这是进阶玩家的必备技能。</li><li><strong>理解输出结构</strong>：花些时间浏览一次完整的输出，熟悉其主要结构（<code>Config</code>, <code>State</code>, <code>NetworkSettings</code>, <code>Mounts</code>），以后排查问题时就能快速定位。</li></ol><hr><p><code>docker container inspect</code> 是 Docker 工具箱中最强大的诊断命令之一，是探索容器内部机制的“瑞士军刀”。</p><ul><li><strong>它是容器元数据的终极来源</strong>，提供了无与伦比的细节深度。</li><li><strong>它是连接抽象概念和具体实现的桥梁</strong>，让你真正“看透”容器。</li><li><strong>结合 <code>--format</code> 和 <code>jq</code></strong>，它从一個诊断工具转变为自动化脚本的核心组件。</li><li><strong>无论是开发、调试还是运维</strong>，它都是不可或缺的得力助手。</li></ul><h3><span id="docker-port">docker port</span></h3><p>在 Docker 网络模型中，容器拥有自己独立的网络命名空间，这意味着容器内部服务的监听端口（如 Nginx 的 80 端口）默认在外部是无法直接访问的。为了解决这个问题，我们使用 <code>-p</code> 或 <code>-P</code> 参数来创建端口映射。但容器一旦运行起来，我们如何快速确认<strong>容器内的端口到底映射到了宿主机的哪个端口上</strong>？<code>docker port</code> 命令就是为了回答这个简单而关键的问题而生的，它是一个轻巧、快速的专用查询工具。</p><hr><p><code>docker port</code> 命令用于<strong>快速列出容器端口到宿主机端口的映射关系</strong>。</p><p>它直接查询 Docker 守护进程中记录的端口绑定信息，并以最清晰的方式呈现出来，让你无需从冗长的 <code>docker inspect</code> 输出中费力地寻找答案。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINER</code>: 目标容器的名称或 ID。</li><li><code>[PRIVATE_PORT[/PROTO]]</code>: （可选）指定要查询的容器内部端口和协议（如 <code>80/tcp</code>），用于过滤结果。</li></ul><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>快速验证与连接</strong>：当你想从宿主机或其他机器连接到一个容器内的服务时，需要知道具体映射到了哪个端口。<code>docker port</code> 提供了最直接的查询方式。</li><li><strong>简化运维操作</strong>：相比使用 <code>docker inspect</code> 并手动解析庞大的 JSON 输出，<code>docker port</code> 的命令和输出都极其简单，非常适合在脚本或快速运维时使用。</li><li><strong>避免记忆和猜测</strong>在复杂环境中，可能同时运行着多个容器，每个容器都有多个端口映射。此命令可以准确告诉你当前的映射状态，避免因记错端口而导致的连接失败。</li></ol><h4><span id="实战示例从查全部到精准查询">实战示例：从查全部到精准查询</span></h4><p>假设我们运行了一个 Nginx 容器，并将容器的 80 端口映射到了宿主机的 <strong>8080</strong> 端口，同时将容器的 443 端口映射到了宿主机的 <strong>8443</strong> 端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my_nginx -p 8080:80 -p 8443:443 nginx</span><br></pre></td></tr></table></figure><p><strong>1. 查询容器的所有端口映射</strong><br>这是最常用的方式，列出该容器配置的所有端口映射规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port my_nginx</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">80/tcp -&gt; 0.0.0.0:8080</span><br><span class="line">443/tcp -&gt; 0.0.0.0:8443</span><br></pre></td></tr></table></figure><p><strong>解读输出：</strong></p><ul><li><code>80/tcp</code>：容器内部监听的端口和协议（TCP）。</li><li><code>-&gt;</code>：表示映射关系。</li><li><code>0.0.0.0:8080</code>：宿主机上绑定的 IP 地址和端口。<code>0.0.0.0</code> 表示绑定在宿主机的所有网络接口上，可通过宿主机的任何一个 IP 地址加 <code>8080</code> 端口来访问。</li></ul><p><strong>2. 查询容器的特定端口映射</strong><br>如果你只关心某个特定端口（例如只想知道 80 端口映射到了哪里），可以使用可选参数进行过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询容器内部80端口的映射情况</span></span><br><span class="line">docker port my_nginx 80</span><br><span class="line"><span class="comment"># 或更精确地指定协议（虽然TCP是默认值）</span></span><br><span class="line">docker port my_nginx 80/tcp</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0:8080</span><br></pre></td></tr></table></figure><p>这次输出更加简洁，只返回了宿主机端的绑定信息。</p><h4><span id="工作原理与局限性">工作原理与局限性</span></h4><p><strong>工作原理：</strong><br><code>docker port</code> 命令本质上是查询 Docker 守护进程维护的 iptables 规则或内部状态表，这些规则是在容器启动时通过 <code>-p</code> 或 <code>-P</code> 参数设置的。它返回的是<strong>配置的映射关系</strong>，而不是实时检测端口是否真正处于监听状态。</p><p><strong>局限性：</strong></p><ol><li><p><strong>仅显示显式映射的端口</strong>：它只显示通过 <code>-p</code> 或 <code>-P</code> 参数设置的端口映射。对于使用 <code>--network=host</code> 模式（主机网络模式）的容器，由于容器直接使用宿主机的网络命名空间，没有端口映射的概念，因此此命令不会返回任何信息。</p></li><li><p><strong>不检测端口状态</strong>：它只告诉你“根据配置，端口应该映射到哪里”，但并不会检查宿主机的 <code>8080</code> 端口是否真的处于监听状态。要验证端口是否可访问，还需要配合 <code>netstat</code>、<code>ss</code> 或 <code>telnet</code> 等命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 docker port 找到映射端口，再用 telnet 测试连通性</span></span><br><span class="line">docker port my_nginx 80</span><br><span class="line">telnet localhost 8080</span><br></pre></td></tr></table></figure></li></ol><h4><span id="最佳实践与应用场景">最佳实践与应用场景</span></h4><ol><li><p><strong>快速诊断连接问题</strong>：当无法通过宿主机 IP 和端口访问容器服务时，第一步就应用 <code>docker port</code> 确认映射关系是否正确建立。</p></li><li><p><strong>自动化脚本</strong>：在 CI&#x2F;CD 流水线或运维脚本中，如果需要获取容器的映射端口以便进行健康检查或集成测试，<code>docker port</code> 的简洁输出非常适合被其他命令直接使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在脚本中获取映射端口并赋值给变量</span></span><br><span class="line">MAPPED_PORT=$(docker port my_nginx 80 | <span class="built_in">cut</span> -d: -f2)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The application is accessible on port <span class="variable">$MAPPED_PORT</span>.&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>与 <code>docker ps</code> 互补</strong>：<code>docker ps</code> 也会显示端口映射，但格式是浓缩的（如 <code>0.0.0.0:8080-&gt;80/tcp</code>）。当 <code>docker ps</code> 的输出因信息过多而不易阅读时，使用 <code>docker port</code> 查看特定容器的映射会更加清晰。</p></li></ol><hr><p><code>docker port</code> 是一个“小而美”的典范，它专注于解决一个非常具体的问题：</p><ul><li><strong>它是端口映射的专用查询工具</strong>，功能单一但极其高效。</li><li><strong>它的输出简洁明了</strong>，无需像解析 <code>docker inspect</code> 那样需要处理复杂的 JSON。</li><li><strong>它是网络调试的第一步</strong>，帮助快速验证基础的网络配置是否正确。</li><li><strong>它完美体现了 Unix 哲学</strong>——“做好一件事”，并与其他命令（如 <code>inspect</code>, <code>ps</code>, <code>netstat</code>）组合使用，形成完整的故障排查链条。</li></ul><h3><span id="docker-cp">docker cp</span></h3><p>Docker 容器以其隔离性而闻名，但这种隔离有时也会带来不便：我们如何将宿主机的配置文件传入容器？又如何将容器内应用程序生成的日志或数据文件提取出来进行分析？<code>docker cp</code>（copy 的缩写）命令正是为了打破这种隔离而设计的。它就像一座<strong>安全的文件桥梁</strong>，允许在宿主机和容器之间双向复制文件和目录，是开发、调试和运维中不可或缺的实用工具。</p><hr><p><code>docker cp</code> 命令用于<strong>在宿主机文件系统和一个运行的或已停止的容器文件系统之间复制文件或目录</strong>。</p><p>它实现了容器内外环境的文件交换，支持双向操作，并且对容器内的进程毫无影响。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> [OPTIONS] CONTAINER:SRC_PATH DEST_PATH</span><br><span class="line">docker <span class="built_in">cp</span> [OPTIONS] SRC_PATH CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINER</code>：目标容器的名称或 ID。</li><li><code>SRC_PATH</code>：源文件或目录的路径。</li><li><code>DEST_PATH</code>：目标文件或目录的路径。</li><li><code>[OPTIONS]</code>：可选参数，目前主要支持 <code>-a</code>（归档模式，保留文件属性）和 <code>-L</code>（跟随符号链接）。</li></ul><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>快速注入配置</strong>：将宿主机上修改好的配置文件（如 Nginx 的 <code>nginx.conf</code>）快速复制到容器中生效，无需重新构建镜像。</li><li><strong>提取日志和数据</strong>：将容器内应用生成的日志文件、临时数据或崩溃报告复制到宿主机上进行深入分析。</li><li><strong>动态调试与支持</strong>：在调试时，向容器内注入调试脚本或工具，或者从容器中提取状态信息。</li><li><strong>备份与恢复</strong>：快速备份容器内用户生成的重要数据，或者将备份数据恢复到另一个容器中。</li></ol><h4><span id="实战示例从宿主机到容器以及反向操作">实战示例：从宿主机到容器，以及反向操作</span></h4><p><strong>1. 将文件从宿主机复制到容器内（Host -&gt; Container）</strong><br>这是最常见的操作，例如传入一个配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将宿主机当前目录下的 app.conf 文件复制到容器内 /etc/ 目录下</span></span><br><span class="line">docker <span class="built_in">cp</span> ./app.conf my_container:/etc/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将宿主机目录 /host/logs 整个复制到容器内的 /tmp 目录下</span></span><br><span class="line">docker <span class="built_in">cp</span> -a /host/logs my_container:/tmp/</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：如果容器内的目标路径是一个目录，文件会被复制到该目录下。如果目标路径不存在，<code>docker cp</code> 会尝试创建它。</li></ul><p><strong>2. 将文件从容器内复制到宿主机（Container -&gt; Host）</strong><br>同样重要，常用于提取数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器内 /var/log/nginx/error.log 文件复制到宿主机当前目录</span></span><br><span class="line">docker <span class="built_in">cp</span> my_container:/var/log/nginx/error.log ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器内 /app/data 整个目录复制到宿主机的 /backup 目录下</span></span><br><span class="line">docker <span class="built_in">cp</span> -a my_container:/app/data /backup/</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：从容器内复制时，源路径必须写全路径，并以 <code>容器名或ID:</code> 开头。</li></ul><p><strong>3. 复制已停止的容器中的文件</strong><br><code>docker cp</code> 的一个巨大优势是它不仅适用于运行中的容器，也适用于已停止（<code>exited</code>）的容器。只要容器没有被删除，你仍然可以访问其文件系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个已停止的容器，其ID为 stopped_container</span></span><br><span class="line">docker <span class="built_in">cp</span> stopped_container:/app/config.json ./recovered_config.json</span><br></pre></td></tr></table></figure><h4><span id="核心选项options详解">核心选项（OPTIONS）详解</span></h4><ul><li><p><strong><code>-a</code> (–archive)</strong>：<strong>归档模式</strong>。这是最常用的选项，它在复制时会保留文件的所有元信息，包括：</p><ul><li>用户和组所有权（UID&#x2F;GID）</li><li>时间戳（修改时间、访问时间）</li><li>权限模式（读、写、执行）</li><li>特殊标志（如 setuid）</li><li>使用 <code>-a</code> 选项可以确保复制的文件与原始文件属性完全一致。</li></ul></li><li><p><strong><code>-L</code> (–follow-link)</strong>：<strong>跟随符号链接</strong>。默认情况下，<code>docker cp</code> 会复制符号链接本身（一个指向其他文件的快捷方式）。使用此选项后，它会复制符号链接所指向的<strong>实际文件内容</strong>。</p></li></ul><h4><span id="最佳实践与重要注意事项">最佳实践与重要注意事项</span></h4><ol><li><p><strong>它不是持久化的替代品</strong>：<code>docker cp</code> 是用于<strong>临时</strong>文件传输的。通过它复制到容器内的文件<strong>仅存在于该容器的可写层中</strong>。如果容器被删除并重新创建（基于原镜像），这些文件会丢失。<strong>持久化数据必须通过 Docker 数据卷（Volumes）或绑定挂载（Bind Mounts）来实现。</strong></p></li><li><p><strong>对运行中应用的影响</strong>：向一个运行中的容器复制文件（尤其是覆盖正在被进程打开的文件）可能会导致不可预知的行为。对于配置文件，更安全的做法是复制进去后，再在容器内发送信号让应用重载配置（如 <code>nginx -s reload</code>），或者重启容器。</p></li><li><p><strong>路径中的空格和特殊字符</strong>：如果文件或目录的路径中包含空格或特殊字符，务必使用引号将其括起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> <span class="string">&quot;my_container:/path/with spaces/file.txt&quot;</span> ./</span><br></pre></td></tr></table></figure></li><li><p><strong>与 <code>docker exec</code> 和重定向的结合使用</strong>：有时，直接生成文件内容到容器内更方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐：先在本机创建文件，再复制</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;config_value=123&quot;</span> &gt; temp.conf</span><br><span class="line">docker <span class="built_in">cp</span> temp.conf my_container:/app/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐：使用 docker exec 和重定向直接写入（更高效）</span></span><br><span class="line">docker <span class="built_in">exec</span> my_container sh -c <span class="string">&#x27;echo &quot;config_value=123&quot; &gt; /app/config&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>性能考虑</strong>：复制大量小文件时，打包成一个归档文件（如 <code>.tar</code>）再进行复制，效率会远高于直接复制目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在宿主机上打包</span></span><br><span class="line">tar -czf logs.tar.gz /path/to/many/files/</span><br><span class="line">docker <span class="built_in">cp</span> logs.tar.gz my_container:/tmp/</span><br><span class="line"><span class="comment"># 在容器内解压</span></span><br><span class="line">docker <span class="built_in">exec</span> my_container tar -xzf /tmp/logs.tar.gz -C /target/dir</span><br></pre></td></tr></table></figure></li></ol><hr><p><code>docker cp</code> 是一个简单而强大的“救火队员”和“调试助手”。</p><ul><li><strong>它是容器与宿主机间临时的文件交换通道</strong>，打破了隔离的壁垒。</li><li><strong>它支持双向操作</strong>，既可用于注入，也可用于提取。</li><li><strong>它适用于运行中和已停止的容器</strong>，提供了极大的灵活性。</li><li><strong><code>-a</code> 选项</strong>是保障文件元信息正确的关键。</li><li><strong>切记它并非持久化方案</strong>，对于重要数据，应始终使用数据卷。</li></ul><h3><span id="docker-diff">docker diff</span></h3><p>Docker 镜像的核心优势之一是其不可变性（Immutable）。我们基于一个纯净的镜像运行容器，但容器在运行过程中，应用程序会产生日志、用户会上传文件、临时数据会被创建。一个关键问题随之而来：<strong>自从容器启动后，它的文件系统相对于最初的镜像，发生了哪些变化？</strong> <code>docker diff</code> 命令正是为了回答这个问题而设计的。它就像一台<strong>文件系统的时光机</strong>，可以清晰地展示出容器读写层（Container Layer）的所有变更，是审计、调试和理解容器行为的强大工具。</p><hr><p><code>docker diff</code> 命令用于<strong>检查一个容器相对于其基础镜像，在文件系统层面所做的更改</strong>。</p><p>这些更改包括添加、修改和删除的文件和目录，它们都被记录在容器的可写层（Container Layer）中。该命令会扫描这些变更，并以列表形式呈现出来。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff CONTAINER</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINER</code>：目标容器的名称或 ID。</li></ul><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>调试与故障排查</strong>：当容器行为异常时，快速检查是否有关键配置文件被意外修改或删除，或者是否有异常文件被创建（如病毒、入侵痕迹）。</li><li><strong>审计与安全分析</strong>：验证容器内的文件变更是否符合预期。例如，一个只读的应用容器不应该在系统目录创建文件。</li><li><strong>逆向工程与学习</strong>：对于不熟悉的第三方镜像，运行后通过 <code>docker diff</code> 可以了解它启动了哪些服务、修改了哪些配置、在哪些路径写入了数据，从而更好地理解其行为。</li><li><strong>为提交镜像做准备</strong>：在手动调试容器并准备使用 <code>docker commit</code> 将其保存为新镜像之前，先用 <code>docker diff</code> 审查一下变更内容，避免将临时文件、日志或敏感信息意外提交到新镜像中。</li></ol><h4><span id="解读输出理解变更类型">解读输出：理解变更类型</span></h4><p><code>docker diff</code> 的命令输出非常简洁，每一行代表一个文件的变更，由一个表示变更类型的字母开头，后接文件或目录的路径。</p><p><strong>变更类型标识符：</strong></p><table><thead><tr><th align="left">标识符</th><th align="left">含义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong><code>A</code></strong></td><td align="left"><strong>Add</strong></td><td align="left">新添加的文件或目录。</td></tr><tr><td align="left"><strong><code>C</code></strong></td><td align="left"><strong>Change</strong></td><td align="left">已存在文件的内容被修改。</td></tr><tr><td align="left"><strong><code>D</code></strong></td><td align="left"><strong>Delete</strong></td><td align="left">已存在文件被删除。</td></tr></tbody></table><p><strong>实战示例输出：</strong><br>假设我们运行一个 Ubuntu 容器，并做一些操作：</p><ol><li>安装 <code>nginx</code> 软件包（会添加大量文件）</li><li>修改 <code>/etc/hosts</code> 文件</li><li>删除 <code>/etc/issue</code> 文件</li></ol><p>执行 <code>docker diff &lt;container_id&gt;</code> 后，你可能会看到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C /etc</span><br><span class="line">C /etc/hosts</span><br><span class="line">D /etc/issue.net</span><br><span class="line">A /var</span><br><span class="line">A /var/lib</span><br><span class="line">A /var/lib/nginx</span><br><span class="line">A /var/lib/nginx/body</span><br><span class="line">A /var/lib/nginx/fastcgi</span><br><span class="line">A /var/lib/nginx/proxy</span><br><span class="line">A /var/lib/nginx/uwsgi</span><br><span class="line">A /var/lib/nginx/scgi</span><br><span class="line">A /run</span><br><span class="line">A /run/nginx.pid</span><br><span class="line">C /var/lib/dpkg/status</span><br><span class="line">A /usr</span><br><span class="line">A /usr/sbin</span><br><span class="line">A /usr/sbin/nginx</span><br><span class="line">... (很长的一系列添加项)</span><br></pre></td></tr></table></figure><p><strong>解读：</strong></p><ul><li><code>C /etc/hosts</code>：我们修改了 hosts 文件。</li><li><code>D /etc/issue.net</code>：我们删除了 issue.net 文件。</li><li>所有以 <code>A</code> 开头的行（如 <code>/usr/sbin/nginx</code>）都是安装 Nginx 时添加的新文件。</li></ul><h4><span id="实战示例与应用场景">实战示例与应用场景</span></h4><p><strong>场景 1：快速排查“容器为什么不起作用？”</strong><br>一个原本运行良好的容器突然无法启动。你可以运行它的最新版本，并使用 <code>docker diff</code> 检查它与之前正常版本的文件差异，也许会发现某个关键的配置文件（<code>C</code>）被覆盖或数据库文件被意外删除（<code>D</code>）。</p><p><strong>场景 2：检查数据持久化位置</strong><br>你想知道一个第三方应用（如 WordPress）默认会把上传的文件和插件放在哪里。你可以：</p><ol><li>启动一个纯净的 WordPress 容器。</li><li>在浏览器中完成安装，上传一张图片，安装一个插件。</li><li>使用 <code>docker diff</code> 命令，查看新增了哪些文件（<code>A</code>）。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff wordpress_container</span><br></pre></td></tr></table></figure><p>输出可能会显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A /var/www/html/wp-content/uploads</span><br><span class="line">A /var/www/html/wp-content/uploads/2024/08</span><br><span class="line">A /var/www/html/wp-content/uploads/2024/08/my-image.jpg</span><br><span class="line">A /var/www/html/wp-content/plugins</span><br><span class="line">A /var/www/html/wp-content/plugins/my-plugin</span><br></pre></td></tr></table></figure><p>这清晰地告诉你，必须将 <code>/var/www/html/wp-content</code> 目录通过卷挂载出来才能持久化数据。</p><p><strong>场景 3：审计容器安全性</strong><br>检查一个正在运行的容器是否被入侵，可以定期执行 <code>docker diff</code>，查看是否有异常的可执行文件（<code>A</code>）被添加到 <code>/tmp</code>、<code>/dev/shm</code> 等目录，或者系统的关键命令（如 <code>/bin/bash</code>）是否被修改（<code>C</code>）。</p><h4><span id="最佳实践与注意事项">最佳实践与注意事项</span></h4><ol><li><p><strong>适用于所有状态的容器</strong>：与许多命令不同，<code>docker diff</code> 既可以用于<strong>运行中</strong>的容器，也可以用于<strong>已停止</strong>的容器。这对于排查已经停止的容器为何出问题非常有用。</p></li><li><p><strong>它显示的是“差异”，不是“内容”</strong>：<code>docker diff</code> 只告诉你<strong>哪些文件变了</strong>（以及变化的类型），但<strong>不会显示文件变化的具体内容</strong>。要查看具体内容，你需要使用 <code>docker cp</code> 将文件复制出来，或者使用 <code>docker exec</code> 在容器内用 <code>cat</code> 查看。</p></li><li><p><strong>理解容器层的本质</strong>：这些变更都存储在容器的可写层中。<strong>一旦容器被删除，所有这些变更都会永久丢失</strong>（除非通过 <code>docker commit</code> 提交为镜像，或通过 <code>docker cp</code> 备份出来）。这再次强调了使用<strong>数据卷（Volumes）</strong> 进行持久化的重要性。</p></li><li><p><strong>输出可能很长</strong>：对于安装了大量软件的容器（如通过 <code>apt install</code>），输出列表会非常长。可以结合 <code>grep</code> 等工具进行过滤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只查看 /etc 目录下的变更</span></span><br><span class="line">docker diff my_container | grep /etc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只查看被删除的文件</span></span><br><span class="line">docker diff my_container | grep ^D</span><br></pre></td></tr></table></figure></li></ol><hr><p><code>docker diff</code> 是一个低调但极其强大的诊断和审计工具。</p><ul><li><strong>它是容器文件系统变化的“审计日志”</strong>，提供了从镜像基础层到当前状态的完整变更跟踪。</li><li><strong>它是理解容器行为的“显微镜”</strong>，通过文件变更反向推导出容器内发生的操作。</li><li><strong>它是安全和调试的“第一响应者”</strong>，帮助快速定位异常文件变更。</li><li><strong>它的输出简单却信息丰富</strong>，三个字母（A, C, D）清晰地概括了所有变更类型。</li></ul><p>虽然它不像 <code>docker logs</code> 或 <code>docker exec</code> 那样常用，但当你需要深入理解容器内部的文件系统发生了什么时，<code>docker diff</code> 是无可替代的首选工具。掌握它，会让你对容器的运作机制有更深刻的理解。</p><h3><span id="docker-commit">docker commit</span></h3><p>在 Docker 的世界里，我们通常通过编写 Dockerfile 来构建一个可重复、可声明的基础镜像。但有时我们会遇到一种情况：需要在容器内进行一系列复杂的交互式调试和配置，这个过程难以用 Dockerfile 的指令完全描述。此时，<code>docker commit</code> 命令就成了一把“快照刀”，它能够<strong>将容器当前的可写层（变化）冻结下来，并打包成一个全新的镜像</strong>。这是一个强大却需要慎用的功能。</p><hr><p><code>docker commit</code> 命令用于<strong>基于一个容器的当前状态创建一个新的镜像</strong>。</p><p>它会将容器相对于其基础镜像所做的所有更改（包括文件系统的添加、修改和删除，但不包括挂载的卷中的数据）保存下来，形成一个新镜像的只读层。这个新镜像可以像其他任何镜像一样，被用于创建新的容器。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINER</code>：源容器的名称或 ID，其当前状态将被保存。</li><li><code>[REPOSITORY[:TAG]]</code>：（可选）为新镜像指定仓库名和标签。如果省略，新镜像会成为一个没有名字的悬虚镜像（dangling image）。</li></ul><h4><span id="为什么需要它核心价值与争议">为什么需要它？核心价值与争议</span></h4><p><code>docker commit</code> 是一个带有“争议”的命令，因为它违背了“不可变基础设施”和“声明式配置”的最佳实践。但在特定场景下，它无可替代：</p><ol><li><strong>交互式调试与原型设计</strong>：当你需要反复试验才能确定正确的配置、依赖项或设置时，可以在容器内手动操作，成功后一次性提交为镜像。这在快速原型阶段非常有用。</li><li><strong>保存调试现场</strong>：当一个正在运行的容器出现复杂问题，你通过 <code>docker exec</code> 进入容器排查。排查结束后，可以将这个包含现场信息（如日志、临时测试文件）的容器状态保存为镜像，供后续分析或分享给他人复现问题。</li><li><strong>从他人手中“抢救”镜像</strong>：如果有人给了你一个正在运行的容器（但无法提供其 Dockerfile），你可以使用 <code>commit</code> 将其保存为镜像，从而得以继续使用和分发。</li></ol><p><strong>尽管有上述用途，但通常认为：</strong><br><strong><code>docker commit</code> 应仅作为最后的手段或临时工具，而不应作为创建镜像的常规方法。</strong> 优先使用 Dockerfile。</p><h4><span id="核心选项options详解">核心选项（OPTIONS）详解</span></h4><table><thead><tr><th align="left">选项</th><th align="left">全称</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><strong><code>-a</code></strong></td><td align="left"><code>--author</code></td><td align="left">指定新镜像的作者信息。</td><td align="left"><code>-a &quot;John Doe &lt;john@example.com&gt;&quot;</code></td></tr><tr><td align="left"><strong><code>-m</code></strong></td><td align="left"><code>--message</code></td><td align="left">为本次提交添加一条注释信息，类似于 Git commit message。这对于记录这次快照的原因至关重要。</td><td align="left"><code>-m &quot;Added curl and configured proxy&quot;</code></td></tr><tr><td align="left"><strong><code>-c</code></strong></td><td align="left"><code>--change</code></td><td align="left"><strong>非常强大</strong>的选项。允许你在提交时应用一条 Dockerfile 指令。可以多次使用。</td><td align="left"><code>-c &#39;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&#39;</code> <br> <code>-c &#39;ENV MODE=production&#39;</code></td></tr><tr><td align="left"><strong><code>-p</code></strong></td><td align="left"><code>--pause</code></td><td align="left">在提交过程中<strong>暂停</strong>容器。这能确保数据一致性，是默认行为。</td><td align="left"></td></tr></tbody></table><h4><span id="实战示例">实战示例</span></h4><p><strong>1. 基础提交：创建一个无名镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们在一个ubuntu容器中安装了nginx</span></span><br><span class="line">docker <span class="built_in">exec</span> my_container apt update &amp;&amp; apt install -y nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将安装了nginx的容器状态提交为一个新镜像</span></span><br><span class="line">docker commit my_container</span><br></pre></td></tr></table></figure><p>输出会返回一个新镜像的 ID，如 <code>sha256:a1b2c3d4...</code>。这个镜像没有名字（REPOSITORY: TAG 为 <code>&lt;none&gt;:&lt;none&gt;</code>），但可以通过 ID 使用。</p><p><strong>2. 提交并命名镜像（推荐）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交并指定仓库名和标签</span></span><br><span class="line">docker commit my_container my-nginx:version1</span><br></pre></td></tr></table></figure><p><strong>3. 提交并添加元信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交并添加作者信息、提交说明，同时修改启动命令</span></span><br><span class="line">docker commit \</span><br><span class="line">  -a <span class="string">&quot;Your Name &lt;email@example.com&gt;&quot;</span> \</span><br><span class="line">  -m <span class="string">&quot;Installed Nginx and configured custom homepage&quot;</span> \</span><br><span class="line">  -c <span class="string">&#x27;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&#x27;</span> \</span><br><span class="line">  my_container \</span><br><span class="line">  my-custom-app:latest</span><br></pre></td></tr></table></figure><h4><span id="最佳实践与严重警告">最佳实践与严重警告</span></h4><ol><li><p><strong>Dockerfile 优先原则</strong>：<strong>永远不要用 <code>docker commit</code> 来代替 Dockerfile</strong>。通过 <code>commit</code> 生成的镜像被称为“黑盒镜像”，它缺乏透明性、可重复性和可维护性。你无法确切知道镜像中包含了哪些更改，也无法轻松地重建它。</p></li><li><p><strong>数据卷不会被提交</strong>：<code>docker commit</code> <strong>不会</strong>保存通过 <code>-v</code> 挂载的<strong>数据卷（Volumes）</strong> 中的内容。卷的目的是持久化数据，与镜像的生命周期分离。</p></li><li><p><strong>小心提交敏感信息</strong>：如果你在容器内操作时写入了密码、API 密钥等敏感信息，它们会被完整地提交到新镜像中。使用前务必检查，或使用 <code>--change</code> 选项在提交后覆盖环境变量。</p></li><li><p><strong>作为临时工具，而非流程核心</strong>：将 <code>docker commit</code> 视为一个“快速存档”工具。一旦通过交互式方法确定了正确的配置，就应该<strong>将这些步骤翻译成 Dockerfile 指令</strong>，从而构建一个真正可管理的镜像。</p></li><li><p><strong>先审查再提交</strong>：提交前，使用 <code>docker diff &lt;container&gt;</code> 命令检查一下容器内到底发生了哪些变化，避免将临时文件、缓存或日志提交进去。</p></li></ol><h4><span id="docker-commit-的工作流程"><code>docker commit</code> 的工作流程</span></h4><pre class="mermaid">graph LR    A[基础镜像: ubuntu:latest] --> B[运行容器: docker run -it --name my_container ubuntu]    B --> C[在容器内操作: apt install nginx]    C --> D[提交容器: docker commit my_container my-nginx:custom]    D --> E[新镜像: my-nginx:custom]    E --> F[基于新镜像运行容器: docker run my-nginx:custom]</pre><hr><p><code>docker commit</code> 是一把强大的“双刃剑”。</p><ul><li><strong>它是什么</strong>：一个将容器现场保存为镜像的“快照”工具。</li><li><strong>它的价值</strong>：在交互式调试、原型设计和拯救现场等场景中提供了无与伦比的便捷性。</li><li><strong>它的危险</strong>：极易创建出臃肿、不透明、不可重复的“黑盒镜像”，违背基础设施即代码（IaC）的最佳实践。</li><li><strong>最佳实践</strong>：<strong>谨慎使用，仅作为权宜之计</strong>。一旦实验成功，应立即将过程转化为 Dockerfile。使用时务必通过 <code>-m</code> 和 <code>-a</code> 添加注释，并通过 <code>--change</code> 规范化配置。</li></ul><h3><span id="docker-pause-和-docker-unpause">docker pause 和 docker unpause</span></h3><p>在 Docker 的日常运维中，我们熟悉了 <code>start</code>、<code>stop</code> 和 <code>restart</code> 这种“生杀予夺”式的生命周期管理。但有时我们需要一种更细腻的控制——能否在不终止进程的情况下，暂时让一个容器“静默”？Docker 提供的 <code>docker pause</code> 和 <code>docker unpause</code> 命令正是这样一对精巧的“魔法开关”，它们允许我们<strong>冻结和恢复容器内所有进程的执行</strong>，为容器管理提供了前所未有的灵活性。</p><h4><span id="什么是-docker-pause-和-docker-unpause">什么是 <code>docker pause</code> 和 <code>docker unpause</code>？</span></h4><ul><li><strong><code>docker pause</code></strong>：用于<strong>暂停（冻结）</strong> 一个运行中容器内的所有进程。</li><li><strong><code>docker unpause</code></strong>：用于<strong>恢复（解冻）</strong> 一个被暂停的容器，使其进程继续正常运行。</li></ul><p>这对命令的核心价值在于其操作的<strong>即时性和无损性</strong>。它利用 Linux 内核的 <strong>cgroup freezer</strong> 功能来实现，整个过程不涉及进程终止和启动，因此对容器内应用程序来说是完全无感知的。</p><h4><span id="为什么需要它们核心价值与应用场景">为什么需要它们？核心价值与应用场景</span></h4><p>虽然不像 <code>stop</code> 和 <code>start</code> 那样常用，但 <code>pause/unpause</code> 在特定场景下是不可或缺的利器：</p><ol><li><p><strong>故障排查与“抓现场”</strong>：当某个容器占用了极高的 CPU 或磁盘 I&#x2F;O，导致系统不稳定时，直接 <code>stop</code> 它会丢失现场。使用 <code>pause</code> 可以立即“定格”所有进程的状态（包括内存中的数据），方便您用 <code>docker inspect</code> 或其他工具分析问题根源，然后再 <code>unpause</code> 恢复。</p><ul><li>这就像是给正在播放的电影按下了<strong>暂停键</strong>，画面定格，但播放器并未关闭。</li></ul></li><li><p><strong>资源争用管理</strong>：在开发或测试环境中，当主机资源紧张时，可以临时 <code>pause</code> 一些非关键容器（如后台任务处理器、开发环境容器），将 CPU 和内存资源让给更重要的服务（如数据库、主应用）。处理完后，再 <code>unpause</code> 它们，无需重新启动。</p></li><li><p><strong>维护与升级</strong>：在对集群进行维护或滚动升级时，可以先 <code>pause</code> 一个容器，确保它不会处理新的请求，同时保留其完整状态。待维护完成后，再 <code>unpause</code> 它无缝接回服务中。</p></li><li><p><strong>一致性快照的辅助工具</strong>：虽然容器本身不支持热备份，但 <code>pause</code> 容器可以为底层文件系统（如果结合存储驱动）或外部备份工具创建一个短暂的、相对一致的窗口期，因为此时没有进程在写入文件。</p></li></ol><h4><span id="工作原理cgroup-freezer-的魔法">工作原理：cgroup freezer 的魔法</span></h4><p>这对命令的实现依赖于 Linux 内核的一个强大功能：<strong>cgroup freezer</strong>。</p><ol><li><p><strong><code>docker pause CONTAINER</code></strong>：</p><ul><li>Docker Daemon 会向该容器对应的 cgroup 发送一个“冻结”指令。</li><li>内核立即将属于这个 cgroup 的所有进程（即容器内所有进程）标记为 <strong>TASK_STOPPED</strong> 或 <strong>TASK_TRACED</strong> 状态。</li><li>此时，这些进程不再被 CPU 调度执行，它们“在原地被冻住”，但依然完整地保留在内存中，包括它们的堆栈、内存数据和所有打开的文件描述符。</li></ul></li><li><p><strong><code>docker unpause CONTAINER</code></strong>：</p><ul><li>Docker Daemon 向 cgroup 发送“解冻”指令。</li><li>内核将所有被冻结的进程状态恢复为 <strong>TASK_RUNNING</strong>。</li><li>进程立即重新进入调度队列，从刚才被暂停的指令处继续执行，就像什么都没有发生过一样。</li></ul></li></ol><p><strong>整个过程不涉及 SIGTERM 或 SIGKILL 信号</strong>，因此应用程序完全不知道曾经被暂停过。</p><h4><span id="实战示例">实战示例</span></h4><p>假设我们有一个名为 <code>my_app</code> 的容器正在运行一个 Web 服务。</p><ol><li><p><strong>暂停容器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause my_app</span><br></pre></td></tr></table></figure><p>执行后，容器的状态（在 <code>docker ps</code> 中）会从 <code>Up</code> 变为 <strong><code>Up (Paused)</code></strong>。</p></li><li><p><strong>尝试访问服务</strong>：<br>此时，任何尝试连接到该容器服务的请求（如 HTTP 请求）都会<strong>挂起或超时</strong>，因为处理请求的进程已经被冻结，无法响应。</p></li><li><p><strong>检查状态</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE          COMMAND                  STATUS</span><br><span class="line">a1b2c3d4e5f6   nginx:latest   <span class="string">&quot;/docker-entrypoint.…&quot;</span>   Up 5 minutes (Paused)</span><br></pre></td></tr></table></figure></li><li><p><strong>恢复容器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause my_app</span><br></pre></td></tr></table></figure><p>容器状态立刻恢复为 <code>Up</code>，被挂起的请求会得到处理，服务恢复正常。</p></li></ol><h4><span id="最佳实践与重要注意事项">最佳实践与重要注意事项</span></h4><ol><li><p><strong>对网络的影响</strong>：被暂停的容器<strong>网络栈同样被冻结</strong>。它不会响应 ARP 请求、TCP 握手等。对于服务发现和负载均衡器来说，这个容器会表现得像突然宕机一样，可能导致请求失败和连接错误。解冻后，恢复过程取决于应用程序和网络设备的超时设置。</p></li><li><p><strong>无损性并非绝对</strong>：虽然进程状态无损，但<strong>应用程序的业务逻辑可能会受影响</strong>。例如，一个被暂停的数据库容器可能导致依赖它的应用报错；一个被暂停的客户端可能导致心跳超时而被服务器踢下线。因此，要在合适的时机（如没有活跃事务时）使用。</p></li><li><p><strong>不能暂停已停止的容器</strong>：<code>pause</code> 和 <code>unpause</code> 只能作用于状态为 <code>Up</code>（运行中）的容器。无法暂停一个已 <code>Exited</code> 的容器。</p></li><li><p><strong>资源并未释放</strong>：被暂停的容器虽然不再使用 CPU，但它占用的<strong>内存会被完整保留</strong>。这一点与 <code>stop</code> 不同，<code>stop</code> 会释放所有资源。</p></li></ol><hr><p><code>docker pause</code> 和 <code>docker unpause</code> 是 Docker 命令集中一对非常独特且强大的工具。</p><ul><li><strong>它们提供了“暂停”而非“停止”的精细控制</strong>，实现了对容器进程的瞬时冻结与恢复。</li><li><strong>其底层依赖于 Linux cgroup freezer</strong>，保证了操作的无损性和即时性。</li><li><strong>核心应用场景是故障排查和资源调度</strong>，允许你在不丢失现场的情况下解决问题。</li><li><strong>使用时需谨慎评估对业务连续性的影响</strong>，特别是对于有状态和有连接的服务。</li></ul><h3><span id="docker-rm">docker rm</span></h3><p>在 Docker 的日常使用中，我们会创建大量的容器用于测试、开发和学习。这些容器在完成任务后，如果一直保留，会逐渐占用大量的磁盘空间。<code>docker rm</code>（remove 的缩写）就是 Docker 世界的“回收站清理”工具，它的作用非常简单直接：<strong>删除一个或多个已停止的容器</strong>。</p><h4><span id="什么是-docker-rm">什么是 <code>docker rm</code>？</span></h4><p><code>docker rm</code> 命令用于<strong>删除一个或多个已停止的容器</strong>。</p><p>删除容器会一并移除与其关联的可写层（容器层），从而释放磁盘空间。这是一个清理环境、保持系统整洁的核心命令。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>你可以同时删除多个容器，只需将它们的名称或 ID 用空格隔开。</p><h4><span id="如何使用简单示例">如何使用？简单示例</span></h4><p><strong>1. 删除一个已停止的容器：</strong><br>这是最常用的场景。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先停止容器</span></span><br><span class="line">docker stop my_container</span><br><span class="line"><span class="comment"># 然后删除它</span></span><br><span class="line">docker <span class="built_in">rm</span> my_container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用容器ID（取前几位即可）</span></span><br><span class="line">docker <span class="built_in">rm</span> a1b2c3d4</span><br></pre></td></tr></table></figure><p><strong>2. 删除多个已停止的容器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> container_1 container_2 container_3</span><br></pre></td></tr></table></figure><p><strong>3. 强制删除一个运行中的容器（不推荐常规使用）：</strong><br>如果你想强制删除一个还在运行的容器，可以使用 <code>-f</code> 或 <code>--force</code> 选项。但这相当于先执行 <code>docker kill</code>，再执行 <code>docker rm</code>，是一种粗暴的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f my_running_container</span><br></pre></td></tr></table></figure><p><strong>4. 清理所有已停止的容器（实用技巧）：</strong><br>使用命令替换一次性删除所有已停止的容器，这是非常高效的清理方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure><ul><li><code>docker ps -aq</code>：列出所有容器（包括已停止的）的 ID。</li><li><code>docker rm</code>：删除这些 ID 对应的容器。</li></ul><h4><span id="核心注意事项">核心注意事项</span></h4><p>虽然命令简单，但以下几点必须牢记，否则可能导致数据丢失：</p><ol><li><p><strong>数据会永久丢失！</strong>：这是最重要的一点。删除容器会<strong>销毁存储在其容器层中的所有数据</strong>。这包括任何创建或修改的文件、安装的软件等。如果这些数据没有通过 <strong>Docker 数据卷（Volumes）</strong> 或<strong>绑定挂载（Bind Mounts）</strong> 持久化到宿主机上，那么删除后数据将无法恢复。</p></li><li><p><strong>无法删除运行中的容器</strong>：默认情况下，Docker 会保护运行中的容器不被意外删除。如果你尝试删除一个 <code>Up</code> 状态的容器，会收到一个错误提示。你必须先 <code>docker stop</code> 它，或者使用 <code>-f</code> 选项强制删除。</p></li><li><p><strong>谨慎使用 <code>-f</code> (force) 选项</strong>：<code>docker rm -f</code> 虽然方便，但应避免成为习惯。它不会给容器内进程 gracefully shutdown 的机会，可能会中断正在进行的操作（如数据库写入），导致数据损坏。<strong>最佳实践永远是先停止，再删除。</strong></p></li><li><p><strong>卷不会被自动删除</strong>：<code>docker rm</code> <strong>不会删除</strong>与容器关联的<strong>匿名卷</strong>。这是 Docker 的一种保护机制，防止你意外删除重要的持久化数据。如果你确认某个匿名卷也不再需要，必须使用 <code>docker volume rm</code> 手动删除它。</p></li></ol><hr><p><code>docker rm</code> 是一个简单但至关重要的容器生命周期管理命令。</p><ul><li><strong>它的核心职责是清理已停止的容器，释放磁盘空间。</strong></li><li><strong>操作前务必确认</strong>容器内的数据已通过卷正确持久化，否则会造成<strong>永久性数据丢失</strong>。</li><li><strong>养成先停后删的好习惯</strong>，谨慎使用 <code>-f</code> 选项。</li><li><strong>结合 <code>docker ps -aq</code> 可以高效地进行批量清理</strong>，保持开发环境的整洁。</li></ul><p>把它当作一个需要谨慎使用的回收站——在按下回车键前，永远记得确认里面的东西是否真的不再需要了。</p><h3><span id="docker-export-和-docker-import">docker export 和 docker import</span></h3><p>在 Docker 的镜像和容器管理中，我们通常使用 <code>docker commit</code> 来创建新镜像，使用仓库来分发镜像。但有时我们需要一种更底层、更直接的方式来迁移或备份一个容器的<strong>纯粹的文件系统</strong>，而不关心其历史、层状结构或元数据。这时，<code>docker export</code> 和 <code>docker import</code> 这一对命令就派上了用场。它们像是为容器文件系统制作了一个“快照”并将其“还原”为一个扁平化的镜像。</p><hr><p>这是一对用于<strong>将容器的文件系统导出为一个压缩包，再将该压缩包导入成为一个新镜像</strong>的命令。</p><ul><li><strong><code>docker export</code></strong>：将一个<strong>容器的文件系统</strong>导出为一个 tar 归档文件（压缩包）。这个包只包含容器当时的文件系统快照，不包含任何镜像历史、层信息或元数据（如 <code>CMD</code>, <code>ENV</code> 等）。</li><li><strong><code>docker import</code></strong>：将一个由 <code>docker export</code> 或其他方式生成的 tar 归档文件，导入并<strong>创建一个新的 Docker 镜像</strong>。这个新镜像只有一层（扁平化），并且会丢失所有原始的历史和大部分元数据。</li></ul><p><strong>简单比喻：</strong></p><ul><li><strong><code>docker export</code></strong>：就像把一台电脑的整个硬盘<strong>克隆</strong>并打包成一个巨大的 <code>.gho</code> 文件。</li><li><strong><code>docker import</code></strong>：就像是把那个 <code>.gho</code> 文件<strong>恢复到一块新硬盘</strong>上。你得到了一个完全一样的系统，但丢失了原来的分区信息、安装日志等。</li></ul><h4><span id="为什么需要它们核心价值与应用场景">为什么需要它们？核心价值与应用场景</span></h4><p>这对命令的使用场景相对特殊，但在以下情况下非常有用：</p><ol><li><strong>跨环境迁移容器状态</strong>：将一个在本地开发环境中配置好的复杂容器（安装了大量依赖和软件），完整地迁移到另一台无法直接连接 Docker 仓库的生产机器上。你可以导出 tar 包， physically（物理地）复制过去，再导入。</li><li><strong>制作极简的基础镜像</strong>：从一个大而全的发行版（如 Ubuntu）容器开始，精心配置和瘦身后，导出其文件系统，再导入为一个新的镜像。这个新镜像不包含任何中间层，可能比通过 Dockerfile 构建的镜像体积更小。</li><li><strong>备份与恢复</strong>：作为一种<strong>容器级别的备份手段</strong>。虽然不推荐作为数据库等有状态服务的主要备份方式（因为无法保证导出时数据一致性），但可以用于备份静态文件或整个环境。</li><li><strong>与非 Docker 系统交换文件系统</strong>：导出的 tar 包是一个标准的文件系统归档，可以被 <code>chroot</code>、虚拟机器或其他容器运行时使用，实现了某种程度的“互通”。</li></ol><h4><span id="实战示例">实战示例</span></h4><p><strong>第 1 步：导出（Export）一个容器</strong><br>假设我们有一个名为 <code>my_configured_container</code> 的容器，里面装好了我们需要的所有软件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器的文件系统导出为 tar.gz 压缩包</span></span><br><span class="line">docker <span class="built_in">export</span> my_configured_container &gt; my_container_backup.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 -o (--output) 选项</span></span><br><span class="line">docker <span class="built_in">export</span> -o my_container_backup.tar my_configured_container</span><br></pre></td></tr></table></figure><p>现在，你得到了一个 <code>my_container_backup.tar.gz</code> 文件，它包含了容器某时刻的完整文件系统快照。</p><p><strong>第 2 步：导入（Import）为一个新镜像</strong><br>将这个 tar 包拿到另一台机器上，或者在本机将其导入为一个全新的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 tar 包导入，并为新镜像指定仓库名和标签</span></span><br><span class="line"><span class="built_in">cat</span> my_container_backup.tar.gz | docker import - my_custom_image:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者从文件直接导入</span></span><br><span class="line">docker import my_container_backup.tar.gz my_custom_image:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以在导入时添加提交信息</span></span><br><span class="line">docker import --message <span class="string">&quot;Imported from backup on <span class="subst">$(date)</span>&quot;</span> my_container_backup.tar.gz my_custom_image:latest</span><br></pre></td></tr></table></figure><p>导入成功后，你就可以像使用其他镜像一样，使用 <code>my_custom_image:latest</code> 来运行新的容器了。</p><h4><span id="核心注意事项与局限性非常重要">核心注意事项与局限性（非常重要！）</span></h4><ol><li><p><strong>只导出文件系统，不导出元数据</strong>：这是最大的限制。<code>export</code> <strong>不会</strong>包含：</p><ul><li>镜像的构建历史（<code> layers</code>）。</li><li>原始的 <code>CMD</code>、<code>ENTRYPOINT</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>WORKDIR</code> 等<strong>元数据配置</strong>。</li><li>容器的运行状态、内存中的数据。</li><li>使用 <code>-v</code> 挂载的<strong>数据卷</strong>中的内容。</li></ul></li><li><p><strong>数据一致性问题</strong>：<code>export</code> 命令<strong>不会暂停容器</strong>。如果在你导出的瞬间，容器内的进程正在写入文件，可能会导致导出的归档文件出现<strong>数据不一致</strong>或<strong>文件损坏</strong>。对于数据库等活跃容器，这是一个高风险操作。</p></li><li><p><strong>扁平化与历史丢失</strong>：通过 <code>import</code> 创建的镜像<strong>只有一层</strong>。你丢失了所有层缓存的优势，也无法查看镜像的构建历史。这使得新镜像的构建和存储效率可能更低。</p></li><li><p><strong>需要手动指定运行时配置</strong>：由于元数据丢失，基于新镜像运行容器时，你很可能需要<strong>手动指定所有配置</strong>，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> \</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  -e <span class="string">&quot;MY_VAR=value&quot;</span> \</span><br><span class="line">  my_custom_image:latest \</span><br><span class="line">  /bin/bash -c <span class="string">&quot;/usr/sbin/nginx&quot;</span> <span class="comment"># 必须手动指定启动命令！</span></span><br></pre></td></tr></table></figure></li></ol><h4><span id="与-docker-save-x2f-docker-load-的区别">与 <code>docker save</code> &#x2F; <code>docker load</code> 的区别</span></h4><p>这是一个非常常见的困惑点：</p><table><thead><tr><th align="left">特性</th><th align="left"><code>export / import</code></th><th align="left"><code>save / load</code></th></tr></thead><tbody><tr><td align="left"><strong>操作对象</strong></td><td align="left"><strong>容器</strong> -&gt; tar -&gt; <strong>镜像</strong></td><td align="left"><strong>镜像</strong> -&gt; tar -&gt; <strong>镜像</strong></td></tr><tr><td align="left"><strong>内容</strong></td><td align="left">仅容器的<strong>文件系统</strong>快照</td><td align="left"><strong>完整的镜像</strong>（包括所有层、历史、元数据）</td></tr><tr><td align="left"><strong>元数据</strong></td><td align="left"><strong>不保留</strong>（<code>CMD</code>, <code>ENV</code> 等丢失）</td><td align="left"><strong>完整保留</strong></td></tr><tr><td align="left"><strong>层级</strong></td><td align="left">合并为<strong>单层</strong>（扁平化）</td><td align="left">保留所有<strong>多层结构</strong></td></tr><tr><td align="left"><strong>主要用途</strong></td><td align="left">迁移或备份<strong>容器的当前状态</strong></td><td align="left">迁移或备份<strong>完整的镜像</strong></td></tr></tbody></table><p><strong>简单总结：用 <code>save/load</code> 来完整地“复制-粘贴”镜像；用 <code>export/import</code> 来“克隆”一个容器的硬盘。</strong></p><hr><p><code>docker export</code> 和 <code>docker import</code> 是一对强大但略显“粗暴”的工具。</p><ul><li><strong>它们提供了容器文件系统级别的快速快照和迁移能力</strong>，绕过了镜像层的概念。</li><li><strong>其核心代价是元数据的丢失</strong>，导致新镜像需要手动配置才能正常运行。</li><li><strong>主要适用于特殊场景</strong>，如环境迁移、制作特定基础镜像或与外部系统交互。</li><li><strong>对于大多数日常需要备份和迁移镜像的场景，应优先使用 <code>docker save</code> 和 <code>docker load</code></strong>。</li></ul><h3><span id="docker-wait">docker wait</span></h3><p>在 Docker 的自动化脚本和 CI&#x2F;CD 流水线中，我们经常需要启动一个容器执行任务，并等待这个任务完成后再进行下一步操作。容器任务完成的标准就是<strong>容器退出</strong>。那么，如何让脚本自动等待容器退出并获取其结果呢？这就是 <code>docker wait</code> 命令的用武之地。它是一个简单、专注且对自动化极其有用的工具。</p><hr><p><code>docker wait</code> 命令用于<strong>阻塞（等待）一个或多个容器退出，然后打印它们的退出代码</strong>。</p><p>它的行为非常纯粹：调用这个命令后，Shell 会在此处等待，直到指定的容器停止运行。一旦容器退出，<code>docker wait</code> 会立即返回该容器的退出状态码（Exit Code），然后脚本才可以继续执行。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">wait</span> CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>你可以同时等待多个容器退出，命令会阻塞直到所有指定容器都退出，并分别返回它们的退出码。</p><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><p><code>docker wait</code> 的核心价值在于<strong>自动化脚本和任务编排</strong>。</p><ol><li><strong>同步任务执行</strong>：在 Shell 脚本中，你需要确保一个容器（可能是一个数据库迁移脚本、一个批处理任务）完全执行成功后，再启动下一个依赖它的容器。<code>docker wait</code> 提供了这种同步能力。</li><li><strong>获取执行结果</strong>：容器内进程的退出状态码（0 通常表示成功，非 0 表示失败）是判断任务是否成功的标准依据。<code>docker wait</code> 是获取这个状态码最直接的方式之一。</li><li><strong>非交互式操作</strong>：它不需要像 <code>docker logs</code> 那样持续输出信息，也不会像 <code>docker attach</code> 那样占用标准输入。它只是安静地等待，非常适合在后台脚本中使用。</li></ol><h4><span id="实战示例">实战示例</span></h4><p><strong>场景：</strong> 你有一个名为 <code>batch_job</code> 的容器，它运行着一个数据处理任务。你需要在脚本中启动它，并等待任务完成，根据成功与否决定后续步骤。</p><p><strong>示例脚本：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 启动一个执行后台任务的容器，并将其放入后台运行</span></span><br><span class="line">docker run --name batch_job my_data_processor:latest &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用 docker wait 等待这个容器执行完毕。</span></span><br><span class="line"><span class="comment">#    脚本会在此处阻塞，直到 batch_job 容器退出。</span></span><br><span class="line">EXIT_CODE=$(docker <span class="built_in">wait</span> batch_job)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 根据退出代码判断任务是否成功</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$EXIT_CODE</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;✅ 任务执行成功！&quot;</span></span><br><span class="line">    <span class="comment"># 执行成功后的后续操作，例如通知、启动下一个服务等</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;❌ 任务执行失败，退出代码：<span class="variable">$EXIT_CODE</span>&quot;</span></span><br><span class="line">    <span class="comment"># 执行失败后的处理，例如错误处理、日志收集、报警等</span></span><br><span class="line">    docker logs batch_job <span class="comment"># 可以立刻获取日志来排查错误</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 清理容器</span></span><br><span class="line">docker <span class="built_in">rm</span> batch_job</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;脚本继续执行...&quot;</span></span><br></pre></td></tr></table></figure><p><strong>等待多个容器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时启动多个任务容器</span></span><br><span class="line">docker run --name worker_1 my_worker &amp;</span><br><span class="line">docker run --name worker_2 my_worker &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有worker容器退出</span></span><br><span class="line">EXIT_CODE_1=$(docker <span class="built_in">wait</span> worker_1)</span><br><span class="line">EXIT_CODE_2=$(docker <span class="built_in">wait</span> worker_2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Worker 1 退出代码: <span class="variable">$EXIT_CODE_1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Worker 2 退出代码: <span class="variable">$EXIT_CODE_2</span>&quot;</span></span><br></pre></td></tr></table></figure><h4><span id="核心注意事项">核心注意事项</span></h4><ol><li><strong>它只等待已存在的容器</strong>：<code>docker wait</code> 只能作用于已经创建的容器（无论状态是运行中还是已停止）。如果指定的容器不存在，命令会报错。</li><li><strong>阻塞特性</strong>：命令会阻塞当前 Shell 或脚本的进程。这意味着在等待期间，你的脚本什么都做不了。请确保这是在预期内的行为。</li><li><strong>与 <code>docker run</code> 的分离模式（<code>-d</code>）是绝配</strong>：最经典的用法就是使用 <code>docker run -d</code> 在后台启动容器，然后立即使用 <code>docker wait</code> 等待它的结果。这样既能实现后台启动，又能同步等待。</li><li><strong>退出代码是关键</strong>：<code>docker wait</code> 的核心输出就是退出代码。容器内的主进程必须正确地返回退出代码（例如，在脚本中使用 <code>exit 0</code> 或 <code>exit 1</code>），这个机制才有意义。</li><li><strong>它不输出日志</strong>：<code>docker wait</code> 非常“安静”，它不会像 <code>docker logs -f</code> 那样向你实时展示容器的输出。你通常需要在其之后配合 <code>docker logs</code> 来获取详细日志。</li></ol><hr><p><code>docker wait</code> 是一个“人狠话不多”的实用命令。</p><ul><li><strong>它的功能极其专注</strong>：安静地等待容器退出并返回结果码。</li><li><strong>它是自动化脚本的“粘合剂”</strong>：实现了容器任务的同步执行，是 CI&#x2F;CD 流水线和运维脚本中的无名英雄。</li><li><strong>使用时需注意其阻塞特性</strong>，并确保与 <code>docker run -d</code> 配合使用以达到最佳效果。</li><li><strong>它的价值体现在退出代码上</strong>，因此要求容器内的应用程序有良好的退出状态管理。</li></ul><h3><span id="docker-rename">docker rename</span></h3><p><code>docker rename</code> 命令用于<strong>修改一个容器的名称</strong>。</p><hr><p>容器创建时，我们会通过 <code>--name</code> 为其指定一个名称。但之后可能发现名称不合适、有拼写错误，或者想遵循新的命名规范。<code>docker rename</code> 就是为了解决这个问题，它允许你在容器创建后<strong>重新命名</strong>，而无需删除和重新创建容器。</p><h4><span id="基本语法">基本语法</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename OLD_NAME NEW_NAME</span><br></pre></td></tr></table></figure><h4><span id="实战示例">实战示例</span></h4><ol><li><p><strong>纠正拼写错误</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不小心把名字打错了</span></span><br><span class="line">docker run -d --name ngixn nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 rename 修正它</span></span><br><span class="line">docker rename ngixn nginx</span><br></pre></td></tr></table></figure></li><li><p><strong>根据新的命名规范重命名</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 旧名称：web</span></span><br><span class="line"><span class="comment"># 新名称：希望加上项目前缀 prod-frontend-web</span></span><br><span class="line">docker rename web prod-frontend-web</span><br></pre></td></tr></table></figure></li><li><p><strong>为匿名容器命名</strong>：<br>如果最初运行容器时忘了使用 <code>--name</code> 参数，Docker 会随机分配一个名字（如 <code>dreamy_curie</code>）。你可以给它一个更有意义的名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename dreamy_curie my-app</span><br></pre></td></tr></table></figure></li></ol><h4><span id="核心注意事项">核心注意事项</span></h4><ul><li><strong>新旧名称不能重复</strong>：新的容器名称必须在当前 Docker 环境中是唯一的，不能与其他任何容器或镜像重名。</li><li><strong>容器状态不限</strong>：此命令对容器的状态没有要求，无论是<strong>运行中（Up）</strong>、<strong>已停止（Exited）</strong> 还是<strong>已暂停（Paused）</strong>，都可以成功重命名。</li><li><strong>即时生效</strong>：重命名操作是立即生效的。之后所有 Docker 命令（<code>docker start</code>, <code>docker stop</code>, <code>docker logs</code>等）都需要使用新的名称来操作这个容器。</li></ul><hr><p><code>docker rename</code> 是一个简单到极致的命令，它就做一件事：<strong>给容器改个名</strong>。它是一个非常方便的管理工具，让你能轻松地维护容器的标识符，保持环境的整洁和规范。</p><h3><span id="docker-container-prune">docker container prune</span></h3><p><code>docker container prune</code> 是一个高效的清理命令，它的功能非常简单粗暴：<strong>一键删除所有已停止的容器</strong>。</p><hr><p>执行这个命令后，Docker 会找出所有处于 <code>exited</code> 状态的容器，并将其全部删除，释放磁盘空间。</p><p><strong>基本用法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接执行会要求确认</span></span><br><span class="line">docker container prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过确认提示，直接删除</span></span><br><span class="line">docker container prune -f</span><br></pre></td></tr></table></figure><h4><span id="为什么需要它">为什么需要它？</span></h4><p>在开发和测试过程中，我们会频繁地创建和停止大量临时容器。手动一个个删除 (<code>docker rm</code>) 非常繁琐。这个命令极大地简化了清理工作，让环境保持整洁。</p><h4><span id="️-核心注意事项重中之重">⚠️ 核心注意事项（重中之重）</span></h4><p>这个命令的便利性背后藏着巨大的数据风险，请务必牢记以下几点：</p><ol><li><p><strong>数据会永久丢失！</strong><br>这是最重要的一点。删除容器会<strong>同时删除其产生的所有数据</strong>。如果这些数据没有通过 <strong>Docker 数据卷（Volumes）</strong> 或<strong>绑定挂载（Bind Mounts）</strong> 持久化到宿主机上，那么删除后数据将<strong>无法恢复</strong>。</p></li><li><p><strong>它不问青红皂白</strong><br>命令会删除<strong>所有</strong>已停止的容器。它不会区分哪个容器是重要的，哪个是临时的。你可能一不小心就删除了一个包含重要配置或日志的已停止容器。</p></li><li><p><strong>谨慎使用 <code>-f</code> (force) 选项</strong><br><code>-f</code> 选项让你跳过最后的确认提示。虽然方便，但这也移除了最后一道安全屏障。<strong>强烈建议不要将 <code>docker container prune -f</code> 放入自动化脚本或设为定时任务</strong>，除非你完全确信所有已停止容器都毫无价值。</p></li><li><p><strong>它不删除关联的匿名卷</strong><br>这是唯一的安全措施。<code>prune</code> <strong>不会自动删除</strong>与这些容器关联的匿名卷。如果你确认这些卷也不再需要，必须使用 <code>docker volume prune</code> 进行二次清理。</p></li></ol><h4><span id="安全使用准则">安全使用准则</span></h4><ul><li><strong>清理前，请务必使用 <code>docker ps -a</code> 清单所有已停止的容器</strong>，确认其中没有包含重要数据的容器。</li><li><strong>对于重要容器，养成使用具名卷或绑定挂载的习惯</strong>，这是避免数据丢失的根本方法。</li><li>可以先使用 <code>docker rm $(docker ps -aq)</code> 手动选择要删除的容器，控制力更强。</li></ul><hr><p><code>docker container prune</code> 是一把锋利的“双刃剑”。</p><ul><li><strong>它是什么</strong>：一个一键清理所有已停止容器的便捷工具。</li><li><strong>它的价值</strong>：快速释放资源，保持环境整洁。</li><li><strong>最大的风险</strong>：<strong>永久性数据丢失</strong>。</li><li><strong>最佳实践</strong>：<strong>谨慎使用</strong>。每次执行前，请务必确认即将被删除的容器列表，确保没有你需要保留的任何数据。</li></ul><h3><span id="docker-update">docker update</span></h3><p>在容器化应用的日常运维中，我们经常会遇到这样的场景：一个正在运行的容器突然需要更多内存来处理高峰流量，或者某个容器占用了过多 CPU 资源需要被限制。如果不想停止和重启服务，该怎么办？Docker 提供的 <code>docker update</code> 命令正是为了解决这个问题，它允许我们<strong>动态地修改一个或多个运行中容器的配置</strong>，是实现弹性伸缩和资源优化的关键工具。</p><hr><p><code>docker update</code> 命令用于<strong>动态更新一个或多个运行中容器的配置</strong>。</p><p>其核心功能是调整容器的资源限制（如 CPU、内存）和部分运行时参数，而无需停止和重新启动容器。这实现了对应用服务的“在线热调整”，对于保证服务的连续性和可用性至关重要。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><h4><span id="为什么需要它核心价值">为什么需要它？核心价值</span></h4><ol><li><strong>应用弹性伸缩</strong>：应对流量波动，在业务高峰时临时为容器增加 CPU 或内存配额，高峰过后再降低，从而高效利用资源。</li><li><strong>故障排查与资源限制</strong>：当某个容器因 bug 导致资源耗尽（如内存泄漏），可以立即降低其资源上限，防止它拖垮整个宿主系统，为排查问题争取时间。</li><li><strong>避免服务中断</strong>：对于有状态服务（如数据库）或难以重启的服务，<code>docker update</code> 提供了无需停服即可调整资源配置的能力，最大程度保证业务连续性。</li><li><strong>成本优化</strong>：根据监控数据，将过度分配的容器资源下调到合理水平，节省云计算成本。</li></ol><h4><span id="核心选项options详解">核心选项（OPTIONS）详解</span></h4><p><code>docker update</code> 的强大之处在于其丰富的选项，主要用于调整资源限制：</p><p><strong>1. CPU 资源调整：</strong></p><ul><li><strong><code>-c, --cpu-shares int</code></strong>：调整 CPU 份额（相对权重）。默认是 1024。提高或降低这个值可以增加或减少容器在 CPU 竞争时的优先级。</li><li><strong><code>--cpus decimal</code></strong>：<strong>最常用</strong>。限制容器可以使用的 CPU 核心数。例如，<code>--cpus 1.5</code> 表示限制容器最多使用 1.5 个 CPU 核心的计算能力。</li><li><strong><code>--cpuset-cpus string</code></strong>：限制容器只能运行在哪些特定的 CPU 核心上。例如，<code>--cpuset-cpus &quot;0-2&quot;</code> 表示只使用前三个核心。</li></ul><p><strong>2. 内存资源调整：</strong></p><ul><li><strong><code>-m, --memory bytes</code></strong>：<strong>最常用</strong>。限制容器能使用的最大内存。例如，<code>-m 512m</code> 或 <code>-m 2g</code>。</li><li><strong><code>--memory-swap bytes</code></strong>：限制容器能使用的内存+交换分区（Swap）的总大小。必须与 <code>-m</code> 参数一起使用。</li></ul><p><strong>3. 重启策略调整：</strong></p><ul><li><strong><code>--restart string</code></strong>：修改容器的重启策略（如 <code>no</code>, <code>on-failure</code>, <code>always</code>, <code>unless-stopped</code>）。这在容器持续崩溃需要修改恢复策略时非常有用。</li></ul><h4><span id="实战示例">实战示例</span></h4><p><strong>场景 1：应对流量高峰，临时增加资源</strong><br>一个 Web 容器在促销期间需要更多计算能力。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器 my_web 的 CPU 限制提升到 2 个核心，内存限制提升到 2GB</span></span><br><span class="line">docker update --cpus 2 -m 2g my_web</span><br></pre></td></tr></table></figure><p><strong>场景 2：限制失控的容器</strong><br>监控发现一个容器内存泄漏，占用了过多资源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 立即将容器的内存上限硬限制为 512MB，防止它耗尽主机内存</span></span><br><span class="line">docker update -m 512m my_buggy_container</span><br></pre></td></tr></table></figure><p><strong>场景 3：批量调整多个容器</strong><br>为整个应用栈的所有容器降低资源配额。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时更新 nginx, web_app, cache 三个容器的 CPU 份额</span></span><br><span class="line">docker update --cpus 0.5 nginx web_app cache</span><br></pre></td></tr></table></figure><h4><span id="最佳实践与重要注意事项">最佳实践与重要注意事项</span></h4><ol><li><p><strong>主要针对运行中的容器</strong>：虽然也可用于已停止的容器，但其主要价值体现在<strong>不中断运行中服务</strong>的动态调整上。</p></li><li><p><strong>资源限制的生效方式</strong>：</p><ul><li><strong>调低限制（如减少内存）</strong>：<strong>立即生效</strong>。如果容器当前使用量已超过新限制，操作系统内核会强制其释放内存，可能会触发容器内的 OOM（内存不足）机制。</li><li><strong>调高限制（如增加 CPU）</strong>：<strong>立即生效</strong>。容器可以立即开始使用新分配的资源。</li></ul></li><li><p><strong>理解“硬限制”与“软限制”</strong>：<code>-m</code> 设置的是硬性上限，容器进程绝对不能超过此值。而 <code>--cpu-shares</code> 是软性权重，只在 CPU 资源发生竞争时起作用。</p></li><li><p><strong>无法更新所有配置</strong>：<code>docker update</code> <strong>不能</strong>修改与容器架构相关的核心配置，例如：</p><ul><li>网络模式（<code>--network</code>）</li><li>端口映射（<code>-p</code>）</li><li>卷挂载（<code>-v</code>）</li><li>环境变量（<code>-e</code>）</li><li>这些修改必须通过<code>docker commit</code>创建新镜像或重建容器来实现。</li></ul></li><li><p><strong>监控调整结果</strong>：更新后，使用 <code>docker stats</code> 命令观察容器的实际资源使用情况，确认调整是否达到预期效果。</p></li></ol><hr><p><code>docker update</code> 是 Docker 运维中实现<strong>精细化资源管理</strong>和<strong>快速故障响应</strong>的利器。</p><ul><li><strong>它是什么</strong>：一个可以动态调整运行中容器资源限制的命令。</li><li><strong>它的核心价值</strong>：<strong>无需重启服务</strong>即可实现资源的弹性伸缩和故障隔离，极大保障了业务的可用性。</li><li><strong>它的主要能力</strong>：调整 CPU、内存限制和重启策略。</li><li><strong>它的局限性</strong>：无法修改网络、存储等核心配置。</li><li><strong>最佳实践</strong>：与监控系统结合，根据 metrics 指标动态调整资源配置，是实现容器化环境高效、稳定运行的高级技巧</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端工具 </category>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Image（镜像）使用指南</title>
      <link href="/2025/08/30/Docker/docker_image/"/>
      <url>/2025/08/30/Docker/docker_image/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#docker-image-%E4%BB%8B%E7%BB%8D">Docker Image 介绍</a></li><li><a href="#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E6%88%90%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB">镜像的组成：分层存储体系</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B1%82">什么是分层？</a></li><li><a href="#%E5%88%86%E5%B1%82%E7%9A%84%E5%A5%BD%E5%A4%84">分层的好处</a></li></ul></li><li><a href="#%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E5%BB%BAdockerfile-%E4%B8%8E-docker-build">镜像的构建：Dockerfile 与 <code>docker build</code></a></li><li><a href="#%E9%95%9C%E5%83%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E5%88%86%E5%8F%91registry">镜像的存储与分发：Registry</a></li><li><a href="#%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%E9%95%9C%E5%83%8F%E7%9A%84%E5%86%85%E5%AE%B9">深入底层：镜像的内容</a></li><li><a href="#%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7">优化技巧</a></li><li><a href="#docker-image-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">Docker Image 常用指令</a><ul><li><a href="#docker-images">docker images</a></li><li><a href="#docker-tag">docker tag</a></li><li><a href="#docker-pull">docker pull</a></li><li><a href="#docker-push">docker push</a></li><li><a href="#docker-rmi">docker rmi</a></li><li><a href="#docker-save-docker-load">docker save、docker load</a></li><li><a href="#docker-image-inspect">docker image inspect</a></li><li><a href="#docker-history">docker history</a></li><li><a href="#docker-image-prune">docker image prune</a></li></ul></li><li><a href="#docker-image-%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5">Docker Image 综合实践</a><ul><li><a href="#%E7%A6%BB%E7%BA%BF%E8%BF%81%E7%A7%BB%E9%95%9C%E5%83%8F">离线迁移镜像</a></li><li><a href="#%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%85%B1%E4%BA%AB">镜像存储的压缩与共享</a></li></ul></li></ul><!-- tocstop --><h2><span id="docker-image-介绍">Docker Image 介绍</span></h2><p>一个 Docker 镜像是一个<strong>只读的模板</strong>，它包含了创建 Docker 容器所需的所有指令和文件系统内容。</p><p>我们可以通过以下方式来理解它：</p><ul><li><strong>面向对象编程类比</strong>：镜像就像是<strong>类</strong>，而容器就是这个类<strong>实例化出来的对象</strong>。一个类可以创建多个对象，同样，一个镜像可以运行出多个容器。</li><li><strong>操作系统安装盘类比</strong>：镜像就像是 <code>.iso</code> 光盘镜像文件，而容器就是使用这个光盘安装好并正在运行的<strong>操作系统</strong>。光盘是静态的、只读的，而安装好的系统是可运行的、可写的。</li></ul><p>需要注意的是，不要将这些比喻中的“类”和“操作系统”的创建方式与 <code>Docker</code> 镜像和容器的创建方式混淆，他们的实现机制是完全不同的。</p><p><code>Docker Image</code> 具有以下特性：</p><ul><li><strong>只读</strong>：镜像一旦创建，其内容就不会改变。</li><li><strong>分层存储</strong>：镜像由一系列<strong>只读层</strong>组成，这是 Docker 的核心技术之一。</li><li><strong>内容寻址</strong>：现代 Docker 使用内容哈希（SHA256）来唯一标识镜像和其每一层，确保内容的一致性，为什么需要使用哈希，这就涉及到了 <code>Dockerfile</code> 的构建过程以及底层的存储机制，后续文章会详细讲解，这里主要是了解 <code>Docker Image</code>。</li></ul><hr><h2><span id="镜像的组成分层存储体系">镜像的组成：分层存储体系</span></h2><p>这是理解镜像最关键、最精髓的部分。</p><h3><span id="什么是分层">什么是分层？</span></h3><p>Docker 镜像并非一个巨大的单体文件，而是由一系列<strong>层</strong>堆叠而成的。每一层代表了 Dockerfile 中的一条指令。</p><p><strong>举个例子，一个简单的 Dockerfile：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>         <span class="comment"># 层 1： 拉取基础镜像层</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app               <span class="comment"># 层 2： 添加当前目录文件到镜像的 /app 目录</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make /app             <span class="comment"># 层 3： 使用 make 构建应用</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> python /app/app.py    <span class="comment"># 层 4： 设置容器启动时的默认命令</span></span></span><br></pre></td></tr></table></figure><p>这个 Dockerfile 构建的镜像至少包含 4 层（实际上基础镜像 <code>ubuntu:20.04</code> 本身也是由多层组成的）。</p><h3><span id="分层的好处">分层的好处</span></h3><ol><li><p><strong>共享和复用</strong>：</p><ul><li>如果两个不同的镜像都基于 <code>ubuntu:20.04</code>，那么你的主机上只需要存储一份 <code>ubuntu:20.04</code> 的层。这极大地节省了磁盘空间和网络传输带宽。</li><li>当你构建新镜像时，如果某一层（例如 <code>RUN apt-get update</code>）没有变化，Docker 会直接使用<strong>本地缓存</strong>的现有层，使得构建过程非常迅速。</li></ul></li><li><p><strong>减少磁盘占用</strong>：</p><ul><li>容器在运行时，会在镜像的所有只读层之上，添加一个<strong>可写的容器层</strong>。所有对运行中容器的文件修改（如创建、删除、更改文件）都发生在这个薄薄的可写层中。这消除了对底层只读层的复制，使得容器启动极其轻量和快速。</li></ul></li><li><p><strong>高效分发</strong>：</p><ul><li>当你 <code>docker push</code> 或 <code>docker pull</code> 一个镜像时，Docker 引擎只会传输你本地没有的层。如果你更新了应用代码（只修改了 <code>COPY</code> 这一层），你只需要重新推送或拉取变化的那一层，而不是整个镜像。</li></ul></li></ol><hr><h2><span id="镜像的构建dockerfile-与-docker-build">镜像的构建：Dockerfile 与 <code>docker build</code></span></h2><p>镜像通常通过一个名为 <code>Dockerfile</code> 的文本文件来定义，并使用 <code>docker build</code> 命令构建在，这里只做一个简单的了解，大致看看即可，后续会详细讲解。</p><p><strong>Dockerfile 主要指令：</strong></p><ul><li><code>FROM</code>： 指定基础镜像，所有镜像的起点。</li><li><code>RUN</code>： 在镜像层中执行命令（如安装软件包）。</li><li><code>COPY</code> &amp; <code>ADD</code>： 将文件从构建上下文复制到镜像中。</li><li><code>CMD</code> &amp; <code>ENTRYPOINT</code>： 指定容器启动时运行的命令。</li><li><code>EXPOSE</code>： 声明容器运行时监听的端口。</li><li><code>ENV</code>： 设置环境变量。</li><li><code>WORKDIR</code>： 设置后续指令的工作目录。</li></ul><p><strong>构建过程：</strong><br>当我们运行 <code>docker build -t my-app:latest .</code> 时：</p><ol><li>Docker 客户端将<strong>构建上下文</strong>（通常是 <code>.</code> 指定的当前目录）发送给 Docker 守护进程。</li><li>守护进程逐条执行 Dockerfile 中的指令。</li><li>每执行一条指令，就会创建一个新的镜像层（如果该指令修改了文件系统）。</li><li>所有指令执行完毕后，最终生成一个标记为 <code>my-app:latest</code> 的镜像。</li></ol><hr><h2><span id="镜像的存储与分发registry">镜像的存储与分发：Registry</span></h2><p>镜像需要被存储和共享，这通过 Registry 实现。</p><ul><li><strong>Docker Hub</strong>： 默认的公共 Registry，就像 GitHub 对于代码一样。你可以从中拉取官方镜像（如 <code>nginx</code>, <code>python</code>）和社区镜像。</li><li><strong>其他公共 Registry</strong>： Harbor、Google Container Registry、Amazon ECR、Azure Container Registry 等。</li><li><strong>私有 Registry</strong>： 你可以搭建自己的私有 Registry（使用 Docker 官方提供的 <code>registry</code> 镜像或其他企业级方案如 Harbor），用于存储公司内部的私有镜像。</li></ul><p><strong>镜像名称结构：</strong> <code>[registry-url]/[username]/[repository]:[tag]</code></p><ul><li><code>registry-url</code>： 默认为 <code>docker.io</code>（Docker Hub）。</li><li><code>username</code>： 在 Docker Hub 或其他 Registry 上的用户名或组织名。</li><li><code>repository</code>： 镜像仓库名，通常代表一个项目或应用。</li><li><code>tag</code>： 标签，用于区分同一镜像的不同版本（如 <code>latest</code>, <code>v1.0</code>, <code>dev</code>）。<strong>最佳实践是避免使用浮动的 <code>latest</code> 标签，而使用明确的版本号。</strong></li></ul><p><strong>常用命令：</strong></p><ul><li><code>docker pull nginx:alpine</code>： 从 Registry 拉取镜像。</li><li><code>docker push my-company.com/dev/my-app:v1.2</code>： 推送镜像到私有 Registry。</li><li><code>docker images</code> 或 <code>docker image ls</code>： 列出本地镜像。</li><li><code>docker rmi &lt;image_id&gt;</code>： 删除本地镜像。</li></ul><hr><h2><span id="深入底层镜像的内容">深入底层：镜像的内容</span></h2><p>一个镜像不仅仅是文件的集合，它还包含一些重要的元数据（JSON 格式）：</p><ol><li><strong>镜像索引</strong>： 用于多架构镜像（如同时支持 <code>amd64</code> 和 <code>arm64</code>），它指向不同平台对应的具体镜像清单。</li><li><strong>镜像清单</strong>： 描述了一个特定平台镜像的配置文件和层信息。</li><li><strong>镜像配置</strong>： 包含了该镜像的详细元数据，如：<ul><li>创建时间、作者</li><li>容器运行时使用的配置（如环境变量、工作目录、入口点命令、暴露的端口）</li><li>该镜像所包含的所有层的哈希值（<code>rootfs.diff_ids</code>）</li></ul></li><li><strong>层文件</strong>： 每个层都是一个压缩包（<code>tar.gz</code>），包含了文件系统的变化。</li></ol><p>我们可以通过 <code>docker inspect &lt;image_name&gt;</code> 命令来查看镜像的配置信息。</p><hr><h2><span id="优化技巧">优化技巧</span></h2><ol><li><p><strong>使用 <code>.dockerignore</code> 文件</strong>： 排除构建上下文中不必要的文件（如 <code>node_modules</code>, <code>.git</code>），加速构建过程并减小镜像体积。</p></li><li><p><strong>选择小巧的基础镜像</strong>： 优先选择 Alpine Linux 等小型镜像，可以极大减小最终镜像体积和安全攻击面。</p></li><li><p><strong>多阶段构建</strong>： 这是构建高效、小体积镜像的<strong>黄金法则</strong>。在一个 Dockerfile 中使用多个 <code>FROM</code> 指令。你可以在一个阶段（“构建阶段”）使用包含编译器等重型工具的镜像来构建应用，然后在另一个阶段（“运行阶段”）只复制构建好的二进制文件到一个非常精简的基础镜像中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阶段一：构建阶段</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o myapp .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阶段二：运行阶段</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/myapp /usr/local/bin/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;myapp&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>合并 RUN 指令</strong>： 将多个 <code>RUN</code> 指令用 <code>&amp;&amp;</code> 连接成一个，减少镜像层数（虽然层数限制现在已不是大问题，但仍能减少一些元数据开销）。</p></li><li><p><strong>明确的标签</strong>： 为生产环境镜像使用语义化版本号（如 <code>v1.2.3</code>）或 Git 提交哈希，而不是默认的 <code>latest</code>。</p></li></ol><hr><h2><span id="docker-image-常用指令">Docker Image 常用指令</span></h2><h3><span id="docker-images">docker images</span></h3><ul><li><p><strong>功能</strong><br>列出本地存储的 Docker 镜像。</p></li><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure></li><li><p><strong>别名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br><span class="line">docker image list</span><br></pre></td></tr></table></figure></li><li><p><strong>关键参数</strong></p><ul><li><code>-a, --all</code>：显示所有镜像（包括中间镜像层，默认情况下会过滤掉中间镜像层）</li><li><code>--digests</code>：显示镜像的摘要信息</li><li><code>-f, --filter</code>：根据条件过滤显示结果</li><li><code>--format</code>：使用 Go 模板格式化输出内容</li><li><code>--no-trunc</code>：显示完整的镜像信息（不截断输出）</li><li><code>-q, --quiet</code>：只显示镜像 ID</li></ul></li><li><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出特定的镜像（ubuntu 仓库的所有版本）</span></span><br><span class="line">docker images ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有镜像（包括中间层）</span></span><br><span class="line">docker images -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示镜像ID</span></span><br><span class="line">docker images -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示完整的镜像信息（不截断）</span></span><br><span class="line">docker images --no-trunc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用过滤器显示特定标签的镜像</span></span><br><span class="line">docker images -f <span class="string">&quot;reference=nginx:*&quot;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3><span id="docker-tag">docker tag</span></h3><ul><li><p><strong>功能</strong><br>为本地镜像创建新的标签，通常用于为镜像添加仓库地址前缀，为推送镜像到仓库做准备。</p></li><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure></li><li><p><strong>别名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag</span><br></pre></td></tr></table></figure></li><li><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为本地镜像添加新的标签</span></span><br><span class="line">docker tag ubuntu:22.04 myregistry.com/myubuntu:22.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为镜像添加版本标签</span></span><br><span class="line">docker tag nginx nginx:1.23.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为镜像添加多个标签</span></span><br><span class="line">docker tag myapp:latest myregistry.com/myapp:v1.0</span><br><span class="line">docker tag myapp:latest myregistry.com/myapp:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到私有仓库前的标签准备</span></span><br><span class="line">docker tag local-image:tag your-private-registry.com/username/repository:tag</span><br></pre></td></tr></table></figure></li><li><p><strong>注意事项</strong></p><ul><li><code>docker tag</code> 并不会创建新的镜像，只是为现有镜像添加了一个新的引用名称</li><li>同一个镜像可以有多个标签，它们共享相同的镜像 ID</li><li>删除一个标签不会删除镜像本身，只有当所有标签都被删除时，镜像才会被真正删除</li><li>在推送镜像到仓库前，必须使用 <code>docker tag</code> 为镜像添加包含仓库地址的完整名称</li></ul></li></ul><hr><h3><span id="docker-pull">docker pull</span></h3><p><strong>功能</strong>：从镜像仓库拉取（下载）镜像或仓库到本地。这是获取和运行容器的基础。</p><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><ul><li><code>NAME</code>：镜像名称，格式通常为 <code>[仓库地址/]用户名/仓库名</code>。</li><li><code>TAG</code>：镜像标签（版本）。如果省略，默认为 <code>latest</code>。</li><li><code>DIGEST</code>：镜像的数字摘要，用于精确指定某个版本的镜像，比 TAG 更唯一、安全。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Docker Hub 拉取最新的 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取指定标签的 Nginx 镜像（版本为 1.25-alpine）</span></span><br><span class="line">docker pull nginx:1.25-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从私有仓库拉取镜像</span></span><br><span class="line">docker pull myregistry.com:5000/myapp:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过镜像摘要拉取，确保内容绝对一致</span></span><br><span class="line">docker pull ubuntu@sha256:abc123...</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>总是明确指定标签（如 <code>:alpine</code>, <code>:v1.0</code>）而非依赖默认的 <code>latest</code>，以确保环境的一致性，通过官网中的 <code>tag</code> 复制对应仓库对应版本的镜像拉取命令是一个好习惯。</li></ul><hr><h3><span id="docker-push">docker push</span></h3><p><strong>功能</strong>：将本地的镜像标签推送到镜像仓库。这是分享和部署自定义镜像的关键步骤。</p><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><ul><li>推送前，必须先用 <code>docker tag</code> 命令将本地镜像命名为符合目标仓库规范的名称（<code>仓库地址/用户名/仓库名:标签</code>）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 首先，为本地镜像打上符合仓库规范的标签</span></span><br><span class="line">docker tag my_local_image:latest your_username/your_repo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 然后，推送到仓库</span></span><br><span class="line">docker push your_username/your_repo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到私有仓库</span></span><br><span class="line">docker push myregistry.com:5000/your_repo:v1.0</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>推送前必须确保已通过 <code>docker login</code> 登录且有相应权限。</li><li>镜像推送是分层的操作的，如果仓库中已存在相同的层，则不会重复上传，节省时间和带宽。</li></ul><hr><h3><span id="docker-rmi">docker rmi</span></h3><p><strong>功能</strong>：删除本地的一个或多个 Docker 镜像。释放磁盘空间或清理不再需要的镜像。</p><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><ul><li><code>IMAGE</code>：要删除的镜像名称或 ID。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除单个镜像</span></span><br><span class="line">docker rmi ubuntu:22.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多个镜像</span></span><br><span class="line">docker rmi nginx:1.23.3 myapp:latest</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>只有在没有容器使用该镜像时，才能成功删除镜像。</li><li>可以使用 <code>-f</code> 选项强制删除正在使用的镜像，但这可能会导致相关容器出现问题。</li></ul><hr><h3><span id="docker-save-docker-load">docker save、docker load</span></h3><p><strong>功能</strong>：<code>docker save</code> 用于将一个或多个镜像保存为 tar 文件，方便迁移或备份；<code>docker load</code> 则用于从 tar 文件中加载镜像。</p><p><strong>语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...] &gt; image.tar</span><br><span class="line">docker load [OPTIONS] &lt; image.tar</span><br></pre></td></tr></table></figure><ul><li><code>IMAGE</code>：要保存或加载的镜像名称或 ID。</li><li><code>OPTIONS</code>：可选参数，如 <code>-o</code> 指定输出文件。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存镜像为 tar 文件</span></span><br><span class="line">docker save -o myimage.tar myapp:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 tar 文件加载镜像</span></span><br><span class="line">docker load -i myimage.tar</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li><code>docker save</code> 保存的是镜像的所有层和元数据，生成的 tar 文件可以在其他 Docker 主机上使用 <code>docker load</code> 加载。</li><li>使用 <code>docker save</code> 和 <code>docker load</code> 可以方便地在没有网络连接的环境中迁移镜像。</li></ul><hr><h3><span id="docker-image-inspect">docker image inspect</span></h3><ul><li><p><strong>功能</strong><br>显示镜像的详细信息，包括元数据、配置信息、层信息等。</p></li><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure></li><li><p><strong>关键参数</strong></p><ul><li><code>-f, --format</code>：使用给定的 Go 模板格式化输出</li></ul></li><li><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定镜像的详细信息</span></span><br><span class="line">docker image inspect nginx:1.23.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看多个镜像的信息</span></span><br><span class="line">docker image inspect ubuntu:22.04 alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用格式输出只查看镜像的架构信息</span></span><br><span class="line">docker image inspect -f <span class="string">&#x27;&#123;&#123;.Architecture&#125;&#125;&#x27;</span> nginx:1.23.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像的创建时间</span></span><br><span class="line">docker image inspect -f <span class="string">&#x27;&#123;&#123;.Created&#125;&#125;&#x27;</span> nginx:1.23.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像的所有层（Layer）</span></span><br><span class="line">docker image inspect -f <span class="string">&#x27;&#123;&#123;.RootFS.Layers&#125;&#125;&#x27;</span> nginx:1.23.3</span><br></pre></td></tr></table></figure></li></ul><hr><h3><span id="docker-history">docker history</span></h3><ul><li><p><strong>功能</strong><br>查看镜像的历史记录，包括每一层的创建时间、作者、命令等信息。</p></li><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure></li><li><p><strong>关键参数</strong></p><ul><li><code>-H, --human=false</code>：以人类可读的格式显示大小</li><li><code>--no-trunc</code>：显示完整的输出（不截断）</li><li><code>--quiet</code>：只显示镜像 ID</li></ul></li><li><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定镜像的历史记录</span></span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/docker_test/namespace_test/test_dir2] - [1634]</span><br><span class="line">└─[$] docker <span class="built_in">history</span> nginx:stable-alpine3.21-perl                                                            [12:45:03]</span><br><span class="line">IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT</span><br><span class="line">0b65b64c7d04   4 months ago   RUN /bin/sh -c <span class="built_in">set</span> -x     &amp;&amp; apkArch=<span class="string">&quot;<span class="subst">$(cat …   38.4MB    buildkit.dockerfile.v0</span></span></span><br><span class="line"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   RUN /bin/sh -c set -x     &amp;&amp; apkArch=<span class="string">&quot;<span class="subst">$(cat …   36.3MB    buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV NJS_RELEASE=1                               0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV NJS_VERSION=0.8.10                          0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   CMD [<span class="string">&quot;nginx&quot;</span> <span class="string">&quot;-g&quot;</span> <span class="string">&quot;daemon off;&quot;</span>]                0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   STOPSIGNAL SIGQUIT                              0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   EXPOSE map[80/tcp:&#123;&#125;]                           0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENTRYPOINT [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]            0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY 30-tune-worker-processes.sh /docker-ent…   4.62kB    buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY 20-envsubst-on-templates.sh /docker-ent…   3.02kB    buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY 15-local-resolvers.envsh /docker-entryp…   389B      buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY 10-listen-on-ipv6-by-default.sh /docker…   2.12kB    buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY docker-entrypoint.sh / # buildkit          1.62kB    buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   RUN /bin/sh -c set -x     &amp;&amp; addgroup -g 101…   4.05MB    buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV DYNPKG_RELEASE=1                            0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV PKG_RELEASE=1                               0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV NGINX_VERSION=1.28.0                        0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   LABEL maintainer=NGINX Docker Maintainers &lt;d…   0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   CMD [<span class="string">&quot;/bin/sh&quot;</span>]                                 0B        buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ADD alpine-minirootfs-3.21.4-x86_64.tar.gz /…   7.82MB    buildkit.dockerfile.v0</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"># 以人类可读的格式查看历史记录</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">┌─[root@VM-16-15-debian] - [/home/ljx/docker_test/namespace_test/test_dir2] - [1633]</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">└─[$] docker history -H nginx:stable-alpine3.21-perl</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT</span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string">0b65b64c7d04   4 months ago   RUN /bin/sh -c set -x     &amp;&amp; apkArch=<span class="string">&quot;<span class="subst">$(cat …   38.4MB    buildkit.dockerfile.v0</span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   RUN /bin/sh -c set -x     &amp;&amp; apkArch=<span class="string">&quot;<span class="subst">$(cat …   36.3MB    buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV NJS_RELEASE=1                               0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV NJS_VERSION=0.8.10                          0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   CMD [<span class="string">&quot;nginx&quot;</span> <span class="string">&quot;-g&quot;</span> <span class="string">&quot;daemon off;&quot;</span>]                0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   STOPSIGNAL SIGQUIT                              0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   EXPOSE map[80/tcp:&#123;&#125;]                           0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENTRYPOINT [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]            0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY 30-tune-worker-processes.sh /docker-ent…   4.62kB    buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY 20-envsubst-on-templates.sh /docker-ent…   3.02kB    buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY 15-local-resolvers.envsh /docker-entryp…   389B      buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY 10-listen-on-ipv6-by-default.sh /docker…   2.12kB    buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   COPY docker-entrypoint.sh / # buildkit          1.62kB    buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   RUN /bin/sh -c set -x     &amp;&amp; addgroup -g 101…   4.05MB    buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV DYNPKG_RELEASE=1                            0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV PKG_RELEASE=1                               0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ENV NGINX_VERSION=1.28.0                        0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   LABEL maintainer=NGINX Docker Maintainers &lt;d…   0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   CMD [<span class="string">&quot;/bin/sh&quot;</span>]                                 0B        buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string"><span class="subst"><span class="string">&lt;missing&gt;      4 months ago   ADD alpine-minirootfs-3.21.4-x86_64.tar.gz /…   7.82MB    buildkit.dockerfile.v0</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure></li></ul><p>可以看出来，<code>docker history</code> 是自带 <code>-H</code> 选项的，默认就是以人类可读的格式显示历史记录。</p><h3><span id="docker-image-prune">docker image prune</span></h3><p>Docker 用久了，磁盘空间容易不足，<code>docker image prune</code> 💾 正是用来清理未使用的镜像，帮助释放磁盘空间的命令。我来为你详细讲解一下它的用法和注意事项。</p><h4><span id="理解未使用的镜像">理解“未使用的镜像”</span></h4><p>Docker 对未使用的对象（如镜像、容器、卷和网络）采取保守的清理策略，除非明确要求，否则通常不会自动删除它们，这可能会导致 Docker 占用额外的磁盘空间。<code>docker image prune</code> 主要清理两类镜像：</p><ul><li><strong>悬空镜像 (Dangling Images)</strong> ：这是 <code>docker image prune</code> <strong>默认清理</strong>的对象。它们是没有标签（Tag）且未被任何容器引用的镜像，通常是由于构建新镜像或重新打标签而产生的中间层或旧镜像。</li><li><strong>所有未使用的镜像</strong> ：使用 <code>-a</code> 或 <code>--all</code> 参数时，此命令会删除所有未被任何容器引用的镜像，无论其是否有标签。这包括了那些你有名有姓但当前没有任何容器使用的镜像（例如，旧版本的 <code>my-app:v1.0</code>）。</li></ul><h4><span id="命令语法和常用选项">命令语法和常用选项</span></h4><p><code>docker image prune</code> 的基本语法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune [OPTIONS]</span><br></pre></td></tr></table></figure><p>常用的 <code>[OPTIONS]</code> 包括：</p><table><thead><tr><th align="left">选项</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><strong><code>-a</code></strong>, <strong><code>--all</code></strong></td><td align="left">删除所有未被容器引用的镜像，而不仅仅是悬空镜像。</td><td align="left"><code>docker image prune -a</code></td></tr><tr><td align="left"><strong><code>-f</code></strong>, <strong><code>--force</code></strong></td><td align="left">强制删除，不显示确认提示。在脚本中常用。</td><td align="left"><code>docker image prune -f</code></td></tr><tr><td align="left"><strong><code>--filter</code></strong></td><td align="left">使用过滤表达式来限制要修剪的镜像。</td><td align="left"><code>docker image prune -a --filter &quot;until=24h&quot;</code></td></tr></tbody></table><h4><span id="常用操作示例">常用操作示例</span></h4><ol><li><p><strong>安全清理悬空镜像（推荐日常使用）</strong><br>这是最安全的做法，因为它只清理那些明确不再需要的“悬空”镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><p>执行后，Docker 会列出待删除的镜像并请求确认（除非使用 <code>-f</code> 强制跳过）。</p></li><li><p><strong>清理所有未使用的镜像（彻底清理，需谨慎）</strong><br>这个命令会删除所有未被任何容器引用的镜像，包括有标签但未被使用的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：此操作可能会删除一些你以后可能还会用到的镜像，下次使用前需要重新拉取或构建。</p></li><li><p><strong>按条件过滤清理镜像</strong><br>你可以使用 <code>--filter</code> 来精确控制要删除的镜像。例如，删除所有创建时间超过 24 小时的未使用镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a --filter <span class="string">&quot;until=24h&quot;</span></span><br></pre></td></tr></table></figure><p>或者，删除所有创建时间超过 7 天的未使用镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a --filter <span class="string">&quot;until=168h&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>强制清理（用于脚本）</strong><br>如果你希望在脚本中自动执行清理，而不被交互提示打断，可以加上 <code>-f</code> 或 <code>--force</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -f  <span class="comment"># 强制删除悬空镜像</span></span><br><span class="line">docker image prune -a -f <span class="comment"># 强制删除所有未使用的镜像</span></span><br></pre></td></tr></table></figure></li></ol><h4><span id="注意事项">注意事项</span></h4><ul><li><p><strong>数据无价，操作前确认</strong> ：在执行 <code>docker image prune -a</code> 前，建议先确认哪些镜像会被删除。可以使用以下命令查看所有悬空镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f dangling=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>若要查看所有镜像及其依赖关系，需仔细评估。</p></li><li><p><strong>被容器使用的镜像不会被删除</strong> ：<strong>无论容器是否正在运行</strong>，只要存在容器（包括已停止的容器）引用了该镜像，该镜像就不会被 <code>prune</code> 删除。这是 Docker 的数据保护机制。</p></li></ul><h4><span id="清理操作的建议流程">清理操作的建议流程</span></h4><p>一个比较安全的清理操作流程可以参考：</p><ol><li><p><strong>停止所有容器</strong>（如果希望清理更彻底）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container <span class="built_in">ls</span> -aq)</span><br></pre></td></tr></table></figure></li><li><p><strong>执行系统级清理</strong>（根据需求选择是否加 <code>--volumes</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune -af --volumes</span><br></pre></td></tr></table></figure></li><li><p><strong>重启需要的服务</strong>（例如使用 Docker Compose）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure></li></ol><h4><span id="查看磁盘空间">查看磁盘空间</span></h4><p>在清理前后，你可以使用以下命令查看 Docker 的磁盘使用情况，了解清理效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br></pre></td></tr></table></figure><h2><span id="docker-image-综合实践">Docker Image 综合实践</span></h2><h3><span id="离线迁移镜像">离线迁移镜像</span></h3><p>在日常开发、部署或环境迁移中，我们经常会遇到这样的场景：生产服务器无法访问外部网络（ air-gapped environment）、需要快速部署一个特定版本的环境，或者只是想将开发好的应用镜像简单地“复制”到另一台机器上。这时，Docker 镜像的离线迁移就成了一项必备技能。</p><p>这里小编将通过一个完整的实验，带你一步步实践如何将一台主机上的 Docker 镜像打包、传输并加载到另一台主机上。</p><h4><span id="实验概述">实验概述</span></h4><p><strong>实验目标</strong>：将<strong>主机 1（Source Host）</strong> 上的一个 <code>busybox</code> 镜像，完整地迁移到<strong>主机 2（Target Host）</strong> 上。</p><p><strong>模拟环境</strong>：</p><ul><li><strong>主机 1</strong>：IP 为 <code>[某内网IP]</code>，我们以 <code>root</code> 用户操作。</li><li><strong>主机 2</strong>：IP 为 <code>82.156.255.140</code>，我们以 <code>ljx</code> 用户操作。</li><li><em>（注：本次实验为演示方便，在同一台机器上模拟了两个主机的角色，但操作流程与真实双机环境完全一致）</em></li></ul><p><strong>使用工具</strong>：</p><ul><li><code>docker save</code> &#x2F; <code>docker load</code></li><li><code>scp</code> (Secure Copy)</li></ul><h4><span id="第一步在主机-1-上查找并打包镜像">第一步：在主机 1 上查找并打包镜像</span></h4><p>首先，我们需要在源主机上找到想要迁移的镜像。</p><ol><li><p><strong>查找镜像</strong>：<br>使用 <code>docker images</code> 配合 <code>grep</code> 命令精确查找我们需要的 <code>busybox</code> 镜像及其唯一的 Image ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep busybox</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">busybox  stable-glibc  1827167fde90  2 years ago  4.42MB</span><br></pre></td></tr></table></figure><p>我们记下这个关键的 Image ID：<code>1827167fde90</code>。</p></li><li><p><strong>打包镜像</strong>：<br>使用 <code>docker save</code> 命令将镜像打包成一个单一的 <code>.tar</code> 文件。这个文件包含了镜像的所有层（Layers）、元数据（Metadata）和标签（Tags）信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o myimage.tar 1827167fde90</span><br></pre></td></tr></table></figure><ul><li><code>-o myimage.tar</code>：指定输出文件名为 <code>myimage.tar</code>。</li><li><code>1827167fde90</code>：指定要打包的镜像 ID。你也可以使用镜像名:标签（如 <code>busybox:stable-glibc</code>）。</li></ul><p>至此，一个完整的 Docker 镜像包 <code>myimage.tar</code> 就准备好了。</p></li></ol><h4><span id="第二步将镜像包传输到主机-2">第二步：将镜像包传输到主机 2</span></h4><p>我们使用 <code>scp</code> 命令，通过 SSH 协议安全地将文件从主机 1 拷贝到主机 2 的指定目录。这是跨主机操作的关键一步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp myimage.tar ljx@82.156.255.140:/home/ljx/docker_test/image_test/</span><br></pre></td></tr></table></figure><ul><li><code>myimage.tar</code>：要传输的文件。</li><li><code>ljx@82.156.255.140</code>：以 <code>ljx</code> 用户身份登录到 IP 为 <code>82.156.255.140</code> 的主机 2。</li><li><code>:/home/ljx/docker_test/image_test/</code>：指定主机 2 上的目标路径。</li></ul><p>如果是首次连接，会提示验证主机指纹，输入 <code>yes</code> 继续即可，然后输入用户 <code>ljx</code> 的密码。</p><h4><span id="第三步在主机-2-上加载并验证镜像">第三步：在主机 2 上加载并验证镜像</span></h4><p>现在，我们切换到主机 2 上进行操作。</p><ol><li><p><strong>验证文件已接收</strong>：<br>首先确认文件已成功传输并位于正确的目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll ~/docker_test/image_test/</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total 4560</span><br><span class="line">-rw------- 1 ljx ljx 4668416 Aug 30 16:21 myimage.tar</span><br></pre></td></tr></table></figure><p>可以看到，一个约 4.5MB 的 <code>myimage.tar</code> 文件已经存在。</p></li><li><p><strong>加载镜像</strong>：<br>使用 <code>docker load</code> 命令将打包文件还原为 Docker 镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i myimage.tar</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loaded image ID: sha256:1827167fde90df99d9341a27fbce2b445550eb2b18105e03f98102f00c0ec35e</span><br></pre></td></tr></table></figure><p><strong>恭喜！输出中的 <code>Loaded image ID</code> 表明镜像已成功加载到主机 2 的 Docker 镜像库中。</strong></p></li><li><p><strong>验证镜像</strong>：<br>最后，让我们检查一下镜像是否真的可以正常使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep 1827167fde90</span><br><span class="line"><span class="comment"># 或者直接运行一个新的容器来测试</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> 1827167fde90 <span class="built_in">echo</span> <span class="string">&quot;Hello from the migrated image!&quot;</span></span><br></pre></td></tr></table></figure><p>如果能看到镜像列表和成功的输出，就证明整个离线迁移实验大功告成！</p></li></ol><hr><p>通过 <code>docker save</code> 和 <code>docker load</code> 进行镜像离线迁移，是一种非常可靠、通用的方法。它的优点是：</p><ul><li><strong>环境无关</strong>：不依赖任何镜像仓库（如 Docker Hub、Harbor）。</li><li><strong>简单直接</strong>：命令易于理解和记忆。</li><li><strong>完整性</strong>：完美保留镜像的所有层和历史。</li></ul><p><strong>注意事项</strong>：</p><ul><li><strong>权限问题</strong>：在目标主机上执行 <code>docker load</code> 时，确保当前用户有操作 Docker 的权限（通常需要加入 <code>docker</code> 用户组）。</li><li><strong>存储空间</strong>：确保传输前后两台主机都有足够的磁盘空间。</li><li><strong>网络安全</strong>：使用 <code>scp</code> 传输时，数据是加密的，保证了镜像的安全性。</li><li><strong>标签丢失</strong>：有时 <code>docker save</code> 通过 Image ID 打包可能会丢失原有的镜像名和标签（Tag），加载后镜像可能变为 <code>&lt;none&gt;:&lt;none&gt;</code>。此时可以使用 <code>docker tag &lt;image_id&gt; &lt;new_name&gt;:&lt;new_tag&gt;</code> 为其重新打 tag。更推荐使用 <code>docker save -o myimage.tar busybox:stable-glibc</code> 这种<strong>镜像名:标签</strong>的方式来保存，可以保留所有信息。</li></ul><h3><span id="镜像存储的压缩与共享">镜像存储的压缩与共享</span></h3><p>在容器镜像的分发过程中，存储压缩与共享机制对于提升效率、节省带宽至关重要。本次实验通过操作同一镜像的不同版本，直观展示了这一机制的工作原理。</p><h4><span id="从远程仓库拉取标签为-v10-的镜像到本地">从远程仓库拉取标签为 v1.0 的镜像到本地</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v1.0</span><br></pre></td></tr></table></figure><p>拉取过程显示完整的下载流程，包括分层信息的获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1.0: Pulling from liujiaxuan/busybox_by_liujiaxuan</span><br><span class="line">Digest: sha256:800a83edaed8daab01f81f408912d121d175066900dd422bdcb6c8c91dbb3268</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v1.0</span><br></pre></td></tr></table></figure><h4><span id="查看本地镜像信息注意到解压后的镜像大小为-442mb">查看本地镜像信息，注意到解压后的镜像大小为 4.42MB</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep busybox</span><br></pre></td></tr></table></figure><p>输出结果显示本地存储的实际大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan   v1.0   1827167fde90   2 years ago    4.42MB</span><br><span class="line">busybox                                                                                       stable-glibc   1827167fde90   2 years ago    4.42MB</span><br></pre></td></tr></table></figure><h4><span id="为演示共享机制删除本地镜像后重新拉取">为演示共享机制，删除本地镜像后重新拉取</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 细节：删除是先去标签再删除</span></span><br><span class="line">┌─[root@VM-16-15-debian] - [~] - [1687]</span><br><span class="line">└─[$] docker rmi 1827167fde90 -f</span><br><span class="line">Untagged: crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v1.0</span><br><span class="line">Untagged: crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan@sha256:800a83edaed8daab01f81f408912d121d175066900dd422bdcb6c8c91dbb3268</span><br><span class="line">Untagged: busybox:stable-glibc</span><br><span class="line">Untagged: busybox@sha256:fea9e0f09e8cbbe7b2d2ca2ebb6e8da1e2e1d7c6ca7a4cf297eb2fcf5afda5ed</span><br><span class="line">Deleted: sha256:1827167fde90df99d9341a27fbce2b445550eb2b18105e03f98102f00c0ec35e</span><br><span class="line">Deleted: sha256:b4cb8796a924c1fe5cf7031b67a551c63f9236c5cb0e0d51af962285ae361db7</span><br><span class="line">┌─[root@VM-16-15-debian] - [~] - [1688]</span><br><span class="line">└─[$] docker pull crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v1.0</span><br><span class="line">v1.0: Pulling from liujiaxuan/busybox_by_liujiaxuan</span><br><span class="line">2dc65973bc71: Pull complete</span><br><span class="line">Digest: sha256:800a83edaed8daab01f81f408912d121d175066900dd422bdcb6c8c91dbb3268</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v1.0</span><br><span class="line">crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v1.0</span><br></pre></td></tr></table></figure><p>重新拉取时观察到完整的分层下载过程。</p><h4><span id="创建新版本标签并推送到仓库">创建新版本标签并推送到仓库</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v1.0 crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v2.0</span><br><span class="line">docker push crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan:v2.0</span><br></pre></td></tr></table></figure><p>推送过程显示分层已存在，无需重复上传：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The push refers to repository [crpi-x6zeb1ynyh83ir4y.cn-hangzhou.personal.cr.aliyuncs.com/liujiaxuan/busybox_by_liujiaxuan]</span><br><span class="line">b4cb8796a924: Layer already exists</span><br><span class="line">v2.0: digest: sha256:800a83edaed8daab01f81f408912d121d175066900dd422bdcb6c8c91dbb3268 size: 527</span><br></pre></td></tr></table></figure><p>通过仓库管理界面查看，可以发现实际存储的镜像数据大小仅为 2.172MB，显著小于本地解压后的 4.42MB：<br><img src="/img/Docker/image/image.png" alt="image"></p><p>这一差异体现了镜像存储的压缩机制：镜像在传输和存储时采用压缩格式（2.172MB），而在本地运行时需要解压为可用的文件系统格式（4.42MB）。同时，基于相同镜像层（Digest 相同）的多个标签可以共享存储空间，推送新版本时只需上传元数据信息，大幅节省了网络带宽和存储成本。</p><p>这种设计将压缩解压的计算代价分散到各个客户端，虽然单个用户需要承担少量的计算开销，但整体上显著减轻了网络基础设施的压力，实现了”积少成多”的优化效果。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端工具 </category>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
            <tag> 镜像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 使用入门</title>
      <link href="/2025/08/28/Docker/docker_use/"/>
      <url>/2025/08/28/Docker/docker_use/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%B8%80-docker-registry-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90">一、Docker Registry 架构解析</a><ul><li><a href="#11-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89">1.1 核心概念定义</a></li><li><a href="#12-%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84">1.2 层次化组织结构</a></li><li><a href="#13-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%9E%B6%E6%9E%84">1.3 技术实现架构</a></li></ul></li><li><a href="#%E4%BA%8C-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%88%86%E7%B1%BB%E4%BD%93%E7%B3%BB">二、镜像仓库分类体系</a><ul><li><a href="#21-%E6%8C%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%88%92%E5%88%86">2.1 按访问权限划分</a></li><li><a href="#22-%E6%8C%89%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E5%95%86%E5%88%92%E5%88%86">2.2 按服务提供商划分</a></li></ul></li><li><a href="#%E4%B8%89-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">三、镜像仓库工作流程</a><ul><li><a href="#31-%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B">3.1 核心操作流程</a></li><li><a href="#32-%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B">3.2 多环境分发流程</a></li><li><a href="#33-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">3.3 本地缓存机制</a></li></ul></li><li><a href="#%E5%9B%9B-%E5%B8%B8%E8%A7%81%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93">四、常见镜像仓库</a><ul><li><a href="#41-docker-hub">4.1 Docker Hub</a></li><li><a href="#42-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90">4.2 国内镜像源</a></li><li><a href="#43-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93">4.3 私有仓库</a></li></ul></li><li><a href="#%E4%BA%94-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%91%BD%E4%BB%A4">五、镜像仓库命令</a><ul><li><a href="#51-docker-login">5.1 <code>docker login</code></a></li><li><a href="#52-docker-pull">5.2 <code>docker pull</code></a></li><li><a href="#53-docker-push">5.3 <code>docker push</code></a></li><li><a href="#54-docker-search">5.4 <code>docker search</code></a></li><li><a href="#55-docker-logout">5.5 <code>docker logout</code></a></li></ul></li><li><a href="#%E5%85%AD-%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4">六、镜像命令</a><ul><li><a href="#61-docker-images">6.1 <code>docker images</code></a></li><li><a href="#62-docker-image-inspect">6.2 <code>docker image inspect</code></a></li><li><a href="#63-docker-tag">6.3 <code>docker tag</code></a></li></ul></li><li><a href="#%E4%B8%83-%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4">七、容器命令</a><ul><li><a href="#73-docker-run">7.3 docker run</a></li><li><a href="#74-docker-ps">7.4 docker ps</a></li></ul></li></ul><!-- tocstop --><p>在学习使用 Docker 之前，深入理解 Docker 镜像仓库的概念至关重要。镜像仓库是 Docker 生态系统的核心组件，为镜像的存储、管理和分发提供了基础设施支持。</p><h2><span id="一-docker-registry-架构解析">一、Docker Registry 架构解析</span></h2><h3><span id="11-核心概念定义">1.1 核心概念定义</span></h3><p><strong>镜像仓库 (Docker Registry)</strong> 是集中存储和分发 Docker 镜像的服务，它提供以下核心功能：</p><ul><li>镜像的存储与管理</li><li>版本控制与标签管理</li><li>用户认证与权限控制</li><li>镜像检索与索引服务</li></ul><h3><span id="12-层次化组织结构">1.2 层次化组织结构</span></h3><p>镜像仓库采用分层化的组织结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry (镜像仓库) → Repository (仓库) → Image (镜像) → Tag (标签)</span><br></pre></td></tr></table></figure><p><strong>具体说明：</strong></p><ul><li><strong>Registry</strong>: 通过 DNS 或 IP 地址标识的镜像仓库服务（如 <code>hub.docker.com</code>）</li><li><strong>Repository</strong>: 包含特定 Docker 镜像所有版本的集合，分为：<ul><li><strong>顶层仓库</strong>: 如 <code>nginx</code>, <code>ubuntu</code></li><li><strong>用户仓库</strong>: 格式为 <code>用户名/仓库名</code>，如 <code>alpine/nginx</code></li></ul></li><li><strong>Tag</strong>: 标识同一镜像的不同版本，如 <code>nginx:latest</code>, <code>nginx:1.25</code></li></ul><h3><span id="13-技术实现架构">1.3 技术实现架构</span></h3><p>每个容器镜像包含两个组成部分：</p><ul><li><strong>元数据 (Metadata)</strong>: 描述镜像的层次结构、校验和、构建历史等信息</li><li><strong>存储数据 (Blob)</strong>: 实际的文件系统层内容，占用主要存储空间</li></ul><p>镜像仓库的整体视图如下：</p><p><img src="/img/Docker/use/registry.png" alt="registry"></p><h2><span id="二-镜像仓库分类体系">二、镜像仓库分类体系</span></h2><h3><span id="21-按访问权限划分">2.1 按访问权限划分</span></h3><h4><span id="1公有仓库-public-registry">（1）公有仓库 (Public Registry)</span></h4><ul><li><strong>典型代表</strong>: Docker Hub, Quay.io</li><li><strong>特点</strong>: 面向公众开放，通常无需认证即可下载镜像</li><li><strong>适用场景</strong>: 开源项目、公共基础镜像分发</li></ul><h4><span id="2私有仓库-private-registry">（2）私有仓库 (Private Registry)</span></h4><ul><li><strong>部署位置</strong>: 私有网络环境</li><li><strong>特点</strong>: 需要身份认证，提供更高的安全性和隐私保护</li><li><strong>适用场景</strong>: 企业内部镜像管理、敏感应用部署</li></ul><h3><span id="22-按服务提供商划分">2.2 按服务提供商划分</span></h3><h4><span id="1赞助仓库-sponsor-registry">（1）赞助仓库 (Sponsor Registry)</span></h4><ul><li>第三方提供商运营</li><li>面向 Docker 社区和客户使用</li></ul><h4><span id="2镜像仓库-mirror-registry">（2）镜像仓库 (Mirror Registry)</span></h4><ul><li>第三方提供的镜像代理服务</li><li>通常需要注册使用（如阿里云镜像服务）</li></ul><h4><span id="3供应商仓库-vendor-registry">（3）供应商仓库 (Vendor Registry)</span></h4><ul><li>由软件供应商直接提供</li><li>如 Google Container Registry, RedHat Quay</li></ul><h4><span id="4私有仓库-private-registry">（4）私有仓库 (Private Registry)</span></h4><ul><li>企业自建的内部分发体系</li><li>提供完整的隔离和安全保障</li></ul><h2><span id="三-镜像仓库工作流程">三、镜像仓库工作流程</span></h2><h3><span id="31-核心操作流程">3.1 核心操作流程</span></h3><p>Docker 镜像仓库的标准工作流程包含以下关键步骤：</p><ol><li><strong>身份认证</strong>: <code>docker login</code> 登录到目标仓库</li><li><strong>镜像拉取</strong>: <code>docker pull</code> 从仓库下载所需镜像</li><li><strong>镜像构建</strong>: 通过 Dockerfile 或 commit 制作新镜像</li><li><strong>镜像推送</strong>: <code>docker push</code> 将镜像上传至仓库</li></ol><blockquote><p><strong>注意</strong>: 拉取公共镜像通常无需登录，但推送镜像必须通过身份认证。</p></blockquote><h3><span id="32-多环境分发流程">3.2 多环境分发流程</span></h3><p>在现代软件开发流程中，镜像通过仓库在不同环境间流转：</p><p><img src="/img/Docker/use/registry_work.png" alt="work"></p><p><strong>环境角色说明：</strong></p><ul><li><strong>开发环境</strong>: 开发人员构建和测试镜像的环境</li><li><strong>测试环境</strong>: 质量保证团队进行功能验证的环境</li><li><strong>预发布环境</strong>: 模拟生产环境进行最终验证</li><li><strong>生产环境</strong>: 面向终端用户的正式运行环境</li></ul><h3><span id="33-本地缓存机制">3.3 本地缓存机制</span></h3><p>Docker Daemon 的智能缓存策略：</p><ul><li>启动容器时优先检查本地镜像缓存</li><li>本地缺失时自动从配置的 Registry 下载</li><li>下载的镜像持久化存储在本地，加速后续使用</li></ul><p>为了更好地理解镜像仓库的概念，我们可以用超市购物来类比：</p><ul><li><strong>Registry</strong> &#x3D; 整个超市（如沃尔玛、家乐福）</li><li><strong>Repository</strong> &#x3D; 商品类别（饮料区、零食区、日用品区）</li><li><strong>Image</strong> &#x3D; 具体商品（可乐、薯片、洗发水）</li><li><strong>Tag</strong> &#x3D; 商品规格（330ml 罐装、500ml 瓶装、家庭装）</li></ul><p>这种层次化的组织结构使得海量镜像的管理和检索变得高效而有序。</p><p>Docker 镜像仓库作为容器化生态的基石，提供了完整的镜像生命周期管理能力。通过理解其架构设计、分类体系和工作原理，开发者能够更好地利用 Docker 技术实现高效的应用构建、分发和部署。掌握镜像仓库的使用是 Docker 技术栈中不可或缺的核心技能。</p><h2><span id="四-常见镜像仓库">四、常见镜像仓库</span></h2><h3><span id="41-docker-hub">4.1 Docker Hub</span></h3><p><code>Docker Hub</code> 是 <code>Docker</code> 提供的托管存储库服务，用于查找容器映像并与您的团队共享。具有以下功能：<br>（1）个人可以注册私有仓库，能够发布自己的镜像<br>（2）提供镜像检索能力<br>（3）提供海量官方和认证组织的镜像<br>（4）从 <code>GitHub</code> 和 <code>Bitbucket</code> 自动构建容器镜像并将它们推送到 <code>Docker Hub</code><br>（5）支持 webhook（webhook 是一种基于 HTTP 的回调函数,发生指定的事件时，服务器会自动将相关的有效负载发送到客户端的 webhook URL。 ）</p><p><code>Docker Hub</code> 功能强大，下面列举几个非常常用的功能：</p><h4><span id="411-镜像搜索">4.1.1 镜像搜索</span></h4><p>用户可以通过关键字搜索功能，快速找到所需的镜像。</p><p><img src="/img/Docker/use/search.png" alt="search"></p><h4><span id="412-镜像-tag-查找">4.1.2 镜像 tag 查找</span></h4><p>用户可以通过镜像的标签（tag）快速找到特定版本的镜像。</p><p><img src="/img/Docker/use/tag.png" alt="tag"></p><p>通过对应的 <code>tag</code> 可以直接获取对应的版本拉取指令，一键 CP，简单无脑</p><p><img src="/img/Docker/use/tag_command.png" alt="command"></p><h3><span id="42-国内镜像源">4.2 国内镜像源</span></h3><p>直接访问 <code>docker hub</code> 通常是比较慢的，因此很多国内云服务商提供了镜像加速服务。常见的国内镜像源包括：</p><ul><li><strong>阿里云</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://&lt;your-region&gt;.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure><ul><li><strong>腾讯云</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirror.ccs.tencentyun.com</span><br></pre></td></tr></table></figure><ul><li><strong>华为云</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://repo.huaweicloud.com</span><br></pre></td></tr></table></figure><ul><li><strong>DaoCloud</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.daocloud.io/mirror</span><br></pre></td></tr></table></figure><p>使用这些国内镜像源可以显著提高镜像拉取速度，减少构建时间。</p><h3><span id="43-私有仓库">4.3 私有仓库</span></h3><p>私有镜像仓库是指部署在企业或组织内部网络环境中，专门用于内部 Docker 镜像存储、管理和分发的镜像仓库服务。在企业级 DevOps 流程中，私有仓库发挥着至关重要的作用。</p><h4><span id="核心价值与定位">核心价值与定位</span></h4><p>私有镜像仓库在企业环境中具有以下关键价值：</p><ul><li><strong>安全性保障</strong>：避免将敏感应用镜像暴露在公网环境中</li><li><strong>网络优化</strong>：内网传输显著提升镜像拉取和推送速度</li><li><strong>合规性要求</strong>：满足行业监管和数据本地化存储要求</li><li><strong>自主可控</strong>：完全掌握镜像的生命周期管理权限</li></ul><p>在自动化发布体系中，私有仓库作为 CI&#x2F;CD 流程的核心枢纽，通常承担以下职责：</p><ul><li>接收来自持续集成阶段构建的应用镜像</li><li>为持续部署阶段提供稳定可靠的镜像源</li><li>实现不同环境（开发、测试、生产）间的镜像版本控制</li></ul><h4><span id="主流私有仓库解决方案">主流私有仓库解决方案</span></h4><h5><span id="1-harbor-企业级-registry-解决方案">1. Harbor - 企业级 Registry 解决方案</span></h5><p><strong>产品背景</strong>：</p><ul><li>由 VMware 公司开源的企业级 Docker Registry 项目</li><li>在 Docker 官方开源 registry 基础上增强而来</li></ul><p><strong>核心特性</strong>：</p><ul><li><strong>可视化管理系统</strong>：提供友好的 Web 管理界面</li><li><strong>基于角色的访问控制（RBAC）</strong>：精细化的权限管理体系</li><li><strong>企业集成能力</strong>：支持 AD&#x2F;LDAP 认证集成</li><li><strong>安全审计功能</strong>：完整的操作日志记录和审计追踪</li><li><strong>多语言支持</strong>：原生支持中文界面</li><li><strong>高可用架构</strong>：支持多节点集群部署</li></ul><p><strong>技术架构</strong>：</p><ul><li>采用微服务架构设计，各组件均以 Docker 容器形式运行</li><li>使用 Docker Compose 或 Kubernetes 进行统一部署和管理</li></ul><h5><span id="2-nexus-repository-通用制品仓库平台">2. Nexus Repository - 通用制品仓库平台</span></h5><p><strong>产品背景</strong>：</p><ul><li>由 Sonatype 公司开发的通用制品仓库管理平台</li><li>最初作为 Maven 私服广泛应用，现已支持多种格式</li></ul><p><strong>核心特性</strong>：</p><ul><li><strong>多格式支持</strong>：同时支持 Maven、Docker、NPM、PyPI 等多种制品格式</li><li><strong>统一管理</strong>：单一平台管理所有类型的开发制品</li><li><strong>代理缓存</strong>：智能缓存公有仓库内容，减少外网依赖</li><li><strong>空间优化</strong>：高效的存储空间管理和垃圾回收机制</li><li><strong>扩展性强</strong>：丰富的插件生态系统和 API 接口</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要统一管理多种类型制品的异构技术栈环境</li><li>已有 Nexus 作为 Maven 私服，希望扩展 Docker 支持的企业</li></ul><h5><span id="3-docker-registry-官方轻量级解决方案">3. Docker Registry - 官方轻量级解决方案</span></h5><p><strong>产品背景</strong>：</p><ul><li>Docker 官方提供的开源镜像仓库实现</li><li>功能简洁，专注于核心的镜像存储和分发</li></ul><p><strong>核心特性</strong>：</p><ul><li><strong>轻量级设计</strong>：资源消耗低，部署简单快捷</li><li><strong>标准兼容</strong>：完全遵循 Docker Registry API 规范</li><li><strong>灵活存储</strong>：支持多种后端存储驱动（文件系统、S3、Azure Blob 等）</li><li><strong>TLS 加密</strong>：支持 HTTPS 安全传输</li><li><strong>基础认证</strong>：提供基本的身份验证机制</li></ul><p><strong>适用场景</strong>：</p><ul><li>小型团队或测试环境的快速搭建</li><li>作为其他复杂解决方案的底层基础</li><li>需要高度定制化开发的基础平台</li></ul><h4><span id="技术选型建议">技术选型建议</span></h4><table><thead><tr><th>特性</th><th>Harbor</th><th>Nexus</th><th>Docker Registry</th></tr></thead><tbody><tr><td><strong>企业级功能</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐</td></tr><tr><td><strong>易用性</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td></tr><tr><td><strong>多格式支持</strong></td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>⭐</td></tr><tr><td><strong>部署复杂度</strong></td><td>中等</td><td>中等</td><td>简单</td></tr><tr><td><strong>社区生态</strong></td><td>活跃</td><td>成熟</td><td>基础</td></tr><tr><td><strong>适合规模</strong></td><td>中大型企业</td><td>混合技术栈企业</td><td>小型团队</td></tr></tbody></table><h4><span id="部署实践建议">部署实践建议</span></h4><ol><li><strong>存储规划</strong>：预留充足的存储空间，并考虑备份策略</li><li><strong>网络配置</strong>：合理规划网络访问策略和域名解析</li><li><strong>监控告警</strong>：建立完整的监控体系，包括磁盘空间、服务状态等</li><li><strong>备份恢复</strong>：制定完善的备份和灾难恢复方案</li><li><strong>权限管理</strong>：根据团队结构设计合理的权限分配方案</li></ol><p>私有镜像仓库的选择应该基于企业的具体需求、技术栈现状和团队规模进行综合考量。对于大多数企业而言，Harbor 提供了最完整的开箱即用体验，而 Nexus 则更适合需要统一管理多种类型制品的复杂环境。</p><h2><span id="五-镜像仓库命令">五、镜像仓库命令</span></h2><h3><span id="51-docker-login">5.1 <code>docker login</code></span></h3><p><strong>简介</strong>：用于登录到 Docker 镜像仓库（如 Docker Hub、阿里云容器镜像服务等私有仓库）。登录后，你才拥有推送镜像到仓库或拉取私有镜像的权限。</p><p><strong>基本用法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br></pre></td></tr></table></figure><ul><li><code>SERVER</code>：镜像仓库地址（可选）。默认为 Docker Hub (<code>https://index.docker.io/v1/</code>)。如果使用私有仓库，需指定其地址，如 <code>registry.example.com:5000</code>。</li><li><code>OPTIONS</code>：常用选项包括 <code>-u</code>（用户名）和 <code>-p</code>（密码），但<strong>不建议直接在命令中输入密码</strong>，以免泄露。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录到 Docker Hub（交互式输入用户名和密码）</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录到私有仓库</span></span><br><span class="line">docker login registry.example.com:5000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命令行参数登录（不推荐，因为密码会留在历史记录中）</span></span><br><span class="line">docker login -u your_username -p your_password</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li><p>登录凭证默认存储在 <code>~/.docker/config.json</code> 文件中。</p></li><li><p>出于安全考虑，更推荐使用 <code>--password-stdin</code> 选项从标准输入读取密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your_password&quot;</span> | docker login -u <span class="string">&quot;your_username&quot;</span> --password-stdin</span><br></pre></td></tr></table></figure></li></ul><hr><h3><span id="52-docker-pull">5.2 <code>docker pull</code></span></h3><p><strong>简介</strong>：从镜像仓库拉取（下载）镜像或仓库到本地。这是获取和运行容器的基础。</p><p><strong>基本用法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><ul><li><code>NAME</code>：镜像名称，格式通常为 <code>[仓库地址/]用户名/仓库名</code>。</li><li><code>TAG</code>：镜像标签（版本）。如果省略，默认为 <code>latest</code>。</li><li><code>DIGEST</code>：镜像的数字摘要，用于精确指定某个版本的镜像，比 TAG 更唯一、安全。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Docker Hub 拉取最新的 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取指定标签的 Nginx 镜像（版本为 1.25-alpine）</span></span><br><span class="line">docker pull nginx:1.25-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从私有仓库拉取镜像</span></span><br><span class="line">docker pull myregistry.com:5000/myapp:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过镜像摘要拉取，确保内容绝对一致</span></span><br><span class="line">docker pull ubuntu@sha256:abc123...</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>总是明确指定标签（如 <code>:alpine</code>, <code>:v1.0</code>）而非依赖默认的 <code>latest</code>，以确保环境的一致性，通过官网中的 <code>tag</code> 复制对应仓库对应版本的镜像拉取命令是一个好习惯。</li></ul><hr><h3><span id="53-docker-push">5.3 <code>docker push</code></span></h3><p><strong>简介</strong>：将本地的镜像标签推送到镜像仓库。这是分享和部署自定义镜像的关键步骤。</p><p><strong>基本用法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><ul><li>推送前，必须先用 <code>docker tag</code> 命令将本地镜像命名为符合目标仓库规范的名称（<code>仓库地址/用户名/仓库名:标签</code>）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 首先，为本地镜像打上符合仓库规范的标签</span></span><br><span class="line">docker tag my_local_image:latest your_username/your_repo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 然后，推送到仓库</span></span><br><span class="line">docker push your_username/your_repo:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到私有仓库</span></span><br><span class="line">docker push myregistry.com:5000/your_repo:v1.0</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>推送前必须确保已通过 <code>docker login</code> 登录且有相应权限。</li><li>镜像推送是分层的操作的，如果仓库中已存在相同的层，则不会重复上传，节省时间和带宽。</li></ul><hr><h3><span id="54-docker-search">5.4 <code>docker search</code></span></h3><p><strong>简介</strong>：在 Docker Hub 或其它配置的仓库中搜索镜像。用于发现官方或社区的可用镜像。</p><p><strong>基本用法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><ul><li><code>TERM</code>：要搜索的关键词。</li><li><code>OPTIONS</code>：常用选项包括 <code>--limit</code>（限制返回结果数量）和 <code>--filter</code>（过滤条件，如 <code>is-official=true</code>）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索与 &quot;nginx&quot; 相关的镜像</span></span><br><span class="line">docker search nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示官方镜像</span></span><br><span class="line">docker search --filter <span class="string">&quot;is-official=true&quot;</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示自动化构建的镜像</span></span><br><span class="line">docker search --filter <span class="string">&quot;is-automated=true&quot;</span> python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制返回 5 个结果</span></span><br><span class="line">docker search --<span class="built_in">limit</span> 5 redis</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>搜索结果中的 <code>OFFICIAL</code> 标记表示是官方维护的镜像，通常更可靠。</li><li><code>STARS</code> 数类似于 GitHub 的点赞数，可以作为流行度和社区认可度的参考。</li></ul><hr><h3><span id="55-docker-logout">5.5 <code>docker logout</code></span></h3><p><strong>简介</strong>：从指定的 Docker 镜像仓库注销，清除本地存储的登录凭证。</p><p><strong>基本用法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">logout</span> [SERVER]</span><br></pre></td></tr></table></figure><ul><li><code>SERVER</code>：镜像仓库地址（可选）。默认为 Docker Hub。</li></ul><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Docker Hub 注销</span></span><br><span class="line">docker <span class="built_in">logout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从私有仓库注销</span></span><br><span class="line">docker <span class="built_in">logout</span> registry.example.com:5000</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>注销操作只会删除 <code>~/.docker/config.json</code> 文件中的对应凭证，不会影响已运行的容器。</li><li>在多用户系统或公共机器上操作后，及时注销是一个好习惯。</li></ul><hr><p>这五个命令构成了与 Docker 镜像仓库交互的核心工作流：</p><ol><li><strong>登录</strong> (<code>login</code>) → 获取权限</li><li><strong>搜索</strong> (<code>search</code>) → 发现镜像</li><li><strong>拉取</strong> (<code>pull</code>) → 获取镜像</li><li><strong>推送</strong> (<code>push</code>) → 分享镜像</li><li><strong>注销</strong> (<code>logout</code>) → 退出登录</li></ol><h2><span id="六-镜像命令">六、镜像命令</span></h2><h3><span id="61-docker-images">6.1 <code>docker images</code></span></h3><ul><li><p><strong>功能</strong><br>列出本地存储的 Docker 镜像。</p></li><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure></li><li><p><strong>别名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br><span class="line">docker image list</span><br></pre></td></tr></table></figure></li><li><p><strong>关键参数</strong></p><ul><li><code>-a, --all</code>：显示所有镜像（包括中间镜像层，默认情况下会过滤掉中间镜像层）</li><li><code>--digests</code>：显示镜像的摘要信息</li><li><code>-f, --filter</code>：根据条件过滤显示结果</li><li><code>--format</code>：使用 Go 模板格式化输出内容</li><li><code>--no-trunc</code>：显示完整的镜像信息（不截断输出）</li><li><code>-q, --quiet</code>：只显示镜像 ID</li></ul></li><li><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出特定的镜像（ubuntu 仓库的所有版本）</span></span><br><span class="line">docker images ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有镜像（包括中间层）</span></span><br><span class="line">docker images -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示镜像ID</span></span><br><span class="line">docker images -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示完整的镜像信息（不截断）</span></span><br><span class="line">docker images --no-trunc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用过滤器显示特定标签的镜像</span></span><br><span class="line">docker images -f <span class="string">&quot;reference=nginx:*&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="62-docker-image-inspect">6.2 <code>docker image inspect</code></span></h3><ul><li><p><strong>功能</strong><br>显示镜像的详细信息，包括元数据、配置信息、层信息等。</p></li><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure></li><li><p><strong>关键参数</strong></p><ul><li><code>-f, --format</code>：使用给定的 Go 模板格式化输出</li></ul></li><li><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定镜像的详细信息</span></span><br><span class="line">docker image inspect nginx:1.23.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看多个镜像的信息</span></span><br><span class="line">docker image inspect ubuntu:22.04 alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用格式输出只查看镜像的架构信息</span></span><br><span class="line">docker image inspect -f <span class="string">&#x27;&#123;&#123;.Architecture&#125;&#125;&#x27;</span> nginx:1.23.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像的创建时间</span></span><br><span class="line">docker image inspect -f <span class="string">&#x27;&#123;&#123;.Created&#125;&#125;&#x27;</span> nginx:1.23.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像的所有层（Layer）</span></span><br><span class="line">docker image inspect -f <span class="string">&#x27;&#123;&#123;.RootFS.Layers&#125;&#125;&#x27;</span> nginx:1.23.3</span><br></pre></td></tr></table></figure></li></ul><h3><span id="63-docker-tag">6.3 <code>docker tag</code></span></h3><ul><li><p><strong>功能</strong><br>为本地镜像创建新的标签，通常用于为镜像添加仓库地址前缀，为推送镜像到仓库做准备。</p></li><li><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure></li><li><p><strong>别名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag</span><br></pre></td></tr></table></figure></li><li><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为本地镜像添加新的标签</span></span><br><span class="line">docker tag ubuntu:22.04 myregistry.com/myubuntu:22.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为镜像添加版本标签</span></span><br><span class="line">docker tag nginx nginx:1.23.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为镜像添加多个标签</span></span><br><span class="line">docker tag myapp:latest myregistry.com/myapp:v1.0</span><br><span class="line">docker tag myapp:latest myregistry.com/myapp:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到私有仓库前的标签准备</span></span><br><span class="line">docker tag local-image:tag your-private-registry.com/username/repository:tag</span><br></pre></td></tr></table></figure></li><li><p><strong>注意事项</strong></p><ul><li><code>docker tag</code> 并不会创建新的镜像，只是为现有镜像添加了一个新的引用名称</li><li>同一个镜像可以有多个标签，它们共享相同的镜像 ID</li><li>删除一个标签不会删除镜像本身，只有当所有标签都被删除时，镜像才会被真正删除</li><li>在推送镜像到仓库前，必须使用 <code>docker tag</code> 为镜像添加包含仓库地址的完整名称</li></ul></li></ul><h2><span id="七-容器命令">七、容器命令</span></h2><h3><span id="73-docker-run">7.3 docker run</span></h3><h4><span id="功能">功能</span></h4><p>创建一个新的容器并运行一个命令。这是 Docker 中最常用且最重要的命令之一，用于从镜像启动容器实例。</p><h4><span id="语法">语法</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><h4><span id="别名">别名</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run</span><br></pre></td></tr></table></figure><h4><span id="关键参数详解">关键参数详解</span></h4><h5><span id="运行模式控制">运行模式控制</span></h5><ul><li><p><strong><code>-d, --detach</code></strong>：后台运行容器，并返回容器 ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p><strong><code>-i, --interactive</code></strong>：以交互模式运行容器，保持 STDIN 打开。</p></li><li><p><strong><code>-t, --tty</code></strong>：为容器分配一个伪终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常 -i 和 -t 一起使用，实现交互式终端</span></span><br><span class="line">docker run -it ubuntu:22.04 bash</span><br></pre></td></tr></table></figure></li></ul><h5><span id="容器标识">容器标识</span></h5><ul><li><p><strong><code>--name</code></strong>：为容器指定一个名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my-nginx nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p><strong><code>-h, --hostname</code></strong>：指定容器的 hostname。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -h myhost ubuntu:22.04</span><br><span class="line"><span class="comment"># 查看容器内的 hostname</span></span><br><span class="line">root@myhost:/# hostname</span><br><span class="line">  myhost</span><br></pre></td></tr></table></figure></li></ul><h5><span id="端口映射">端口映射</span></h5><ul><li><p><strong><code>-P, --publish-all</code></strong>：将容器暴露的所有端口随机映射到主机端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P nginx  <span class="comment"># 映射到随机主机端口</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>-p, --publish</code></strong>：指定端口映射，格式：<code>主机端口:容器端口</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 nginx        <span class="comment"># 主机8080 → 容器80</span></span><br><span class="line">docker run -p 80:80 nginx          <span class="comment"># 主机80 → 容器80</span></span><br><span class="line">docker run -p 127.0.0.1:8080:80 nginx  <span class="comment"># 仅本地访问</span></span><br></pre></td></tr></table></figure></li></ul><h5><span id="资源限制">资源限制</span></h5><ul><li><p><strong><code>--cpuset-cpus</code></strong>：绑定容器到指定 CPU 运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --cpuset-cpus=<span class="string">&quot;0-2&quot;</span> ubuntu  <span class="comment"># 使用0-2号CPU</span></span><br><span class="line">docker run --cpuset-cpus=<span class="string">&quot;0,1&quot;</span> ubuntu   <span class="comment"># 使用0和1号CPU</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>-m, --memory</code></strong>：设置容器使用内存最大值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/docker_test/namespace_test/test_dir2] - [1590]</span><br><span class="line">└─[$] docker run -d -m 512m nginx:stable-alpine3.21-perl      <span class="comment"># 限制512MB内存</span></span><br><span class="line">844e981eb908a6208d2531732444da829408f718349c27ca57c25c2eac987d85</span><br><span class="line"><span class="comment"># 查看容器资源使用情况</span></span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/docker_test/namespace_test/test_dir2] - [1590]</span><br><span class="line">└─[$] docker stats 844e981eb908a6208d2531732444da829408f718349c27ca57c25c2eac987d85</span><br><span class="line">CONTAINER ID   NAME                CPU %     MEM USAGE / LIMIT   MEM %     NET I/O       BLOCK I/O     PIDS</span><br><span class="line">844e981eb908   boring_mirzakhani   0.00%     2.957MiB / 512MiB   0.58%     876B / 126B   0B / 12.3kB   3</span><br></pre></td></tr></table></figure></li></ul><h5><span id="环境变量">环境变量</span></h5><ul><li><p><strong><code>-e, --env</code></strong>：设置环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -e MY_VAR=value ubuntu</span><br><span class="line">docker run -e DATABASE_URL=postgres://user:pass@host/db app</span><br></pre></td></tr></table></figure></li></ul><h5><span id="容器链接">容器链接</span></h5><ul><li><p><strong><code>--link</code></strong>：添加链接到另一个容器（已逐渐被网络功能替代）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">link</span> redis-container:redis app</span><br></pre></td></tr></table></figure></li></ul><h5><span id="容器生命周期">容器生命周期</span></h5><ul><li><p><strong><code>--rm</code></strong>：容器退出时自动删除容器文件系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时测试用，退出后自动清理</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -it ubuntu:22.04 /bin/bash</span><br></pre></td></tr></table></figure></li></ul><h4><span id="使用示例">使用示例</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后台运行nginx容器，命名为web，映射端口80</span></span><br><span class="line">docker run -d --name web -p 80:80 nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式运行ubuntu容器，退出后自动删除</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -it ubuntu:22.04 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器并设置环境变量</span></span><br><span class="line">docker run -e ENV=production -e DEBUG=<span class="literal">false</span> myapp:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制容器资源使用</span></span><br><span class="line">docker run -m 512m --cpuset-cpus=<span class="string">&quot;0-1&quot;</span> resource-limited-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定主机名和端口映射</span></span><br><span class="line">docker run -h myapp -p 8080:3000 myapp:latest</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li>如果没有指定 <code>COMMAND</code>，容器将运行镜像中定义的默认命令</li><li>使用 <code>-d</code> 后台运行时，可以使用 <code>docker logs</code> 查看输出</li><li><code>--rm</code> 选项适合临时测试，生产环境通常需要持久化容器</li><li>端口映射时确保主机端口没有被其他进程占用</li><li>资源限制参数有助于防止单个容器消耗过多主机资源</li></ol><h3><span id="74-docker-ps">7.4 docker ps</span></h3><h4><span id="功能">功能</span></h4><p>列出容器。这是 Docker 中最常用的监控和管理命令之一，用于查看当前容器运行状态。</p><h4><span id="语法">语法</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><h4><span id="别名">别名</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line">docker container list</span><br><span class="line">docker container ps</span><br></pre></td></tr></table></figure><h4><span id="关键参数详解">关键参数详解</span></h4><h5><span id="显示范围控制">显示范围控制</span></h5><ul><li><p><strong><code>-a, --all</code></strong>：显示所有容器，包括停止的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p><strong><code>-f, --filter</code></strong>：根据条件过滤显示结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f <span class="string">&quot;name=web&quot;</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=running&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>-n, --last</code></strong>：显示最近创建的 n 个容器（包括所有状态）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -n 3</span><br></pre></td></tr></table></figure></li></ul><h5><span id="显示格式控制">显示格式控制</span></h5><ul><li><p><strong><code>-q, --quiet</code></strong>：只显示容器 ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -q</span><br></pre></td></tr></table></figure></li><li><p><strong><code>--no-trunc</code></strong>：显示完整信息，不截断输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps --no-trunc</span><br></pre></td></tr></table></figure></li><li><p><strong><code>--format</code></strong>：使用 Go 模板格式化输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>-s, --size</code></strong>：显示容器文件大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -s</span><br></pre></td></tr></table></figure></li></ul><h5><span id="时间显示">时间显示</span></h5><ul><li><p><strong><code>-l, --latest</code></strong>：显示最近创建的容器（包括所有状态）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l</span><br></pre></td></tr></table></figure></li></ul><h4><span id="输出列说明">输出列说明</span></h4><p>执行 <code>docker ps</code> 后显示的表格包含以下重要列：</p><table><thead><tr><th>列名</th><th>说明</th></tr></thead><tbody><tr><td><strong>CONTAINER ID</strong></td><td>容器的唯一标识符（通常显示前 12 位）</td></tr><tr><td><strong>IMAGE</strong></td><td>创建容器所使用的镜像名称</td></tr><tr><td><strong>COMMAND</strong></td><td>容器启动时运行的命令</td></tr><tr><td><strong>CREATED</strong></td><td>容器创建时间</td></tr><tr><td><strong>STATUS</strong></td><td>容器状态（Up 表示运行中，Exited 表示已退出）</td></tr><tr><td><strong>PORTS</strong></td><td>端口映射信息</td></tr><tr><td><strong>NAMES</strong></td><td>容器名称</td></tr></tbody></table><h4><span id="过滤器常用用法">过滤器常用用法</span></h4><p>过滤器是 <code>docker ps</code> 的强大功能，支持多种过滤条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按名称过滤</span></span><br><span class="line">docker ps -f <span class="string">&quot;name=web&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按状态过滤</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=running&quot;</span>   <span class="comment"># 运行中的容器</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=exited&quot;</span>    <span class="comment"># 已停止的容器</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=created&quot;</span>   <span class="comment"># 已创建但未运行的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按镜像过滤</span></span><br><span class="line">docker ps -f <span class="string">&quot;ancestor=nginx&quot;</span>   <span class="comment"># 使用nginx镜像的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按退出代码过滤</span></span><br><span class="line">docker ps -a -f <span class="string">&quot;exited=0&quot;</span>      <span class="comment"># 正常退出的容器</span></span><br><span class="line">docker ps -a -f <span class="string">&quot;exited=1&quot;</span>      <span class="comment"># 异常退出的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按标签过滤</span></span><br><span class="line">docker ps -f <span class="string">&quot;label=environment=production&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合多个过滤器</span></span><br><span class="line">docker ps -f <span class="string">&quot;name=db&quot;</span> -f <span class="string">&quot;status=running&quot;</span></span><br></pre></td></tr></table></figure><h4><span id="格式化输出示例">格式化输出示例</span></h4><p>使用 <code>--format</code> 参数可以自定义输出格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示ID和名称</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示ID、名称、状态和端口</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以JSON格式输出</span></span><br><span class="line">docker ps --format <span class="string">&quot;&#123;&#123;json .&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义表格标题</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span> --format <span class="string">&quot;ID\tNAME\tSTATUS&quot;</span></span><br></pre></td></tr></table></figure><h4><span id="使用示例">使用示例</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器（包括已停止的）</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最近创建的2个容器</span></span><br><span class="line">docker ps -n 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示运行中容器的ID</span></span><br><span class="line">docker ps -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看名称包含&quot;web&quot;的容器</span></span><br><span class="line">docker ps -f <span class="string">&quot;name=web&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有异常退出的容器</span></span><br><span class="line">docker ps -a -f <span class="string">&quot;exited=1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示容器大小信息</span></span><br><span class="line">docker ps -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义格式输出</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4><span id="实际应用场景">实际应用场景</span></h4><ol><li><p><strong>快速查看容器状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日常监控</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p><strong>查找特定容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找MySQL容器</span></span><br><span class="line">docker ps -f <span class="string">&quot;name=mysql&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>批量操作容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有运行中的容器</span></span><br><span class="line">docker stop $(docker ps -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有已停止的容器</span></span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q -f <span class="string">&quot;status=exited&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>故障排查</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看异常退出的容器</span></span><br><span class="line">docker ps -a -f <span class="string">&quot;exited=1&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>资源监控</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器占用空间</span></span><br><span class="line">docker ps -s</span><br></pre></td></tr></table></figure></li></ol><h4><span id="注意事项">注意事项</span></h4><ol><li>默认情况下 <code>docker ps</code> 只显示运行中的容器</li><li>使用 <code>-a</code> 参数可以查看所有状态的容器</li><li>过滤器功能非常强大，可以组合多个条件进行精确查询</li><li>格式化输出适合编写脚本和自动化工具</li><li>容器 ID 的前几个字符通常就足够唯一标识一个容器</li></ol><p><code>docker ps</code> 是 Docker 日常管理中最基础且重要的命令，熟练掌握其各种参数和用法能够极大提高容器管理效率。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端工具 </category>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 底层关键技术-namespace &amp;&amp; cgroup</title>
      <link href="/2025/08/23/Docker/docker_key_tech/"/>
      <url>/2025/08/23/Docker/docker_key_tech/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#namespace">namespace</a><ul><li><a href="#dd-%E5%91%BD%E4%BB%A4">dd 命令</a></li><li><a href="#mkfs-%E5%91%BD%E4%BB%A4">mkfs 命令</a></li><li><a href="#df-%E5%91%BD%E4%BB%A4">df 命令</a></li><li><a href="#mount-%E5%91%BD%E4%BB%A4">mount 命令</a></li><li><a href="#unshare-%E5%91%BD%E4%BB%A4">unshare 命令</a></li><li><a href="#mount-%E9%9A%94%E7%A6%BB">mount 隔离</a></li></ul></li><li><a href="#cgroup">cgroup</a><ul><li><a href="#%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E6%8C%82%E8%BD%BD%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C">管理基础：挂载与目录操作</a></li><li><a href="#%E5%AE%9E%E6%88%98%E4%BD%BF%E7%94%A8-cgroup-v2-%E9%99%90%E5%88%B6-cpu-%E4%BD%BF%E7%94%A8%E7%8E%87">实战：使用 cgroup v2 限制 CPU 使用率</a></li><li><a href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BC%98%E5%8A%BF">核心特性与优势</a></li></ul></li></ul><!-- tocstop --><h2><span id="namespace">namespace</span></h2><p><code>Linux Namespace</code> 是 <code>Linux</code> 内核提供的一种内核级别环境隔离机制。它的主要目的是将全局的系统资源包装在一个抽象的隔离空间中，使得从每个 <code>Namespace</code> 内部看来，它都拥有自己独立的全局资源实例。</p><p>你可以把它想象成一种“障眼法”：它对进程“撒谎”，让一组进程“看到”一套独立的系统资源，而另一组进程“看到”另一套完全不同的资源。这些被隔离的资源包括进程 ID、主机名、用户 ID、网络接口、文件系统挂载点等。</p><p>核心目标：实现轻量级虚拟化（容器化），让一个进程或一组进程在一个隔离的运行环境中运行，而无需启动完整的虚拟机。这正是 <code>Docker</code>、<code>LXC</code>、<code>Kubernetes</code> 等容器技术的基石。</p><h3><span id="dd-命令">dd 命令</span></h3><p><code>dd</code> 是一个命令行工具，用于在 Unix 和类 Unix 操作系统（如 Linux）上<strong>转换和复制文件</strong>。它的名字源于 IBM 的 Job Control Language (JCL) 语句 “Data Definition”，但其功能更像是“磁盘转储”（Disk Dump）或“数据复制器”。</p><p>它的核心功能是<strong>按块</strong>从输入文件（<code>if</code>）读取数据，进行可能的转换，然后写入输出文件（<code>of</code>）。由于其底层操作的特性和灵活性，它成为了系统管理员、开发者和高级用户进行各种低级磁盘操作的瑞士军刀。</p><hr><h4><span id="命令语法">命令语法</span></h4><p>基本语法非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=&lt;输入文件&gt; of=&lt;输出文件&gt; [选项]</span><br></pre></td></tr></table></figure><ul><li><code>if=</code>： input file，输入文件。默认为标准输入（stdin）。</li><li><code>of=</code>： output file，输出文件。默认为标准输出（stdout）。</li></ul><hr><h4><span id="核心常用选项">核心常用选项</span></h4><table><thead><tr><th align="left">选项</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>bs=</code></td><td align="left"><strong>block size</strong>： 同时设置输入和输出的块大小。这是最重要的选项之一，极大影响性能。</td><td align="left"><code>bs=4M</code></td></tr><tr><td align="left"><code>count=</code></td><td align="left">要复制的<strong>块的数量</strong>。</td><td align="left"><code>count=1</code></td></tr><tr><td align="left"><code>skip=</code></td><td align="left">从输入文件开头<strong>跳过</strong>的块数。</td><td align="left"><code>skip=1</code></td></tr><tr><td align="left"><code>seek=</code></td><td align="left">在输出文件开头<strong>跳过</strong>的块数。</td><td align="left"><code>seek=1</code></td></tr><tr><td align="left"><code>status=</code></td><td align="left">显示进度信息的级别。<code>progress</code> 显示周期性进度，<code>none</code> 不显示。</td><td align="left"><code>status=progress</code></td></tr><tr><td align="left"><code>conv=</code></td><td align="left"><strong>转换</strong>参数，用逗号分隔多个。最常用的是 <code>fsync</code>（确保数据物理写入）和 <code>nocreat</code>（不创建输出文件）。</td><td align="left"><code>conv=fsync</code></td></tr></tbody></table><hr><p><code>status</code> 选项的作用</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <p><code>status=progress</code> 的作用就像一个<strong>实时仪表盘</strong>，它的核心价值是<strong>提供反馈</strong>。</p><p>当你运行一个需要很长时间的 <code>dd</code> 命令时（比如复制整个硬盘），终端会<strong>看起来完全卡住</strong>，没有任何输出，只有一个闪烁的光标。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=/dev/sdb bs=4M</span><br><span class="line"><span class="comment"># 按下回车后... 一片寂静，可能持续几十分钟甚至几个小时</span></span><br></pre></td></tr></table></figure><p><strong>用户的感受：</strong></p><ul><li>“它还在工作吗？”</li><li>“是死机了吗？”</li><li>“我要不要强制终止它？”</li><li>“已经复制了多少？还剩多少时间？”</li></ul><p>这种不确定性非常令人焦虑，尤其是在处理重要数据时。</p><p>加上这个选项后，<code>dd</code> 会定期（通常是每秒）向标准错误输出（stderr）打印一行进度信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=/dev/sdb bs=4M status=progress</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">987425382 bytes (987 MB, 942 MiB) copied, 15 s, 65.8 MB/s</span><br></pre></td></tr></table></figure><p>或者更现代的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">467854336 bytes (468 MB, 446 MiB, 112384 sectors) copied, 9.12321 s, 51.3 MB/s</span><br></pre></td></tr></table></figure><p>再或者（使用 <code>oflag=direct</code> 等时）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2838312960 bytes (2.8 GB, 2.6 GiB) copied, 12.4323 s, 228 MB/s</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">467854336 bytes (468 MB, 446 MiB, 112384 sectors) copied, 9.12321 s, 51.3 MB/s</span><br></pre></td></tr></table></figure><p>再或者（使用 <code>oflag=direct</code> 等时）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2838312960 bytes (2.8 GB, 2.6 GiB) copied, 12.4323 s, 228 MB/s</span><br></pre></td></tr></table></figure><p><strong>这行信息包含了极其有用的情报：</strong></p><ul><li><strong><code>987425382 bytes</code></strong>： <strong>已经复制了多少数据</strong>。你知道工作正在推进。</li><li><strong><code>15 s</code></strong>： <strong>已经运行了多长时间</strong>。</li><li><strong><code>65.8 MB/s</code></strong>： <strong>当前的传输速率</strong>。这是性能调试的关键指标。如果速度远低于你的磁盘性能，可能意味着遇到了瓶颈（比如加密、压缩、网络等）。</li><li><strong>(942 MiB)</strong>： 同时用二进制单位（MiB&#x2F;GiB）显示，更直观。</li></ul><p>所以，虽然 <code>status=progress</code> 不改变 <code>dd</code> 命令的<strong>实质</strong>，但它极大地改善了使用 <code>dd</code> 命令的<strong>体验</strong>和<strong>可观测性</strong>。<strong>强烈建议在任何需要等待的 <code>dd</code> 命令中都加上它</strong>。</p>    </div></div><h4><span id="经典实用示例">经典实用示例</span></h4><h5><span id="1-制作启动盘最经典的用途">1. 制作启动盘（最经典的用途）</span></h5><p>将 ISO 镜像文件写入 U 盘 (<code>/dev/sdb</code>)。<strong>警告：操作前务必确认目标设备，否则可能导致数据丢失！</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=ubuntu-22.04.iso of=/dev/sdb bs=4M status=progress oflag=<span class="built_in">sync</span></span><br></pre></td></tr></table></figure><ul><li><code>if=ubuntu-22.04.iso</code>: 输入是 ISO 镜像文件。</li><li><code>of=/dev/sdb</code>: 输出是整个 U 盘设备（<strong>不是分区</strong>，如 <code>/dev/sdb1</code>）。</li><li><code>bs=4M</code>: 使用 4MiB 的大块进行读写，提高速度。</li><li><code>status=progress</code>: 显示复制进度和速度。</li><li><code>oflag=sync</code>: 确保每次写入都同步到物理介质，保证数据完整性。</li></ul><h5><span id="2-磁盘x2f分区备份与还原">2. 磁盘&#x2F;分区备份与还原</span></h5><p><strong>备份整个磁盘（例如 <code>/dev/sda</code>）到一个镜像文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=/path/to/backup.img bs=4M status=progress</span><br></pre></td></tr></table></figure><p><strong>从镜像文件还原到磁盘：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/path/to/backup.img of=/dev/sda bs=4M status=progress</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 对于包含大量空块的磁盘（如虚拟机磁盘），使用 <code>gzip</code> 压缩会更高效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份并压缩</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda bs=4M | gzip &gt; /path/to/backup.img.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压并还原</span></span><br><span class="line">gzip -dc /path/to/backup.img.gz | <span class="built_in">sudo</span> <span class="built_in">dd</span> of=/dev/sda bs=4M status=progress</span><br></pre></td></tr></table></figure><h5><span id="3-测试磁盘读写速度">3. 测试磁盘读写速度</span></h5><p><strong>测试写入速度：</strong><br>创建一个 1GB 的文件，测试写入性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./testfile bs=1G count=1 oflag=direct</span><br></pre></td></tr></table></figure><ul><li><code>if=/dev/zero</code>: 提供无限的空字符（0x00）。</li><li><code>of=./testfile</code>: 输出到当前目录的 testfile。</li><li><code>bs=1G count=1</code>: 写一个 1GiB 的块。</li><li><code>oflag=direct</code>: 使用直接 I&#x2F;O，绕过系统缓存，得到更真实的磁盘速度。</li></ul><p><strong>测试读取速度：</strong><br>读取刚才创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=./testfile of=/dev/null bs=1G count=1 iflag=direct</span><br></pre></td></tr></table></figure><ul><li><code>of=/dev/null</code>: 相当于一个数据黑洞，丢弃所有写入的数据。</li><li><code>iflag=direct</code>: 使用直接 I&#x2F;O 读取。</li></ul><h5><span id="4-安全擦除磁盘数据">4. 安全擦除磁盘数据</span></h5><p>用随机数据覆盖整个磁盘，使其难以恢复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=/dev/sdX bs=4M status=progress</span><br></pre></td></tr></table></figure><ul><li><code>if=/dev/urandom</code>: 提供高质量的随机数据。</li><li><code>of=/dev/sdX</code>: 目标设备。</li></ul><p>（对于快速擦除，用零覆盖一次通常就足够了）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/sdX bs=4M status=progress</span><br></pre></td></tr></table></figure><h5><span id="5-转换文件内容">5. 转换文件内容</span></h5><p><strong>将文件转换为大写：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=input.txt of=output.txt conv=ucase</span><br></pre></td></tr></table></figure><p><strong>将 EBCDIC 编码的文件转换为 ASCII：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=ebcdic_file.txt of=ascii_file.txt conv=ascii</span><br></pre></td></tr></table></figure><h5><span id="6-仅复制磁盘的-mbr主引导记录">6. 仅复制磁盘的 MBR（主引导记录）</span></h5><p>MBR 通常位于磁盘的第一个扇区（512 字节）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份 MBR</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=mbr_backup.bak bs=512 count=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原 MBR</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=mbr_backup.bak of=/dev/sda bs=512 count=1</span><br></pre></td></tr></table></figure><h5><span id="7-创建特定大小的空文件">7. 创建特定大小的空文件</span></h5><p>快速创建一个充满零的 100MB 文件，用于测试或占位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=test.file bs=1M count=100</span><br></pre></td></tr></table></figure><hr><h4><span id="注意事项和警告">注意事项和警告</span></h4><ol><li><strong>极具破坏性</strong>： <code>dd</code> 命令不会询问确认。如果你将 <code>of=</code>（输出目标）指定错了（比如是你的系统盘），它就会毫不犹豫地覆盖并销毁所有数据。<strong>“Double-check before you press Enter!”</strong>（按下回车前务必双重检查！）</li><li><strong>理解设备名</strong>： 在操作 <code>/dev/sdX</code> 这样的块设备时，务必使用 <code>lsblk</code> 或 <code>fdisk -l</code> 命令确认设备标识符。</li><li><strong>性能优化</strong>： <code>bs</code>（块大小）的设置对性能影响巨大。太小的值（如 512Bytes）会导致大量 I&#x2F;O 操作，降低速度。太大的值可能会超出系统缓存。通常 <code>1M</code> 到 <code>8M</code> 是一个很好的起点。使用 <code>status=progress</code> 来观察速度。</li><li><strong>数据完整性</strong>： 在写入重要数据（如制作启动盘）后，使用 <code>oflag=sync</code> 或 <code>conv=fsync</code> 来确保所有数据都从内存缓冲区刷新到了物理设备上。</li></ol><h3><span id="mkfs-命令">mkfs 命令</span></h3><p><strong><code>mkfs</code></strong> 是 <strong>MaKe FileSystem</strong> 的缩写。它的作用就是在<strong>块设备</strong>（如硬盘分区、U 盘、软盘）或<strong>镜像文件</strong>上<strong>创建（格式化）一个文件系统</strong>。</p><p>您可以把它想象成：在一块已经划分好的“土地”（分区）上，按照特定的“规划和布局”（文件系统类型，如 ext4, FAT32）修建一座“城市”的基础设施（文件系统结构）。在这之后，您才能在上面“存放人员和物资”（存储文件）。</p><hr><h4><span id="命令格式与工作原理">命令格式与工作原理</span></h4><p><code>mkfs</code> 其实是一个<strong>前端工具</strong>，它本身并不直接完成所有工作，而是会去调用相应的特定文件系统创建工具。</p><p><strong>基本语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs [选项] [-t 文件系统类型] [设备名] [块数]</span><br></pre></td></tr></table></figure><ul><li><code>-t 文件系统类型</code>： 指定要创建的文件系统，如 <code>ext4</code>, <code>xfs</code>, <code>vfat</code> 等。</li><li><code>设备名</code>： 要在哪个设备上创建文件系统，例如 <code>/dev/sdb1</code>。</li><li><code>块数</code>： 很少手动指定，通常使用整个设备。</li></ul><p><strong>例如，当你执行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure><p><code>mkfs</code> 会实际上调用更专门的程序 <code>mkfs.ext4</code> 来完成工作。这就是为什么你也会经常看到直接调用 <code>mkfs.&lt;类型&gt;</code> 的命令格式。</p><hr><h4><span id="常用文件系统类型">常用文件系统类型</span></h4><table><thead><tr><th align="left">类型</th><th align="left">命令</th><th align="left">描述</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>ext4</strong></td><td align="left"><code>mkfs.ext4</code></td><td align="left">Linux 最主流、最稳定的日志文件系统。</td><td align="left">Linux 系统根分区、家用、通用服务器。</td></tr><tr><td align="left"><strong>XFS</strong></td><td align="left"><code>mkfs.xfs</code></td><td align="left">高性能日志文件系统，擅长处理大文件。</td><td align="left">大型服务器、数据库、视频编辑。</td></tr><tr><td align="left"><strong>Btrfs</strong></td><td align="left"><code>mkfs.btrfs</code></td><td align="left">先进的功能性文件系统，支持写时复制、快照、压缩等。</td><td align="left">需要高级功能的桌面用户或服务器。</td></tr><tr><td align="left"><strong>vFAT</strong></td><td align="left"><code>mkfs.vfat</code></td><td align="left">兼容性最好的文件系统，无权限设置。</td><td align="left">U 盘、SD 卡，需要在 Windows&#x2F;Linux&#x2F;Mac 间交叉使用。</td></tr><tr><td align="left"><strong>NTFS</strong></td><td align="left"><code>mkfs.ntfs</code></td><td align="left">Windows 现代文件系统，支持大文件和 ACL。</td><td align="left">主要用于 Windows 系统分区，Linux 也可读写。</td></tr><tr><td align="left"><strong>exFAT</strong></td><td align="left"><code>mkfs.exfat</code></td><td align="left">微软为闪存设备设计的文件系统，比 FAT32 支持更大文件。</td><td align="left">大容量 U 盘、移动硬盘，用于跨平台交换大文件。</td></tr></tbody></table><hr><h4><span id="常用选项">常用选项</span></h4><p>这些选项通常用于直接调用 <code>mkfs.&lt;类型&gt;</code> 命令时。</p><table><thead><tr><th align="left">选项</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-L</code></td><td align="left"><code>-L MYDATA</code></td><td align="left">为文件系统设置一个<strong>卷标</strong>，便于用标签挂载而非设备名。</td></tr><tr><td align="left"><code>-c</code></td><td align="left"><code>-c</code></td><td align="left">在创建文件系统前检查设备是否有<strong>坏块</strong>。</td></tr><tr><td align="left"><code>-q</code></td><td align="left"><code>-q</code></td><td align="left"><strong>安静</strong>模式，减少输出信息。</td></tr><tr><td align="left"><code>-f</code></td><td align="left"><code>-f</code></td><td align="left"><strong>强制</strong>创建，即使参数可能有问题也会尝试。</td></tr><tr><td align="left"><code>-N</code></td><td align="left"><code>-N 10000</code></td><td align="left">显式指定 inode 的数量（文件数量的上限）。</td></tr></tbody></table><hr><h4><span id="重要警告与前提">重要警告与前提</span></h4><p><strong>&#96;mkfs 命令会永久销毁目标设备上的所有现有数据！</strong><br>格式化之前，<strong>必须</strong>：</p><ol><li><strong>确认设备名</strong>： 使用 <code>lsblk</code>、<code>fdisk -l</code> 等命令<strong>双重、三重确认</strong>你要格式化的设备是否正确。</li><li><strong>卸载设备</strong>： 确保该设备没有被系统挂载 (<code>umount /dev/sdb1</code>)。对已挂载的设备进行格式化会导致严重错误。</li></ol><hr><h4><span id="实用示例">实用示例</span></h4><h5><span id="示例-1将-u-盘格式化为-fat32最大兼容性">示例 1：将 U 盘格式化为 FAT32（最大兼容性）</span></h5><p>假设 U 盘被识别为 <code>/dev/sdb1</code>（<strong>请务必确认！</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先卸载</span></span><br><span class="line"><span class="built_in">sudo</span> umount /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再格式化为 FAT32，并设置卷标为“MYUSB”</span></span><br><span class="line"><span class="built_in">sudo</span> mkfs -t vfat -n MYUSB /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接使用 mkfs.vfat</span></span><br><span class="line"><span class="built_in">sudo</span> mkfs.vfat -n MYUSB /dev/sdb1</span><br></pre></td></tr></table></figure><h5><span id="示例-2将分区格式化为-linux-常用的-ext4">示例 2：将分区格式化为 Linux 常用的 ext4</span></h5><p>假设要格式化的分区是 <code>/dev/sdc1</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> umount /dev/sdc1</span><br><span class="line"><span class="built_in">sudo</span> mkfs -t ext4 -L BackupDrive /dev/sdc1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更常见的直接用法</span></span><br><span class="line"><span class="built_in">sudo</span> mkfs.ext4 -L BackupDrive /dev/sdc1</span><br></pre></td></tr></table></figure><h5><span id="示例-3创建-xfs-文件系统">示例 3：创建 XFS 文件系统</span></h5><p>XFS 是很多企业级应用的首选。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> umount /dev/sdd1</span><br><span class="line"><span class="built_in">sudo</span> mkfs.xfs -f -L Database /dev/sdd1</span><br><span class="line"><span class="comment"># `-f` 强制创建，如果设备上已有文件系统则需要此选项</span></span><br></pre></td></tr></table></figure><h5><span id="示例-4检查坏块后再格式化">示例 4：检查坏块后再格式化</span></h5><p>这是一个好习惯，尤其对于新旧不明的硬盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.ext4 -c /dev/sde1</span><br><span class="line"><span class="comment"># 这个过程会很久，因为它会先扫描整个设备的坏道</span></span><br></pre></td></tr></table></figure><h5><span id="示例-5格式化一个镜像文件">示例 5：格式化一个镜像文件</span></h5><p>你不仅可以格式化设备，也可以格式化一个文件（通常需要先关联到 loop 设备）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 1G 的空文件</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=my-disk.img bs=1M count=1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这个文件格式化为 ext4</span></span><br><span class="line">mkfs.ext4 my-disk.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载这个镜像文件来使用它</span></span><br><span class="line"><span class="built_in">sudo</span> mount -o loop my-disk.img /mnt</span><br></pre></td></tr></table></figure><hr><h4><span id="mkfs-执行成功后你会看到什么"><code>mkfs</code> 执行成功后你会看到什么？</span></h4><p>运行 <code>sudo mkfs.ext4 /dev/sdb1</code> 后，你会看到类似如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mke2fs 1.46.5 (30-Dec-2021)</span><br><span class="line">Creating filesystem with 2621440 4k blocks and 655360 inodes</span><br><span class="line">Filesystem UUID: 6e5cff33-5f3d-4a86-b965-85c821a9e6b7</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span></span><br><span class="line">Writing inode tables: <span class="keyword">done</span></span><br><span class="line">Creating journal (16384 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这些信息告诉你文件系统的基本参数：块数、inode 数、UUID、超级块备份位置等。</p><hr><ul><li><strong><code>mkfs</code></strong> 是用于<strong>创建文件系统</strong>的命令，也就是高级格式化。</li><li>它是一个<strong>前端</strong>，实际调用的是 <code>mkfs.ext4</code>、<code>mkfs.xfs</code> 等具体工具。</li><li><strong>使用前务必确认设备未挂载且设备名正确</strong>，否则会导致数据丢失。</li><li>根据使用场景（Linux 专用、跨平台、大文件性能）选择合适的文件系统类型。</li><li>常用的选项包括设置卷标 <code>-L</code> 和检查坏块 <code>-c</code>。</li></ul><h3><span id="df-命令">df 命令</span></h3><p><strong><code>df</code></strong> 是 <strong>Disk Filesystem</strong> 的缩写。它的主要功能是<strong>报告文件系统的磁盘空间使用情况</strong>。简单来说，它告诉你：</p><ol><li><strong>系统上有哪些磁盘&#x2F;分区</strong>（文件系统）已经被挂载了。</li><li><strong>每个磁盘&#x2F;分区总共有多少空间</strong>。</li><li><strong>已经使用了多少空间</strong>。</li><li><strong>还剩下多少可用空间</strong>。</li><li><strong>它们被挂载到了哪个目录</strong>（挂载点）。</li></ol><p>它是监控磁盘空间、防止磁盘被写满导致系统问题的首选工具。</p><hr><h4><span id="命令语法">命令语法</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> [选项] [文件或目录]</span><br></pre></td></tr></table></figure><ul><li>如果不加任何参数，<code>df</code> 会显示所有<strong>已挂载</strong>的文件系统的使用情况。</li><li>如果指定了<code>文件或目录</code>，<code>df</code> 会报告该文件或目录所在的文件系统的空间情况。</li></ul><hr><h4><span id="核心常用选项">核心常用选项</span></h4><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-h</code></td><td align="left"><strong>人类可读</strong>模式。以易读的单位（K, M, G, T）显示大小，而不是单纯的块数。<strong>这是最常用的选项。</strong></td></tr><tr><td align="left"><code>-T</code></td><td align="left"><strong>显示文件系统类型</strong>。会在输出中增加一列 <code>Type</code>，显示是 ext4, xfs, tmpfs 还是其他类型。</td></tr><tr><td align="left"><code>-i</code></td><td align="left"><strong>显示 inode 信息</strong>而不是块使用情况。可以查看文件数量是否达到上限。</td></tr><tr><td align="left"><code>-x [类型]</code></td><td align="left"><strong>排除</strong>指定类型的文件系统。例如 <code>-x tmpfs</code> 不显示临时文件系统。</td></tr><tr><td align="left"><code>--total</code></td><td align="left">在输出结果的末尾添加一行<strong>总计</strong>信息。</td></tr><tr><td align="left"><code>-a</code></td><td align="left"><strong>显示所有</strong>文件系统，包括那些大小为 0 的伪文件系统（如 <code>/proc</code>, <code>/sys</code>）。</td></tr></tbody></table><hr><h4><span id="输出列解读">输出列解读</span></h4><p>当你运行 <code>df -h</code>，你会看到类似这样的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev            3.9G     0  3.9G    0% /dev</span><br><span class="line">tmpfs           787M  2.1M  785M    1% /run</span><br><span class="line">/dev/nvme0n1p2  234G   65G  157G   30% /</span><br><span class="line">tmpfs           3.9G   87M  3.8G    3% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">/dev/nvme0n1p1  511M  6.1M  505M    2% /boot/efi</span><br><span class="line">tmpfs           787M   88K  787M    1% /run/user/1000</span><br></pre></td></tr></table></figure><p>各列的含义如下：</p><ul><li><strong>文件系统</strong>： 磁盘设备的名称（如 <code>/dev/nvme0n1p2</code>）或特殊文件系统（如 <code>tmpfs</code>, <code>udev</code>）。</li><li><strong>容量</strong>： 该文件系统的<strong>总大小</strong>。</li><li><strong>已用</strong>： 已经使用了多少空间。</li><li><strong>可用</strong>： <strong>剩余可用的空间</strong>。这是最需要关注的列，防止它变为 0。</li><li><strong>已用%</strong>： 已用空间占总空间的百分比。一眼就能看出哪个盘快满了。</li><li><strong>挂载点</strong>： 该文件系统被挂载到了哪个目录。例如，根分区 <code>/</code> 是系统最重要的挂载点。</li></ul><hr><h4><span id="实用示例">实用示例</span></h4><h5><span id="示例-1最基本用法人类可读格式">示例 1：最基本用法（人类可读格式）</span></h5><p>这是<strong>最常用</strong>的命令，没有之一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><p>输出易于阅读，快速查看所有磁盘的使用情况。</p><h5><span id="示例-2查看特定目录所在分区的空间">示例 2：查看特定目录所在分区的空间</span></h5><p>比如你想知道 <code>/home</code> 目录还有多少空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h /home</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sda1       200G   50G  150G   25% /home</span><br></pre></td></tr></table></figure><h5><span id="示例-3显示文件系统类型">示例 3：显示文件系统类型</span></h5><p>想知道各个分区都是什么格式（ext4? NTFS?）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hT</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件系统       类型      容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sda1      ext4      234G   65G  157G   30% /</span><br><span class="line">/dev/sdb1      vfat      30G    5G   25G    17% /media/myusb</span><br></pre></td></tr></table></figure><h5><span id="示例-4检查-inode-使用情况">示例 4：检查 inode 使用情况</span></h5><p>有时候磁盘空间明明还有剩余，但系统却报错“No space left on device”。这通常是 <strong>inode 用尽</strong>了（创建了太多小文件）。这个命令可以诊断这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -i</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件系统       Inode 已用(I) 可用(I) 已用%(I) 挂载点</span><br><span class="line">/dev/sda1      5.8M    1.1M    4.7M      19% /</span><br></pre></td></tr></table></figure><p>如果 <strong>可用(I)</strong> 接近 0 或 <strong>已用%(I)</strong> 是 100%，说明 inode 耗尽，需要清理文件。</p><h5><span id="示例-5排除特定类型的文件系统">示例 5：排除特定类型的文件系统</span></h5><p>例如，不想看那些临时的 <code>tmpfs</code> 文件系统，只关心真实的硬盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h -x tmpfs</span><br></pre></td></tr></table></figure><h5><span id="示例-6查看所有文件系统包括伪文件系统">示例 6：查看所有文件系统（包括伪文件系统）</span></h5><p>显示包括 <code>/proc</code>, <code>/sys</code> 在内的所有信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -a</span><br></pre></td></tr></table></figure><p>（这个输出通常会很长，包含很多内核虚拟的文件系统。）</p><hr><h4><span id="需要注意的要点">需要注意的要点</span></h4><ol><li><strong>“可用”空间</strong>： 通常，根文件系统 (<code>/</code>) 会保留约 5% 的磁盘空间（可由 <code>tune2fs -m</code> 调整）仅供 root 用户使用，以防止系统完全崩溃。所以普通用户看到的“可用”空间可能比实际计算的少一点点。</li><li><strong>伪文件系统</strong>： 像 <code>tmpfs</code>, <code>udev</code>, <code>proc</code> 这些并不是真正的物理磁盘，它们是内核在内存中创建的<strong>虚拟文件系统</strong>，用于管理设备、进程信息等。它们的空间使用是动态变化的。</li><li><strong>网络文件系统</strong>： <code>df</code> 也会显示通过网络挂载的文件系统，如 NFS 或 Samba 共享。</li><li><strong>挂载点</strong>： 理解挂载点的概念至关重要。<code>/home</code> 目录可能是一个独立的大分区，而 <code>/boot</code> 通常是一个较小的独立分区。</li></ol><h4><span id="总结">总结</span></h4><ul><li><strong><code>df</code></strong> 是查看<strong>磁盘空间总体使用情况</strong>的命令。</li><li><strong><code>du</code></strong> 是查看<strong>某个目录或文件具体占用多少空间</strong>的命令。它们两个通常配合使用：先用 <code>df</code> 发现哪个盘空间紧张，再用 <code>du</code> 去那个盘下找是哪个目录或文件占用了大量空间。</li><li><strong><code>df -h</code></strong> 是你最应该记住的命令。</li><li>如果遇到磁盘空间满的错误，但 <code>df -h</code> 显示还有空间，记得用 <strong><code>df -i</code></strong> 检查是否是 inode 用尽了。</li></ul><p>掌握 <code>df</code> 命令是每个 Linux 用户和管理员进行系统监控和存储管理的基本功。</p><h3><span id="mount-命令">mount 命令</span></h3><p><strong><code>mount</code></strong> 命令用于将存储设备（如硬盘分区、U 盘、光盘、ISO 镜像）上的文件系统<strong>附加</strong>到 Linux 目录树的某个<strong>挂载点</strong>上，从而使该设备中的文件和目录可以被访问。</p><p>反之，<strong><code>umount</code></strong> 命令则用于将其<strong>分离</strong>，断开访问通道。</p><p><strong>核心思想</strong>：它是在物理存储设备和用户可见的目录路径之间<strong>搭建一座桥梁</strong>。</p><hr><h4><span id="命令语法">命令语法</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount [-选项] [-o 挂载选项] &lt;设备名&gt; &lt;挂载点&gt;</span><br><span class="line">umount &lt;挂载点或设备名&gt;</span><br></pre></td></tr></table></figure><hr><h4><span id="基本用法示例">基本用法示例</span></h4><h5><span id="1-查看所有已挂载的文件系统">1. 查看所有已挂载的文件系统</span></h5><p>不加任何参数直接运行 <code>mount</code>，会显示系统中所有已挂载的文件系统列表，信息非常详细。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure><p>输出会包括设备、挂载点、文件系统类型、挂载选项等，类似于 <code>df -h</code> 但更详细。</p><h5><span id="2-挂载一个-u-盘手动挂载">2. 挂载一个 U 盘（手动挂载）</span></h5><p>假设系统将 U 盘识别为 <code>/dev/sdb1</code>，我们要将它挂载到 <code>/mnt/usb</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：创建挂载点目录 (如果不存在)</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /mnt/usb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：执行挂载</span></span><br><span class="line"><span class="built_in">sudo</span> mount /dev/sdb1 /mnt/usb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：访问U盘内容</span></span><br><span class="line"><span class="built_in">ls</span> /mnt/usb</span><br></pre></td></tr></table></figure><h5><span id="3-卸载设备">3. 卸载设备</span></h5><p>操作完成后，必须卸载才能安全移除设备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过挂载点卸载</span></span><br><span class="line"><span class="built_in">sudo</span> umount /mnt/usb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者通过设备名卸载</span></span><br><span class="line"><span class="built_in">sudo</span> umount /dev/sdb1</span><br></pre></td></tr></table></figure><p><strong>重要提示</strong>：<code>umount</code> 而不是 <code>unmount</code>。</p><hr><h4><span id="常用选项和高级用法">常用选项和高级用法</span></h4><h5><span id="-t指定文件系统类型"><code>-t</code>：指定文件系统类型</span></h5><p>如果系统无法自动识别设备类型，或者你想明确指定，可以使用 <code>-t</code> 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 明确指定文件系统类型为 vfat (FAT32)</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t vfat /dev/sdb1 /mnt/usb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载光盘，类型通常是 iso9660</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t iso9660 /dev/sr0 /mnt/cdrom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载 exFAT 格式的U盘 (可能需要先安装 exfat-fuse)</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t exfat /dev/sdc1 /mnt/usb</span><br></pre></td></tr></table></figure><h5><span id="-o指定挂载选项非常强大"><code>-o</code>：指定挂载选项（非常强大）</span></h5><p>这是 <code>mount</code> 命令最灵活的部分，允许你精细控制挂载行为。多个选项用逗号分隔。</p><p><strong>常用挂载选项：</strong></p><table><thead><tr><th align="left">选项</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>ro</code> &#x2F; <code>rw</code></td><td align="left"><strong>只读</strong> &#x2F; <strong>读写</strong> 挂载。挂载光盘或只读镜像时用 <code>ro</code>。</td><td align="left"><code>-o ro</code></td></tr><tr><td align="left"><code>remount</code></td><td align="left"><strong>重新挂载</strong>一个已挂载的文件系统。常用于将只读挂载改为读写。</td><td align="left"><code>-o remount,rw /</code></td></tr><tr><td align="left"><code>loop</code></td><td align="left"><strong>挂载镜像文件</strong>。将普通文件（如 <code>.iso</code>）当作块设备来挂载。</td><td align="left"><code>-o loop ubuntu.iso /mnt/iso</code></td></tr><tr><td align="left"><code>defaults</code></td><td align="left">使用默认选项：<code>rw</code>, <code>suid</code>, <code>dev</code>, <code>exec</code>, <code>auto</code>, <code>nouser</code>, <code>async</code>。</td><td align="left"><code>-o defaults</code></td></tr><tr><td align="left"><code>noexec</code></td><td align="left">禁止执行该文件系统上的<strong>二进制程序</strong>。增加安全性。</td><td align="left"><code>-o noexec</code></td></tr><tr><td align="left"><code>nosuid</code></td><td align="left">忽略 <code>suid</code> 和 <code>sgid</code> 权限位。增加安全性。</td><td align="left"><code>-o nosuid</code></td></tr><tr><td align="left"><code>user</code></td><td align="left"><strong>允许普通用户</strong>挂载设备。</td><td align="left"><code>-o user</code></td></tr><tr><td align="left"><code>uid</code>, <code>gid</code></td><td align="left">设定挂载后文件<strong>所有者的用户 ID 和组 ID</strong>，解决权限问题。</td><td align="left"><code>-o uid=1000,gid=1000</code></td></tr><tr><td align="left"><code>username</code>, <code>password</code></td><td align="left">挂载 <strong>Windows 共享 (CIFS&#x2F;SMB)</strong> 时使用的认证信息。</td><td align="left"><code>-o username=john,password=secret</code></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以只读方式挂载光盘</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t iso9660 -o ro /dev/sr0 /mnt/cdrom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载ISO镜像文件</span></span><br><span class="line"><span class="built_in">sudo</span> mount -o loop ubuntu-22.04.iso /mnt/iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载NTFS分区并赋予当前用户读写权限 (需安装ntfs-3g)</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t ntfs-3g -o uid=1000,gid=1000 /dev/sdd1 /mnt/ntfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新挂载根目录为读写模式 (在救援模式中常用)</span></span><br><span class="line"><span class="built_in">sudo</span> mount -o remount,rw /</span><br></pre></td></tr></table></figure><hr><h4><span id="注意事项">注意事项</span></h4><ol><li><strong>卸载失败</strong>： 如果 <code>umount</code> 失败并提示 <code>device is busy</code>，表示有进程正在使用该挂载点下的文件。你可以：<ul><li>使用 <code>lsof /mnt/usb</code> 查看是哪个进程在占用。</li><li>切换到其他目录，再尝试卸载。</li><li>使用 <code>umount -l</code>（lazy unmount）延迟卸载，等设备不再繁忙时再断开。</li></ul></li><li><strong>权限问题</strong>： 挂载的设备可能因为权限问题导致当前用户无法读写。通常用 <code>-o uid=...,gid=...</code> 选项解决。</li><li><strong>安全卸载</strong>： <strong>永远在拔出 U 盘或移动硬盘前执行 <code>umount</code></strong>，否则可能导致数据损坏。</li></ol><h4><span id="总结">总结</span></h4><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>mount</code></td><td align="left"><strong>挂载</strong>文件系统到目录树</td></tr><tr><td align="left"><code>umount</code></td><td align="left"><strong>卸载</strong>已挂载的文件系统</td></tr><tr><td align="left"><code>mount -a</code></td><td align="left">挂载 <strong><code>/etc/fstab</code></strong> 中定义的所有文件系统</td></tr><tr><td align="left"><code>mount -o loop</code></td><td align="left">挂载<strong>镜像文件</strong></td></tr><tr><td align="left"><code>mount -o remount</code></td><td align="left"><strong>重新挂载</strong>，改变挂载参数</td></tr></tbody></table><p><code>mount</code> 命令是 Linux 系统管理的瑞士军刀，它将物理存储、网络资源与系统的逻辑目录树无缝连接起来，体现了 Linux <strong>“一切皆文件”</strong> 的设计哲学。</p><h3><span id="unshare-命令">unshare 命令</span></h3><p><strong><code>unshare</code></strong> 命令允许一个<strong>已经存在的进程</strong>从其父进程“脱离”一个或多个 <strong>Namespace</strong>，从而进入一个<strong>新的、隔离的上下文</strong>中运行。</p><p><strong>简单来说：</strong> 它能让你的当前 shell 或命令“脱离”原来的网络、进程树、挂载点等视图，获得一个全新的、隔离的环境，而<strong>不需要启动一个新的容器或虚拟机</strong>。</p><hr><h4><span id="与-clone-系统调用的区别">与 <code>clone()</code> 系统调用的区别</span></h4><p>要理解 <code>unshare</code>，最好先知道它的“兄弟”——<code>clone()</code>。</p><ul><li><strong><code>clone()</code></strong>： 在<strong>创建新进程的同时</strong>就将其放入新的 Namespace。<code>docker run</code>、<code>podman run</code> 等容器命令在底层最终调用的是 <code>clone()</code>。<strong>（出生即隔离）</strong></li><li><strong><code>unshare()</code></strong>： 让一个<strong>已经运行着的进程</strong>脱离它当前的 Namespace。<strong>（后天改造隔离）</strong></li></ul><p><code>unshare</code> 命令就是这个系统调用的命令行包装。</p><hr><h4><span id="命令语法">命令语法</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unshare [选项] [&lt;程序&gt; [&lt;参数&gt;...]]</span><br></pre></td></tr></table></figure><ul><li><strong>选项</strong>： 指定要脱离哪种类型的 Namespace。</li><li><strong>程序</strong>： 可选参数。如果指定了，则在新创建的 Namespace 中直接运行这个程序。如果没指定，则默认会在新 Namespace 中启动一个新的 shell。</li></ul><hr><h4><span id="核心选项指定要脱离的-namespace">核心选项（指定要脱离的 Namespace）</span></h4><table><thead><tr><th align="left">选项</th><th align="left">对应的 Namespace</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left"><code>--mount</code> or <code>-m</code></td><td align="left">Mount (<code>CLONE_NEWNS</code>)</td><td align="left">拥有独立的文件系统挂载点视图。</td></tr><tr><td align="left"><code>--uts</code> or <code>-u</code></td><td align="left">UTS (<code>CLONE_NEWUTS</code>)</td><td align="left">可以设置独立的主机名和域名。</td></tr><tr><td align="left"><code>--ipc</code> or <code>-i</code></td><td align="left">IPC (<code>CLONE_NEWIPC</code>)</td><td align="left">拥有独立的 System V IPC 和 POSIX 消息队列。</td></tr><tr><td align="left"><code>--net</code> or <code>-n</code></td><td align="left">Network (<code>CLONE_NEWNET</code>)</td><td align="left">拥有独立的网络栈（接口、路由、防火墙等）。</td></tr><tr><td align="left"><code>--pid</code> or <code>-p</code></td><td align="left">PID (<code>CLONE_NEWPID</code>)</td><td align="left">拥有独立的进程 ID 空间。<strong>需要与 <code>--fork</code> 一起使用。</strong></td></tr><tr><td align="left"><code>--user</code> or <code>-U</code></td><td align="left">User (<code>CLONE_NEWUSER</code>)</td><td align="left">拥有独立的用户和用户组 ID 映射。</td></tr><tr><td align="left"><code>--cgroup</code> or <code>-C</code></td><td align="left">Cgroup (<code>CLONE_NEWCGROUP</code>)</td><td align="left">拥有独立的 cgroup 根目录。</td></tr><tr><td align="left"><code>--time</code> or <code>-T</code></td><td align="left">Time (<code>CLONE_NEWTIME</code>)</td><td align="left">允许独立设置系统时钟偏移量。</td></tr></tbody></table><p><strong>常用辅助选项：</strong></p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>--fork</code> or <code>-f</code></td><td align="left">在启动指定程序前先 fork 一个子进程。<strong>与 <code>--pid</code> 必须一起使用</strong>，否则新 Namespace 中第一个进程的 PID 会是 1，它退出后整个 Namespace 就销毁了。</td></tr><tr><td align="left"><code>--mount-proc</code></td><td align="left">将 <code>/proc</code> 文件系统重新挂载到新的 Mount Namespace 中。<strong>与 <code>--pid</code> 一起使用时是必须的</strong>，否则 <code>ps</code>, <code>top</code> 等命令无法正常工作（它们仍然会看到宿主机的所有进程）。</td></tr><tr><td align="left"><code>--map-root-user</code></td><td align="left">在新的 User Namespace 中，将当前用户映射为 root (uid 0)。这允许你在没有外部 root 权限的情况下，在内部拥有 root 权限。</td></tr><tr><td align="left"><code>--root=&lt;目录&gt;</code></td><td align="left">将指定的目录设置为新的根目录（类似 <code>chroot</code>）。</td></tr></tbody></table><hr><h4><span id="实用示例">实用示例</span></h4><h5><span id="示例-1创建一个新的-network-namespace">示例 1：创建一个新的 Network Namespace</span></h5><p>创建一个拥有独立网络环境的 shell。在这个 shell 里，你看不到宿主机的网络接口（除了 loopback）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> unshare --net /bin/bash</span><br><span class="line"><span class="comment"># 进入新的bash后，查看网络，只有lo接口</span></span><br><span class="line">ip a</span><br></pre></td></tr></table></figure><h5><span id="示例-2创建一个新的-pid-和-mount-namespace最像迷你容器">示例 2：创建一个新的 PID 和 Mount Namespace（最像迷你容器）</span></h5><p>这是最经典的用法，创建一个进程隔离的环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> unshare --pid --fork --mount-proc /bin/bash</span><br></pre></td></tr></table></figure><ul><li><code>--pid</code>： 创建新的 PID Namespace。</li><li><code>--fork</code>： 让 <code>unshare</code> 先 fork，再执行 <code>/bin/bash</code>，这样 bash 的 PID 就是 1。</li><li><code>--mount-proc</code>： 重新挂载 <code>/proc</code>，使得 <code>ps aux</code> 等命令只显示这个新 Namespace 内的进程（实际上只有几个）。<br>现在，你运行 <code>ps aux</code>，会发现看不到宿主机上的其他进程，仿佛进入了一个崭新的系统。</li></ul><h5><span id="示例-3在新的-namespace-中改变主机名uts">示例 3：在新的 Namespace 中改变主机名（UTS）</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先查看当前主机名</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的 UTS Namespace 并运行 bash</span></span><br><span class="line"><span class="built_in">sudo</span> unshare --uts /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在新环境中修改主机名</span></span><br><span class="line">hostname my-new-container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看，主机名已变</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开另一个终端，查看原主机名，发现并未改变。证明隔离成功。</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment"># 退出后，主机名恢复</span></span><br></pre></td></tr></table></figure><h5><span id="示例-4普通用户创建伪-root环境user-namespace">示例 4：普通用户创建“伪 root”环境（User Namespace）</span></h5><p>这是非常强大的一点：<strong>普通用户可以不需 root 权限就创建新的 User Namespace</strong>，并在其中拥有 root 权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不需要 sudo！</span></span><br><span class="line">unshare --user --map-root-user --pid --fork --mount-proc /bin/bash</span><br><span class="line"><span class="built_in">whoami</span> <span class="comment"># 输出：root</span></span><br><span class="line"><span class="built_in">id</span> <span class="comment"># 输出：uid=0(root) gid=0(root) groups=0(root)</span></span><br></pre></td></tr></table></figure><ul><li><code>--user</code> 和 <code>--map-root-user</code>： 让你在内部成为 root。</li><li>注意：这个内部的 root 权限<strong>仅限于这个新的 Namespace 之内</strong>，例如你可以挂载文件系统、设置能力（capabilities），但对宿主机的影响非常有限，安全性很高。</li></ul><h5><span id="示例-5直接运行一个程序">示例 5：直接运行一个程序</span></h5><p>不启动交互式 shell，而是直接在新 Namespace 中运行一个一次性命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> unshare --net --pid --fork --mount-proc <span class="built_in">sleep</span> 300</span><br><span class="line"><span class="comment"># 这个 `sleep` 进程在一个隔离的 PID 和 Network Namespace 中运行300秒</span></span><br></pre></td></tr></table></figure><hr><p><code>unshare</code> 是 <strong>Docker&#x2F;容器技术的底层基础之一</strong>。</p><ul><li>当你运行 <code>docker run -it ubuntu bash</code> 时，Docker 引擎在底层做的事情，就类似于一个超级加强版的 <code>unshare</code> 命令：它一次性调用了几乎所有 <code>--mount --uts --ipc --net --pid --user --cgroup</code> 选项，并在此基础上增加了 Cgroups（资源限制）、镜像根文件系统等更多功能。</li><li><code>unshare</code> 让你能够<strong>手动地、一步一步地</strong>体验和理解容器是如何实现隔离的。</li></ul><h3><span id="mount-隔离">mount 隔离</span></h3><p>在 Linux 容器技术中，Mount Namespace 是实现文件系统隔离的核心机制，它允许每个容器拥有自己独立的文件系统挂载点视图，仿佛运行在一个完全独立的系统之上。这意味着在一个容器内部进行的挂载或卸载操作，不会影响到宿主机器或其他容器，反之亦然。</p><h4><span id="核心原理挂载传播与命名空间">核心原理：挂载传播与命名空间</span></h4><p>Mount Namespace 的实现并非简单的“屏蔽”或“过滤”，而是依赖于 Linux 内核一项更为精巧的设计：<strong>挂载传播（Mount Propagation）</strong>。</p><p>每个挂载点都有一个<strong>传播类型</strong>属性，它决定了挂载事件如何在不同的命名空间之间通知和共享。当一个新 Mount Namespace 被创建时（例如通过 <code>unshare --mount</code> 或 <code>clone()</code> 系统调用），它会复制当前命名空间的挂载点列表。然而，这些复制过来的挂载点的默认传播类型被设置为 <strong><code>MS_PRIVATE</code></strong>（私有）。</p><p><strong><code>MS_PRIVATE</code> 的含义是</strong>：在该挂载点下发生的任何挂载或卸载事件，都被视为当前 Mount Namespace 的“私事”。内核不会将此事件通知给任何其他命名空间，其他命名空间也不会将它们的挂载变更传播过来。这就像在两者之间设置了一道双向不可见的单向玻璃，完美实现了隔离。</p><h4><span id="实践演示私有挂载实验">实践演示：私有挂载实验</span></h4><p>通过一个简单的命令，我们可以清晰地观察到 Mount Namespace 的隔离效果：</p><ol><li><p><strong>创建隔离环境</strong>：首先，我们使用 <code>unshare</code> 命令创建一个新的 Mount Namespace（<code>--mount</code>）并启动一个 shell。<code>--mount-proc</code> 选项不仅会挂载一个新的 <code>/proc</code>，其内部也会调用 <code>unshare(CLONE_NEWNS)</code> 来创建新的 Mount Namespace。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> unshare --mount --fork --mount-proc /bin/bash</span><br></pre></td></tr></table></figure></li><li><p><strong>准备存储介质</strong>：在新创建的隔离 shell 中，我们创建一个空的镜像文件并将其格式化为 ext4 文件系统，模拟一块虚拟磁盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./my-disk.img bs=1M count=100</span><br><span class="line">mkfs.ext4 ./my-disk.img</span><br></pre></td></tr></table></figure></li><li><p><strong>执行挂载操作</strong>：将格式化好的镜像文件挂载到一个目标目录（如 <code>./mnt</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./mnt</span><br><span class="line">mount ./my-disk.img ./mnt</span><br></pre></td></tr></table></figure><p>此时，在隔离环境内使用 <code>df -h</code> 或 <code>mount</code> 命令，可以清晰地看到该挂载点。</p></li><li><p><strong>验证隔离性</strong>：<strong>这是最关键的一步。</strong> 此时，在宿主系统或其他任何终端窗口中使用 <code>mount</code> 或 <code>df -h</code> 命令查看，<strong>都无法发现</strong> <code>my-disk.img</code> 被挂载到了 <code>./mnt</code>。这个挂载操作完全被限制在了新创建的 Mount Namespace 内部，对外部系统不可见。</p></li></ol><h2><span id="cgroup">cgroup</span></h2><p>cgroup（Control Groups）是 Linux 内核提供的一种机制，用于对一组进程进行统一的资源限制、隔离和统计。它是容器化技术（如 Docker 和 Kubernetes）最核心的基石之一。</p><p>与早期的 cgroup v1 相比，cgroup v2 带来了更清晰统一的管理模型、更一致的组织结构以及更强大的功能（如原子化资源分配）。目前主流的 Linux 发行版均已默认采用 cgroup v2。</p><p>其核心思想可以通过下图来理解：</p><pre class="mermaid">flowchart TDsubgraph Host[宿主机系统]    subgraph CgroupRoot[统一层级结构 /sys/fs/cgroup/]        direction TB        Root[/根控制组<br>控制所有系统资源/]        Root --> A[控制组 A<br>e.g. 数据库]        Root --> B[控制组 B<br>e.g. Web 服务]        Root --> C[控制组 C<br>e.g. 备份任务]        A --> A1[控制组 A1<br>e.g. 数据库子任务]    endendA -.->|施加 CPU、内存等限制| LA[进程列表 A]B -.->|施加 CPU、内存等限制| LB[进程列表 B]C -.->|施加 CPU、内存等限制| LC[进程列表 C]A1 -.->|继承父组限制并可叠加| LA1[进程列表 A1]</pre><p>cgroup v2 通过一个统一的层级结构（通常挂载在 <code>/sys/fs/cgroup/</code>）来管理所有资源控制器（cpu、memory、io 等）。每个子目录都是一个控制组，可以为其配置资源限制，并将进程纳入其中进行管理。</p><h3><span id="管理基础挂载与目录操作">管理基础：挂载与目录操作</span></h3><p>cgroup v2 的管理接口通过虚拟文件系统（通常为 <code>cgroup2fs</code>）暴露。首先需要挂载，但现代系统通常已自动完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 cgroup2 挂载点</span></span><br><span class="line">mount | grep cgroup2</span><br><span class="line"><span class="comment"># 输出示例：cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime)</span></span><br></pre></td></tr></table></figure><p>管理 cgroup 的本质就是操作 <code>/sys/fs/cgroup/</code> 下的目录和文件：</p><ul><li><strong>创建控制组</strong>：使用 <code>mkdir</code> 创建一个子目录。</li><li><strong>配置限制</strong>：向该目录下的特定文件（如 <code>cpu.max</code>）写入配置值。</li><li><strong>加入进程</strong>：将进程的 PID 写入该目录下的 <code>cgroup.procs</code> 文件。</li><li><strong>删除控制组</strong>：使用 <code>rmdir</code> 删除空目录。</li></ul><h3><span id="实战使用-cgroup-v2-限制-cpu-使用率">实战：使用 cgroup v2 限制 CPU 使用率</span></h3><p>本示例将演示如何创建一个 cgroup，并将其内所有进程的 CPU 使用率限制为 <strong>单个核心的 20%</strong>。</p><h4><span id="第-1-步创建控制组">第 1 步：创建控制组</span></h4><p>我们创建一个名为 <code>cpu_demo</code> 的控制组。创建目录即创建了 cgroup。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 cgroup 根目录</span></span><br><span class="line"><span class="built_in">cd</span> /sys/fs/cgroup/</span><br><span class="line"><span class="comment"># 创建新的控制组</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> cpu_demo</span><br></pre></td></tr></table></figure><p>创建后，系统会自动在该目录下生成所有控制文件（<code>cpu.max</code>, <code>cgroup.procs</code> 等）。</p><h4><span id="第-2-步配置-cpu-限制">第 2 步：配置 CPU 限制</span></h4><p>cgroup v2 通过 <code>cpu.max</code> 文件来设置 CPU 配额，其格式为：<code>$MAX $PERIOD</code>。</p><ul><li><strong><code>$PERIOD</code></strong>： 一个周期的时间长度（微秒）。通常固定为 <code>100000</code>（即 100 毫秒）。</li><li><strong><code>$MAX</code></strong>： 在上述一个周期内，该 cgroup 中所有进程<strong>最多能使用的 CPU 时间</strong>（微秒）。计算公式为：<code>MAX = PERIOD * desired_cpu_percentage</code>。</li></ul><p>我们的目标是 20%，所以计算：<code>100000 * 0.2 = 20000</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 CPU 配额：100ms 周期内最多使用 20ms 的 CPU 时间</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;20000 100000&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /sys/fs/cgroup/cpu_demo/cpu.max</span><br></pre></td></tr></table></figure><p>这表示该 cgroup 中的进程在任何 100ms 的时间窗口内，最多只能运行 20ms，即 20% 的 CPU 时间。</p><h4><span id="第-3-步验证限制效果">第 3 步：验证限制效果</span></h4><p>为了验证限制，我们需要一个能消耗大量 CPU 的程序。这里使用 <code>stress</code> 工具。</p><ol><li><p><strong>将当前 Shell 加入控制组</strong>：<br> 当前 Shell 中启动的进程会自动继承其 cgroup。我们将当前 Shell 加入 <code>cpu_demo</code>。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前 shell 的 PID 写入 cgroup.procs</span></span><br><span class="line"><span class="built_in">echo</span> $$ | <span class="built_in">sudo</span> <span class="built_in">tee</span> /sys/fs/cgroup/cpu_demo/cgroup.procs</span><br></pre></td></tr></table></figure></li><li><p><strong>启动压力测试</strong>：<br> 在新终端中，使用 <code>pidstat</code> 监控 CPU。在原终端中启动 <code>stress</code>，它会尝试占满一个核心。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个消耗 CPU 的 worker</span></span><br><span class="line">stress -c 1 &amp;</span><br></pre></td></tr></table></figure></li><li><p><strong>监控 CPU 使用率</strong>：<br> 在另一个终端，使用 <code>pidstat</code> 监控 <code>stress</code> 进程。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pidstat -p $(pgrep -o stress) -u 1</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment"># 06:14:48 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span></span><br><span class="line"><span class="comment"># 06:14:49 PM     0      1234    20.0      0.0      0.0     80.0     20.0     1  stress</span></span><br></pre></td></tr></table></figure><p> <strong>结果分析</strong>：可以看到，<code>%CPU</code> 列被稳定地限制在了 <strong>~20%</strong>。同时，<code>%wait</code> 值很高，表明进程大部分时间在等待 CPU 时间片，这正是 cgroup 通过内核调度器进行“节流”限制的直观表现。</p></li></ol><h4><span id="第-4-步清理">第 4 步：清理</span></h4><p>实验完成后，务必进行清理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 终止测试进程</span></span><br><span class="line">pkill stress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将当前 shell 移回根 cgroup</span></span><br><span class="line"><span class="built_in">echo</span> $$ | <span class="built_in">sudo</span> <span class="built_in">tee</span> /sys/fs/cgroup/cgroup.procs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除创建的 cgroup (必须确保组内无进程)</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rmdir</span> /sys/fs/cgroup/cpu_demo</span><br></pre></td></tr></table></figure><h3><span id="核心特性与优势">核心特性与优势</span></h3><p>通过上述演示，我们可以看到 cgroup v2 的一些核心优势：</p><ul><li><strong>统一层级结构</strong>：所有控制器（CPU、内存、IO 等）在同一目录下管理，结构清晰。</li><li><strong>接口简单直观</strong>：通过读写文件即可完成所有配置，易于理解和自动化。</li><li><strong>限制精确有效</strong>：在内核层面进行资源调度和隔离，效果稳定可靠。</li><li><strong>继承性</strong>：子 cgroup 继承父 cgroup 的限制，并可以进一步收紧，提供了灵活的资源配置能力。</li></ul><p>cgroup v2 是理解和实现现代 Linux 系统资源管理的基础，从简单的进程限制到复杂的容器编排，都离不开它的强大功能。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端工具 </category>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 前置知识-技术架构演进</title>
      <link href="/2025/08/22/Docker/docker_base/"/>
      <url>/2025/08/22/Docker/docker_base/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5">常见概念</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li><li><a href="#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87metric">评价指标（Metric）</a></li></ul></li><li><a href="#%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B">架构演进</a><ul><li><a href="#%E5%8D%95%E6%9C%BA%E6%9E%B6%E6%9E%84">单机架构</a></li><li><a href="#%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84">应用数据分离架构</a></li><li><a href="#%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84">应用服务集群架构</a></li><li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-or-%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84">读写分离 or 主从分离架构</a></li><li><a href="#%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84">冷热分离架构</a></li><li><a href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93">垂直分库</a></li><li><a href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93">水平分库</a></li><li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84">微服务架构</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E6%9E%B6%E6%9E%84">容器编排架构</a></li></ul></li></ul><!-- tocstop --><h2><span id="常见概念">常见概念</span></h2><p>在正式引入架构演进之前，为避免读者对架构中的概念有所疑惑，故对其中一些比较重要的概念做前置介绍：</p><h3><span id="基本概念">基本概念</span></h3><h4><span id="应用applicationx2f-系统system">应用（Application）&#x2F; 系统（System）</span></h4><p>为了完成一整套服务的一个程序或者一组相互配合的程序群。生活例子类比：为了完成一项任务，而搭建的由一个人或者一群相互配的人组成的团队。</p><h4><span id="模块modulex2f-组件component">模块（Module）&#x2F; 组件（Component）</span></h4><p>当应用较复杂时，为了分离职责，将其中具有清晰职责的、内聚性强的部分，抽象出概念，便于理解。生活例子类比：军队中为了进行某据点的攻克，将人员分为突击小组、爆破小组、掩护小组、通信小组等。</p><h4><span id="分布式distributed">分布式（Distributed）</span></h4><p>系统中的多个模块被部署于不同服务器之上，即可以将该系统称为分布式系统。如 Web 服务器与数据库分别工作在不同的服务器上，或者多台 Web 服务器被分别部署在不同服务器上。生活例子类比：为了更好的满足现实需要，一个在同一个办公场地的工作小组被分散到多个城市的不同工作场地中进行远程配合工作完成目标。跨主机之间的模块之间的通信基本要借助网络支撑完成。</p><h4><span id="集群cluster">集群（Cluster）</span></h4><p>被部署于多台服务器上的、为了实现特定目标的一个&#x2F;组特定的组件，整个整体被称为集群。比如多个 MySQL 工作在不同服务器上，共同提供数据库服务目标，可以被称为一组数据库集群。生活例子类比：为了解决军队攻克防守坚固的大城市的作战目标，指挥部将大批炮兵部队集中起来形成一个炮兵打击集群。</p><p>分布式 vs 集群。通常不用太严格区分两者的细微概念，细致的话，分布式强调的是物理形态，即工作在不同服务器上并且通过网络通信配合完成任务；而集群更在意逻辑形态，即是否为了完成特定服务目标。</p><h4><span id="主masterx2f-从slave">主（Master）&#x2F; 从（Slave）</span></h4><p>集群中，通常有一个程序需要承担更多的职责，被称为主；其他承担附属职责的被称为从。比如 MySQL 集群中，只有其中一台服务器上数据库允许进行数据的写入（增&#x2F;删&#x2F;改），其他数据库的数据修改全部要从这台数据库同步而来，则把那台数据库称为主库，其他数据库称为从库。</p><h4><span id="中间件middleware">中间件（Middleware）</span></h4><p>一类提供不同应用程序用于相互通信的软件，即处于不同技术、工具和数据库之间的桥梁。生活例子类比：一家饭店开始时，会每天去市场挑选买菜，但随着饭店业务量变大，成立一个采购部，由采购部专职于采买业务，称为厨房和菜市场之间的桥梁。</p><h4><span id="容器docker">容器（Docker）</span></h4><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux 或 Windows 操作系统的机器上，也可以实现虚拟化。可以理解为一个集装箱，集装箱里面是每个用户的货物，整体打包。</p><h4><span id="容器编排k8s">容器编排（K8S）</span></h4><p>kubernetes，简称 K8s，是用 8 代替名字中间的 8 个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效。可以理解为一个货船，安装集装箱的大小，货物情况合理的来组织集装箱完成整体货物的搬运。</p><h3><span id="评价指标metric">评价指标（Metric）</span></h3><h4><span id="可用性availability">可用性（Availability）</span></h4><p>考察单位时间段内，系统可以正常提供服务的概率&#x2F;期望。例如：年化系统可用性 &#x3D; 系统正常提供服务时长 &#x2F; 一年总时长。这里暗含着一个指标，即如何评价系统提供无法是否正常，我们就不深入了。平时我们常说的 4 个 9 即系统可以提供 99.99% 的可用性，5 个 9 是 99.999% 的可用性，以此类推。我们平时只是用高可用（High Availability HA）这个非量化目标简要表达我们系统的追求。</p><h4><span id="响应时长response-time-rt">响应时长（Response Time RT）</span></h4><p>指用户完成输入到系统给出用户反应的时长。例如点外卖业务的响应时长 &#x3D; 拿到外卖的时刻 - 完成点单的时刻。通常我们需要衡量的是最长响应时长、平均响应时长和中位数响应时长。这个指标原则上是越小越好，但很多情况下由于实现的限制，需要根据实际情况具体判断</p><h4><span id="吞吐throughputvs-并发concurrent">吞吐（Throughput）vs 并发（Concurrent）</span></h4><p>吞吐考察单位时间段内，系统可以成功处理的请求的数量。并发指系统同一时刻支持的请求最高量。例如一条 2 车道高速公路，一分钟可以通过 20 辆车，则并发是 2，一分钟的吞吐量是 20。实践中，并发量往往无法直接获取，很多时候都是用极短的时间段（比如 1 秒）的吞吐量做代替。我们平时用高并发（Hight Concurrent）这个非量化目标简要表达系统的追求。</p><h2><span id="架构演进">架构演进</span></h2><h3><span id="单机架构">单机架构</span></h3><p><img src="/img/Docker/base/single.png" alt="single"></p><p>初期，我们需要利用我们精干的技术团队，快速将业务系统投入市场进行检验，并且可以迅速响应变化要求。但好在前期用户访问量很少，没有对我们的性能、安全等提出很高的要求，而且系统架构简单，无需专业的运维团队，所以选择单机架构是合适的。</p><p>在这种架构当中，应用服务和数据库服务共用一台服务器，所有的请求都通过这台服务器进行处理。</p><p>的确，这样的架构部署简单，成本也很低，但是会存在严重的性能瓶颈，且数据库和应用服务会互相竞争资源。</p><h3><span id="应用数据分离架构">应用数据分离架构</span></h3><p>随着系统的上线，我们不出意外地获得了成功。市场上出现了一批忠实于我们的用户，使得系统的访问量逐步上升，逐渐逼近了硬件资源的极限，同时团队也在此期间积累了对业务流程的一批经验。面对当前的性能压力，我们需要未雨绸缪去进行系统重构、架构挑战，以提升系统的承载能力。但由于预算仍然很紧张，我们选择了将应用和数据分离的做法，可以最小代价的提升系统的承载能力</p><p><img src="/img/Docker/base/apart.png" alt="apart"></p><p>和之前架构的主要区别在于将数据库服务独立部署在同一个数据中心的其他服务器上，应用服务通过网络访问数据，但是这种架构也难免遇到一些缺点，我们来总结一下这个架构的优缺点：</p><h4><span id="优点"><strong>优点</strong></span></h4><ol><li><strong>性能提升</strong>：相较于单机架构（应用和数据库同服），将应用服务和数据库服务分离到不同服务器上，减轻了单台服务器的资源竞争压力，整体性能得到提升。</li><li><strong>容灾能力增强</strong>：实现了初步的隔离。数据库被独立出来，避免了因应用程序故障（如内存泄漏、CPU 占满）而直接拖垮数据库服务，提升了系统的稳定性和容灾能力。</li><li><strong>成本相对可控</strong>：作为架构演进的第一步，此方案只需增加少量的服务器，其硬件和运维成本相对于更复杂的分布式架构而言，依然在可接受的范围内。</li></ol><h4><span id="缺点"><strong>缺点</strong></span></h4><ol><li><strong>硬件成本变高</strong>：这种架构需要购买和维护更多的服务器，导致了硬件成本和运维复杂度的增加。</li><li><strong>存在性能瓶颈</strong>：虽然性能相比单机有提升，但数据库和应用通常仍是“单点”。随着业务增长，尤其是数据库层面，很容易遇到 I&#x2F;O、CPU 等瓶颈，<strong>无法独立应对海量的并发请求</strong>。</li></ol><h3><span id="应用服务集群架构">应用服务集群架构</span></h3><p>应用集群架构是指在水平扩展（Scale-Out）方案中，<strong>将多台应用服务器组织成一个统一的整体，共同对外提供服务的架构模式</strong>。这个集群对用户来说就像一个单一、高性能和高可用的服务器。</p><p><img src="/img/Docker/base/cluster.png" alt="cluster"></p><p>其核心目的是：<strong>通过增加廉价商用服务器的数量，而非提升单台服务器的性能（Scale-Up），来线性地提升系统的整体处理能力和可用性。</strong></p><p>当系统用户量激增，单台应用服务器遇到性能瓶颈（如 CPU、内存、网络带宽耗尽）时，主要有两种选择：</p><ol><li><strong>垂直扩展：</strong> 升级单台服务器的硬件（更快的 CPU、更大的内存）。<strong>缺点</strong>：成本高昂（性能提升非线性增长）、有物理上限、存在单点故障风险。</li><li><strong>水平扩展：</strong> 增加更多的服务器。<strong>缺点</strong>：引入了架构复杂性，需要解决流量如何分发、会话如何保持等问题。</li></ol><p>应用集群架构正是<strong>水平扩展方案的具体实现</strong>。</p><h4><span id="核心组件负载均衡器">核心组件：负载均衡器</span></h4><p>实现应用集群的关键是引入一个<strong>负载均衡器</strong>。它就像是一个<strong>交通警察</strong>，站在所有应用服务器之前，负责将所有 incoming 的用户请求，按照预设的规则，智能地分发到集群中某一台健康的应用服务器上。</p><h5><span id="常见的流量调度算法">常见的流量调度算法</span></h5><p>负载均衡器根据不同的算法决定将请求分发给谁：</p><ul><li><strong>轮询：</strong> 将请求依次、平均地分发给每一台服务器。</li><li><strong>加权轮询：</strong> 给性能更强的服务器分配更高的权重，让其处理更多的请求，实现“能者多劳”。</li><li><strong>最少连接数：</strong> 将新的请求发送给当前连接数最少的服务器，避免某台服务器过载。</li><li><strong>IP 哈希&#x2F;一致性哈希：</strong> 根据用户的 IP 地址计算出一个哈希值，相同来源的请求总是被分配到同一台服务器上。<strong>优点</strong>：可以很好地解决<strong>用户会话</strong>的问题，例如用户的登录状态可以只保存在一台服务器上而无需同步到所有服务器。</li></ul><hr><h4><span id="应用集群架构的优缺点">应用集群架构的优缺点</span></h4><h5><span id="优点"><strong>优点</strong></span></h5><ol><li><strong>高并发处理能力：</strong> 通过多台服务器并行处理请求，极大地提升了系统的整体<strong>吞吐量</strong>，能够应对海量用户访问。</li><li><strong>高可用性：</strong> 消除了单点故障。如果集群中一台应用服务器宕机，负载均衡器能够自动检测到并将其从健康列表中移除，后续流量只会被分发到其他正常的服务器上，从而保证服务不中断。</li><li><strong>良好的可扩展性：</strong> 当流量进一步增长时，可以非常简单地向集群中<strong>动态添加</strong>新的应用服务器，几乎可以无限水平扩展。</li><li><strong>成本效益高：</strong> 使用多台普通商用服务器通常比升级到一台顶级大型机的成本更低，更具性价比。</li></ol><h5><span id="缺点"><strong>缺点</strong></span></h5><ol><li><strong>架构复杂性增加：</strong> 需要引入并维护负载均衡器等新组件。</li><li><strong>带来新的技术挑战：</strong><ul><li><strong>会话保持问题：</strong> 如果用户第一次请求被发到服务器 A 并登录，第二次请求被发到服务器 B，如何让 B 也知道用户已登录？解决方案有：Session 复制、Session 集中存储（如存入 Redis）、或使用 IP 哈希算法固定用户访问的服务器。</li><li><strong>数据一致性问题：</strong> 所有应用服务器需要访问同一数据源（如数据库、缓存），要确保它们看到的数据是一致的。</li><li><strong>依赖服务压力：</strong> 应用服务器变多了，它们共同依赖的数据库、文件服务等下游服务可能会成为新的瓶颈。</li></ul></li></ol><h3><span id="读写分离-or-主从分离架构">读写分离 or 主从分离架构</span></h3><p><img src="/img/Docker/base/slave.png" alt="slave"></p><p>读写分离&#x2F;主从分离架构是一种<strong>通过复制技术，将一个数据库（主库）的数据同步到另一个或多个数据库（从库），并在此基础上实现写操作（增删改）与读操作（查询）分离</strong>的数据库架构模式。</p><p>其核心思想是：<strong>一主多从，主库负责写，从库负责读。</strong></p><p>当应用层通过集群化解决了自身瓶颈后，压力就全部转移到了数据库层面。单一数据库服务器很快就会遇到 I&#x2F;O、CPU、连接数等瓶颈。然而，数据库<strong>不能像应用服务器那样简单地通过加机器并负载均衡来扩展</strong>，因为必须要保证所有机器上数据的一致性。</p><p>读写分离架构就是为了解决数据库的<strong>读多写少</strong>型压力而生的。它基于一个关键观察：<strong>在大多数业务系统（如电商、内容网站）中，读请求（如浏览商品、查看文章）的频率远高于写请求（如下单、评论）。</strong></p><hr><h4><span id="它是如何工作的">它是如何工作的？</span></h4><ol><li><p><strong>主数据库</strong>：承担所有<strong>写操作</strong>（INSERT, UPDATE, DELETE）。任何对数据的修改都只发生在这里。它是数据的唯一权威来源。</p></li><li><p><strong>从数据库</strong>：通过数据库内置的<strong>复制机制</strong>（如 MySQL 的 binlog 复制），实时（或近实时）地将主库的数据变更同步过来。从库是主库的一个<strong>完整副本</strong>。它<strong>只承担读操作</strong>（SELECT）。</p></li><li><p><strong>应用层调整</strong>：应用程序在访问数据库时，需要进行判断：</p><ul><li>当执行<strong>写操作</strong>时，请求直接发往<strong>主库</strong>。</li><li>当执行<strong>读操作</strong>时，请求被分发到某一个<strong>从库</strong>。</li></ul></li></ol><p>这个过程通常需要一个<strong>数据库中间件</strong>（或是在应用内集成特定组件）来智能地路由读写请求。</p><h4><span id="读写分离架构的优缺点">读写分离架构的优缺点</span></h4><h5><span id="优点">优点</span></h5><ol><li><strong>显著提升读取性能</strong>：这是最核心的优点。通过<strong>增加从库数量</strong>，可以将大量的读请求分散到多台机器上，从而极大地提升了系统的整体查询处理能力和<strong>吞吐量</strong>。解决了“热点数据的频繁读取导致数据库负载很高”的问题。</li><li><strong>间接提升写入性能</strong>：将读操作从主库剥离，使主库可以<strong>更专注于处理写操作</strong>，减少了锁竞争等开销，从而间接提升了写操作的性能。</li><li><strong>提高数据库可用性与容灾能力</strong>：<ul><li><strong>高可用</strong>：如果一台从库宕机，其他从库仍然可以提供读服务，系统整体功能不受大的影响。</li><li><strong>数据备份</strong>：从库本质上就是一个实时备份的数据库副本，可以用于数据备份和恢复，降低了数据丢失的风险。</li><li><strong>快速故障转移</strong>：如果主库宕机，可以快速地将一台从库提升为新的主库（需要配合其他工具和流程），缩短系统不可用时间。</li></ul></li></ol><h5><span id="缺点">缺点</span></h5><ol><li><strong>数据同步延迟（致命缺点）</strong>：这是该架构最大的挑战。由于主库到从库的数据同步是<strong>异步</strong>的（通常是出于性能考虑），它需要时间。这会导致<strong>主从数据短暂不一致</strong>。<ul><li><strong>场景</strong>：用户刚下单成功（数据写入主库），立刻刷新订单列表（请求被路由到尚未同步完成的从库），可能看不到刚下的订单。这对用户体验是致命的。</li><li><strong>解决方案</strong>：对一致性要求极高的操作，可以强制走主库查询（但这会增加主库压力）。</li></ul></li><li><strong>架构复杂度和成本增加</strong>：<ul><li>需要引入和管理更多的数据库服务器，<strong>硬件和运维成本更高</strong>。</li><li>应用程序需要识别读写操作并进行路由，增加了代码的复杂性。通常需要引入或开发额外的中间件。</li></ul></li><li><strong>主库仍然是单点</strong>：写操作和数据同步的源头仍然是单一主库，它本身存在单点故障风险。虽然可以通过一些高可用方案（如 MHA、MGR）缓解，但并未从根本上解决写操作的扩展性问题。</li></ol><h3><span id="冷热分离架构">冷热分离架构</span></h3><p>冷热分离架构是一种<strong>根据数据的访问频率（热度）将其分离到不同存储介质或系统中进行管理的设计思想</strong>。其核心目的是：<strong>将有限的高性能资源（如内存）服务于最需要它的高频访问数据（热数据），而将低频访问数据（冷数据）存放在成本更低、容量更大的存储中</strong>，从而实现成本与性能的最优平衡。</p><p><img src="/img/Docker/base/hot.png" alt="hot_cold"></p><p>在实践中，它最常见的实现方式就是<strong>引入缓存</strong>，构建一个层次化的存储体系。</p><hr><h4><span id="为什么需要冷热分离架构">为什么需要冷热分离架构？</span></h4><p>在前面的读写分离架构中，虽然从库分担了读压力，但所有请求最终仍然会到达数据库。这存在几个明显问题：</p><ol><li><strong>数据库瓶颈仍在</strong>：对于<strong>极端热点的数据</strong>（如明星八卦新闻、秒杀商品信息），即使经过读写分离，大量的重复查询依然会对数据库造成巨大的压力，成为系统的瓶颈。</li><li><strong>响应时间瓶颈</strong>：即使数据库能承受住压力，每次请求都需要执行完整的 SQL 查询、磁盘 I&#x2F;O 等操作，<strong>响应时间（RT）的极限受限于数据库本身</strong>，难以进一步降低。</li><li><strong>资源浪费</strong>：数据库中存储着大量很少被访问的历史数据（冷数据），它们与高频访问的热数据存放在一起，共享着昂贵的数据库资源，这是一种浪费。</li></ol><p>冷热分离架构（引入缓存）正是为了<strong>根治“热点数据频繁读取导致数据库负载很高”这一顽疾</strong>。</p><hr><h4><span id="架构原理">架构原理</span></h4><p>该架构在应用层和数据库层之间增加了一个<strong>缓存层</strong>（通常是基于内存的键值存储，如 Redis、Memcached）。</p><ol><li><p><strong>数据分级</strong>：</p><ul><li><strong>热数据</strong>：访问频率极高的数据（如热门商品信息、热门文章、用户会话信息）。存放在<strong>缓存层</strong>。</li><li><strong>冷数据</strong>：访问频率低的数据（如历史订单、旧日志、归档信息）。存放在<strong>数据库层</strong>。</li></ul></li><li><p><strong>工作流程（以读取为例）</strong>：</p><ul><li><strong>第 1 步</strong>：应用需要读取数据时，首先<strong>查询缓存</strong>。</li><li><strong>第 2 步 - 缓存命中</strong>：如果缓存中存在该数据（<strong>Hit</strong>），则直接返回给应用，<strong>整个过程完全不涉及数据库</strong>。</li><li><strong>第 3 步 - 缓存未命中</strong>：如果缓存中不存在该数据（<strong>Miss</strong>），则再去查询数据库。</li><li><strong>第 4 步</strong>：从数据库取出数据后，一方面返回给应用，另一方面<strong>将数据写入缓存</strong>，并设置一个过期时间，以便后续请求能直接从缓存中获取。</li></ul></li></ol><hr><h4><span id="冷热分离架构的优缺点">冷热分离架构的优缺点</span></h4><h5><span id="优点">优点</span></h5><ol><li><strong>性能大幅提升</strong>：内存的读写速度（微秒级）远高于磁盘（毫秒级）。<strong>响应时长（RT）显著降低</strong>，用户体验极佳。</li><li><strong>极大减轻数据库压力</strong>：绝大部分的读请求被缓存拦截，数据库的<strong>吞吐量</strong>瓶颈被打破，使其能更专注于处理写操作和真正的缓存未命中查询。</li><li><strong>高并发支撑能力</strong>：缓存系统天生擅长处理高并发读取，使得系统<strong>应对突发流量的能力</strong>（如秒杀、热点事件）大大增强。</li><li><strong>成本效益高</strong>：用相对廉价的内存资源保护了昂贵且脆弱的数据库资源，性价比极高。</li></ol><h5><span id="缺点与挑战引入了新的技术复杂性">缺点与挑战（引入了新的技术复杂性）</span></h5><ol><li><strong>数据一致性难题</strong>：如何保证缓存中的数据与数据库中的数据一致？<ul><li><strong>场景</strong>：更新了数据库中的商品价格后，如何确保缓存中的旧价格被及时清除或更新？</li><li><strong>常见策略</strong>：设置缓存过期时间、在更新数据库后主动删除或更新缓存（如先更新数据库，再删除缓存）。</li></ul></li><li><strong>缓存穿透</strong>：查询一个数据库中<strong>根本不存在</strong>的数据，导致每次请求都无法命中缓存，直接击穿到数据库。<ul><li><strong>解决方案</strong>：缓存空值、使用布隆过滤器进行初步校验。</li></ul></li><li><strong>缓存击穿</strong>：某个<strong>热点 key</strong>在缓存过期的瞬间，大量请求同时涌入，直接击穿到数据库。<ul><li><strong>解决方案</strong>：设置热点数据永不过期、使用互斥锁（Mutex Lock）只允许一个请求去重建缓存。</li></ul></li><li><strong>缓存雪崩</strong>：在同一时间，<strong>大量缓存 key 同时过期</strong>，导致所有请求都涌向数据库，造成数据库瞬时压力过大而崩溃。<ul><li><strong>解决方案</strong>：给缓存过期时间加上随机值，避免集体过期。</li></ul></li><li><strong>架构复杂度提升</strong>：需要维护和监控缓存集群，增加了运维成本。</li><li><strong>数据库瓶颈</strong>：业务体量支持变大后，数据不断增加，数据库单库太大，单个表体量也太大，数据查询会很慢，导致数据库再度成为系统瓶颈</li></ol><h3><span id="垂直分库">垂直分库</span></h3><p><strong>垂直分库</strong>是基于业务维度，将同一个数据库中的<strong>不同业务模块的表</strong>拆分到不同的物理数据库中的架构设计。</p><p><img src="/img/Docker/base/vertical.png" alt="vertical"></p><p>其核心思想是：<strong>专库专用，按业务拆分</strong>。比如，一个庞大的单体数据库（如 <code>mall_db</code>），可能包含了用户、商品、订单、支付等多个业务模块的表。垂直分库就是将这些表分离出来，分别建立独立的数据库：<code>user_db</code>（用户库）、<code>product_db</code>（商品库）、<code>order_db</code>（订单库）、<code>payment_db</code>（支付库）。</p><hr><h4><span id="为什么需要垂直分库">为什么需要垂直分库</span></h4><p>当业务发展到一定规模，单个数据库会面临如下瓶颈，垂直分库是解决这些问题的自然演进：</p><ol><li><strong>单机性能瓶颈</strong>：所有业务的表都存放在一个数据库实例上，其连接数、CPU、I&#x2F;O、磁盘空间等资源是有限的，最终会成为整个系统的天花板。</li><li><strong>运维与耦合性问题</strong>：<ul><li><strong>难以维护</strong>：一个巨大的数据库，表结构复杂，任何改动和迁移风险都极高。</li><li><strong>耦合性高</strong>：所有业务耦合在一起，无法针对特定业务进行优化、扩容或故障隔离。一个业务的高压力查询可能会拖慢整个系统的其他业务。</li></ul></li><li><strong>团队协作问题</strong>：不同的开发团队可能需要操作同一个数据库，容易引发权限管理和安全风险。</li></ol><p>垂直分库的目标是<strong>实现业务层面的解耦，让每个业务库可以独立管理、独立优化和独立扩展</strong>。</p><hr><h4><span id="架构原理">架构原理</span></h4><ol><li><p><strong>拆分依据</strong>：根据系统的业务领域模型进行拆分。一个经典的电商系统可以拆分为：</p><ul><li><strong>用户库 (<code>user_db</code>)</strong>：存储用户信息、会员等级、收货地址等。</li><li><strong>商品库 (<code>product_db</code>)</strong>：存储商品信息、类目、库存、品牌等。</li><li><strong>订单库 (<code>order_db</code>)</strong>：存储订单主表、订单明细表等。</li><li><strong>支付库 (<code>payment_db</code>)</strong>：存储支付记录、账单、交易流水等。</li></ul></li><li><p><strong>应用层调整</strong>：应用程序在访问数据库时，需要知道要操作的数据位于哪个业务库。这通常需要在代码或中间件中进行路由：</p><ul><li>用户登录 → 连接 <code>user_db</code></li><li>查询商品 → 连接 <code>product_db</code></li><li>下单 → 需要同时操作 <code>order_db</code> 和 <code>product_db</code>（扣减库存）</li></ul></li></ol><hr><h4><span id="垂直分库的优缺点">垂直分库的优缺点</span></h4><h5><span id="优点">优点</span></h5><ol><li><strong>解决系统级耦合问题</strong>：这是最大的优点。实现了<strong>业务清晰、系统解耦</strong>。不同的业务可以由不同的团队维护不同的数据库。</li><li><strong>提升整体性能</strong>：将不同业务的负载分散到不同的数据库服务器上，避免了资源竞争，<strong>提升了系统的整体吞吐能力</strong>。</li><li><strong>便于优化和扩展</strong>：<ul><li><strong>可针对性优化</strong>：可以根据不同业务的特点（如用户库读多写少，支付库写多读少）独立配置硬件和优化参数。</li><li><strong>可独立扩展</strong>：如果用户量激增，可以单独对 <code>user_db</code> 进行扩容（如升级硬件或后续做读写分离），而不影响商品和订单业务。</li></ul></li><li><strong>提升可用性</strong>：实现了故障隔离。如果 <code>product_db</code> 因故宕机，通常不会影响到用户登录和支付功能（除非是下单流程），系统的可用性更高。</li></ol><h5><span id="缺点">缺点</span></h5><ol><li><strong>架构复杂度显著增加</strong>：<ul><li>应用程序需要维护多个数据源，并实现复杂的数据访问路由逻辑。</li><li>系统的部署和运维复杂度上升。</li></ul></li><li><strong>跨库关联查询困难（无法进行 JOIN 操作）</strong>：这是最致命的缺点。<ul><li><strong>场景</strong>：查询“某个用户购买过的所有商品”需要关联用户库和订单库。在单体数据库中一个简单的 <code>JOIN</code> 查询就能完成，但在垂直分库后，<strong>数据库本身不再支持跨库 JOIN</strong>。</li><li><strong>解决方案</strong>：必须在<strong>应用层</strong>通过代码来实现。先从一个库查询出订单 ID 列表，再去另一个库用 <code>IN</code> 查询商品信息，然后自己在内存中组装数据。这增加了代码的复杂度和网络开销。</li></ul></li><li><strong>分布式事务问题</strong>：<ul><li><strong>场景</strong>：用户下单操作，需要在 <code>order_db</code> 中创建订单，同时在 <code>product_db</code> 中扣减库存。这两个操作必须同时成功或失败，这就涉及<strong>跨数据库的事务</strong>。</li><li><strong>解决方案</strong>：需要引入复杂的分布式事务解决方案（如两阶段提交 2PC、基于消息队列的最终一致性方案等），技术难度和性能开销都很大。</li></ul></li><li><strong>成本增加</strong>：需要更多的数据库服务器，硬件和运维成本更高。</li></ol><p><strong>垂直分库是系统从单体架构迈向分布式架构非常关键的一步。</strong> 它主要解决了<strong>业务耦合</strong>和<strong>单机资源瓶颈</strong>的问题。</p><p>它通常发生在<strong>读写分离</strong>和<strong>引入缓存</strong>之后，当这些手段都无法缓解单数据库实例的压力时，就会考虑按业务进行垂直拆分。</p><p>然而，垂直分库也带来了<strong>跨库查询</strong>和<strong>分布式事务</strong>这两个经典的分布式系统难题。解决这些难题，通常需要业务上做出妥协（如避免跨库关联），或者引入更复杂的中间件和技术方案。当垂直分库后，单个业务库的数据量依然巨大时，下一步就会自然演进到<strong>水平分库（分库分表）</strong>。</p><h3><span id="水平分库">水平分库</span></h3><p><strong>水平分库分表</strong>是指将<strong>同一个逻辑表</strong>中的数据，按照某种特定的规则（如哈希、范围等），分散存储到<strong>多个物理数据库</strong>的<strong>多个结构相同的表</strong>中。</p><p>其核心思想是：<strong>“分散存储，分散访问”</strong>，通过将数据和请求分摊到多个低成本的服务器上，来突破单机容量的上限。</p><hr><h4><span id="为什么需要水平分库">为什么需要水平分库</span></h4><p>垂直分库后，单个业务库（如 <code>订单库</code>）仍然可能面临巨大挑战：</p><ol><li><strong>单表数据量过大</strong>：例如，订单表数据达到亿级甚至十亿级，SQL 查询性能（如全表扫描、索引深度）会急剧下降。</li><li><strong>单库写操作瓶颈</strong>：所有的写请求仍然集中在一个数据库上，CPU、磁盘 I&#x2F;O 和网络带宽成为瓶颈，无法通过升级硬件线性提升性能。</li><li><strong>单点故障风险</strong>：这个业务库如果宕机，整个业务模块（如所有订单功能）会完全不可用。</li></ol><p>水平分库就是为了<strong>根治单个业务库的容量和性能瓶颈</strong>。</p><hr><h4><span id="它是如何工作的核心分片策略">它是如何工作的？（核心：分片策略）</span></h4><p>水平分库的核心在于选择一个合适的分片键（Sharding Key）和分片算法，确保数据能均匀分布。</p><h5><span id="1-常用的分片策略">1. 常用的分片策略</span></h5><table><thead><tr><th align="left">策略</th><th align="left">描述</th><th align="left">优点</th><th align="left">缺点</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><strong>哈希取模</strong></td><td align="left">对分片键（如<code>user_id</code>）进行哈希计算，然后对分片总数取模，得到目标分片。</td><td align="left"><strong>数据分布均匀</strong>，负载均衡性好。</td><td align="left"><strong>扩容困难</strong>。增加分片数量时，需要大量数据迁移。</td><td align="left"><code>分片序号 = hash(user_id) % 4</code></td></tr><tr><td align="left"><strong>范围分片</strong></td><td align="left">根据分片键的值的范围（如时间、ID 区间）进行分片。</td><td align="left"><strong>易于扩容</strong>，只需在新分片写入新数据。</td><td align="left"><strong>容易产生数据热点</strong>（如最新数据都在一个分片上）。</td><td align="left"><code>create_time &lt; &#39;2023&#39;</code> 的数据在分片 0，<code>&#39;2023&#39; &lt;= create_time &lt; &#39;2024&#39;</code> 的在分片 1</td></tr><tr><td align="left"><strong>地理分片</strong></td><td align="left">根据用户所在地理位置等业务属性分片。</td><td align="left">符合业务特征，能优化本地访问。</td><td align="left">分布可能不均匀。</td><td align="left">华北用户数据存北京机房，华南用户数据存深圳机房</td></tr><tr><td align="left"><strong>一致性哈希</strong></td><td align="left">一个特殊的哈希算法，在扩缩容时仅需迁移少量数据。</td><td align="left"><strong>扩缩容影响小</strong>，数据迁移量少。</td><td align="left">实现相对复杂。</td><td align="left">常用于缓存集群（如 Redis），数据库分片也有应用</td></tr></tbody></table><h5><span id="2-架构与组件">2. 架构与组件</span></h5><p>应用程序通常不直接连接多个分片数据库，而是通过一个<strong>数据库中间件</strong>来访问。这个中间件是水平分库架构的“大脑”。</p><ul><li><strong>角色</strong>：<strong>SQL 代理</strong>、<strong>路由中心</strong>、<strong>结果聚合器</strong>。</li><li><strong>工作流程</strong>：<ol><li>应用向中间件发送一条 SQL（<code>SELECT * FROM orders WHERE user_id = 123</code>）。</li><li>中间件<strong>解析 SQL</strong>，根据<code>user_id = 123</code>和预设的分片规则（如<code>hash(123) % 4 = 1</code>），<strong>将 SQL 路由</strong>到对应的物理分片（如<code>order_db_1.orders_1</code>）上执行。</li><li>中间件<strong>接收各个分片返回的结果</strong>，进行聚合、排序、分页等处理。</li><li>中间件将最终结果返回给应用。</li></ol></li><li><strong>常见中间件</strong>：ShardingSphere（应用层）、Mycat（代理层）、Vitess 等。</li></ul><hr><h4><span id="水平分库的优缺点">水平分库的优缺点</span></h4><h5><span id="优点">优点</span></h5><ol><li><strong>极大提升系统容量与性能</strong>：从根本上解决了<strong>单库存储容量</strong>、<strong>写并发瓶颈</strong>和<strong>单表性能</strong>问题。</li><li><strong>提升系统可用性</strong>：单个分片数据库宕机，只影响部分数据和功能，不会导致整个业务模块完全不可用。</li><li><strong>良好的可扩展性</strong>：理论上可以通过不断增加分片数量来实现近乎无限的线性扩展。</li></ol><h5><span id="缺点与挑战复杂性急剧上升">缺点与挑战（复杂性急剧上升）</span></h5><ol><li><strong>分布式事务</strong>：一个业务逻辑同时操作多个分片时，如何保证所有分片上的数据一致性？这是最大挑战。（方案：Seata、最终一致性）</li><li><strong>跨分片查询</strong>：<code>ORDER BY ... LIMIT</code>、<code>GROUP BY</code>、<code>JOIN</code> 等操作变得异常复杂，需要在中间件中聚合多个分片的结果，性能损耗大。</li><li><strong>全局主键生成</strong>：如何避免多个分片产生重复 ID？（方案：Snowflake 雪花算法、Redis、数据库序列）</li><li><strong>数据迁移与扩容</strong>：初始分片数规划不当，后续扩容（如从 4 个分片扩展到 8 个）会非常痛苦，需要迁移大量数据。</li><li><strong>运维复杂度</strong>：需要管理大量的数据库实例，监控、备份、恢复等运维工作的复杂度呈指数级增长。</li></ol><p><strong>水平分库是数据库架构演进的终极武器，也是最后的手段。</strong> 它带来了巨大的性能和容量提升，但也极大地增加了系统的复杂性。它不是为了解决小问题而设计的。</p><p>因此，架构师必须谨慎评估：</p><ul><li><strong>是否真的必要？</strong> 是否已用尽读写分离、缓存、垂直分库等其他优化手段？</li><li><strong>如何选择分片键？</strong> 这决定了数据分布是否均匀，是成功与否的关键。</li><li><strong>如何应对挑战？</strong> 必须对分布式事务、全局 ID 等问题有成熟的解决方案。</li></ul><h3><span id="微服务架构">微服务架构</span></h3><p>微服务架构是一种将单一应用程序作为<strong>一套小型服务</strong>的集合来开发的架构风格。每个服务都<strong>围绕特定的业务能力构建</strong>（如用户服务、商品服务、订单服务），并可以<strong>独立部署、独立运行和独立扩展</strong>。服务之间通过轻量级的通信机制（通常是 HTTP&#x2F;REST 或 RPC）进行协作。</p><p>其核心思想是：<strong>分而治之，强内聚，弱耦合</strong>。</p><p><img src="/img/Docker/base/server.png" alt="server"></p><hr><h4><span id="为什么需要微服务架构">为什么需要微服务架构？</span></h4><p>在分库分后，虽然数据库能力得到了扩展，但应用层却变成了一个维护的噩梦：</p><ol><li><strong>“巨石应用”困境</strong>：所有业务代码仍然集中在一个庞大的、单一的应用中（通常称为单体架构）。这个应用需要连接<strong>所有拆分后的数据库</strong>，代码变得无比复杂和臃肿。</li><li><strong>极高的耦合度</strong>：修改用户模块的一行代码，可能需要重新构建和部署整个庞大的应用，因为所有模块都紧密耦合在一起。</li><li><strong>技术栈僵化</strong>：整个系统必须使用统一的技术栈（如 Java Spring），难以引入更合适的新技术（如用 Go 编写高性能的推荐服务，用 Python 编写 AI 服务）。</li><li><strong>扩展性差</strong>：无法根据业务压力进行细粒度扩展。即使只有商品搜索服务面临高并发，也不得不扩展整个单体应用，造成资源浪费。</li><li><strong>团队协作低效</strong>：一个大团队维护一个巨无霸代码库，沟通成本高，发布流程复杂，效率低下。</li></ol><p>微服务架构通过<strong>将应用本身也进行拆分</strong>，来从根本上解决上述问题。</p><hr><h4><span id="架构原理">架构原理</span></h4><ol><li><p><strong>服务拆分</strong>：根据业务边界（领域驱动设计 DDD），将庞大的单体应用拆分为一系列小的、自治的服务。</p><ul><li><strong>示例</strong>：电商系统被拆分为：<ul><li><code>用户服务</code>：负责注册、登录、用户信息管理。</li><li><code>商品服务</code>：负责商品管理、类目管理、库存查询。</li><li><code>订单服务</code>：负责下单、订单查询。</li><li><code>支付服务</code>：负责支付流程。</li><li><code>购物车服务</code>：负责购物车管理。</li></ul></li></ul></li><li><p><strong>独立部署与运行</strong>：每个服务都是一个独立的进程，可以被部署在任何地方。它们<strong>拥有自己独立的数据库</strong>（或数据库分片），服务之间不能直接访问对方的数据库，只能通过 API 调用。</p></li><li><p><strong>服务间通信</strong>：服务之间通过轻量级的通信机制进行协作，通常是：</p><ul><li><strong>同步调用</strong>：如 HTTP&#x2F;RESTful API 或 gRPC。适用于需要立即得到结果的场景。</li><li><strong>异步消息</strong>：如通过消息队列（Kafka, RabbitMQ）。适用于解耦和最终一致性的场景。</li></ul></li><li><p><strong>服务治理</strong>：由于服务数量众多，需要一系列基础设施来管理它们，这就是<strong>服务网格</strong>和<strong>云原生技术</strong>的用武之地。</p><ul><li><strong>API 网关</strong>：所有外部请求的统一入口，负责路由、认证、限流、日志等。</li><li><strong>服务注册与发现</strong>：服务启动后将自己注册到中心（如 Nacos, Consul），并能发现其他服务的位置。</li><li><strong>配置中心</strong>：统一管理所有服务的配置。</li><li><strong>熔断、降级、限流</strong>：防止服务雪崩，提升系统弹性。</li></ul></li></ol><hr><h4><span id="微服务架构的优缺点">微服务架构的优缺点</span></h4><h5><span id="优点">优点</span></h5><ol><li><strong>技术异构性</strong>：每个服务可以使用最适合其需求的技术栈，不受其他服务约束。</li><li><strong>强内聚，弱耦合</strong>：每个服务功能单一，职责清晰，代码更易理解和维护。</li><li><strong>独立部署与扩展</strong>：每个服务可以独立开发、测试、部署和扩展，极大地提升了交付速度和资源利用率。</li><li><strong>故障隔离</strong>：单个服务发生故障不会像多米诺骨牌一样导致整个系统崩溃。</li><li><strong>提升团队效率</strong>：小的、跨功能的团队可以独立负责一个或多个服务的全生命周期（“你构建，你运行”）。</li></ol><h5><span id="缺点">缺点</span></h5><ol><li><strong>架构复杂度急剧升高</strong>：这是最大的缺点。从单体的一体式架构转变为分布式系统，带来了巨大的复杂性。</li><li><strong>运维难度极大</strong>：需要管理数十甚至上百个服务，对自动化部署、监控、告警的要求极高。<strong>容器化技术（Docker）和容器编排工具（Kubernetes）几乎是微服务的必需品</strong>。</li><li><strong>分布式系统的挑战</strong>：<ul><li><strong>网络延迟和不稳定性</strong>：远程调用远比本地调用慢且不可靠。</li><li><strong>分布式事务</strong>：保证跨多个服务的数据一致性极其困难，通常需要放弃强一致性，采用最终一致性方案。</li><li><strong>故障排查困难</strong>：一个请求可能经过多个服务，排查问题需要聚合各个服务的日志（需要引入分布式链路追踪，如 SkyWalking, Zipkin）。</li></ul></li><li><strong>资源开销</strong>：每个服务实例都需要额外的内存和 CPU 开销（如每个 Spring Boot 应用启动都需要 JVM）。</li></ol><hr><h4><span id="总结">总结</span></h4><p>微服务架构不是银弹，而是一把<strong>双刃剑</strong>。它通过将应用拆分为小服务，解决了<strong>复杂项目的开发效率和可维护性</strong>问题，但同时也引入了<strong>分布式系统的所有复杂性</strong>。</p><p>它的引入通常是这样一个过程：</p><ol><li>数据库层面先通过<strong>读写分离、垂直分库、水平分库</strong>解决了数据容量和性能问题。</li><li>随之而来的<strong>应用层复杂度和耦合度</strong>问题变得不可接受。</li><li>于是，<strong>微服务架构</strong>被引入，将应用按业务拆解，每个微服务独立管理自己的数据和业务，并通过明确的 API 进行协作。</li></ol><p>这是一种<strong>用运维的复杂性来换取开发的简单性和业务的敏捷性</strong>的权衡。只有在业务足够复杂、团队规模较大、且具备成熟的 DevOps 和自动化运维能力时，才应考虑采用微服务架构。</p><h3><span id="容器编排架构">容器编排架构</span></h3><p>这是一种利用<strong>容器化技术</strong>（如 Docker）将应用及其所有依赖项打包成一个标准化的、轻量的、可移植的单元（镜像），然后使用<strong>容器编排平台</strong>（如 Kubernetes, K8s）来自动化地部署、管理、扩展和运维这些容器化应用的架构模式。</p><p>其核心目标是：<strong>实现应用的标准化交付和运维的自动化，从而高效地管理由大量微服务组成的复杂系统。</strong></p><p><img src="/img/Docker/base/container.png" alt="container"></p><hr><h4><span id="为什么需要它">为什么需要它？</span></h4><p>微服务架构解决了开发和业务敏捷性的问题，但却给运维带来了巨大的灾难：</p><ol><li><strong>部署工作量大且复杂</strong>：几十上百个微服务，每个都需要配置运行环境、依赖库、启动参数，手动部署效率低下，极易出错。</li><li><strong>环境不一致问题</strong>：开发、测试、生产环境差异导致“在我这儿是好的”经典问题。</li><li><strong>资源隔离与冲突</strong>：多个服务部署在同一台机器上，可能因为环境变量、端口、依赖库版本不同而产生冲突。</li><li><strong>扩缩容极其麻烦</strong>：应对流量高峰时需要快速扩容多个服务实例，流量过去后又要及时缩容以节省成本。手动操作速度慢，且难以精确控制。</li><li><strong>资源利用率低</strong>：为了应对可能的流量高峰，需要长期闲置大量服务器资源，造成巨大浪费。</li></ol><p>容器化与编排技术正是为了解决微服务带来的<strong>运维复杂性</strong>和<strong>资源利用率</strong>问题。</p><hr><h4><span id="架构工作原理">架构工作原理</span></h4><h5><span id="1-容器化docker">1. 容器化（Docker）</span></h5><ul><li><strong>打包</strong>：开发者将应用代码、运行时环境、系统工具、系统库和设置一起打包到一个<strong>Docker 镜像</strong>中。这个镜像是一个轻量级的、可执行的独立软件包。</li><li><strong>标准</strong>：镜像一旦构建完成，就可以在任何安装了 Docker 引擎的环境中<strong>以完全相同的方式运行</strong>，彻底解决了环境不一致的问题。</li><li><strong>隔离</strong>：运行的镜像称为<strong>容器</strong>。容器之间共享主机操作系统内核，但拥有各自独立的文件系统、网络和进程空间，实现了<strong>隔离性</strong>，避免了冲突。</li></ul><h5><span id="2-容器编排kubernetes-k8s">2. 容器编排（Kubernetes, K8s）</span></h5><p>K8s 是一个生产级别的容器编排系统，可以看作是一个<strong>分布式的操作系统</strong>，用于管理海量的容器化应用。</p><ul><li><strong>核心概念</strong>：<ul><li><strong>Pod</strong>：K8s 的最小调度单元，通常包含一个或多个紧密关联的容器。</li><li><strong>Deployment</strong>：定义了 Pod 的期望状态（如需要运行 3 个副本）。K8s 会确保实际状态始终与期望状态一致。</li><li><strong>Service</strong>：为一组 Pod 提供一个稳定的网络入口（IP 地址和 DNS 名称），实现负载均衡和服务发现。</li></ul></li><li><strong>工作流程</strong>：<ol><li>用户通过配置文件（YAML）声明应用的期望状态（如：我需要运行 2 个“用户服务”的实例）。</li><li>将配置提交给 K8s Master（主节点）。</li><li>K8s <strong>调度器</strong>会智能地决定将 Pod 部署到哪个<strong>Node</strong>（工作节点）上。</li><li>各个 Node 上的<strong>Kubelet</strong>代理接收指令，从镜像仓库拉取镜像并启动容器。</li><li>如果某个容器宕机，K8s 会<strong>自动重启</strong>它。如果整个 Node 宕机，K8s 会在其他 Node 上<strong>重新创建</strong>Pod。</li><li>当需要扩容时，只需修改配置文件中的副本数量，K8s 就会<strong>自动创建</strong>新的 Pod 实例。</li></ol></li></ul><hr><h4><span id="容器编排架构的优缺点">容器编排架构的优缺点</span></h4><h5><span id="优点">优点</span></h5><ol><li><strong>部署、运维简单快速</strong>：<strong>一条命令</strong>就可以完成几百个服务的滚动更新、扩缩容、版本回滚，实现了完全的<strong>自动化运维</strong>。</li><li><strong>环境标准化与隔离</strong>：容器镜像保证了环境一致性，从根本上解决了“开发测试生产环境不一致”的问题。容器间隔离性好，无冲突。</li><li><strong>高可用性与自愈能力</strong>：Pod 故障后会自动重启，节点故障后 Pod 会被自动迁移到健康节点，极大提升了系统的<strong>SLA（服务等级协议）</strong>。</li><li><strong>高效的资源利用与弹性伸缩</strong>：<ul><li>可以混合部署多种服务，充分利用服务器资源。</li><li>可以基于 CPU&#x2F;内存使用率或自定义指标（如 QPS）进行<strong>自动扩缩容</strong>，真正做到按需使用资源，成本优化。</li></ul></li></ol><h5><span id="缺点">缺点</span></h5><ol><li><strong>学习曲线陡峭</strong>：技术栈非常复杂（Docker, K8s, Helm, Prometheus 等），对开发和运维团队的技术要求极高。</li><li><strong>系统复杂性增加</strong>：引入了一个分布式的管理平台（K8s 集群），其本身的搭建、维护和故障排查就非常复杂。</li><li><strong>监控和日志挑战</strong>：大量的、动态变化的容器实例使得传统的监控和日志收集方式失效，必须引入更先进的<strong>云原生监控体系</strong>（如 Prometheus + Grafana）和<strong>集中式日志收集</strong>（如 ELK）。</li><li><strong>网络模型复杂</strong>：容器网络涉及 Overlay、CNI 等概念，配置和调试相对复杂。</li><li><strong>成本问题（自建时）</strong>：自建和维护一个高可用的 K8s 集群需要投入大量的人力和机器成本。这也是为什么很多公司选择直接使用<strong>云厂商提供的托管 K8s 服务</strong>（如阿里云 ACK、腾讯云 TKE、Amazon EKS）的原因，它们极大地降低了管理控制平面的负担。</li></ol><hr><h4><span id="总结">总结</span></h4><p><strong>容器化与容器编排架构是微服务架构的“最佳伴侣”</strong>。它并不是一个业务架构，而是一个<strong>支撑性的基础设施架构</strong>。</p><p>它通过将应用<strong>容器化</strong>来解决环境一致性和隔离性问题，通过<strong>编排</strong>来解决微服务部署、运维和管理的自动化问题。</p><p>这套架构的出现，使得大规模部署和管理微服务从一种“痛苦的折磨”变成了“可实现的工程实践”，是现代云计算和互联网公司技术栈的基石。它的引入，标志着企业的研发运维体系真正走向了<strong>云原生</strong>时代。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端工具 </category>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
            <tag> 技术架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从复制</title>
      <link href="/2025/08/20/Redis/redis_slave/"/>
      <url>/2025/08/20/Redis/redis_slave/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#redis-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">Redis 核心机制解析：深入理解主从复制</a></li><li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%85%8D%E7%BD%AE">主从复制配置</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81">查看主从复制状态</a></li><li><a href="#slaveof">slaveof</a><ul><li><a href="#%E4%B8%80-slaveof-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">一、<code>SLAVEOF</code> 指令详解</a></li><li><a href="#%E4%BA%8C-slaveof-%E8%87%AA%E5%B7%B1%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8E%E6%9E%9C%E5%88%86%E6%9E%90">二、<code>SLAVEOF</code> 自己连接自己的后果分析</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84">拓扑结构</a><ul><li><a href="#1-%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E7%BB%93%E6%9E%84">1. 一主一从结构</a></li><li><a href="#2-%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E7%BB%93%E6%9E%84%E6%98%9F%E5%BD%A2%E7%BB%93%E6%9E%84">2. 一主多从结构（星形结构）</a></li><li><a href="#3-%E6%A0%91%E5%BD%A2%E5%88%86%E5%B1%82%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84">3. 树形（分层）主从结构</a></li><li><a href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E8%A1%A8">总结对比表</a></li></ul></li><li><a href="#%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%90%AF%E9%97%AE%E9%A2%98">主从结构服务器重启问题</a></li><li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86">主从复制原理</a><ul><li><a href="#redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E6%A6%82%E8%A6%81">Redis 主从复制过程概要</a></li><li><a href="#redis-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6psync-%E8%AF%A6%E8%A7%A3">Redis 数据同步核心机制：PSYNC 详解</a></li><li><a href="#redis-%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6">Redis 全量复制</a></li><li><a href="#redis-%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6">Redis 部分复制</a></li><li><a href="#redis-%E5%AE%9E%E6%97%B6%E5%A4%8D%E5%88%B6%E7%BB%B4%E6%8C%81%E6%95%B0%E6%8D%AE%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%BF%83%E8%B7%B3">Redis 实时复制：维持数据最终一致性的心跳</a></li></ul></li></ul><!-- tocstop --><h2><span id="redis-核心机制解析深入理解主从复制">Redis 核心机制解析：深入理解主从复制</span></h2><p>在现代分布式架构中，单点故障是系统可靠性的最大威胁之一。为了解决这个问题，一个常见的实践是将数据复制多个副本并部署到不同的服务器上，这不仅提供了故障恢复的能力，还能通过负载均衡大幅提升系统的整体性能与吞吐量。作为高性能键值数据库的佼佼者，Redis 同样内置了强大而灵活的<strong>复制（Replication）</strong> 功能，允许用户创建包含相同数据的多个副本。</p><p>Redis 的复制功能是其高可用架构的基石。我们日常所使用的<strong>哨兵（Sentinel）</strong> 和<strong>集群（Cluster）</strong> 模式，都是在复制的基本机制之上构建而来的。可以说，深入理解复制，是掌握 Redis 高可用方案的必经之路。</p><p>在本篇博客中，我们将全方位解析 Redis 的主从复制机制。您将了解到：</p><ul><li><strong>如何操作</strong>：包括如何建立或断开复制连接、如何保证复制过程的安全性以及从节点的只读配置。</li><li><strong>如何规划</strong>：介绍复制所支持的各种拓扑结构（如一主一从、一主多从、树状结构等），以及不同架构的适用场景与优缺点。</li><li><strong>如何理解</strong>：深入剖析复制的工作原理，详细讲解建立复制、全量复制、部分复制、心跳检测等核心过程背后的实现细节。</li></ul><h2><span id="主从复制配置">主从复制配置</span></h2><p>参与复制的 <code>Redis</code> 实例划分为主节点 （master）和从节点（slave）。每个从结点只能有⼀个主节点，而⼀个主节点可以同时具有多个从结点。复制的数据流是单向的，只能由主节点到从节点。配置复制的方式有以下三种：</p><ol><li>在配置文件中加入 slaveof {masterHost} {masterPort} 随 Redis 启动生效。</li><li>在 redis-server 启动命令时加入 –slaveof {masterHost} {masterPort} 生效。</li><li>直接使用 redis 命令：slaveof {masterHost} {masterPort} ⽣效。</li></ol><p>下面我将通过修改配置文件的方式来实现主从复制的配置。</p><p>一般来说，主从复制实现的是分布式系统，但由于小编的财力实在有限，只能在本地模拟一个主从复制的环境。实际生产环境中，虽然说是每个主机都作为单机部署，但实际上往往会通过容器化等方式来实现更灵活的部署，这里暂时不做过多介绍，后面会有相关内容。</p><p>我会将 <code>Redis</code> 的配置文件复制多份给从节点使用，并在每个从节点的配置文件中加入对应的 <code>slaveof</code> 配置。</p><p>当然，若我们想要使用主从复制，首先应当将配置文件中的 <code>daemonize</code> 选项设置为 <code>yes</code>，以便在后台运行。该选项是用来指定 Redis 服务器是否以守护进程的方式运行的（一般来说这个选项是默认开启的）。</p><p>然后我们分别为每个从节点配置对应的 <code>slaveof</code> 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从节点1的端口号配置</span><br><span class="line"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="line"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port 6380</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从节点2的端口号配置</span><br><span class="line"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="line"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port 6381</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 从节点1的主从配置</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 从节点2的主从配置</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>而后，我们就可以启动这两个从节点了。启动命令与主节点类似，只需指定配置文件即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动从节点1</span></span><br><span class="line">redis-server slave1.conf</span><br><span class="line"><span class="comment"># 启动从节点2</span></span><br><span class="line">redis-server slave2.conf</span><br></pre></td></tr></table></figure><h2><span id="查看主从复制状态">查看主从复制状态</span></h2><p>我们通过命令可以查看当前的主从复制状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/redistest/project2] - [1044]</span><br><span class="line">└─[$] netstat -ntpa | grep redis-serve                                                                       [22:39:59]</span><br><span class="line">tcp        0      0 0.0.0.0:6380            0.0.0.0:*               LISTEN      1077922/redis-serve</span><br><span class="line">tcp        0      0 0.0.0.0:6381            0.0.0.0:*               LISTEN      1077941/redis-serve</span><br><span class="line">tcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      1042293/redis-serve</span><br><span class="line">tcp        0      0 127.0.0.1:6379          127.0.0.1:59180         ESTABLISHED 1042293/redis-serve</span><br><span class="line">tcp        0      0 127.0.0.1:59180         127.0.0.1:6379          ESTABLISHED 1077941/redis-serve</span><br><span class="line">tcp        0      0 127.0.0.1:59174         127.0.0.1:6379          ESTABLISHED 1077922/redis-serve</span><br><span class="line">tcp        0      0 127.0.0.1:6379          127.0.0.1:59174         ESTABLISHED 1042293/redis-serve</span><br><span class="line">tcp6       0      0 ::1:6380                :::*                    LISTEN      1077922/redis-serve</span><br><span class="line">tcp6       0      0 ::1:6381                :::*                    LISTEN      1077941/redis-serve</span><br><span class="line">tcp6       0      0 ::1:6379                :::*                    LISTEN      1042293/redis-serve</span><br></pre></td></tr></table></figure><p>其中每一行的含义如下：</p><ul><li><p><code>LISTEN</code> 状态的端口（如 6379、6380、6381）：</p><ul><li>这些是 Redis 主节点和从节点各自监听的服务端口。</li><li>例如：<ul><li><code>0.0.0.0:6379</code>、<code>0.0.0.0:6380</code>、<code>0.0.0.0:6381</code> 表示主节点和两个从节点分别监听在本机所有网卡的 6379、6380、6381 端口，等待客户端或其他 Redis 节点的连接。</li><li><code>::1:6379</code>、<code>::1:6380</code>、<code>::1:6381</code> 是 IPv6 的监听端口，作用同上。</li></ul></li></ul></li><li><p><code>ESTABLISHED</code> 状态的端口：</p><ul><li>这些是主从节点之间已经建立的 TCP 连接。</li><li>例如：<ul><li><code>127.0.0.1:6379 &lt;-&gt; 127.0.0.1:59180</code>、<code>127.0.0.1:6379 &lt;-&gt; 127.0.0.1:59174</code> 等，表示主节点 6379 端口和从节点的某个本地端口（如 59180、59174）之间已经建立了主从同步的数据通道。</li></ul></li><li>这些连接保证了主节点可以实时地将数据同步到从节点。</li></ul></li></ul><p>这里讲解一个小细节，我们的主节点是通过 <code>service</code> 命令来管理的，而不是直接通过 <code>redis-server</code> 启动的。这意味着主节点的进程是由系统服务管理的，可以更方便地进行监控和管理。若我们尝试直接杀掉主节点的进程，系统会自动重启它。是由 1 号进程管理的，验证如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/redistest/project1/build] - [1012]</span><br><span class="line">└─[$] ps axj | grep redis                                                                                    [19:46:17]</span><br><span class="line">      1 1039968 1039968 1039968 ?             -1 Ssl    105   0:00 /usr/bin/redis-server 0.0.0.0:6379</span><br><span class="line">1041179 1041741 1041740 1041065 pts/0    1041740 S+       0   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv redis</span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/redistest/project1/build] - [1013]</span><br><span class="line">└─[$] <span class="built_in">kill</span> -9 1039968                                                                                        [19:46:19]</span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/redistest/project1/build] - [1014]</span><br><span class="line">└─[$] ps axj | grep redis                                                                                    [19:48:54]</span><br><span class="line">      1 1042293 1042293 1042293 ?             -1 Ssl    105   0:00 /usr/bin/redis-server 0.0.0.0:6379</span><br><span class="line">1041179 1042301 1042300 1041065 pts/0    1042300 S+       0   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv redis</span><br></pre></td></tr></table></figure><p>可以看到，服务是由 1 号进程管理的，我将主节点进程杀掉后，系统会自动重启它（前后的 <code>PID</code> 变化），自然就是 1 号进程重启的该进程</p><p>我们分别启动主节点和两个从节点的服务后，可以通过 <code>redis-cli</code> 命令行工具连接到主节点和从节点，利用 <code>info replication</code> 命令查看主从复制状态：</p><p>首先是主节点的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=1595,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=1595,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1d0a5e10c42ce1b2af4b14795cbe0c3ff81aef53</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1595</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:1595</span><br></pre></td></tr></table></figure><p>对这些信息的解释如下：</p><ul><li><code>role:master</code>：表示当前节点是主节点。</li><li><code>connected_slaves:2</code>：表示当前主节点有两个从节点连接。</li><li><code>slave0</code> 和 <code>slave1</code>：分别表示两个从节点的状态信息，包括 IP 地址、端口、状态、偏移量和延迟等。</li><li><code>master_failover_state:no-failover</code>：表示当前没有故障转移发生。</li><li><code>master_replid</code> 和 <code>master_replid2</code>：表示主节点的复制 ID。</li><li><code>master_repl_offset</code>：表示主节点的复制偏移量。</li><li><code>second_repl_offset</code>：表示第二个复制偏移量。</li><li><code>repl_backlog_active</code>：表示复制积压缓冲区是否激活。</li><li><code>repl_backlog_size</code>：表示复制积压缓冲区的大小。</li><li><code>repl_backlog_first_byte_offset</code> 和 <code>repl_backlog_histlen</code>：表示复制积压缓冲区的相关信息。</li></ul><p>偏移量是用来标注数据在复制过程中的位置和状态的，帮助我们更好地理解主从复制的机制和数据流动。如果主从节点的偏移量一致，则说明主从节点的数据是一致的。</p><p>有关主从复制的更多信息，可以参考 <code>Redis</code> 官方文档中的 <a href="https://redis.io/topics/replication">Replication</a> 部分。状态中的后面四个选项我将会在后续的内容中详细介绍。</p><p>然后是从节点的状态，我们以第一个从节点为例，来看看其配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:5</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:3275</span><br><span class="line">slave_repl_offset:3275</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1d0a5e10c42ce1b2af4b14795cbe0c3ff81aef53</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:3275</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:3275</span><br></pre></td></tr></table></figure><p>你会发现，从节点的配置和主节点大多数信息是相同的，其中 <code>role:slave</code> 表示当前节点是从节点，而 <code>master_*</code> 相关的配置项则指向主节点的信息。这些信息帮助从节点与主节点保持同步，并确保数据的一致性。</p><p>可以看到的是，即便是从节点，仍然有 <code>connected_slaves:0</code> 这样的配置项，这说明从节点也是可以有从节点的。</p><p>这样一来，主节点的数据就会被同步到从节点上，从节点可以通过 <code>info replication</code> 命令查看当前的复制状态。</p><h2><span id="slaveof">slaveof</span></h2><h3><span id="一-slaveof-指令详解">一、<code>SLAVEOF</code> 指令详解</span></h3><p><code>SLAVEOF</code> 是一个功能强大的管理命令，用于动态地配置和管理 Redis 的主从复制关系。它主要有两种用法：</p><h4><span id="1-建立复制关系slaveof-master_ip-master_port">1. 建立复制关系：<code>SLAVEOF master_ip master_port</code></span></h4><ul><li><strong>功能</strong>：让当前 Redis 服务器成为指定主节点（master）的从节点（slave&#x2F;replica）。</li><li><strong>流程</strong>：<ol><li><strong>断开旧关系</strong>：如果当前服务器已经是另一个主节点的从节点，则会先断开与旧主节点的复制连接。</li><li><strong>建立新连接</strong>：与新的主节点建立网络连接。</li><li><strong>数据同步</strong>：<ul><li><strong>全量复制</strong>：从节点会先执行一个全量同步。它会清空自己的所有数据，然后主节点会生成一个当前数据集的 RDB 快照文件并发送给从节点。从节点接收并加载这个 RDB 文件，从而获得主节点在某个时间点的完整数据副本。</li><li><strong>部分复制</strong>：在全量同步之后，主节点会将后续新的写命令持续地、异步地发送给从节点，以保持数据实时一致。</li></ul></li></ol></li><li><strong>应用场景</strong>：扩容读性能、做数据备份、为高可用方案（哨兵&#x2F;集群）做准备。</li></ul><h4><span id="2-断开复制关系slaveof-no-one">2. 断开复制关系：<code>SLAVEOF NO ONE</code></span></h4><ul><li><strong>功能</strong>：让当前从节点停止复制，并<strong>晋升为一个独立的主节点</strong>。</li><li><strong>流程</strong>：<ol><li><strong>断开连接</strong>：停止与主节点的复制连接，不再接收主节点的数据流。</li><li><strong>晋升为主</strong>：自身的角色从 <code>slave</code> 变为 <code>master</code>。</li><li><strong>保留数据</strong>：<strong>关键点：它不会清空自身已有的数据</strong>。它只是停止了数据同步，但断开那一刻它所拥有的所有数据都会保留下来。这使得它可以在原主节点宕机时，随时准备接管服务（通常需要配合哨兵来自动完成）。</li></ol></li><li><strong>应用场景</strong>：故障恢复后的人工干预、网络分区后的重置、将某个从节点提升为新的主节点。</li></ul><h4><span id="3-切主操作slaveof-new_master_ip-new_master_port">3. 切主操作：<code>SLAVEOF new_master_ip new_master_port</code></span></h4><p>这实际上是第一种用法的延伸。当一个从节点执行此命令指向一个新的主节点时，会发生：</p><ol><li><strong>断开旧主</strong>：等同于先执行了 <code>SLAVEOF NO ONE</code> 的第一步（断开连接）。</li><li><strong>连接新主</strong>：与新的主节点建立连接。</li><li><strong>删除数据</strong>：<strong>关键区别：这里会清空从节点当前的所有数据！</strong> 因为要保证数据完全来自于新的主节点，必须从一个干净的状态开始同步。</li><li><strong>全量同步</strong>：从新主节点执行一次完整的全量复制流程。</li></ol><hr><h3><span id="二-slaveof-自己连接自己的后果分析">二、<code>SLAVEOF</code> 自己连接自己的后果分析</span></h3><p>现在，我们尝试让 6381 端口的子节点执行 <code>SLAVEOF 127.0.0.1 6381</code>（即自己连接自己）</p><h4><span id="发生了什么流程拆解">发生了什么？（流程拆解）</span></h4><ol><li><p><strong>角色分裂</strong>：服务器 X（端口 6381）接收到命令，试图成为自己的从节点。它的逻辑上分裂为两个角色：<strong>主节点 X</strong> 和 <strong>从节点 X</strong>。</p></li><li><p><strong>从节点 X 的流程</strong>：</p><ul><li>它遵循 <code>SLAVEOF</code> 的标准流程，首先尝试与“主节点 X”（即自己）建立连接。从网络协议上看，连接自己是成功的。</li><li>连接成功后，它发送 <code>PING</code>，自己回复自己，所以认为主节点健康。</li><li>接着，它发起同步请求 <code>PSYNC</code>，将自己的复制 ID 和偏移量发给“主节点 X”，请求增量数据。</li></ul></li><li><p><strong>主节点 X 的回应</strong>：</p><ul><li>“主节点 X”收到了来自“从节点 X”的 <code>PSYNC</code> 请求。</li><li>然而，“主节点 X” <strong>自身也是一个从节点</strong>（因为它执行了 <code>SLAVEOF</code> 命令）。根据 Redis 的核心设计原则：<strong>一个从节点在未与其主节点完成同步之前，是不能为其他从节点提供数据的</strong>。因为它的数据可能不是最新的，直接同步会给其他节点带来脏数据。</li><li>因此，“主节点 X”会检查自身状态，发现 <code>myself-&gt;masterhost</code> 是存在的（指向它自己），于是它果断地<strong>拒绝</strong>了“从节点 X”的同步请求，并回复错误：<code>-NOMASTERLINK Can&#39;t SYNC while not connected with my master</code>（“我连我自己的主都还没连上呢，没法给你同步！”）。</li></ul></li><li><p><strong>死循环形成</strong>：</p><ul><li>“从节点 X”收到拒绝回复后，判定同步失败。</li><li>同步失败会触发重试机制。在短暂的延迟（约 1 秒）后，“从节点 X”又会发起新一轮的连接和同步请求。</li><li>这个循环会每秒一次地、永不停歇地进行下去。</li></ul></li></ol><h4><span id="会导致什么后果">会导致什么后果？</span></h4><ol><li><strong>CPU 资源耗尽</strong>：每一次重试同步，尤其是如果触发了全量同步的判断，都会导致 <code>fork()</code> 操作。频繁的 <code>fork()</code> 会消耗大量 CPU 资源，导致服务器卡死。</li><li><strong>内存消耗飙升</strong>：<code>fork()</code> 操作在写时复制（Copy-On-Write）机制下，如果实例数据量大，会导致内存占用显著增加，有被系统强制杀死的风险。</li><li><strong>服务不可用</strong>：Redis 进程忙于处理这个无意义的死循环，无法有效处理外部客户端的正常请求，性能急剧下降甚至无响应。</li><li><strong>日志磁盘爆满</strong>：日志文件会被每秒一轮的重复错误信息迅速填满。</li></ol><h4><span id="如何修复">如何修复？</span></h4><p>修复方法非常简单直接，就是<strong>打破这个循环</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接到出问题的 Redis 服务器</span></span><br><span class="line">redis-cli -p 6381</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令，让它停止扮演从节点角色，恢复正常</span></span><br><span class="line">127.0.0.1:6381&gt; SLAVEOF NO ONE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>执行后，它解除了自己的从节点身份，循环立即终止，CPU 和内存使用率会逐渐恢复正常。</p><h3><span id="总结">总结</span></h3><table><thead><tr><th align="left">操作</th><th align="left">正常用法</th><th align="left"><strong>错误用法（自己连自己）</strong></th></tr></thead><tbody><tr><td align="left"><strong>命令</strong></td><td align="left"><code>SLAVEOF &lt;真实主节点IP&gt; &lt;端口&gt;</code></td><td align="left"><code>SLAVEOF 127.0.0.1 &lt;自身端口&gt;</code></td></tr><tr><td align="left"><strong>逻辑</strong></td><td align="left">两个独立进程间的<strong>网络通信</strong>和数据同步。</td><td align="left">单个进程内部的<strong>逻辑死锁</strong>和<strong>自循环</strong>。</td></tr><tr><td align="left"><strong>数据</strong></td><td align="left">从节点会拥有主节点的数据副本。</td><td align="left"><strong>数据不会有任何变化</strong>，但进程忙于循环，无法服务。</td></tr><tr><td align="left"><strong>后果</strong></td><td align="left">实现读写分离、数据冗余。</td><td align="left"><strong>服务不可用</strong>，CPU&#x2F;内存资源被耗尽。</td></tr><tr><td align="left"><strong>性质</strong></td><td align="left">核心的<strong>功能特性</strong>。</td><td align="left">危险的<strong>错误配置</strong>和<strong>运维事故</strong>。</td></tr></tbody></table><p><strong>切记</strong>：<code>SLAVEOF</code> 是一个强大的工具，但绝对不要指向自己。在自动化脚本和运维操作中，务必加入检查逻辑，防止这种“自杀式”配置的发生。</p><p>Redis 的复制拓扑非常灵活，可以根据不同的应用场景选择最合适的结构。这三种结构在复杂性、性能和容灾能力上各有侧重。</p><hr><h2><span id="拓扑结构">拓扑结构</span></h2><h3><span id="1-一主一从结构">1. 一主一从结构</span></h3><p>这是最简单、最基础的复制拓扑。</p><ul><li><p><strong>结构描述</strong>：一个主节点（Master）配一个从节点（Slave）。</p></li><li><p><strong>示意图</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redis-A (Master)</span><br><span class="line">      |</span><br><span class="line">      |</span><br><span class="line">Redis-B (Slave)</span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong></p><ol><li><strong>架构简单</strong>：部署和维护都非常容易，逻辑清晰。</li><li><strong>故障转移基础</strong>：这是实现高可用的最小单元。当主节点宕机时，可以手动（或通过哨兵自动）将从节点 <code>SLAVEOF NO ONE</code> 提升为主节点，继续提供服务，实现故障恢复。</li><li><strong>读写分离与持久化优化</strong>：<ul><li><strong>读写分离</strong>：可以让应用程序在主节点上写，在从节点上读，分担负载。</li><li><strong>持久化优化</strong>：<strong>可以在从节点上开启 AOF 持久化，而在主节点上关闭</strong>。这样做的好处是：<ul><li>避免了持久化（生成 RDB 或写 AOF）对主节点性能造成的任何干扰，保证主节点极高的写入性能。</li><li>从节点同样可以保证数据的安全性（因为它有完整的 AOF 日志）。这是一种非常经典的性能与安全兼顾的部署方式。</li></ul></li></ul></li></ol><p><strong>缺点</strong></p><ol><li><strong>有限的读扩展能力</strong>：只有一个从节点来处理读请求，读性能的扩展能力有限。</li><li><strong>容错性一般</strong>：如果唯一的从节点也宕机了，系统就失去了备份和读扩展能力，直到从节点恢复。</li><li><strong>主节点负载</strong>：主节点仍需承担复制所有数据到一个从节点的压力。</li></ol><p><strong>适用场景</strong>：数据量不大、读请求不是特别多的场景；作为高可用方案的基础单元；希望保证数据安全但又想最大化主节点写入性能的场景。</p><hr><h3><span id="2-一主多从结构星形结构">2. 一主多从结构（星形结构）</span></h3><p>这是最常见的拓扑结构，主要用于<strong>读写分离</strong>。</p><ul><li><p><strong>结构描述</strong>：一个主节点（Master）配多个从节点（Slave）。</p></li><li><p><strong>示意图</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      Redis-A (Master)</span><br><span class="line">      /    |    \</span><br><span class="line">     /     |     \</span><br><span class="line">Redis-B Redis-C Redis-D ... (Slaves)</span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong></p><ol><li><strong>强大的读扩展能力</strong>：这是其核心优势。通过部署多个从节点，可以将大量的读请求负载均衡到各个从节点上，极大地提升了系统的整体读吞吐量，轻松应对高并发读场景。</li><li><strong>专用从节点</strong>：可以为一个从节点分配特殊的任务。例如，专门用于执行 <code>keys</code>、<code>sort</code> 等耗时较长的命令，或者专门用于做每日的 RDB 快照备份，而不会影响为线上提供服务的其他从节点。</li><li><strong>更高的数据冗余</strong>：多个从节点意味着多份数据副本，数据安全性更高。</li></ol><p><strong>缺点</strong></p><ol><li><strong>加重主节点负担</strong>：这是最大的缺点。多个从节点会导致主节点写命令的多次发送。主节点需要为<strong>每一个</strong>从节点单独发送一份数据副本。如果从节点数量非常多（例如几十个），主节点的网络和 CPU 资源将大量消耗在复制操作上，反而会影响其处理正常写命令的能力。</li><li><strong>复制延迟放大</strong>：如果主节点写入压力巨大，所有从节点都可能出现不同程度的复制延迟（Replication Lag）。从节点越多，最后一个完成同步的从节点的延迟可能越大。</li><li><strong>资源消耗</strong>：每个从节点都会占用独立的内存来存储完整的数据集，对物理资源的消耗更大。</li></ol><p><strong>适用场景</strong>：读远大于写的经典互联网业务场景，需要显著提升读性能。</p><hr><h3><span id="3-树形分层主从结构">3. 树形（分层）主从结构</span></h3><p>这是一种用于优化一主多从缺点的进阶拓扑结构。</p><ul><li><p><strong>结构描述</strong>：从节点不仅可以复制主节点，还可以作为其他从节点的主节点，形成一种层级关系。<strong>中间的从节点既是下游节点的 Slave，又是上游节点的 Master</strong>。</p></li><li><p><strong>示意图</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      Redis-A (Master)</span><br><span class="line">         /   \</span><br><span class="line">        /     \</span><br><span class="line">Redis-B (Slave/Master)   Redis-C (Slave)</span><br><span class="line">      /   \</span><br><span class="line">     /     \</span><br><span class="line">Redis-D (Slave)   Redis-E (Slave)</span><br></pre></td></tr></table></figure><ul><li>A 是主节点。</li><li>B 和 C 是 A 的从节点。</li><li>D 和 E 是 B 的从节点（此时 B 是 D 和 E 的主节点）。</li></ul></li></ul><p><strong>优点</strong></p><ol><li><strong>显著减轻主节点压力</strong>：这是其核心价值。有效降低主节点负载和需要传送给从节点的数据量。主节点 A 只需要将数据同步给 B 和 C 两个节点，再由 B 节点将数据同步给 D 和 E。这样，主节点只需要处理 <strong>2 个</strong>从节点的复制请求，而不是 <strong>4 个</strong>。</li><li><strong>网络优化</strong>：在跨机房或跨地域部署时，可以让一个机房内的一个从节点（如 B）作为本机房的其他从节点（D、E）的主节点，避免所有机器都直接跨网络连接远方的主节点，节省了带宽并降低了延迟。</li></ol><p><strong>缺点</strong></p><ol><li><strong>架构复杂</strong>：部署和维护的复杂度更高。</li><li><strong>延迟增加</strong>：数据需要经过多层传递，到达最下层从节点（如 D、E）的延迟会比直接连接主节点的从节点（如 C）更高。</li><li><strong>故障点增加</strong>：中间层的节点（如 B）变得非常关键。如果它宕机，其下层的所有从节点（D、E）都会中断复制。</li></ol><p><strong>适用场景</strong>：主节点需要挂载大量从节点（例如超过 10 个）的场景；跨地域部署时优化网络带宽和成本的场景。</p><h3><span id="总结对比表">总结对比表</span></h3><table><thead><tr><th align="left">拓扑结构</th><th align="left">优点</th><th align="left">缺点</th><th align="left">核心应用场景</th></tr></thead><tbody><tr><td align="left"><strong>一主一从</strong></td><td align="left">简单、故障转移基础、可优化持久化</td><td align="left">读扩展性差</td><td align="left">数据备份、高可用基础、写密集型场景</td></tr><tr><td align="left"><strong>一主多从</strong></td><td align="left"><strong>读性能扩展性极强</strong>、数据冗余高、职责分离</td><td align="left"><strong>主节点压力大</strong>、资源消耗多</td><td align="left"><strong>读写分离</strong>，读多写少的经典业务</td></tr><tr><td align="left"><strong>树形主从</strong></td><td align="left"><strong>极大减轻主节点压力</strong>、优化网络带宽</td><td align="left">架构复杂、延迟增加、故障点增加</td><td align="left">挂载大量从节点、跨地域部署</td></tr></tbody></table><p>最终的选择取决于具体需求：是更注重读性能、写性能，还是数据的安全性，以及运维能力和基础设施情况。</p><h2><span id="主从结构服务器重启问题">主从结构服务器重启问题</span></h2><p>通过上述方式创建主从节点后，若我们用 <code>service redis restart</code> 重启主节点，会发现主节点重启失败，这是因为当我们利用该指令启动服务是通过 <code>redis</code> 用户启动的服务，而我们通过 <code>redis-cli</code> 连接时使用的是 <code>root</code> 用户。而 <code>redis-cli</code> 指令是在主节点创建之后用来创建从节点的。这就意味着这些从节点创建后也会在相同的目录下创建和 <code>redis</code> 用户一样的 <code>aof</code> 或 <code>rdb</code> 文件。当我们创建主节点时，文件的拥有者和所属组是 <code>redis</code> 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─[root@VM-16-15-debian] - [~redis/appendonlydir] - [1145]</span><br><span class="line">└─[$] <span class="built_in">rm</span> -rf appendonly.aof.*                                                                                [16:39:32]</span><br><span class="line">┌─[root@VM-16-15-debian] - [~redis/appendonlydir] - [1146]</span><br><span class="line">└─[$] service redis-server restart                                                                           [16:41:05]</span><br><span class="line">┌─[root@VM-16-15-debian] - [~redis/appendonlydir] - [1147]</span><br><span class="line">└─[$] ll                                                                                                     [16:41:10]</span><br><span class="line">total 8.0K</span><br><span class="line">-rw-rw---- 1 redis redis 89 Aug 21 16:41 appendonly.aof.1.base.rdb</span><br><span class="line">-rw-r----- 1 redis redis  0 Aug 21 16:41 appendonly.aof.1.incr.aof</span><br><span class="line">-rw-r----- 1 redis redis 88 Aug 21 16:41 appendonly.aof.manifest</span><br></pre></td></tr></table></figure><p>当我们利用 <code>redis-cli</code> 命令创建从节点时，这些从节点的 <code>aof</code> 或 <code>rdb</code> 文件的拥有者和所属组会变成 <code>root</code> 用户。这就导致了权限问题，从而使得主节点在重启时无法正常加载这些文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─[root@VM-16-15-debian] - [~redis/appendonlydir] - [1148]</span><br><span class="line">└─[$] ll                                                                                                     [16:41:26]</span><br><span class="line">total 12K</span><br><span class="line">-rw-rw---- 1 redis redis 89 Aug 21 16:41 appendonly.aof.1.base.rdb</span><br><span class="line">-rw-r----- 1 redis redis  0 Aug 21 16:41 appendonly.aof.1.incr.aof</span><br><span class="line">-rw-r--r-- 1 root  root  89 Aug 21 16:41 appendonly.aof.7.base.rdb</span><br><span class="line">-rw-r--r-- 1 root  root   0 Aug 21 16:41 appendonly.aof.7.incr.aof</span><br><span class="line">-rw-r--r-- 1 root  root  88 Aug 21 16:41 appendonly.aof.manifest</span><br></pre></td></tr></table></figure><p>关系如下：</p><p><img src="/img/Redis/slave/redis.png" alt="alt text"></p><p>可以看到，因为 <code>Redis7</code> 版本后对混合持久化采用版本号轮转的方式来存储的，因此 <code>base</code> 文件和 <code>incr</code> 文件并不冲突，但是 <code>manifest</code> 文件的拥有者和所属组会变成 <code>root</code> 用户，这就会导致 <code>service</code> 命令重启主节点后主节点发现 <code>appendonly.aof.manifest</code> 文件时权限不足，而且也没有办法对该文件进行删除，故无法在指定的路径下创建新的 <code>manifest</code> 文件，就会导致重启失败。</p><p>解决方法很简单，我们让子节点的持久化文件存储在和主节点不同的目录下即可。我们可以在从节点的配置文件中指定不同的 <code>appendonly</code> 和 <code>dbfilename</code> 路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 从节点1</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir /home/ljx/redistest/project2/slave1</span><br><span class="line"># 从节点2</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir /home/ljx/redistest/project2/slave2</span><br></pre></td></tr></table></figure><p>这样一来，我们就让每个不同的节点的持久化文件存储在不同的目录下，避免了权限冲突的问题。</p><p>同时，在生产环境中，建议所有 Redis 实例都统一用 redis 用户启动，避免 root 写入文件</p><h2><span id="主从复制原理">主从复制原理</span></h2><h3><span id="redis-主从复制过程概要">Redis 主从复制过程概要</span></h3><p>Redis 主从复制是数据同步的核心机制，其建立过程主要包含以下六个关键步骤。下图清晰地展示了从节点启动后，与主节点建立连接并完成数据同步的完整流程：</p><pre class="mermaid">flowchart TD    A[从节点配置 slaveof &ltmaster_ip&gt &ltmaster_port&gt] --> B    subgraph B [第1步: 保存主节点信息]        B1[保存master_ip与master_port\nmaster_link_status:down]    end    B --> C    subgraph C [第2步: 建立TCP连接]        C1[从节点定时任务尝试连接主节点]        C2{连接成功?}        C2 -- 是 --> D[发送PING命令]        C2 -- 否 --> C3[等待重试]    end    D --> E{PONG响应正常?}    E -- 是 --> F    E -- 否 --> C3[断开连接, 等待重试]    subgraph F [第3步: 权限验证]        F1[主节点要求密码?]        F1 -- 是 --> F2[从节点提供masterauth]        F2 --> F3{密码验证通过?}        F3 -- 是 --> G        F3 -- 否 --> H[复制过程停止]        F1 -- 否 --> G    end    subgraph G [第4步: 同步数据集]        G1[首次复制?]        G1 -- 是 --> G2[进行全量同步]        G1 -- 否 --> G3[尝试部分同步]    end    G --> I    subgraph I [第5步: 命令持续复制]        I1[主节点持续发送\n修改命令]        I2[从节点执行命令\n保持数据一致性]        I1 --> I2    end</pre><h4><span id="详细步骤说明">详细步骤说明</span></h4><p><strong>1. 保存主节点信息</strong></p><ul><li><strong>触发</strong>：从节点 (<code>slave</code>) 配置 <code>slaveof &lt;master_ip&gt; &lt;master_port&gt;</code> 并启动后。</li><li><strong>动作</strong>：从节点将主节点的 IP (<code>master_host</code>) 和端口 (<code>master_port</code>) 保存到自身。</li><li><strong>状态</strong>：此时主从连接尚未建立，连接状态 (<code>master_link_status</code>) 为 <code>down</code>。</li></ul><p><strong>2. 主从建立 Socket 连接</strong></p><ul><li><strong>触发</strong>：从节点内部有一个每秒运行的定时任务，用于维护复制逻辑。</li><li><strong>动作</strong>：定时任务发现新配置的主节点后，会尝试与主节点 (<code>master</code>) 建立一个 TCP 网络连接。</li><li><strong>重试</strong>：如果连接失败，定时任务会无限重试，直到连接成功或用户停止复制。</li></ul><p><strong>3. 发送 PING 命令（应用层健康检查）</strong></p><ul><li><strong>触发</strong>：TCP 连接成功建立后。</li><li><strong>目的</strong>：检查主节点是否在应用层正常工作，以及当前连接的网络状态是否良好。</li><li><strong>结果</strong>：<ul><li><strong>成功</strong>：主节点返回 <code>PONG</code>，进入下一步。</li><li><strong>失败</strong>：从节点会断开 TCP 连接，并等待定时任务下次重新建立连接。</li></ul></li></ul><p><strong>4. 权限验证</strong></p><ul><li><strong>触发</strong>：PING-PONG 检查通过后。</li><li><strong>验证方式</strong>：<ul><li>如果主节点配置了 <code>requirepass</code> 参数，则需要进行密码验证。</li><li>从节点需要通过 <code>masterauth</code> 参数配置相同的密码。</li></ul></li><li><strong>结果</strong>：<ul><li><strong>成功</strong>：复制过程继续。</li><li><strong>失败</strong>：从节点的复制过程停止。</li></ul></li></ul><p><strong>5. 同步数据集</strong></p><ul><li><strong>触发</strong>：权限验证通过后，尤其是首次建立复制的场景。</li><li><strong>动作</strong>：主节点将其持有的全部数据发送给从节点。</li><li><strong>特性</strong>：这是复制过程中最耗时的一步，根据不同情况分为：<ul><li><strong>全量同步</strong>：从节点首次连接或无法部分同步时，主节点生成 <code>RDB</code> 快照并发送。</li><li><strong>部分同步</strong>：连接中断后重连，主节点仅发送中断期间丢失的命令（依赖复制积压缓冲区 <code>repl-backlog-buffer</code>）。</li></ul></li></ul><p><strong>6. 命令持续复制</strong></p><ul><li><strong>触发</strong>：全量&#x2F;部分同步完成后。</li><li><strong>动作</strong>：<ul><li>主节点每执行一个会修改数据的写命令，都会异步地发送给从节点。</li><li>从节点接收并执行相同的命令，从而保证主从数据的一致性。</li></ul></li><li><strong>状态</strong>：复制进入稳定的持续阶段，只要连接保持，数据就会一直同步。</li></ul><h3><span id="redis-数据同步核心机制psync-详解">Redis 数据同步核心机制：PSYNC 详解</span></h3><p>在 Redis 主从复制中，数据同步是保证数据一致性的基石。<code>PSYNC</code> 命令作为 <code>SYNC</code> 的增强版，有效地解决了全量复制在高开销和网络抖动场景下的痛点，支持<strong>全量复制</strong>和<strong>部分复制</strong>两种模式。</p><h4><span id="一-两种同步模式">一、两种同步模式</span></h4><ol><li><p><strong>全量复制 (Full Resynchronization)</strong></p><ul><li><strong>场景</strong>：主要用于初次建立主从关系的场景。</li><li><strong>过程</strong>：主节点将当前内存中的全部数据生成一个 RDB 快照文件，发送给从节点。从节点清空自身旧数据后，加载 RDB 文件。</li><li><strong>开销</strong>：当数据量巨大时，会对主节点的 CPU、内存、磁盘 I&#x2F;O 以及网络带宽造成巨大压力。</li></ul></li><li><p><strong>部分复制 (Partial Resynchronization)</strong></p><ul><li><strong>场景</strong>：用于处理因网络闪断等原因造成数据丢失后重连的场景。</li><li><strong>过程</strong>：从节点重新连接后，主节点仅补发中断期间缺失的命令数据。</li><li><strong>优势</strong>：补发的数据量远小于全量数据，开销小，效率高，是保障复制高效的关键。</li></ul></li></ol><h4><span id="二-psync-的核心要素复制-id-与偏移量">二、PSYNC 的核心要素：复制 ID 与偏移量</span></h4><p><code>PSYNC</code> 命令的语法为：<code>PSYNC &lt;replid&gt; &lt;offset&gt;</code>。其运行逻辑依赖于两个核心机制：</p><ol><li><p><strong>复制 ID (Replication ID)</strong></p><ul><li>每个主节点都有一个唯一的 <code>master_replid</code>，用于标识一个特定的数据集。主节点重启或从节点晋升为主节点时，会生成一个新的 <code>replid</code>。</li><li>从节点会保存主节点的 <code>replid</code>，并在尝试重连时发送给主节点。</li><li><strong><code>master_replid2</code> 的妙用</strong>：节点（尤其是曾切换角色的节点）会记录两组 <code>replid</code>。例如，从节点因网络分区“自立为主”后，会生成新的 <code>master_replid</code>，同时将旧主节点的 <code>replid</code> 保存在 <code>master_replid2</code> 中。这样网络恢复后，它可以根据 <code>master_replid2</code> 找回原来的主从关系，避免不必要的全量同步。</li></ul></li><li><p><strong>复制偏移量 (Replication Offset)</strong></p><ul><li><strong>主从节点各自维护</strong>一个偏移量 (<code>offset</code>)。</li><li><strong>主节点</strong>每传播一个写命令，其偏移量 <code>master_repl_offset</code> 就会增加该命令的字节长度。</li><li><strong>从节点</strong>每接收到并执行一个命令，其偏移量 <code>slave_repl_offset</code> 也会相应增加。</li><li><strong>作用</strong>：通过对比主从节点的偏移量，可以判断数据是否一致。当从节点重连时，通过上报自己的 <code>offset</code>，主节点便能判断需要补发哪些数据。</li></ul></li></ol><h4><span id="三-psync-的工作流程">三、PSYNC 的工作流程</span></h4><p>其工作流程可以概括为以下几个步骤，如下图所示：</p><pre class="mermaid">flowchart TD    A[从节点发送 PSYNC 请求] --> B{主节点判断}    B -- replid 不匹配<br>或 offset 不在积压缓冲区 --> C[回复 +FULLRESYNC<br>触发全量复制]    B -- replid 匹配且<br>offset 在积压缓冲区内 --> D[回复 +CONTINUE<br>触发部分复制]    C --> E[从节点接收RDB快照并加载]    D --> F[主节点发送积压缓冲区内<br>从offset之后的所有命令]    E --> G[进入命令传播阶段<br>主持续发送写命令]    F --> G</pre><ol><li><strong>从节点发送请求</strong>：从节点向主节点发送 <code>PSYNC ? -1</code>（请求全量复制）或 <code>PSYNC &lt;replid&gt; &lt;offset&gt;</code>（请求部分复制）。</li><li><strong>主节点决策</strong>：主节点根据收到的 <code>replid</code> 和 <code>offset</code> 判断如何响应：<ul><li>如果 <code>replid</code> 与自身不匹配，或 <code>offset</code> 背后的数据不在<strong>复制积压缓冲区</strong>中，则回复 <code>+FULLRESYNC &lt;replid&gt; &lt;offset&gt;</code>，触发<strong>全量复制</strong>。</li><li>如果 <code>replid</code> 匹配且 <code>offset</code> 背后的数据仍在缓冲区中，则回复 <code>+CONTINUE</code>，触发<strong>部分复制</strong>，并将缺失的命令流发送给从节点。</li></ul></li><li><strong>同步执行</strong>：从节点根据响应执行全量或部分同步流程。</li><li><strong>命令持续传播</strong>：同步完成后，主节点进入命令传播阶段，持续将新的写命令发送给从节点，维持数据最终一致性。</li></ol><h4><span id="四-总结与优势">四、总结与优势</span></h4><ul><li><strong>自动化</strong>：<code>PSYNC</code> 过程由 Redis 自身管理，开发者无需手动干预。</li><li><strong>高效性</strong>：部分复制机制极大地降低了网络闪断带来的复制开销。</li><li><strong>可靠性</strong>：通过 <code>Replication ID</code> 和 <code>Offset</code> 的巧妙设计， robustly 处理了主从切换和重连的各种复杂场景。</li><li><strong>非阻塞</strong>：与旧的 <code>SYNC</code> 命令不同，<code>PSYNC</code> 执行期间不会阻塞主节点的其他操作。</li></ul><h4><span id="注意事项">注意事项</span></h4><p>在 <code>Redis</code> 新版本当中，<code>sync</code> 指令也是采用的创建后台子进程的方式来进行全量数据的同步，这样可以避免阻塞主线程，提高系统的整体性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">&quot;psync&quot;</span>)) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If a slave uses SYNC, we are dealing with an old implementation</span></span><br><span class="line"><span class="comment">         * of the replication protocol (like redis-cli --slave). Flag the client</span></span><br><span class="line"><span class="comment">         * so that we don&#x27;t expect to receive REPLCONF ACK feedbacks. */</span></span><br><span class="line">        c-&gt;flags |= CLIENT_PRE_PSYNC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.child_type == CHILD_TYPE_RDB &amp;&amp;</span><br><span class="line">        server.rdb_child_type == RDB_CHILD_TYPE_DISK)&#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (server.child_type == CHILD_TYPE_RDB &amp;&amp;</span><br><span class="line">               server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF) &amp;&amp;</span><br><span class="line">            server.repl_diskless_sync_delay) &#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess()) &#123;</span><br><span class="line">                startBgsaveForReplication(c-&gt;slave_capa, c-&gt;slave_req);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，8.2.1 版本中的 <code>Redis</code> 在实现 <code>SYNC</code> 时，同样会让它执行 <code>startBgsaveForReplication</code> 从而创建子进程实现复制，我们查询 <code>Redis</code> 文档可以看到：</p><p><img src="/img/Redis/slave/doc.png" alt="redis"></p><p>“在较新版本的 Redis 中，它已被 PSYNC 取代”，这是官方文档的原话</p><h3><span id="redis-全量复制">Redis 全量复制</span></h3><p>全量复制是 Redis 主从复制中最为基础和彻底的数据同步方式。它确保了从节点在初次建立复制或无法进行部分复制时，获得与主节点完全一致的数据副本。然而，这个过程成本高昂，理解其机制对于优化 Redis 架构至关重要。</p><h4><span id="一-全量复制的核心流程">一、全量复制的核心流程</span></h4><p>全量复制的过程可以清晰地分为以下几个阶段，其完整流程如下图所示：</p><pre class="mermaid">flowchart TD    A[从节点发送PSYNC ? -1] --> B[主节点回复+FULLRESYNC<br>并携带replid与offset]    B --> C[主节点执行bgsave<br>生成RDB快照]    C --> D[主节点将RDB文件发送给从节点]    D --> E[从节点将RDB文件保存至本地磁盘]    C -.-> F[主节点将bgsave期间的<br>写命令存入复制缓冲区]    E --> G[从节点清空自身旧数据]    G --> H[从节点加载RDB文件]    F --> I[主节点发送复制缓冲区中的命令]    I --> J[从节点执行这些命令<br>追平主节点最新状态]    H --> K[若开启AOF, 从节点执行<br>BGREWRITEAOF重写AOF文件]</pre><p><strong>阶段一：连接与协商</strong></p><ol><li><strong>发起同步</strong>：从节点启动后，向主节点发送 <code>PSYNC ? -1</code> 命令。参数 <code>?</code> 和 <code>-1</code> 表明从节点未知主节点的运行 ID 和复制偏移量，意图进行全量复制。</li><li><strong>主节点响应</strong>：主节点识别出全量复制的请求，回复 <code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>。其中包含主节点的<strong>运行 ID</strong> 和当前的<strong>复制偏移量</strong>，从节点会保存这些信息以备后用。</li></ol><p><strong>阶段二：RDB 快照生成与传输</strong> 3. <strong>生成快照</strong>：主节点调用 <code>bgsave</code> 命令，在<strong>后台派生一个子进程</strong>生成 RDB 快照文件。此举避免了阻塞主进程。 4. <strong>传输数据</strong>：RDB 文件生成后，主节点将其发送给从节点。从节点会将其<strong>暂存到本地磁盘</strong>。</p><p><strong>阶段三：数据加载与追赶</strong> 5. <strong>清空旧数据</strong>：从节点在加载新的 RDB 数据前，会<strong>清空自身所有旧数据</strong>，以确保状态的一致性。 6. <strong>加载快照</strong>：从节点<strong>加载</strong>接收到的 RDB 文件到内存中，此时其数据状态与主节点开始执行 <code>bgsave</code> 那个时刻的点完全相同。 7. <strong>补发增量数据</strong>：在 <code>bgsave</code> 子进程生成 RDB 期间，主节点接收的新写命令会被写入一个专门的<strong>复制缓冲区</strong>。待 RDB 传输完成，主节点会将该缓冲区内的所有命令<strong>补发</strong>给从节点。从节点执行这些命令，从而追平主节点的最新状态。</p><p><strong>阶段四：后续处理</strong> 8. <strong>AOF 重写</strong>：如果从节点配置了 AOF 持久化，在加载完 RDB 后，它会自动触发 <code>BGREWRITEAOF</code> 操作，立即生成一份与当前内存数据对应的最新 AOF 文件。</p><h4><span id="二-全量复制的高成本分析">二、全量复制的高成本分析</span></h4><p>全量复制是一项资源密集型操作，其高昂的成本体现在多个环节：</p><ol><li><p><strong>主节点开销</strong></p><ul><li><strong>CPU&#x2F;内存</strong>：<code>bgsave</code> 创建子进程进行快照生成，属于 <strong>CPU 密集型</strong>操作，可能导致主节点 CPU 占用飙升。同时，子进程会拷贝父进程的内存页，可能导致<strong>内存占用翻倍</strong>。</li><li><strong>磁盘 I&#x2F;O</strong>：传统模式下，主节点需要将 RDB 文件<strong>写入磁盘</strong>。</li></ul></li><li><p><strong>网络开销</strong></p><ul><li>需要将整个 RDB 文件<strong>通过网络传输</strong>。对于数据量达数个 GB 的实例，会占用大量带宽，可能影响其他业务的网络性能。</li></ul></li><li><p><strong>从节点开销</strong></p><ul><li><strong>数据清空与加载</strong>：从节点<strong>清空旧数据</strong>和<strong>加载新 RDB</strong> 的过程是阻塞性的，在此期间从节点无法对外提供服务。</li><li><strong>磁盘 I&#x2F;O</strong>：从节点需要将接收到的 RDB 数据<strong>写入本地磁盘</strong>，然后再次<strong>从磁盘读取</strong>以加载到内存。</li></ul></li></ol><p><strong>结论</strong>：应<strong>极力避免</strong>对数据量大的生产环境实例进行全量复制。优化策略包括：配置合理的 <code>repl-backlog-size</code> 以支持部分复制、保证主从网络稳定、在从节点重启前做好持久化等。</p><h4><span id="三-优化无盘复制-diskless-replication">三、优化：无盘复制 (Diskless Replication)</span></h4><p>为了 mitigating 磁盘 I&#x2F;O 带来的开销，Redis 自 2.8.18 版本起支持<strong>无盘复制</strong>。</p><ul><li><strong>传统模式</strong>：主节点 <code>bgsave</code> → <strong>写入磁盘</strong> → 从节点读取 RDB 文件。</li><li><strong>无盘模式</strong>：主节点 <code>bgsave</code> → <strong>直接通过网络发送 RDB 数据给从节点</strong>。</li></ul><p><strong>优势</strong>：省去了主节点磁盘写入和从节点磁盘读取的步骤，<strong>显著降低磁盘 I&#x2F;O 压力</strong>，尤其适用于磁盘性能较差的机器或高速网络环境。可通过配置 <code>repl-diskless-sync yes</code> 开启。</p><blockquote><p>在大多数情况下，网络传输速度都是最大的性能瓶颈，因此，即便有了无盘复制的优化，实际上对效率的提升并不大</p></blockquote><h3><span id="redis-部分复制">Redis 部分复制</span></h3><p>部分复制是 Redis 为优化全量复制的高昂开销而设计的核心机制。它能够在主从连接出现短暂中断后，仅同步缺失的数据，从而极大地提升复制效率和系统可用性。</p><h4><span id="一-核心概念复制积压缓冲区">一、核心概念：复制积压缓冲区</span></h4><p>要理解部分复制，首先要了解其基石——<strong>复制积压缓冲区</strong>。</p><ul><li><p><strong>是什么</strong>：复制积压缓冲区是主节点上一个<strong>固定长度的先进先出队列</strong>。默认大小为 1MB，在主节点拥有从节点时自动创建。</p></li><li><p><strong>工作原理</strong>：主节点在处理每一个写命令时，除了将其发送给所有从节点，还会<strong>写入这个缓冲区</strong>。这使得缓冲区中总是保存着最近传播的写命令。</p></li><li><p><strong>环形结构</strong>：缓冲区是一个环形队列，当新数据写满后，会覆盖最旧的数据。其状态可以通过 <code>INFO replication</code> 命令监控：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repl_backlog_active:1           <span class="comment"># 激活状态</span></span><br><span class="line">repl_backlog_size:1048576       <span class="comment"># 缓冲区总大小 (1MB)</span></span><br><span class="line">repl_backlog_first_byte_offset:7479 <span class="comment"># 缓冲区起始偏移量</span></span><br><span class="line">repl_backlog_histlen:1048576    <span class="comment"># 当前缓冲区中有效数据的长度</span></span><br></pre></td></tr></table></figure></li><li><p><strong>核心作用</strong>：根据偏移量 (<code>offset</code>)，主节点可以判断从节点缺失的数据是否还在这个缓冲区中。如果存在，即可进行部分复制；如果已被覆盖，则只能退回到全量复制。</p></li></ul><h4><span id="二-部分复制的触发与流程">二、部分复制的触发与流程</span></h4><p>部分复制的核心思想是“缺啥补啥”，其完整流程如下图所示，通常在网络中断后重连时触发：</p><pre class="mermaid">flowchart TD    A[主从连接因网络中断超时断开] --> B[中断期间: 主节点继续处理写命令<br>并将其存入复制积压缓冲区]    B --> C[网络恢复后, 从节点重连主节点]    C --> D[从节点发送PSYNC请求<br>携带之前的主节点replid与自身offset]    D --> E{主节点校验<br>从节点offset是否在<br>积压缓冲区范围内?}    E -- 是 --> F    subgraph F [部分复制流程]        F1[主节点回复 +CONTINUE]        F2[从节点接收响应, 准备接收数据]        F3[主节点从积压缓冲区中<br>查找并发送从offset之后的所有命令]        F4[从节点执行命令, 追平数据]    end    E -- 否 --> G    subgraph G [全量复制流程]        G1[主节点回复 +FULLRESYNC]        G2[触发完整的全量复制过程]    end    F --> H[同步完成, 进入命令持续传播阶段]    G --> H</pre><p><strong>流程阶段解析：</strong></p><ol><li><p><strong>连接中断与数据缓存</strong>：</p><ul><li>主从节点之间因网络抖动或中断，连接时间超过 <code>repl-timeout</code> 配置值，连接断开。</li><li>中断期间，主节点依然正常处理写命令。这些无法即时发送给从节点的命令被<strong>暂存到复制积压缓冲区</strong>中。</li></ul></li><li><p><strong>重连与同步请求</strong>：</p><ul><li>网络恢复后，从节点自动重连主节点，并重新发起复制请求。</li><li>从节点使用之前保存的<strong>主节点运行 ID</strong> 和<strong>自身的复制偏移量</strong>作为参数，发送 <code>PSYNC &lt;replid&gt; &lt;offset&gt;</code> 命令。</li></ul></li><li><p><strong>主节点验证与决策</strong>：</p><ul><li>主节点验证从节点传来的 <code>replid</code> 是否与自身匹配。</li><li><strong>关键检查</strong>：主节点判断从节点传来的 <code>offset</code> 是否还在自己的复制积压缓冲区范围内。<ul><li><strong>如果 <code>offset</code> 仍在缓冲区中</strong>：主节点回复 <code>+CONTINUE</code>，表示可以进行部分复制。</li><li><strong>如果 <code>offset</code> 已被覆盖</strong>：主节点回复 <code>+FULLRESYNC</code>，并触发全量复制。</li></ul></li></ul></li><li><p><strong>数据补发与最终一致</strong>：</p><ul><li>主节点从积压缓冲区中提取从节点 <code>offset</code> 之后的所有命令，发送给从节点。</li><li>从节点接收并执行这些命令，最终将自己的数据状态追平至与主节点一致。</li></ul></li></ol><h4><span id="三-部分复制的优势与配置建议">三、部分复制的优势与配置建议</span></h4><ul><li><p><strong>巨大优势</strong>：部分复制机制将中断恢复的代价从<strong>传输整个数据集</strong>降低为<strong>仅传输中断期间的少量写命令</strong>，极大地减少了对 CPU、网络和 I&#x2F;O 资源的消耗，降低了系统延迟。</p></li><li><p><strong>关键配置</strong>：</p><ul><li><strong><code>repl-backlog-size</code></strong>：<strong>调整此配置至关重要</strong>。对于写操作频繁的系统，1MB 的默认值可能很快被覆盖，导致部分复制失效。建议根据 <code>master_repl_offset</code> 的增长速度（如每秒偏移量增量）和可能的网络中断时间（如 60 秒）来估算并调大该值（例如设置为 <code>100MB</code>），以降低全量复制的概率。</li><li><strong><code>repl-timeout</code></strong>：设置合理的超时时间，避免在网络波动时过早断开连接。</li></ul></li></ul><h4><span id="四-总结">四、总结</span></h4><p>部分复制是 Redis 主从复制高可用性的关键保障。它通过<strong>复制积压缓冲区</strong>这一精巧的设计，实现了高效、快速的数据故障恢复。理解和合理配置 <code>repl-backlog-size</code> 等参数，是保证 Redis 主从架构在大流量、不稳定网络环境下依然稳定可靠的关键。</p><h3><span id="redis-实时复制维持数据最终一致性的心跳">Redis 实时复制：维持数据最终一致性的心跳</span></h3><p>当全量或部分复制完成后，主从节点之间的数据状态达到一致。此后，为了保持这种一致性，系统会进入<strong>实时复制</strong>阶段（也称为命令传播阶段）。这是主从复制过程中最持久和常态化的阶段，确保从节点能够实时跟上主节点的数据变化。</p><h4><span id="一-核心机制命令传播">一、核心机制：命令传播</span></h4><p>实时复制的核心过程非常简单高效：</p><ol><li><strong>主节点</strong>接收并执行任何一个会修改数据集（如 <code>SET</code>, <code>LPUSH</code>, <code>SADD</code>, <code>DEL</code> 等）的写命令。</li><li>主节点将该命令<strong>异步地</strong>通过之前建立的 TCP 长连接发送给所有从节点。</li><li><strong>从节点</strong>接收、解析并<strong>执行</strong>相同的命令，从而使得自身数据状态与主节点保持同步。</li></ol><p>这个过程是<strong>异步</strong>的，意味着主节点不会等待从节点执行完毕后再返回结果给客户端，这保证了高性能，但也带来了极短的<strong>主从延迟</strong>。</p><h4><span id="二-生命线心跳维护机制">二、生命线：心跳维护机制</span></h4><p>为了确保命令传播的 TCP 长连接稳定可用，并能及时发现失败的从节点，Redis 在主从节点之间实现了一套<strong>应用层的心跳检测机制</strong>。</p><p>这套机制的核心作用是<strong>保活连接</strong>和<strong>监控状态</strong>，其工作原理如下图所示：</p><pre class="mermaid">sequenceDiagram    participant M as 主节点    participant S as 从节点    Note over M, S: 心跳检测机制    loop Every 10 Seconds        M->>S: PING        S-->>M: PONG (响应)    end    loop Every 1 Second        S->>M: REPLCONF ACK <offset>    end    Note over M: 监控超时    Note over M: 若超过repl-timeout(默认60s)<br>未收到从节点REPLCONF ACK，<br>则判定从节点下线，断开连接。</offset></pre><p><strong>1. 主节点 → 从节点：PING（健康检查）</strong></p><ul><li><strong>频率</strong>：主节点默认每隔 <strong>10 秒</strong>向从节点发送一次 <code>PING</code> 命令。</li><li><strong>目的</strong>：<ul><li>检查从节点是否仍然存活。</li><li>检查网络连接是否正常。</li><li>维持长连接活性，防止被中间网络设备因超时断开。</li></ul></li></ul><p><strong>2. 从节点 → 主节点：REPLCONF ACK（偏移量上报）</strong></p><ul><li><strong>频率</strong>：从节点默认每隔 <strong>1 秒</strong>向主节点发送一次 <code>REPLCONF ACK &lt;offset&gt;</code> 命令。</li><li><strong>目的</strong>：<ul><li><strong>上报自身复制偏移量</strong>：主节点通过此命令知晓每个从节点的复制进度，可用于监控延迟和判断部分复制的可能性。</li><li><strong>作为另一种心跳信号</strong>：这是对主节点 <code>PING</code> 的补充，更频繁地向主节点证明自己的活跃状态。</li><li>实现<strong>读写分离</strong>场景下的<strong>弱一致性保证</strong>（通过 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 配置）。</li></ul></li></ul><h4><span id="三-超时判定与故障处理">三、超时判定与故障处理</span></h4><ul><li><strong><code>repl-timeout</code></strong>：这是一个关键配置项，默认值为 <strong>60 秒</strong>。它定义了主从节点之间心跳响应的超时时间。</li><li><strong>故障判定</strong>：如果主节点在 <code>repl-timeout</code> 时间内，既没有收到从节点的 <code>REPLCONF ACK</code> 响应，也没有收到其对 <code>PING</code> 的 <code>PONG</code> 回复，主节点就会判定该从节点已下线。</li><li><strong>处理方式</strong>：主节点会<strong>主动断开</strong>与该从节点的复制连接，以释放资源。从节点恢复后，需要重新发起连接并根据偏移量尝试进行部分复制或全量复制。</li></ul><h4><span id="四-总结与意义">四、总结与意义</span></h4><ul><li><strong>实时复制</strong>是主从复制中<strong>持续进行</strong>的阶段，通过异步传播命令来保持数据一致性。</li><li><strong>心跳机制</strong>是维持复制链路可靠的<strong>生命线</strong>，它包括主节点的 <code>PING</code> 和从节点的 <code>REPLCONF ACK</code>。</li><li><strong><code>repl-timeout</code></strong> 是判断连接健康度的关键阈值，超时会导致连接断开。</li><li>这种设计使得 Redis 主从复制在保证高性能的同时，也具备了一定的自愈能力，能够自动处理网络波动和从节点临时故障的场景，是构建可靠 Redis 架构的基础。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 事务</title>
      <link href="/2025/08/20/Redis/redis_trans/"/>
      <url>/2025/08/20/Redis/redis_trans/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5">Redis事务的概念</a></li><li><a href="#redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%9C%BA%E5%88%B6">Redis事务的操作与机制</a><ul><li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">事务的相关指令</a></li><li><a href="#redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9C%BA%E5%88%B6">Redis事务的机制</a></li></ul></li><li><a href="#redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E9%87%8D%E5%90%AF%E6%88%96%E5%85%B3%E9%97%AD%E6%97%B6%E7%9A%84%E8%A1%8C%E4%B8%BA">Redis事务的注意事项：重启或关闭时的行为</a><ul><li><a href="#aof-%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E9%9A%9C">AOF 持久化中的事务完整性保障</a></li><li><a href="#aof-%E5%BC%82%E5%B8%B8%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E8%A1%8C%E4%B8%BA">AOF 异常加载时的行为</a></li></ul></li><li><a href="#%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">实战建议与注意事项</a></li></ul><!-- tocstop --><h2><span id="redis事务的概念">Redis事务的概念</span></h2><p>Redis的事务与MySQL的事务概念类似，都是将一系列操作绑定为一个整体，使其能够批量执行。但与MySQL相比，Redis事务在实现上更为简单，功能也相对弱化。</p><p>Redis事务的主要特点包括：</p><ul><li><strong>弱化的原子性</strong>：Redis没有回滚机制，只能实现命令的批量执行，无法做到“一个失败就恢复到初始状态”。</li><li><strong>不保证一致性</strong>：Redis事务不涉及约束检查，也没有回滚机制，执行结果只保证命令能依次执行，但不保证事务中途不会出现非法状态。</li><li><strong>不需要隔离性</strong>：由于Redis是单线程处理请求的，因此不会并发执行事务，也就不存在复杂的隔离级别问题。</li><li><strong>不保证持久性</strong>：事务操作结果仅保存在内存中，是否持久化取决于Redis自身的持久化机制，与事务无关。</li></ul><p>本质上，Redis事务是通过在服务器端维护一个“事务队列”来实现的。客户端在事务中提交的命令会先进入队列，只有在发送 <code>EXEC</code> 命令时，事务队列中的所有操作才会被依次执行。因此，Redis事务只能保证队列中命令的<strong>连续执行</strong>，而不像MySQL事务那样具备严格的ACID特性。</p><p>总结来说，Redis事务更像是“批量执行命令”的机制，而不是传统意义上的完整事务控制。</p><h2><span id="redis事务的操作与机制">Redis事务的操作与机制</span></h2><p>Redis事务通过一组命令来完成，用户可以将多个命令绑定在一起，最后一次性执行。与传统数据库不同，Redis事务更像是批量执行命令的过程，但其控制逻辑却与乐观锁机制十分相似：<strong>先提交，再判断是否允许提交，如果不允许则回退，不会执行任何操作</strong>。在事务提交的竞争中，Redis也遵循<strong>谁先提交，谁生效</strong>的原则，而不是谁先开启事务。</p><h3><span id="事务的相关指令">事务的相关指令</span></h3><ol><li><p><strong>MULTI</strong><br>用于开启一个事务。执行成功后返回 <code>OK</code>，此时事务进入开启状态，接下来输入的命令并不会立刻执行，而是进入事务队列中等待提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p><strong>EXEC</strong><br>用于真正执行事务。事务队列中的所有命令会依次执行。如果在执行前，被 <code>WATCH</code> 监控的键发生了变化，则整个事务会被放弃，所有命令都不会执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br></pre></td></tr></table></figure></li><li><p><strong>DISCARD</strong><br>用于放弃当前事务。执行后会清空事务队列，之前加入的操作都不会被执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p><strong>WATCH</strong><br>用于监控一个或多个 <code>key</code>。在事务执行前，如果被监控的 <code>key</code> 被修改，则事务会失败并回滚，不会执行队列中的任何命令。这就像是一种乐观锁机制，确保事务在提交时数据没有被其他客户端篡改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; WATCH key</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key 100</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果此时有其他客户端修改了 key</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(nil)   # 执行失败</span><br></pre></td></tr></table></figure></li></ol><h3><span id="redis事务的机制">Redis事务的机制</span></h3><p>Redis事务的实现机制可以概括为以下几点：</p><ol><li><p><strong>命令入队</strong><br>当事务开启后，客户端的命令不会立即执行，而是进入事务队列，直到收到 <code>EXEC</code> 才会一并提交。</p></li><li><p><strong>乐观锁机制</strong><br>在事务提交时，Redis会检查被 <code>WATCH</code> 监控的键是否发生过修改。如果检测到修改，整个事务都会失败并回滚。</p><ul><li>Redis通过<strong>版本号机制</strong>来实现这一判断，每次 <code>key</code> 被修改都会更新其版本号。</li><li>在提交事务时，Redis会检查事务开始时记录的版本号与当前版本号是否一致，如果不一致则说明 <code>key</code> 被修改过，此时事务作废。</li></ul></li><li><p><strong>ABA问题的避免</strong><br>这种版本号机制与Java中的ABA问题处理方式类似。即便一个 <code>key</code> 的值被改为原来的值，版本号依然会发生变化，从而避免“值未变但实际被修改过”的情况。</p></li><li><p><strong>提交优先级</strong><br>Redis事务并不按照开启时间来决定生效顺序，而是根据<strong>谁先提交</strong>来决定结果。这样可以最大限度提高并发处理能力。</p></li></ol><hr><p>通过以上机制，Redis事务在保证性能的同时，利用 <code>WATCH</code> + 版本号机制实现了类似乐观锁的控制策略，确保了事务在提交阶段的数据一致性。</p><h2><span id="redis事务的注意事项重启或关闭时的行为">Redis事务的注意事项：重启或关闭时的行为</span></h2><p>当 Redis 在事务尚未提交时发生重启、崩溃或被关闭，未提交的事务命令会被丢弃，效果类似执行了 DISCARD：</p><h3><span id="aof-持久化中的事务完整性保障">AOF 持久化中的事务完整性保障</span></h3><ul><li>Redis 使用单次 write (2) 系统调用将事务写入 AOF，保证原子性。</li><li>如果在此过程中发生崩溃，AOF 文件末尾可能残留半条事务，Redis 启动时会检测并拒绝加载文件，防止加载不完整事务。可使用 <code>redis-check-aof</code> 工具修复。</li><li>官方指出：“Redis 重启后要么加载完整事务，要么完全忽略它，不会出现部分执行的情况。”</li></ul><h3><span id="aof-异常加载时的行为">AOF 异常加载时的行为</span></h3><ul><li>如果 AOF 文件末尾存在不完整命令，Redis 默认会截断它并继续加载，优先保证系统可用性。因此若在事务未提交前被截断，所有未执行的命令都会被丢弃。所以一般不需要担心 Redis 启动后会加载不完整的事务。</li></ul><hr><h2><span id="实战建议与注意事项">实战建议与注意事项</span></h2><ul><li><strong>尽快提交事务</strong>：开启事务后应及时使用 <code>EXEC</code>，避免操作滞留于队列中。</li><li><strong>使用合适的持久化策略</strong>：AOF 请配置适当 fsync 策略以减少数据丢失风险。</li><li><strong>启动故障自动修复</strong>：若启动时报 AOF 异常，可用 <code>redis-check-aof --fix</code> 修复。</li><li><strong>事务加载机制解释</strong>：Redis 保证“事务要么完整加载，要么完全不加载”，避免部分执行不一致。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 持久化</title>
      <link href="/2025/08/19/Redis/redis_rdb/"/>
      <url>/2025/08/19/Redis/redis_rdb/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#rdb">RDB</a><ul><li><a href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6">触发机制</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li><li><a href="#redis-rdb-%E6%8C%81%E4%B9%85%E5%8C%96%E4%BC%98%E7%BC%BA%E7%82%B9">Redis RDB 持久化优缺点</a></li><li><a href="#aof">AOF</a></li><li><a href="#aof-%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6">AOF 重写机制</a></li><li><a href="#aof-%E4%BC%98%E7%BC%BA%E7%82%B9">AOF 优缺点</a></li><li><a href="#redis-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E8%AF%A6%E8%A7%A3">Redis 混合持久化详解</a></li><li><a href="#redis-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E5%9C%A8-70-%E7%89%88%E6%9C%AC%E5%90%8E%E7%9A%84%E6%94%B9%E5%8A%A8">Redis 混合持久化在 7.0 版本后的改动</a></li></ul></li></ul><!-- tocstop --><p><code>Redis</code> 支持 <code>RDB</code> 和 <code>AOF</code> 两种持久化机制，持久化功能有效地避免因进程退出造成数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复</p><h2><span id="rdb">RDB</span></h2><p><code>RDB</code>（Redis Database）是 <code>Redis</code> 的默认持久化方式，它会在指定的时间间隔内将数据快照保存到磁盘上，也可以通过手动触发的方式触发</p><h3><span id="触发机制">触发机制</span></h3><h4><span id="手动触发">手动触发</span></h4><p>通过 <code>save</code> 指令和 <code>bgsave</code> 指令都可以实现手动触发快照机制，两者的区别如下：</p><ul><li><code>save</code> 命令：阻塞当前 <code>Redis</code> 服务器，直到保存操作完成，对于内存比较大的实例会造成长时间的阻塞，这种情况基本不采用该命令</li><li><code>bgsave</code> 命令：<code>Redis</code> 进程会执行 <code>fork</code> 操作创建子进程，<code>RDB</code> 持久化过程由子进程负责，完成后自动结束，子进程会通知父进程执行完毕，因此该指令所产生的阻塞只发生在 <code>fork</code> 阶段，因此时间很短。当然，<code>fork</code> 指令最大的开销在于进程控制块的复制和页表的复制，这些资源的复制同样是有非常大的开销的，且在子进程复制页表后，若父进程对内存进行了写操作，会触发写时拷贝，同样会有额外的资源消耗，因此并不建议频繁使用该命令</li></ul><h4><span id="自动触发">自动触发</span></h4><p>除了手动触发以外，<code>Redis</code> 运行自动触发 <code>RDB</code> 持久化机制，这个触发机制才是在实战中更具有价值的，触发时机如下：</p><p>是的，除了手动触发（<code>save</code>&#x2F;<code>bgsave</code>），<strong>自动触发 RDB 持久化</strong> 在实际生产环境中更为关键，因为它能平衡性能和数据安全，避免依赖人工干预。以下是 Redis 自动触发 RDB 的三种核心场景及其细节：</p><hr><h5><span id="1-通过-save-配置自动触发最常用">1. <strong>通过 <code>save</code> 配置自动触发（最常用）</strong></span></h5><ul><li><p><strong>配置语法</strong>：<br><code>save &lt;seconds&gt; &lt;key-changes&gt;</code><br>例如：<code>save 900 1</code> 表示 <strong>900 秒内至少 1 个 key 被修改</strong>时触发 <code>bgsave</code>。</p></li><li><p><strong>工作原理</strong>：<br>Redis 周期性检查是否满足配置的条件，若满足则自动启动 <code>bgsave</code>（后台执行，非阻塞）。</p></li><li><p><strong>默认配置</strong>（Redis 默认的 <code>redis.conf</code> 片段）：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>含义：  </p><ul><li>900 秒内 1 次修改 → 触发  </li><li>300 秒内 10 次修改 → 触发  </li><li>60 秒内 10000 次修改 → 触发<br>（满足任意一条即触发）</li></ul></li><li><p><strong>注意事项</strong>：  </p><ul><li>生产环境需根据业务负载调整参数，避免频繁触发（如高写入场景可放宽 <code>save</code> 条件）。  </li><li>若完全禁用自动保存，需配置 <code>save &quot;&quot;</code>。</li></ul></li></ul><hr><h5><span id="2-主节点在复制时自动触发">2. <strong>主节点在复制时自动触发</strong></span></h5><ul><li><strong>场景</strong>：当从节点（Slave）发起 <strong>全量复制（SYNC）</strong> 时，主节点（Master）会自动执行 <code>bgsave</code> 生成 RDB 文件，然后传输给从节点。  </li><li><strong>细节</strong>：  <ul><li>即使未配置 <code>save</code> 规则，复制过程也会强制触发 RDB。  </li><li>若主节点已有最近生成的 RDB 文件（且数据未显著变化），可能直接复用该文件（Redis 7.0+ 优化）。</li></ul></li><li><strong>风险</strong>：  <ul><li>主节点内存过大时，生成 RDB 可能阻塞主进程（<code>fork</code> + COW 开销），影响集群稳定性。  </li><li>解决方案：建议在低峰期扩容从节点，或使用 <code>repl-diskless-sync</code> 配置（无盘复制，直接通过网络发送数据，避免落盘）。</li></ul></li></ul><hr><h5><span id="3-执行-shutdown-时触发">3. 执行 <code>shutdown</code> 时触发</span></h5><ul><li><strong>行为</strong>：<br>当执行 <code>shutdown</code> 命令关闭 Redis 时，<strong>如果 AOF 未开启</strong>，Redis 会默认执行一次 <code>save</code>（同步阻塞式 RDB 持久化），确保数据不丢失。  </li><li><strong>控制参数</strong>：  <ul><li><code>shutdown save</code>：强制保存 RDB（默认行为）。  </li><li><code>shutdown nosave</code>：跳过保存，直接关闭。</li></ul></li><li><strong>应用场景</strong>：<br>在维护停机前手动执行 <code>shutdown save</code>，比直接杀进程更安全。</li></ul><h3><span id="配置文件">配置文件</span></h3><h4><span id="1-rdb-文件保存路径与动态配置">1. <strong>RDB 文件保存路径与动态配置</strong></span></h4><ul><li><strong>核心机制</strong>：<ul><li><strong>默认路径</strong>：<code>dir /var/lib/redis/</code> + <code>dbfilename dump.rdb</code><br>（注意：默认路径可能因安装方式或操作系统而异，例如 Docker 中常见 <code>/data</code>）</li></ul></li></ul><p>若手动修改配置文件，需重启 Redis 使其生效。</p><ul><li><strong>生产建议</strong>：<ul><li><strong>持久化配置</strong>：动态修改后需同步更新 <code>redis.conf</code>，避免重启失效。  </li><li><strong>权限管理</strong>：确保 Redis 进程对目标目录有读写权限（否则 <code>bgsave</code> 会静默失败）。  </li><li><strong>备份策略</strong>：将 RDB 文件保存到独立磁盘或云存储（如 AWS S3），避免单点故障。</li></ul></li></ul><hr><h4><span id="2-rdb-文件压缩的权衡">2. <strong>RDB 文件压缩的权衡</strong></span></h4><ul><li><p><strong>技术细节</strong>：</p><ul><li><strong>算法</strong>：LZF 压缩（低 CPU 开销，适合实时场景）。  </li><li><strong>压缩比</strong>：文本型数据（如 JSON）压缩率高，二进制数据（如序列化对象）效果有限。  </li><li><strong>开关控制</strong>：<code>rdbcompression yes</code>（默认开启），禁用可减少 CPU 占用（但文件体积激增）。</li></ul></li><li><p><strong>性能影响</strong>：</p><table><thead><tr><th>场景</th><th>开启压缩</th><th>关闭压缩</th></tr></thead><tbody><tr><td><strong>CPU 占用</strong></td><td>较高（尤其大数据集）</td><td>几乎为零</td></tr><tr><td><strong>磁盘 I&#x2F;O</strong></td><td>写入量减少 50%~80%</td><td>写入原始数据量</td></tr><tr><td><strong>网络传输</strong></td><td>更快（从节点同步加速）</td><td>慢（带宽占用高）</td></tr></tbody></table><p><strong>建议</strong>：  </p><ul><li>在 CPU 资源充足的场景下<strong>保持开启</strong>（尤其适合云环境或网络复制）。  </li><li>若 Redis 实例已 CPU 过载（如单核 80%+），可临时关闭压缩缓解压力。</li></ul></li></ul><hr><h4><span id="3-rdb-文件校验与故障恢复">3. <strong>RDB 文件校验与故障恢复</strong></span></h4><ul><li><p><strong>损坏检测</strong>：</p><ul><li><p>Redis 启动时自动校验 RDB 文件完整性（魔数 + CRC 校验），损坏则报错：<br><code># Fatal error loading the DB: Invalid file format.</code></p></li><li><p><strong>修复工具</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-rdb dump.rdb</span><br></pre></td></tr></table></figure><p>该工具会报告损坏位置（如无效键值对、文件截断等），但<strong>无法直接修复</strong>。</p></li></ul></li><li><p><strong>容灾方案</strong>：</p><ol><li><strong>恢复备份</strong>：从最近的正常 RDB 或 AOF 文件恢复。  </li><li><strong>重建数据</strong>：若无可用的备份，可尝试手动编辑 RDB 文件（风险极高，需十六进制工具）。  </li><li><strong>从从节点提升</strong>：如果主节点 RDB 损坏，且从节点数据完整，可故障转移至从节点。</li></ol></li><li><p><strong>预防措施</strong>：</p><ul><li><strong>定期验证</strong>：对备份的 RDB 文件运行 <code>redis-check-rdb</code>。  </li><li><strong>AOF 互补</strong>：开启 <code>appendonly yes</code> + <code>aof-use-rdb-preamble</code>（混合持久化），双重保障。</li></ul></li></ul><h3><span id="redis-rdb-持久化优缺点">Redis RDB 持久化优缺点</span></h3><h4><span id="优点">✅ 优点</span></h4><h5><span id="1-紧凑的二进制格式">1. <strong>紧凑的二进制格式</strong></span></h5><ul><li><p>RDB 是一个高度压缩的二进制文件，占用空间小，非常适合：</p><ul><li><strong>数据备份</strong>（如每小时&#x2F;每天全量备份）</li><li><strong>全量复制</strong>（主从同步、灾备）</li></ul></li><li><p>示例场景：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每6小时备份并上传到HDFS</span></span><br><span class="line">save 21600 1</span><br><span class="line">hadoop fs -put /var/lib/redis/dump.rdb /backup/redis/$(<span class="built_in">date</span> +%Y%m%d).rdb</span><br></pre></td></tr></table></figure></li></ul><h5><span id="2-极快的恢复速度">2. <strong>极快的恢复速度</strong></span></h5><ul><li><p>相比 AOF 的日志重放方式，RDB 直接加载二进制数据：</p><ul><li>恢复 10GB 数据：AOF 可能需要分钟级，RDB 仅需秒级</li></ul></li><li><p>重要指标：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -n 1000000 --rdb /tmp/dump.rdb  <span class="comment"># 测试恢复速度</span></span><br></pre></td></tr></table></figure></li></ul><h4><span id="缺点">❌ 缺点</span></h4><h5><span id="1-非实时持久化">1. <strong>非实时持久化</strong></span></h5><ul><li><p>致命短板：</p><ul><li><code>bgsave</code> 依赖 <code>fork()</code> 创建子进程（<strong>重量级操作</strong>）</li><li>频繁执行会导致：<ul><li>CPU 峰值（COW 机制）</li><li>内存双倍占用风险</li></ul></li></ul></li><li><p>典型问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控fork耗时（超过100ms需告警）</span></span><br><span class="line">redis-cli info stats | grep latest_fork_usec</span><br></pre></td></tr></table></figure></li></ul><h5><span id="2-版本兼容性风险">2. <strong>版本兼容性风险</strong></span></h5><ul><li>RDB 格式随 Redis 版本演进变化：<table><thead><tr><th>Redis 版本</th><th>RDB 版本</th><th>兼容性风险</th></tr></thead><tbody><tr><td>&lt;&#x3D; 5.0</td><td>v6</td><td>高</td></tr><tr><td>6.x</td><td>v7</td><td>中</td></tr><tr><td>7.x</td><td>v8</td><td>低</td></tr></tbody></table></li><li>升级时必须测试旧版 RDB 文件的加载情况</li></ul><h3><span id="aof">AOF</span></h3><p><code>AOF</code> 持久化，以独立日志的方式记录每次写命令，重启时再重新执行 <code>AOF</code> 文件中的命令达到恢复数据的目的。<code>AOF</code> 的主要作用是解决数据持久化的实时性，虽然 <code>AOF</code> 的使用开销比 <code>RDB</code> 要高，但是它提供了更高的数据安全性和更细粒度的恢复能力，且当代计算机的性能已经足以支撑 <code>AOF</code> 的使用</p><p>若想使用 <code>AOF</code>，需要在配置文件中将 <code>appendonly</code>设置为yes，开启 <code>AOF</code> 持久化功能，<code>AOF</code> 文件名通过 <code>appendfilename</code> 配置，默认是 <code>appendonly.aof</code>，保存目录和 <code>RDB</code> 是一致的，通过 <code>dir</code> 配置指定。<code>AOF</code>的工作流程如下：</p><h4><span id="aof-工作流程"><strong>AOF 工作流程</strong></span></h4><h5><span id="1-命令写入append"><strong>1. 命令写入（Append）</strong></span></h5><ul><li>所有写入命令（如 <code>SET</code>、<code>DEL</code>）会先写入 <strong>AOF 缓冲区（aof_buf）</strong>，而不是直接写入磁盘。</li><li><strong>目的</strong>：避免频繁磁盘 I&#x2F;O 影响性能。</li></ul><h5><span id="2-同步到磁盘sync"><strong>2. 同步到磁盘（Sync）</strong></span></h5><p>Redis 提供 <strong>3 种同步策略</strong>（通过 <code>appendfsync</code> 配置）：</p><table><thead><tr><th>策略</th><th>行为</th><th>数据安全性</th><th>性能影响</th></tr></thead><tbody><tr><td><strong><code>always</code></strong></td><td>每个命令都同步写入磁盘（fsync）</td><td>最高</td><td>最差</td></tr><tr><td><strong><code>everysec</code></strong></td><td>每秒同步一次（默认）</td><td>适中</td><td>较好</td></tr><tr><td><strong><code>no</code></strong></td><td>由操作系统决定何时写入（通常 30s 左右）</td><td>最低</td><td>最好</td></tr></tbody></table><h5><span id="3-aof-重写rewrite"><strong>3. AOF 重写（Rewrite）</strong></span></h5><ul><li><strong>问题</strong>：AOF 文件会不断增长（如 <code>INCR</code> 操作 100 次会记录 100 条命令）。</li><li><strong>解决方案</strong>：Redis 会定期执行 <strong>AOF 重写（BGREWRITEAOF）</strong>，生成一个更紧凑的新 AOF 文件（只保留最终状态）。</li><li><strong>触发方式</strong>：<ul><li>手动触发：<code>BGREWRITEAOF</code> 命令。</li><li>自动触发：通过 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code> 配置。</li></ul></li></ul><h5><span id="4-数据恢复load"><strong>4. 数据恢复（Load）</strong></span></h5><ul><li>Redis 重启时，会<strong>优先加载 AOF 文件</strong>（如果存在）来恢复数据。</li><li><strong>执行方式</strong>：逐条执行 AOF 文件中的命令（类似于回放日志）。</li></ul><hr><h4><span id="aof-流程图mermaid"><strong>AOF 流程图（Mermaid）</strong></span></h4><pre class="mermaid">flowchart TD    A[客户端写入命令] --> B[写入 AOF 缓冲区 aof_buf]    B --> C{appendfsync 策略}    C -->|always| D[立即同步到磁盘]    C -->|everysec| E[每秒同步一次]    C -->|no| F[由 OS 决定同步]    D & E & F --> G[AOF 文件增长]    G --> H{AOF 文件过大?}    H -->|是| I[触发 BGREWRITEAOF]    H -->|否| G    I --> J[生成新 AOF 文件（压缩版）]    J --> K[替换旧 AOF 文件]    L[Redis 重启] --> M[加载 AOF 文件恢复数据]</pre><hr><h3><span id="aof-重写机制">AOF 重写机制</span></h3><ul><li><strong>触发条件</strong>：<ul><li>AOF 文件大小超过 <code>auto-aof-rewrite-min-size</code>。</li><li>AOF 文件增长超过 <code>auto-aof-rewrite-percentage</code>。</li></ul></li></ul><p>当 AOF 文件达到重写条件中的任意一个时，Redis 会自动触发 AOF 重写，生成一个新的 AOF 文件（只保留最终状态）。</p><p>流程图如下：</p><p><img src="/img/Redis/data_type/List/persistence/aof_rewrite.png" alt="rewrite"></p><ol><li>执⾏ AOF 重写请求。<br>如果当前进程正在执⾏ AOF 重写，请求不执行。如果当前进程正在执行 bgsave 操作，重写命令延迟到 bgsave 完成之后再执⾏。</li><li>父进程执行 fork 创建子进程。</li><li>重写<br>  a. 主进程 <code>fork</code> 之后，继续响应其他命令。所有修改操作写入 <code>AOF</code> 缓冲区并根据 <code>appendfsync</code> 策略同步到硬盘，保证旧 <code>AOF</code> 文件机制正确。<br>  b. 子进程只有 <code>fork</code> 之前的所有内存信息，父进程中需要将 <code>fork</code> 之后这段时间的修改操作写⼊ <code>AOF</code> 重写缓冲区中。</li><li>子进程根据内存快照，将命令合并到新的 AOF ⽂件中。</li><li>子进程完成重写<br>  a. 新文件写入后，子进程发送信号给⽗进程。<br>  b. 父进程把 <code>AOF</code>重写缓冲区内临时保存的命令追加到新 <code>AOF</code> 文件中。<br>  c. ⽤新 AOF 文件替换旧 <code>AOF</code> 文件。</li></ol><p>当 <code>Redis</code> 启动时，会根据 <code>RDB</code> 和 <code>AOF</code> 文件的内容，进行数据恢复：</p><p><img src="/img/Redis/data_type/List/persistence/aof_recover.png" alt="recover"></p><h3><span id="aof-优缺点">AOF 优缺点</span></h3><h4><span id="优点"><strong>✅ 优点</strong></span></h4><ol><li><strong>数据更安全</strong>：最多丢失 1s 数据（<code>appendfsync everysec</code>）。</li><li><strong>可读性强</strong>：AOF 是文本格式（可手动编辑修复）。</li><li><strong>自动重写</strong>：避免文件无限增长。</li></ol><h4><span id="缺点"><strong>❌ 缺点</strong></span></h4><ol><li><strong>文件体积大</strong>：相比 RDB，AOF 文件通常更大。</li><li><strong>恢复速度慢</strong>：需要逐条执行命令。</li><li><strong>写入性能略低</strong>：频繁同步会影响吞吐量。</li></ol><h3><span id="redis-混合持久化详解">Redis 混合持久化详解</span></h3><p>混合持久化是 Redis 4.0 引入的重要特性，它结合了 RDB 和 AOF 两种持久化方式的优点，既保证了数据安全性，又提高了恢复速度。下面我将从工作原理、实现机制、优缺点和使用建议等方面进行全面讲解。</p><h4><span id="1-基本概念">1. 基本概念</span></h4><p>混合持久化（RDB-AOF Hybrid Persistence）是指：</p><ul><li>在 AOF 重写时，将当前数据集以 RDB 格式写入 AOF 文件开头</li><li>后续的写命令继续以 AOF 格式追加到文件中</li><li>最终生成的文件前半部分是 RDB 二进制数据，后半部分是 AOF 命令文本</li></ul><h4><span id="2-核心实现机制">2. 核心实现机制</span></h4><p><strong>触发条件：</strong></p><ol><li>需要同时满足：<ul><li>开启了 AOF（appendonly yes）</li><li>开启了混合模式（aof-use-rdb-preamble yes）</li><li>触发 AOF 重写（自动或手动）</li></ul></li></ol><p><strong>工作流程：</strong></p><pre class="mermaid">flowchart TD    A[触发AOF重写] --> B[fork子进程]    B --> C[子进程将内存数据写成RDB格式]    C --> D[写入到新AOF文件头部]    D --> E[父进程继续接收命令]    E --> F[新命令以AOF格式追加到缓冲区]    F --> G[重写完成后合并到新AOF文件]    G --> H[替换旧AOF文件]</pre><p><strong>关键点：</strong></p><ul><li>重写过程是非阻塞的（BGREWRITEAOF）</li><li>使用写时复制（COW）机制保证数据一致性</li><li>重写期间的新命令会写入两个缓冲区：<ul><li>aof_buf：正常的AOF缓冲区</li><li>aof_rewrite_buf：专为重写准备的缓冲区</li></ul></li></ul><h4><span id="3-文件结构示例">3. 文件结构示例</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RDB二进制数据]  ← 文件开头是RDB格式的快照</span><br><span class="line">*3\r\n$3\r\nSET\r\n$5\r\nkey1\r\n$7\r\nvalue1\r\n  ← 后面追加AOF格式命令</span><br><span class="line">*3\r\n$3\r\nSET\r\n$5\r\nkey2\r\n$7\r\nvalue2\r\n</span><br></pre></td></tr></table></figure><h4><span id="4-数据恢复过程">4. 数据恢复过程</span></h4><ol><li>Redis 重启时检测到 AOF 文件</li><li>发现文件开头是 RDB 魔数”REDIS”</li><li>先快速加载 RDB 部分（二进制解析）</li><li>然后按顺序执行后面的 AOF 命令</li><li>完成数据恢复</li></ol><h4><span id="5-配置参数">5. 配置参数</span></h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes                  <span class="comment"># 启用AOF</span></span><br><span class="line">aof-use-rdb-preamble yes        <span class="comment"># 启用混合持久化</span></span><br><span class="line">aof-rewrite-incremental-fsync yes <span class="comment"># 重写时增量fsync</span></span><br><span class="line">auto-aof-rewrite-percentage 100 <span class="comment"># 文件增长比例阈值</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb  <span class="comment"># 最小重写大小</span></span><br></pre></td></tr></table></figure><h4><span id="6-优缺点分析">6. 优缺点分析</span></h4><p><strong>优势：</strong></p><ul><li>恢复速度快：RDB 二进制加载比 AOF 命令回放快很多</li><li>数据更安全：AOF 部分保证了重写期间的数据不丢失</li><li>文件更紧凑：RDB 格式比纯 AOF 更节省空间</li><li>兼容性好：支持旧版 RDB 文件格式</li></ul><p><strong>劣势：</strong></p><ul><li>实现复杂度高</li><li>需要 Redis 4.0+ 版本支持</li><li>文件可读性降低（部分二进制）</li></ul><h4><span id="7-生产环境建议">7. 生产环境建议</span></h4><ol><li><p>对于关键业务，强烈建议开启：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure></li><li><p>监控重写过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli info persistence | grep aof_rewrite</span><br></pre></td></tr></table></figure></li><li><p>定期检查 AOF 文件完整性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure></li><li><p>配合适当的备份策略（如每小时备份到远程存储）</p></li></ol><h4><span id="8-性能对比">8. 性能对比</span></h4><table><thead><tr><th>指标</th><th>纯RDB</th><th>纯AOF</th><th>混合模式</th></tr></thead><tbody><tr><td>启动恢复速度</td><td>快</td><td>慢</td><td>快</td></tr><tr><td>数据安全性</td><td>低</td><td>高</td><td>高</td></tr><tr><td>文件大小</td><td>小</td><td>大</td><td>中等</td></tr><tr><td>写入性能影响</td><td>低</td><td>中</td><td>中</td></tr></tbody></table><h3><span id="redis-混合持久化在-70-版本后的改动">Redis 混合持久化在 7.0 版本后的改动</span></h3><p>在 Redis 7.0+ 的 <strong>Multi-Part AOF (MP-AOF)</strong> 持久化机制中，<code>appendonly.aof.manifest</code>、<code>appendonly.aof.1.base.rdb</code> 和 <code>appendonly.aof.1.incr.aof</code> 这三个文件共同协作，实现高效的数据持久化和恢复。以下是它们的详细作用和运作机制：</p><hr><h4><span id="1-appendonlyaofmanifest清单文件">1. <strong><code>appendonly.aof.manifest</code>（清单文件）</strong></span></h4><p><strong>作用</strong>：</p><ul><li>记录所有 <strong>基本文件（base）</strong> 和 <strong>增量文件（incr）</strong> 的加载顺序，确保 Redis 重启时能正确恢复数据。  </li><li>类似于一个“目录”，告诉 Redis 应该按什么顺序加载数据文件。</li></ul><p><strong>文件内容示例</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;seq&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;base&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;seq&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;appendonly.aof.1.base.rdb&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;incr&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;seq&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;appendonly.aof.1.incr.aof&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>运作机制</strong>：</p><ul><li>Redis 启动时，<strong>先读取 <code>manifest</code></strong>，然后按 <code>base</code> → <code>incr</code> 的顺序加载文件。</li><li>在 <strong>AOF 重写（<code>BGREWRITEAOF</code>）</strong> 时，会生成新的 <code>base</code> 文件并更新 <code>manifest</code>，确保原子性切换。</li></ul><hr><h4><span id="2-appendonlyaof1baserdb基本文件">2. <strong><code>appendonly.aof.1.base.rdb</code>（基本文件）</strong></span></h4><p><strong>作用</strong>：</p><ul><li>存储 <strong>全量数据快照</strong>，采用 <strong>RDB 二进制格式</strong>（默认情况下，<code>aof-use-rdb-preamble yes</code>）。  </li><li>相当于传统混合持久化中的 <strong>RDB 头部</strong>，但现在是独立文件。</li></ul><p><strong>运作机制</strong>：</p><ul><li>在 <strong>AOF 重写</strong> 时，Redis 会 <code>fork</code> 子进程，将当前内存数据 <strong>序列化为 RDB 格式</strong> 并写入该文件。</li><li>由于 RDB 是压缩的二进制格式，<strong>恢复速度极快</strong>（相比纯 AOF 重放命令）。</li></ul><hr><h4><span id="3-appendonlyaof1incraof增量文件">3. <strong><code>appendonly.aof.1.incr.aof</code>（增量文件）</strong></span></h4><p><strong>作用</strong>：</p><ul><li>记录 <strong>AOF 重写之后的所有写操作</strong>，采用 <strong>Redis 协议文本格式</strong>（RESP）。  </li><li>类似于传统 AOF 的尾部，但现在是独立文件。</li></ul><p><strong>文件内容示例</strong>（RESP 协议）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n</span><br></pre></td></tr></table></figure><p><strong>运作机制</strong>：</p><ul><li>Redis <strong>主进程</strong> 在执行写操作时，会同时写入：<ol><li><strong>旧 AOF 文件</strong>（如果尚未完成重写）。</li><li><strong><code>aof_rewrite_buf</code> 缓冲区</strong>（用于新 <code>incr.aof</code> 文件）。</li></ol></li><li>当 <strong>AOF 重写完成</strong> 后，增量命令会追加到 <code>incr.aof</code>，并更新 <code>manifest</code>。</li></ul><hr><h4><span id="三者的协作流程"><strong>三者的协作流程</strong></span></h4><ol><li><p><strong>AOF 重写触发</strong>（手动 <code>BGREWRITEAOF</code> 或自动触发）：</p><ul><li>子进程生成新的 <code>base.rdb</code>（全量快照）。</li><li>主进程继续接收命令，写入 <code>incr.aof</code>。</li><li>完成后，更新 <code>manifest</code> 指向新文件。</li></ul></li><li><p><strong>Redis 重启恢复</strong>：</p><ul><li>读取 <code>manifest</code>，按顺序加载：<ol><li><code>base.rdb</code>（快速恢复全量数据）。</li><li><code>incr.aof</code>（重放增量命令，保证数据最新）。</li></ol></li></ul></li><li><p><strong>文件轮转</strong>：</p><ul><li>当 <code>incr.aof</code> 过大时，会触发新的 AOF 重写，生成新的 <code>base.rdb</code> 和 <code>incr.aof</code>，并更新 <code>manifest</code>。</li></ul></li></ol><hr><h4><span id="与传统混合持久化的区别"><strong>与传统混合持久化的区别</strong></span></h4><table><thead><tr><th>特性</th><th>传统混合模式（单文件）</th><th>MP-AOF（多文件）</th></tr></thead><tbody><tr><td><strong>存储方式</strong></td><td>RDB头部 + AOF尾部</td><td><code>base.rdb</code> + <code>incr.aof</code></td></tr><tr><td><strong>文件管理</strong></td><td>单文件，重写时替换</td><td>多文件，<code>manifest</code> 管理版本</td></tr><tr><td><strong>恢复速度</strong></td><td>快（RDB优先）</td><td>更快（并行加载可能）</td></tr><tr><td><strong>运维友好性</strong></td><td>难拆分备份</td><td>可单独备份 <code>base</code>&#x2F;<code>incr</code></td></tr></tbody></table><hr><h4><span id="redis-官方推荐"><strong>Redis 官方推荐</strong></span></h4><ul><li><strong>默认开启 MP-AOF</strong>（Redis 7.0+），因为它：<ul><li>更<strong>健壮</strong>（文件损坏时影响更小）。</li><li>更<strong>高效</strong>（<code>base.rdb</code> 加载快，<code>incr.aof</code> 增量小）。</li></ul></li><li>可通过 <code>redis-check-aof --fix</code> 修复损坏的 AOF 文件。</li></ul><p>如果需要回退到传统单文件模式，可设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br><span class="line">aof-manifest-enabled no</span><br></pre></td></tr></table></figure><p>但官方建议保持 MP-AOF，除非有特殊兼容性需求。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis C++ 客户端使用指南-Zset 篇</title>
      <link href="/2025/08/16/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_zset/"/>
      <url>/2025/08/16/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_zset/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#redisczset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3">Redis++（C++）ZSet（有序集合）类型常用接口详解</a><ul><li><a href="#zadd-zrange">zadd、zrange</a></li><li><a href="#zcard">zcard</a></li><li><a href="#zrem">zrem</a></li><li><a href="#zscore">zscore</a></li><li><a href="#zrank">zrank</a></li></ul></li></ul><!-- tocstop --><h2><span id="redisczset有序集合类型常用接口详解">Redis++（C++）ZSet（有序集合）类型常用接口详解</span></h2><p>在 C++ 后端开发中，redis++ 提供了丰富的 ZSet（有序集合）类型操作接口，支持元素的添加、查询、删除、分数和排名获取等功能。下面结合实际代码示例，详细介绍常用接口的函数原型和用法。</p><hr><h3><span id="zadd-zrange">zadd、zrange</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">zadd</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;member, <span class="type">double</span> score)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">zadd</span><span class="params">(<span class="type">const</span> StringView &amp;key, std::initializer_list&lt;std::pair&lt;StringView, <span class="type">double</span>&gt;&gt; m)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input&gt;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">zadd</span><span class="params">(<span class="type">const</span> StringView &amp;key, Input first, Input last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zrange</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">long</span> <span class="type">long</span> start, <span class="type">long</span> <span class="type">long</span> stop, Output output)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1: 添加单个元素(成员value1，分数1.0)</span></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2: 使用initializer_list批量添加元素</span></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, &#123;</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value2&quot;</span>, <span class="number">2.0</span>), </span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value3&quot;</span>, <span class="number">3.0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3: 使用容器和迭代器批量添加元素</span></span><br><span class="line">std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; values = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;value4&quot;</span>, <span class="number">4.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;value5&quot;</span>, <span class="number">5.0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询有序集合全部元素(带分数)</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ZSET contents after zadd:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; results;</span><br><span class="line">redis.<span class="built_in">zrange</span>(<span class="string">&quot;myzset&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(results));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;res : results) &#123;</span><br><span class="line">    std::cout &lt;&lt; res.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; res.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只查询成员名(不带分数)</span></span><br><span class="line">std::vector&lt;std::string&gt; members;</span><br><span class="line">redis.<span class="built_in">zrange</span>(<span class="string">&quot;myzset&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(members));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;member : members) &#123;</span><br><span class="line">    std::cout &lt;&lt; member &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZSET contents after zadd:</span><br><span class="line">value1: 1</span><br><span class="line">value2: 2</span><br><span class="line">value3: 3</span><br><span class="line">value4: 4</span><br><span class="line">value5: 5</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">value4</span><br><span class="line">value5</span><br></pre></td></tr></table></figure><hr><h3><span id="zcard">zcard</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">zcard</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加测试元素</span></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, &#123;</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value2&quot;</span>, <span class="number">2.0</span>), </span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value3&quot;</span>, <span class="number">3.0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取有序集合元素数量</span></span><br><span class="line"><span class="keyword">auto</span> zcard = redis.<span class="built_in">zcard</span>(<span class="string">&quot;myzset&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ZSET cardinality: &quot;</span> &lt;&lt; zcard &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不存在的有序集合元素数量</span></span><br><span class="line"><span class="keyword">auto</span> non_exist_zcard = redis.<span class="built_in">zcard</span>(<span class="string">&quot;non_exist_zset&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Non-existent ZSET cardinality: &quot;</span> &lt;&lt; non_exist_zcard &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZSET cardinality: 3</span><br><span class="line">Non-existent ZSET cardinality: 0</span><br></pre></td></tr></table></figure><hr><h3><span id="zrem">zrem</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">zrem</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;member)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加测试元素</span></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, &#123;</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value2&quot;</span>, <span class="number">2.0</span>), </span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value3&quot;</span>, <span class="number">3.0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素value2</span></span><br><span class="line">redis.<span class="built_in">zrem</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看删除后的集合内容</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ZSET contents after zrem:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; results;</span><br><span class="line">redis.<span class="built_in">zrange</span>(<span class="string">&quot;myzset&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(results));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;res : results) &#123;</span><br><span class="line">    std::cout &lt;&lt; res.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; res.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZSET contents after zrem:</span><br><span class="line">value1: 1</span><br><span class="line">value3: 3</span><br></pre></td></tr></table></figure><hr><h3><span id="zscore">zscore</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OptionalDouble <span class="title">zscore</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;member)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加测试元素</span></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, &#123;</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value2&quot;</span>, <span class="number">2.0</span>), </span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value3&quot;</span>, <span class="number">3.0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素分数(返回OptionalDouble)</span></span><br><span class="line"><span class="keyword">auto</span> score = redis.<span class="built_in">zscore</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (score) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Score of value2: &quot;</span> &lt;&lt; score.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value2 not found in ZSET&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不存在的元素分数</span></span><br><span class="line"><span class="keyword">auto</span> non_exist_score = redis.<span class="built_in">zscore</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!non_exist_score) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value4 not found in ZSET&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Score of value2: 2</span><br><span class="line">value4 not found in ZSET</span><br></pre></td></tr></table></figure><hr><h3><span id="zrank">zrank</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OptionalLongLong <span class="title">zrank</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;member)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加测试元素</span></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;myzset&quot;</span>, &#123;</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value2&quot;</span>, <span class="number">2.0</span>), </span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;value3&quot;</span>, <span class="number">3.0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素排名(从0开始)</span></span><br><span class="line"><span class="keyword">auto</span> rank = redis.<span class="built_in">zrank</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rank) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rank of value2: &quot;</span> &lt;&lt; rank.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value2 not found in ZSET&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不存在的元素排名</span></span><br><span class="line"><span class="keyword">auto</span> non_exist_rank = redis.<span class="built_in">zrank</span>(<span class="string">&quot;myzset&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!non_exist_rank) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value4 not found in ZSET&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rank of value2: 1</span><br><span class="line">value4 not found in ZSET</span><br></pre></td></tr></table></figure><hr><p>通过这些接口，C++ 后端可以高效地操作 Redis 的 ZSet（有序集合）类型数据结构，支持元素的增删查、分数和排名获取等多种业务场</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> C++ </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis C++ 客户端使用指南-Hash 篇</title>
      <link href="/2025/08/16/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_hash/"/>
      <url>/2025/08/16/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_hash/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#redischash-%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3">Redis++（C++）Hash 类型常用接口详解</a><ul><li><a href="#hset-hget">hset、hget</a></li><li><a href="#hexists">hexists</a></li><li><a href="#hdel">hdel</a></li><li><a href="#hlen">hlen</a></li><li><a href="#hkeys-hvals">hkeys、hvals</a></li><li><a href="#hmset-hmget">hmset、hmget</a></li></ul></li></ul><!-- tocstop --><h2><span id="redischash-类型常用接口详解">Redis++（C++）Hash 类型常用接口详解</span></h2><p>在 C++ 后端开发中，redis++ 提供了丰富的 Hash 类型操作接口，支持字段的添加、查询、删除、批量操作等功能。下面结合实际代码示例，详细介绍常用接口的函数原型和用法。</p><hr><h3><span id="hset-hget">hset、hget</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">hset</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;field, <span class="type">const</span> StringView &amp;val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">hset</span><span class="params">(<span class="type">const</span> StringView &amp;key, std::initializer_list&lt;StringView&gt; field_vals)</span></span>;</span><br><span class="line"><span class="function">OptionalString <span class="title">hget</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;field)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置单个字段值</span></span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用初始化列表设置多个字段值</span></span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, &#123;<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;field3&quot;</span>, <span class="string">&quot;value3&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段值，使用value_or提供默认值</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field1: &quot;</span> &lt;&lt; redis.<span class="built_in">hget</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>).<span class="built_in">value_or</span>(<span class="string">&quot;nil&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field2: &quot;</span> &lt;&lt; redis.<span class="built_in">hget</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field2&quot;</span>).<span class="built_in">value_or</span>(<span class="string">&quot;nil&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field3: &quot;</span> &lt;&lt; redis.<span class="built_in">hget</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field3&quot;</span>).<span class="built_in">value_or</span>(<span class="string">&quot;nil&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field1: value1</span><br><span class="line">Field2: value2</span><br><span class="line">Field3: value3</span><br></pre></td></tr></table></figure><hr><h3><span id="hexists">hexists</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hexists</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;field)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置多个字段值</span></span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, &#123;<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;field3&quot;</span>, <span class="string">&quot;value3&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字段是否存在</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field1 exists: &quot;</span> &lt;&lt; (redis.<span class="built_in">hexists</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field2 exists: &quot;</span> &lt;&lt; (redis.<span class="built_in">hexists</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field2&quot;</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field4 exists: &quot;</span> &lt;&lt; (redis.<span class="built_in">hexists</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field4&quot;</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field1 exists: Yes</span><br><span class="line">Field2 exists: Yes</span><br><span class="line">Field4 exists: No</span><br></pre></td></tr></table></figure><hr><h3><span id="hdel">hdel</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">hdel</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;field)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">hdel</span><span class="params">(<span class="type">const</span> StringView &amp;key, std::initializer_list&lt;StringView&gt; fields)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置多个字段值</span></span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, &#123;<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;field3&quot;</span>, <span class="string">&quot;value3&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除单个字段</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> deleted = redis.<span class="built_in">hdel</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Deleted field1: &quot;</span> &lt;&lt; deleted &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除多个字段(不存在的字段会被忽略)</span></span><br><span class="line">deleted = redis.<span class="built_in">hdel</span>(<span class="string">&quot;myhash&quot;</span>, &#123;<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;field4&quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Deleted field2 and field4: &quot;</span> &lt;&lt; deleted &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证字段是否被删除</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field1 exists: &quot;</span> &lt;&lt; (redis.<span class="built_in">hexists</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field2 exists: &quot;</span> &lt;&lt; (redis.<span class="built_in">hexists</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field2&quot;</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Field4 exists: &quot;</span> &lt;&lt; (redis.<span class="built_in">hexists</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field4&quot;</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deleted field1: 1</span><br><span class="line">Deleted field2 and field4: 1</span><br><span class="line">Field1 exists: No</span><br><span class="line">Field2 exists: No</span><br><span class="line">Field4 exists: No</span><br></pre></td></tr></table></figure><hr><h3><span id="hlen">hlen</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">hlen</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置多个字段值</span></span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, &#123;<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;field3&quot;</span>, <span class="string">&quot;value3&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Hash中的字段数量</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len = redis.<span class="built_in">hlen</span>(<span class="string">&quot;myhash&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Length of myhash: &quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Length of myhash: 3</span><br></pre></td></tr></table></figure><hr><h3><span id="hkeys-hvals">hkeys、hvals</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hkeys</span><span class="params">(<span class="type">const</span> StringView &amp;key, Output output)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hvals</span><span class="params">(<span class="type">const</span> StringView &amp;key, Output output)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置多个字段值</span></span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">hset</span>(<span class="string">&quot;myhash&quot;</span>, &#123;<span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;field3&quot;</span>, <span class="string">&quot;value3&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有字段名</span></span><br><span class="line">std::vector&lt;std::string&gt; keys;</span><br><span class="line">redis.<span class="built_in">hkeys</span>(<span class="string">&quot;myhash&quot;</span>, std::<span class="built_in">back_inserter</span>(keys));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Keys in myhash: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;key : keys) &#123;</span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有字段值</span></span><br><span class="line">std::vector&lt;std::string&gt; values;</span><br><span class="line">redis.<span class="built_in">hvals</span>(<span class="string">&quot;myhash&quot;</span>, std::<span class="built_in">back_inserter</span>(values));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Values in myhash: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : values) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Keys in myhash: field1 field2 field3 </span><br><span class="line">Values in myhash: value1 value2 value3 </span><br></pre></td></tr></table></figure><hr><h3><span id="hmset-hmget">hmset、hmget</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hmset</span><span class="params">(<span class="type">const</span> StringView &amp;key, std::initializer_list&lt;StringView&gt; field_vals)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hmset</span><span class="params">(<span class="type">const</span> StringView &amp;key, Input first, Input last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hmget</span><span class="params">(<span class="type">const</span> StringView &amp;key, std::initializer_list&lt;StringView&gt; fields, Output output)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1: 使用初始化列表批量设置字段值</span></span><br><span class="line">redis.<span class="built_in">hmset</span>(<span class="string">&quot;myhash&quot;</span>, &#123;<span class="string">&quot;field1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;field2&quot;</span>, <span class="string">&quot;value2&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2: 使用pair对象批量设置字段值</span></span><br><span class="line">redis.<span class="built_in">hmset</span>(<span class="string">&quot;myhash&quot;</span>, &#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;field3&quot;</span>, <span class="string">&quot;value3&quot;</span>),</span><br><span class="line">                       std::<span class="built_in">make_pair</span>(<span class="string">&quot;field4&quot;</span>, <span class="string">&quot;value4&quot;</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3: 使用vector批量设置字段值</span></span><br><span class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; fields = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;field5&quot;</span>, <span class="string">&quot;value5&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;field6&quot;</span>, <span class="string">&quot;value6&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">redis.<span class="built_in">hmset</span>(<span class="string">&quot;myhash&quot;</span>, fields.<span class="built_in">begin</span>(), fields.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量获取多个字段值</span></span><br><span class="line">std::vector&lt;std::string&gt; res;</span><br><span class="line">redis.<span class="built_in">hmget</span>(<span class="string">&quot;myhash&quot;</span>, &#123;<span class="string">&quot;field1&quot;</span>, <span class="string">&quot;field2&quot;</span>, <span class="string">&quot;field3&quot;</span>, <span class="string">&quot;field4&quot;</span>, <span class="string">&quot;field5&quot;</span>, <span class="string">&quot;field6&quot;</span>&#125;, </span><br><span class="line">           std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Value: value1</span><br><span class="line">Value: value2</span><br><span class="line">Value: value3</span><br><span class="line">Value: value4</span><br><span class="line">Value: value5</span><br><span class="line">Value: value6</span><br></pre></td></tr></table></figure><hr><p>通过这些接口，C++ 后端可以高效地操作 Redis 的 Hash 类型数据结构，支持字段的增删查改和批量操作，适合存储对象属性、配置信息</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> C++ </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis C++ 客户端使用指南-Set 篇</title>
      <link href="/2025/08/15/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_set/"/>
      <url>/2025/08/15/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_set/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#rediscset-%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3">Redis++（C++）Set 类型常用接口详解</a><ul><li><a href="#sadd-smembers">sadd、smembers</a></li><li><a href="#sismember">sismember</a></li><li><a href="#spop">spop</a></li><li><a href="#scard">scard</a></li><li><a href="#sinter-sunion">sinter、sunion</a></li><li><a href="#sinterstore">sinterstore</a></li></ul></li></ul><!-- tocstop --><h2><span id="rediscset-类型常用接口详解">Redis++（C++）Set 类型常用接口详解</span></h2><p>在 C++ 后端开发中，redis++ 提供了丰富的 Set 类型操作接口，支持集合的添加、查询、弹出、集合运算等功能。下面结合实际代码示例，详细介绍常用接口的函数原型和用法。</p><hr><h3><span id="sadd-smembers">sadd、smembers</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sadd</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;member)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smembers</span><span class="params">(<span class="type">const</span> StringView &amp;key, Output output)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向集合添加元素(自动去重)</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value1&quot;</span>);  <span class="comment">// 添加元素value1</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value2&quot;</span>);  <span class="comment">// 添加元素value2</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value3&quot;</span>);  <span class="comment">// 添加元素value3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合所有成员</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Set contents after sadd:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::set&lt;std::string&gt; values;</span><br><span class="line"><span class="comment">// 使用inserter将结果插入到set容器</span></span><br><span class="line">redis.<span class="built_in">smembers</span>(<span class="string">&quot;myset&quot;</span>, std::<span class="built_in">inserter</span>(values, values.<span class="built_in">end</span>()));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : values) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 输出集合内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set contents after sadd:</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br></pre></td></tr></table></figure><hr><h3><span id="sismember">sismember</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sismember</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;member)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向集合添加元素</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查元素是否存在于集合中</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Is value1 a member of myset? &quot;</span> </span><br><span class="line">          &lt;&lt; (redis.<span class="built_in">sismember</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value1&quot;</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Is value3 a member of myset? &quot;</span> </span><br><span class="line">          &lt;&lt; (redis.<span class="built_in">sismember</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value3&quot;</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is value1 a member of myset? Yes</span><br><span class="line">Is value3 a member of myset? No</span><br></pre></td></tr></table></figure><hr><h3><span id="spop">spop</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OptionalString <span class="title">spop</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向集合添加多个元素</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看集合原始内容</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Set contents before spop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::set&lt;std::string&gt; values;</span><br><span class="line">redis.<span class="built_in">smembers</span>(<span class="string">&quot;myset&quot;</span>, std::<span class="built_in">inserter</span>(values, values.<span class="built_in">end</span>()));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : values) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机弹出一个元素(原子操作)</span></span><br><span class="line"><span class="keyword">auto</span> spop_value = redis.<span class="built_in">spop</span>(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;SPop value: &quot;</span> &lt;&lt; spop_value.<span class="built_in">value_or</span>(<span class="string">&quot;nil&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看弹出后的集合内容</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Set contents after spop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">values.<span class="built_in">clear</span>();</span><br><span class="line">redis.<span class="built_in">smembers</span>(<span class="string">&quot;myset&quot;</span>, std::<span class="built_in">inserter</span>(values, values.<span class="built_in">end</span>()));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : values) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set contents before spop:</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">SPop value: value2</span><br><span class="line">Set contents after spop:</span><br><span class="line">value1</span><br><span class="line">value3</span><br></pre></td></tr></table></figure><hr><h3><span id="scard">scard</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">scard</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向集合添加元素</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合元素数量(基数)</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Set cardinality: &quot;</span> &lt;&lt; redis.<span class="built_in">scard</span>(<span class="string">&quot;myset&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不存在的集合基数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Non-existent set cardinality: &quot;</span> &lt;&lt; redis.<span class="built_in">scard</span>(<span class="string">&quot;non_exist_set&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set cardinality: 3</span><br><span class="line">Non-existent set cardinality: 0</span><br></pre></td></tr></table></figure><hr><h3><span id="sinter-sunion">sinter、sunion</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sinter</span><span class="params">(std::initializer_list&lt;StringView&gt; keys, Output output)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sunion</span><span class="params">(std::initializer_list&lt;StringView&gt; keys, Output output)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备两个测试集合</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;value1&quot;</span>);  <span class="comment">// set1: &#123;value1, value2&#125;</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;value2&quot;</span>);  <span class="comment">// set2: &#123;value2, value3&#125;</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个集合的交集</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Intersection of set1 and set2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::set&lt;std::string&gt; intersection;</span><br><span class="line">redis.<span class="built_in">sinter</span>(&#123;<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>&#125;, std::<span class="built_in">inserter</span>(intersection, intersection.<span class="built_in">end</span>()));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : intersection) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 输出: value2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个集合的并集</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Union of set1 and set2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::set&lt;std::string&gt; unionsection;</span><br><span class="line">redis.<span class="built_in">sunion</span>(&#123;<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>&#125;, std::<span class="built_in">inserter</span>(unionsection, unionsection.<span class="built_in">end</span>()));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : unionsection) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 输出: value1, value2, value3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intersection of set1 and set2:</span><br><span class="line">value2</span><br><span class="line">Union of set1 and set2:</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br></pre></td></tr></table></figure><hr><h3><span id="sinterstore">sinterstore</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sinterstore</span><span class="params">(<span class="type">const</span> StringView &amp;destination, std::initializer_list&lt;StringView&gt; keys)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备两个测试集合</span></span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算交集并将结果存储到新集合</span></span><br><span class="line">redis.<span class="built_in">sinterstore</span>(<span class="string">&quot;result&quot;</span>, &#123;<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看结果集合内容</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Result set contents:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::set&lt;std::string&gt; result;</span><br><span class="line">redis.<span class="built_in">smembers</span>(<span class="string">&quot;result&quot;</span>, std::<span class="built_in">inserter</span>(result, result.<span class="built_in">end</span>()));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : result) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 输出: value2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result set contents:</span><br><span class="line">value2</span><br></pre></td></tr></table></figure><hr><p>通过这些接口，C++ 后端可以高效地操作 Redis 的 Set 类型数据结构，支持集合的基本操作和集合运算，适合多种业务场景。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> C++ </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis C++ 客户端使用指南-List 篇</title>
      <link href="/2025/08/15/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_list/"/>
      <url>/2025/08/15/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_list/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#redisclist-%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3">Redis++（C++）List 类型常用接口详解</a><ul><li><a href="#lpush-lrange">lpush、lrange</a></li><li><a href="#rpush-lpop-rpop">rpush、lpop、rpop</a></li><li><a href="#blpop%E9%98%BB%E5%A1%9E%E5%BC%B9%E5%87%BA">blpop（阻塞弹出）</a></li><li><a href="#llen">llen</a></li></ul></li></ul><!-- tocstop --><h2><span id="redisclist-类型常用接口详解">Redis++（C++）List 类型常用接口详解</span></h2><p>在 C++ 后端开发中，redis++ 提供了丰富的 List 类型操作接口，支持高效的头尾插入、弹出、阻塞弹出等功能。下面结合实际代码示例，详细介绍常用接口的函数原型和用法。</p><hr><h3><span id="lpush-lrange">lpush、lrange</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lpush</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;val)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lrange</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">long</span> <span class="type">long</span> start, <span class="type">long</span> <span class="type">long</span> stop, Output output)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从列表左侧插入元素(插入顺序为value1→value2→value3→value4)</span></span><br><span class="line"><span class="comment">// 最终列表顺序为[value4, value3, value2, value1]</span></span><br><span class="line">redis.<span class="built_in">lpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">lpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value2&quot;</span>); </span><br><span class="line">redis.<span class="built_in">lpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">redis.<span class="built_in">lpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询列表全部元素(0表示第一个元素，-1表示最后一个元素)</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;List contents after lpush:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::vector&lt;std::string&gt; values;</span><br><span class="line">redis.<span class="built_in">lrange</span>(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(values));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : values) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List contents after lpush:</span><br><span class="line">value4</span><br><span class="line">value3</span><br><span class="line">value2</span><br><span class="line">value1</span><br></pre></td></tr></table></figure><hr><h3><span id="rpush-lpop-rpop">rpush、lpop、rpop</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">rpush</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;val)</span></span>;</span><br><span class="line"><span class="function">OptionalString <span class="title">lpop</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br><span class="line"><span class="function">OptionalString <span class="title">rpop</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从列表右侧插入元素(插入顺序为value1→value2→value3)</span></span><br><span class="line"><span class="comment">// 最终列表顺序为[value1, value2, value3]</span></span><br><span class="line">redis.<span class="built_in">rpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">rpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">rpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询列表全部元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;List contents after rpush:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::vector&lt;std::string&gt; values;</span><br><span class="line">redis.<span class="built_in">lrange</span>(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(values));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : values) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从左侧弹出元素(移除并返回第一个元素)</span></span><br><span class="line"><span class="keyword">auto</span> lpop_value = redis.<span class="built_in">lpop</span>(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;LPOP value: &quot;</span> &lt;&lt; lpop_value.<span class="built_in">value_or</span>(<span class="string">&quot;nil&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右侧弹出元素(移除并返回最后一个元素)</span></span><br><span class="line"><span class="keyword">auto</span> rpop_value = redis.<span class="built_in">rpop</span>(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;RPOP value: &quot;</span> &lt;&lt; rpop_value.<span class="built_in">value_or</span>(<span class="string">&quot;nil&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询弹出后的列表内容</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;List contents after pop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">values.<span class="built_in">clear</span>();</span><br><span class="line">redis.<span class="built_in">lrange</span>(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(values));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : values) &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List contents after rpush:</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">LPOP value: value1</span><br><span class="line">RPOP value: value3</span><br><span class="line">List contents after pop:</span><br><span class="line">value2</span><br></pre></td></tr></table></figure><hr><h3><span id="blpop阻塞弹出">blpop（阻塞弹出）</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span><br><span class="line">Optional&lt;std::pair&lt;std::string, std::string&gt;&gt; <span class="built_in">blpop</span>(std::initializer_list&lt;StringView&gt; keys, <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt; &amp;timeout);</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个线程模拟生产者</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 每个线程创建自己的Redis连接实例(重要！)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    sw::redis::Redis redis(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 线程1在2秒后向mylist1插入数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::this_thread::sleep_for(<span class="number">2</span>s);</span></span></span><br><span class="line"><span class="params"><span class="function">    redis.rpush(<span class="string">&quot;mylist1&quot;</span>, <span class="string">&quot;value1&quot;</span>); </span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 线程2在1秒后向mylist2插入数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">    sw::redis::Redis redis(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    std::this_thread::sleep_for(<span class="number">1</span>s);</span></span></span><br><span class="line"><span class="params"><span class="function">    redis.rpush(<span class="string">&quot;mylist2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程循环阻塞弹出</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞弹出(最多等待10秒)，监听mylist1和mylist2</span></span><br><span class="line">    <span class="keyword">auto</span> blpop_value = redis.<span class="built_in">blpop</span>(&#123;<span class="string">&quot;mylist1&quot;</span>, <span class="string">&quot;mylist2&quot;</span>&#125;, <span class="number">10</span>s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (blpop_value) &#123;</span><br><span class="line">        <span class="comment">// 返回值为pair&lt;list_name, value&gt;</span></span><br><span class="line">        std::cout &lt;&lt; blpop_value-&gt;first &lt;&lt; <span class="string">&quot;: BLPOP value: &quot;</span> </span><br><span class="line">                  &lt;&lt; blpop_value-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;BLPOP timed out&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程结束</span></span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mylist2: BLPOP value: value2</span><br><span class="line">mylist1: BLPOP value: value1</span><br><span class="line">BLPOP timed out</span><br></pre></td></tr></table></figure><h4><span id="重点说明">重点说明</span></h4><p>你可能会疑惑，为什么没有将 <code>redis</code> 实例直接共享给 <code>t1</code> 和 <code>t2</code>？<br>实际上，<strong>redis++ 的 Redis 实例不是线程安全的</strong>，如果多个线程共享同一个 Redis 连接，会导致连接状态混乱，尤其在有阻塞操作（如 <code>blpop</code>）时，极易出现 <code>UNBLOCKED force unblock from blocking operation</code> 这类异常。</p><p><strong>正确做法是：每个线程都创建自己的 Redis 连接实例。</strong><br>这样可以避免主从切换、连接被强制中断等问题，保证阻塞操作的正常执行。</p><hr><h3><span id="llen">llen</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">llen</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向列表插入三个元素</span></span><br><span class="line">redis.<span class="built_in">rpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">rpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">rpush</span>(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取列表长度</span></span><br><span class="line"><span class="keyword">auto</span> llen = redis.<span class="built_in">llen</span>(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Length of mylist: &quot;</span> &lt;&lt; llen &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不存在的列表长度</span></span><br><span class="line"><span class="keyword">auto</span> non_exist_len = redis.<span class="built_in">llen</span>(<span class="string">&quot;non_exist_list&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Length of non_exist_list: &quot;</span> &lt;&lt; non_exist_len &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Length of mylist: 3</span><br><span class="line">Length of non_exist_list: 0</span><br></pre></td></tr></table></figure><hr><p>通过这些接口，C++ 后端可以高效地操作 Redis 的 List 类型数据结构。<strong>注意多线程场景下每个线程应独立创建 Redis 连接，避免线程安全问题和阻塞操作异常。</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> C++ </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis C++ 客户端使用指南-String 篇</title>
      <link href="/2025/08/15/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_string/"/>
      <url>/2025/08/15/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_string/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#redis-%E4%B8%AD-string-%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3">redis++ 中 String 类型相关接口详解</a><ul><li><a href="#set-get">set、get</a></li><li><a href="#set%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-get%E8%BF%87%E6%9C%9F%E5%90%8E">set（带过期时间）&#x2F; get（过期后）</a></li><li><a href="#mset-mget">mset、mget</a></li><li><a href="#getrange-setrange">getrange、setrange</a></li><li><a href="#incr-decr">incr、decr</a></li></ul></li></ul><!-- tocstop --><h2><span id="redis-中-string-类型相关接口详解">redis++ 中 String 类型相关接口详解</span></h2><p>redis++（sw::redis::Redis）为 Redis 字符串类型提供了丰富的 C++ 接口，下面将详细介绍常用接口的函数原型及用法。</p><hr><h3><span id="set-get">set、get</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;val)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;val, <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt; &amp;timeout)</span></span>;</span><br><span class="line"><span class="function">OptionalString <span class="title">get</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键值对</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值，使用OptionalString接收返回值</span></span><br><span class="line"><span class="comment">// OptionalString需要调用value()方法获取实际值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> val1 = redis.<span class="built_in">get</span>(<span class="string">&quot;key1&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value1: &quot;</span> &lt;&lt; val<span class="number">1.</span><span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> val2 = redis.<span class="built_in">get</span>(<span class="string">&quot;key2&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value2: &quot;</span> &lt;&lt; val<span class="number">2.</span><span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> val3 = redis.<span class="built_in">get</span>(<span class="string">&quot;key3&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value3: &quot;</span> &lt;&lt; val<span class="number">3.</span><span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不存在的键</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> val4 = redis.<span class="built_in">get</span>(<span class="string">&quot;key4&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value4: &quot;</span> &lt;&lt; val<span class="number">4.</span><span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key4 does not exist&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value1: value1</span><br><span class="line">value2: value2</span><br><span class="line">value3: value3</span><br><span class="line">key4 does not exist</span><br></pre></td></tr></table></figure><hr><h3><span id="set带过期时间x2f-get过期后">set（带过期时间）&#x2F; get（过期后）</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;val, <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt; &amp;timeout)</span></span>;</span><br><span class="line"><span class="function">OptionalString <span class="title">get</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用chrono时间字面量</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置带过期时间的键值对(5秒、10秒、15秒后过期)</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">5</span>s);</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="number">10</span>s);</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="number">15</span>s);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Sleeping for 7 seconds...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 线程休眠7秒</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">7</span>s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查键是否已过期</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> val1 = redis.<span class="built_in">get</span>(<span class="string">&quot;key1&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value1: &quot;</span> &lt;&lt; val<span class="number">1.</span><span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key1 has expired&quot;</span> &lt;&lt; std::endl;  <span class="comment">// 5秒后已过期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> val2 = redis.<span class="built_in">get</span>(<span class="string">&quot;key2&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value2: &quot;</span> &lt;&lt; val<span class="number">2.</span><span class="built_in">value</span>() &lt;&lt; std::endl;  <span class="comment">// 10秒未过期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> val3 = redis.<span class="built_in">get</span>(<span class="string">&quot;key3&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value3: &quot;</span> &lt;&lt; val<span class="number">3.</span><span class="built_in">value</span>() &lt;&lt; std::endl;  <span class="comment">// 15秒未过期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sleeping for 7 seconds...</span><br><span class="line">key1 has expired</span><br><span class="line">value2: value2</span><br><span class="line">value3: value3</span><br></pre></td></tr></table></figure><hr><h3><span id="mset-mget">mset、mget</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mset</span><span class="params">(std::initializer_list&lt;std::pair&lt;StringView, StringView&gt;&gt; kvs)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mset</span><span class="params">(Input first, Input last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mget</span><span class="params">(std::initializer_list&lt;StringView&gt; keys, Output output)</span></span>;</span><br></pre></td></tr></table></figure><h4><span id="mset-的两种-key-value-传递方式">mset 的两种 key-value 传递方式</span></h4><ol><li><p><strong>直接用 initializer_list：</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="built_in">mset</span>(&#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>), std::<span class="built_in">make_pair</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>用迭代器（适合已有容器）：</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; values = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">redis.<span class="built_in">mset</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li></ol><h4><span id="mget-获取-key-的细节">mget 获取 key 的细节</span></h4><ul><li>mget 结果用 <code>std::vector&lt;sw::redis::OptionalString&gt;</code> 存储，表示每个 key 的值（不存在时为 null）。</li><li>需用插入迭代器（如 <code>std::back_inserter</code>）将结果插入容器。</li><li>取值时可用 <code>value_or(&quot;nil&quot;)</code>，不存在时返回 “nil”。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;sw::redis::OptionalString&gt; res;</span><br><span class="line">redis.<span class="built_in">mget</span>(&#123;<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;key5&quot;</span>&#125;, std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;MGET results:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;value : res) &#123;</span><br><span class="line">    std::cout &lt;&lt; value.<span class="built_in">value_or</span>(<span class="string">&quot;nil&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MGET results:</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">value4</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><hr><h3><span id="getrange-setrange">getrange、setrange</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">getrange</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">long</span> <span class="type">long</span> start, <span class="type">long</span> <span class="type">long</span> end)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">setrange</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">long</span> <span class="type">long</span> offset, <span class="type">const</span> StringView &amp;val)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Original value of key1: &quot;</span> &lt;&lt; redis.<span class="built_in">get</span>(<span class="string">&quot;key1&quot;</span>).<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子字符串(索引从0开始，包含结束位置)</span></span><br><span class="line"><span class="keyword">auto</span> range = redis.<span class="built_in">getrange</span>(<span class="string">&quot;key1&quot;</span>, <span class="number">7</span>, <span class="number">11</span>);  <span class="comment">// 获取&quot;World&quot;</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Range from key1 (7 to 11): &quot;</span> &lt;&lt; range &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改子字符串(从指定偏移量开始替换)</span></span><br><span class="line">redis.<span class="built_in">setrange</span>(<span class="string">&quot;key1&quot;</span>, <span class="number">7</span>, <span class="string">&quot;Redis&quot;</span>);  <span class="comment">// 将&quot;World&quot;替换为&quot;Redis&quot;</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Updated value of key1: &quot;</span> &lt;&lt; redis.<span class="built_in">get</span>(<span class="string">&quot;key1&quot;</span>).<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Original value of key1: Hello, World!</span><br><span class="line">Range from key1 (7 to 11): World</span><br><span class="line">Updated value of key1: Hello, Redis!</span><br></pre></td></tr></table></figure><hr><h3><span id="incr-decr">incr、decr</span></h3><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">incr</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">decr</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空Redis数据库</span></span><br><span class="line">redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置初始计数器值</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;counter&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Initial value of counter: &quot;</span> &lt;&lt; redis.<span class="built_in">get</span>(<span class="string">&quot;counter&quot;</span>).<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子递增操作(值+1)</span></span><br><span class="line">redis.<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value after incr: &quot;</span> &lt;&lt; redis.<span class="built_in">get</span>(<span class="string">&quot;counter&quot;</span>).<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子递减操作(值-1)</span></span><br><span class="line">redis.<span class="built_in">decr</span>(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value after decr: &quot;</span> &lt;&lt; redis.<span class="built_in">get</span>(<span class="string">&quot;counter&quot;</span>).<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：如果键不存在，incr/decr会将其初始化为0再操作</span></span><br><span class="line">redis.<span class="built_in">del</span>(<span class="string">&quot;new_counter&quot;</span>);  <span class="comment">// 确保键不存在</span></span><br><span class="line">redis.<span class="built_in">incr</span>(<span class="string">&quot;new_counter&quot;</span>); <span class="comment">// 从0开始递增到1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;New counter value: &quot;</span> &lt;&lt; redis.<span class="built_in">get</span>(<span class="string">&quot;new_counter&quot;</span>).<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Initial value of counter: 10</span><br><span class="line">Value after incr: 11</span><br><span class="line">Value after decr: 10</span><br><span class="line">New counter value: 1</span><br></pre></td></tr></table></figure><hr><p>通过这些接口，C++ 后端可以高效、类型安全地操作 Redis 的字符串类型，在使用的时候一定要注意异常处理，同时需要注意在合适的场合选择不同的重载方法来满足具体的需求。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> C++ </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis C++ 客户端使用指南-基础指令篇</title>
      <link href="/2025/08/14/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_func/"/>
      <url>/2025/08/14/Redis/C++%E5%AE%A2%E6%88%B7%E7%AB%AF/redis_cpp_func/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#c-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5">C++ 客户端连接</a></li><li><a href="#%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4">基础指令</a><ul><li><a href="#set">SET</a></li><li><a href="#exists-del">EXISTS、DEL</a></li><li><a href="#keys">KEYS</a></li><li><a href="#expire-ttl">EXPIRE、TTL</a></li><li><a href="#type">TYPE</a></li></ul></li></ul><!-- tocstop --><h2><span id="c-客户端连接">C++ 客户端连接</span></h2><p>C++ 客户端连接 Redis 的基本步骤如下：</p><ol><li>引入 Redis C++ 客户端库头文件</li><li>创建 Redis 客户端对象</li><li>连接到 Redis 服务器</li></ol><p>当然，最重要的是需要安装 Redis C++ 客户端库，如 hiredis 或 redis-plus-plus。若还未安装，请跳转：<a href="https://github.com/sewenew/redis-plus-plus">redis-plus-plus</a></p><p>里面的安装步骤非常详细，按照说明进行即可。</p><p>在我们成功安装并配置好 Redis C++ 客户端后，就可以开始编写代码连接 Redis 服务器了，我们先实现一个非常简单的连接服务器代码，通过 ping 指令来判断连接是否成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Redis连接，使用TCP协议连接本地6379端口</span></span><br><span class="line">        sw::<span class="function">redis::Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送PING命令测试连接</span></span><br><span class="line">        <span class="keyword">auto</span> result = redis.<span class="built_in">ping</span>();  <span class="comment">// 返回OptionalString类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">// 成功连接会返回&quot;PONG&quot;</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;连接成功: &quot;</span> &lt;&lt; *result &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;连接失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e) &#123;</span><br><span class="line">        <span class="comment">// 捕获连接异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Redis连接异常: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时是需要告诉编译器静态库路径的，我们通过 <code>cmake</code> 添加相应的链接库：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(RedisDemo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(redis_demo main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接必要的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(redis_demo </span><br><span class="line">    /usr/local/lib/libredis++.a  <span class="comment"># redis-plus-plus静态库</span></span><br><span class="line">    pthread                     <span class="comment"># 线程库</span></span><br><span class="line">    hiredis                     <span class="comment"># hiredis基础库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>hiredis</code> 默认就在 <code>/usr/lib</code> 目录下，因此在 <code>CMakeLists.txt</code> 中只需要链接 <code>hiredis</code> 库即可，无需指定路径。但是 <code>redis-plus-plus</code> 默认是在 <code>/usr/local/lib</code> 目录下，因为我并没有将其安装到系统默认的库路径中，因此需要在 <code>CMakeLists.txt</code> 中指定其路径。若你在配置静态库默认路径的时候已经将 <code>usr/local/lib</code> 添加到系统库路径中，则无需手动指定。</p><p>可以看到，运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接成功: PONG</span><br></pre></td></tr></table></figure><h2><span id="基础指令">基础指令</span></h2><h3><span id="set">SET</span></h3><p><code>set</code> 用于设置指定 key 的字符串值。<br>对应的 C++ 接口为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::set</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> StringView &amp;val)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br></pre></td></tr></table></figure><p>配合 <code>get</code> 方法可以获取对应 key 的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> val1 = redis.<span class="built_in">get</span>(<span class="string">&quot;key1&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value1: &quot;</span> &lt;&lt; val<span class="number">1.</span><span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value1: value1</span><br><span class="line">value2: value2</span><br><span class="line">value3: value3</span><br><span class="line">key4 does not exist</span><br></pre></td></tr></table></figure><hr><h3><span id="exists-del">EXISTS、DEL</span></h3><p><code>exists</code> 用于判断一个或多个 key 是否存在，返回存在的 key 的数量。<br><code>del</code> 用于删除指定的 key。</p><p>对应的 C++ 接口为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::exists</span><span class="params">(<span class="type">const</span> std::initializer_list&lt;StringView&gt; &amp;keys)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::del</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置测试键</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查多个键是否存在(返回存在的键数量)</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> exist_count = redis.<span class="built_in">exists</span>(&#123;<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;存在的键数量: &quot;</span> &lt;&lt; exist_count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除key1</span></span><br><span class="line">redis.<span class="built_in">del</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次检查</span></span><br><span class="line">exist_count = redis.<span class="built_in">exists</span>(&#123;<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;删除后存在的键数量: &quot;</span> &lt;&lt; exist_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存在的键数量: 3</span><br><span class="line">删除后存在的键数量: 2</span><br></pre></td></tr></table></figure><hr><h3><span id="keys">KEYS</span></h3><p><code>keys</code> 用于查找所有符合给定模式的 key。<br>对应的 C++ 接口为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::keys</span><span class="params">(<span class="type">const</span> StringView &amp;pattern, Output output)</span></span>;</span><br></pre></td></tr></table></figure><p>通常配合 <code>std::back_inserter</code> 使用，将结果插入到容器中。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; keys;</span><br><span class="line">redis.<span class="built_in">keys</span>(<span class="string">&quot;key*&quot;</span>, std::<span class="built_in">back_inserter</span>(keys));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;All keys: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;key : keys) &#123;</span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All keys: key3 key2 key1 </span><br></pre></td></tr></table></figure><hr><h3><span id="expire-ttl">EXPIRE、TTL</span></h3><p><code>expire</code> 用于为指定 key 设置过期时间（秒），<code>ttl</code> 用于获取 key 的剩余过期时间（秒）。</p><p>对应的 C++ 接口为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::expire</span><span class="params">(<span class="type">const</span> StringView &amp;key, <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt; &amp;timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::ttl</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">redis.<span class="built_in">expire</span>(<span class="string">&quot;key1&quot;</span>, <span class="number">10</span>s);</span><br><span class="line">redis.<span class="built_in">expire</span>(<span class="string">&quot;key2&quot;</span>, <span class="number">20</span>s);</span><br><span class="line">redis.<span class="built_in">expire</span>(<span class="string">&quot;key3&quot;</span>, <span class="number">30</span>s);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;TTL of key1: &quot;</span> &lt;&lt; redis.<span class="built_in">ttl</span>(<span class="string">&quot;key1&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;TTL of key2: &quot;</span> &lt;&lt; redis.<span class="built_in">ttl</span>(<span class="string">&quot;key2&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;TTL of key3: &quot;</span> &lt;&lt; redis.<span class="built_in">ttl</span>(<span class="string">&quot;key3&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;TTL of key1 after 5 seconds: &quot;</span> &lt;&lt; redis.<span class="built_in">ttl</span>(<span class="string">&quot;key1&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;TTL of key2 after 5 seconds: &quot;</span> &lt;&lt; redis.<span class="built_in">ttl</span>(<span class="string">&quot;key2&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;TTL of key3 after 5 seconds: &quot;</span> &lt;&lt; redis.<span class="built_in">ttl</span>(<span class="string">&quot;key3&quot;</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TTL of key1: 10</span><br><span class="line">TTL of key2: 20</span><br><span class="line">TTL of key3: 30</span><br><span class="line">TTL of key1 after 5 seconds: 5</span><br><span class="line">TTL of key2 after 5 seconds: 15</span><br><span class="line">TTL of key3 after 5 seconds: 25</span><br></pre></td></tr></table></figure><hr><h3><span id="type">TYPE</span></h3><p><code>type</code> 用于返回 key 所储存的值的类型。<br>对应的 C++ 接口为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">Redis::type</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">redis.<span class="built_in">lpush</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; members = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;value3&quot;</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;value4&quot;</span>, <span class="number">2.0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;key3&quot;</span>, members.<span class="built_in">begin</span>(), members.<span class="built_in">end</span>());</span><br><span class="line">redis.<span class="built_in">sadd</span>(<span class="string">&quot;key4&quot;</span>, &#123;<span class="string">&quot;value5&quot;</span>, <span class="string">&quot;value6&quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type of key1: &quot;</span> &lt;&lt; redis.<span class="built_in">type</span>(<span class="string">&quot;key1&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type of key2: &quot;</span> &lt;&lt; redis.<span class="built_in">type</span>(<span class="string">&quot;key2&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type of key3: &quot;</span> &lt;&lt; redis.<span class="built_in">type</span>(<span class="string">&quot;key3&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type of key4: &quot;</span> &lt;&lt; redis.<span class="built_in">type</span>(<span class="string">&quot;key4&quot;</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type of key1: string</span><br><span class="line">Type of key2: list</span><br><span class="line">Type of key3: zset</span><br><span class="line">Type of key4: set</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> C++ </tag>
            
            <tag> 客户端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基于 Epoll 的主从 Reactor 多线程模型</title>
      <link href="/2025/08/02/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/Reactor/"/>
      <url>/2025/08/02/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/Reactor/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-reactor-%E6%A8%A1%E5%9E%8B">什么是 <code>Reactor</code> 模型</a><ul><li><a href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">核心概念</a></li><li><a href="#%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB">模型分类</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">工作流程</a></li></ul></li><li><a href="#%E5%9F%BA%E4%BA%8E-epoll-%E7%9A%84%E4%B8%BB%E4%BB%8E-reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">基于 Epoll 的主从 Reactor 多线程模型</a><ul><li><a href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">核心组件</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-1">工作流程</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a><ul><li><a href="#connectionhpp-%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90"><code>Connection.hpp</code> 连接类实现解析</a></li><li><a href="#epollhpp-%E5%B0%81%E8%A3%85%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90"><code>Epoll.hpp</code> 封装类实现解析</a></li><li><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90">定时器管理系统设计解析</a></li><li><a href="#%E7%9B%91%E5%90%AC%E5%99%A8listener%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90">监听器(Listener)类实现解析</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%99%A8eventloop%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90">事件循环器(EventLoop)核心实现解析</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90">服务端主程序实现解析</a></li><li><a href="#%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E">核心架构说明</a></li></ul></li></ul><!-- tocstop --><h2><span id="什么是-reactor-模型">什么是 <code>Reactor</code> 模型</span></h2><p><code>Reactor 模型</code> 是一种基于事件驱动的高性能网络编程模型，广泛应用于高并发场景中。其核心思想是通过I&#x2F;O多路复用和事件分发机制，高效地处理网络请求，避免线程阻塞和资源浪费。</p><h3><span id="核心概念">核心概念</span></h3><p><code>Reactor 模型</code> 的核心是事件驱动机制，通过监听 I&#x2F;O 事件（如连接建立、数据读写等），将事件分发给相应的处理器（Handler）进行处理。它主要由以下两个角色组成：</p><p>1.Reactor（反应器）：负责监听和分发事件。它通过 I&#x2F;O 多路复用（如 select、poll 或 epoll）监听多个连接的事件，并将事件分发给对应的处理器。</p><p>2.Handler（处理器）：负责具体的事件处理逻辑，如数据读取、业务处理和响应发送。</p><h3><span id="模型分类">模型分类</span></h3><p><code>Reactor 模型</code> 根据线程和资源的分配方式，分为以下三种实现方式：</p><ul><li><p>单 Reactor 单线程模型： Reactor 和所有 Handler 都运行在同一个线程中。 优点：模型简单，无需处理多线程同步问题。 缺点：性能有限，无法充分利用多核 CPU，且单线程阻塞会导致整个系统不可用。</p></li><li><p>单 Reactor 多线程模型： Reactor 负责事件监听和分发，具体的业务处理交由线程池完成。 优点：充分利用多核 CPU，提升并发处理能力。 缺点：Reactor 仍是单线程运行，高并发场景下可能成为瓶颈。</p></li><li><p>主从 Reactor 多线程模型： 主 Reactor 负责监听新连接并将其分配给从 Reactor。 从 Reactor 负责具体的 I&#x2F;O 事件处理，并将任务交给线程池完成。 优点：主从分离，职责明确，适合高并发场景，充分利用多核资源。</p></li></ul><h3><span id="工作流程">工作流程</span></h3><p>以主从 Reactor 多线程模型为例，其工作流程如下：</p><p>1.主 Reactor 监听新连接事件，通过 Acceptor 接收连接。</p><p>2.新连接被分配给从 Reactor，从 Reactor 负责监听该连接的 I&#x2F;O 事件。</p><p>3.当有 I&#x2F;O 事件发生时，从 Reactor 调用对应的 Handler 进行处理。</p><p>4.Handler 读取数据后，将任务交给线程池处理业务逻辑。</p><p>5.线程池完成业务处理后，将结果返回给 Handler，Handler 再通过网络发送响应。</p><h2><span id="基于-epoll-的主从-reactor-多线程模型">基于 Epoll 的主从 Reactor 多线程模型</span></h2><p><code>Epoll</code> 是 Linux 下的一种 I&#x2F;O 多路复用机制，它提供了高效的事件通知机制。基于 Epoll 的主从 Reactor 多线程模型，可以充分利用多核 CPU，实现高并发处理。</p><h3><span id="核心组件">核心组件</span></h3><p>1.主 Reactor：监听新连接事件，通过 Acceptor 接收连接，并将其分配给从 Reactor。</p><p>2.从 Reactor：监听已连接的 I&#x2F;O 事件，调用 Handler 进行处理。</p><p>3.Handler：负责具体的事件处理逻辑，如数据读取、业务处理和响应发送。</p><p>4.TimerManager：链接管理器，根据用户的活跃状态决定是否关闭链接。</p><p>而我们的主从 <code>Reactor</code> 处理的是简单的计算器任务，因此暂不需将任务交给线程池处理业务逻辑。</p><h3><span id="工作流程">工作流程</span></h3><p>1.主 Reactor 监听新连接事件，通过 Acceptor 接收连接。</p><p>2.新连接被分配给从 Reactor，从 Reactor 负责监听该连接的 I&#x2F;O 事件。</p><p>3.当有 I&#x2F;O 事件发生时，从 Reactor 调用对应的 Handler 进行处理。</p><p>4.Handler 读取数据后，进行业务逻辑处理，并通过网络发送响应。</p><h3><span id="注意事项">注意事项</span></h3><p>1.主 Reactor 和从 Reactor 应该运行在不同的线程中，以充分利用多核 CPU。</p><p>2.从 Reactor 应该使用非阻塞 I&#x2F;O，因为 Epoll 使用的是边缘触发模式，我们需要对数据进行完整读取。</p><p>3.一般在读取到用户的数据后处理完直接将数据发送给用户，但是若发送给用户后用户缓冲区仍然有数据，说明用户未读取完，我们需要对用户的写事件 <code>EPOLLOUT</code> 进行监听，直到用户读取完数据。</p><h2><span id="代码实现">代码实现</span></h2><h3><span id="connectionhpp-连接类实现解析"><code>Connection.hpp</code> 连接类实现解析</span></h3><h4><span id="1-头文件保护与基本包含">1. 头文件保护与基本包含</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CONNECTION_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CONNECTION_HPP_ 1</span></span><br><span class="line"><span class="comment">// 防止头文件重复包含的标准保护措施</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>       <span class="comment">// 智能指针支持</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// 函数对象支持</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span>   <span class="comment">// 项目通用头文件</span></span></span><br></pre></td></tr></table></figure><h4><span id="2-前向声明与类型定义">2. 前向声明与类型定义</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>;</span><br><span class="line"><span class="comment">// Connection类的前向声明，用于func_t类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = std::function&lt;<span class="built_in">void</span>(std::weak_ptr&lt;Connection&gt;)&gt;;</span><br><span class="line"><span class="comment">// 定义回调函数类型：</span></span><br><span class="line"><span class="comment">// 参数为Connection的弱指针，无返回值</span></span><br><span class="line"><span class="comment">// 使用weak_ptr避免循环引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>; </span><br><span class="line"><span class="comment">// EventLoop类的前向声明</span></span><br></pre></td></tr></table></figure><h4><span id="3-connection类定义">3. Connection类定义</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化socket描述符，默认不关注写事件</span></span><br><span class="line">    <span class="built_in">Connection</span>(<span class="type">int</span> sock)</span><br><span class="line">    :<span class="built_in">sock_</span>(sock),</span><br><span class="line">    <span class="built_in">write_care_</span>(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取socket文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Sockfd</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> sock_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加数据到输入缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendInBuffer</span><span class="params">(<span class="type">const</span> std::string &amp;info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        inbuffer_ += info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加数据到输出缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendOutBuffer</span><span class="params">(<span class="type">const</span> std::string &amp;info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        outbuffer_ += info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入缓冲区引用</span></span><br><span class="line">    <span class="function">std::string &amp;<span class="title">Inbuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inbuffer_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输出缓冲区引用</span></span><br><span class="line">    <span class="function">std::string &amp;<span class="title">OutBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outbuffer_;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="4-成员变量详解">4. 成员变量详解</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> sock_;              <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    std::string inbuffer_;  <span class="comment">// 输入数据缓冲区</span></span><br><span class="line">    std::string outbuffer_; <span class="comment">// 输出数据缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所属EventLoop的弱引用（避免循环引用）</span></span><br><span class="line">    std::weak_ptr&lt;EventLoop&gt; el;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三个核心回调函数：</span></span><br><span class="line">    <span class="type">func_t</span> recv_cb;    <span class="comment">// 读事件回调</span></span><br><span class="line">    <span class="type">func_t</span> send_cb;    <span class="comment">// 写事件回调 </span></span><br><span class="line">    <span class="type">func_t</span> except_cb;  <span class="comment">// 异常事件回调</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端信息</span></span><br><span class="line">    std::string ip_;     <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="type">uint16_t</span> port_;      <span class="comment">// 客户端端口号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写事件关注标志</span></span><br><span class="line">    <span class="comment">// true表示需要监听EPOLLOUT事件</span></span><br><span class="line">    <span class="type">bool</span> write_care_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4><span id="5-设计要点说明">5. 设计要点说明</span></h4><h5><span id="51-缓冲区管理">5.1 缓冲区管理</span></h5><ul><li>使用<code>std::string</code>作为缓冲区容器</li><li>提供<code>Append</code>方法追加数据</li><li>返回引用避免不必要的拷贝</li></ul><h5><span id="52-回调机制">5.2 回调机制</span></h5><ul><li>三个关键回调函数通过<code>std::function</code>封装</li><li>使用<code>weak_ptr</code>传递自身引用，防止循环引用</li><li>回调由EventLoop事件循环触发</li></ul><h5><span id="53-资源管理">5.3 资源管理</span></h5><ul><li>原始socket描述符由RAII管理</li><li><code>weak_ptr</code>关联EventLoop避免内存泄漏</li><li>写事件标志实现动态EPOLLOUT注册</li></ul><h3><span id="epollhpp-封装类实现解析"><code>Epoll.hpp</code> 封装类实现解析</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _EPOLL_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EPOLL_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span>  <span class="comment">// epoll系统调用头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nocopy.hpp&quot;</span>   <span class="comment">// 禁止拷贝的基类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>      <span class="comment">// 日志系统头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认epoll_wait超时时间(毫秒)</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> default_time_out = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码枚举</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    epoll_create_error = <span class="number">1</span>,  <span class="comment">// epoll创建失败错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Epoll封装类，继承nocopy禁止拷贝构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoll</span>: <span class="keyword">public</span> nocopy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数：创建epoll实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Epoll</span>()</span><br><span class="line">    :<span class="built_in">timeout</span>(default_time_out)  <span class="comment">// 初始化超时时间</span></span><br><span class="line">    &#123;</span><br><span class="line">        epfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);  <span class="comment">// 创建epoll实例</span></span><br><span class="line">        <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 记录创建失败日志（线程ID、错误码、错误信息）</span></span><br><span class="line">            <span class="built_in">lg</span>(Error, <span class="string">&quot;thread-%d, epoll_create false, errno: %d, errstr: %s&quot;</span>, </span><br><span class="line">               <span class="built_in">pthread_self</span>(), errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">exit</span>(epoll_create_error);  <span class="comment">// 创建失败直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录创建成功日志</span></span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;thread-%d, epoll create success, epoll fd: %d&quot;</span>, <span class="built_in">pthread_self</span>(), epfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 等待epoll事件</span></span><br><span class="line"><span class="comment">     * @param events 输出参数，用于接收事件数组</span></span><br><span class="line"><span class="comment">     * @param num 最大事件数量</span></span><br><span class="line"><span class="comment">     * @return 就绪的事件数量，-1表示错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">EpollWait</span><span class="params">(<span class="keyword">struct</span> epoll_event events[], <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(epfd, events, num, timeout);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">lg</span>(Error, <span class="string">&quot;epoll_wait false, errno: %d, errstr: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 控制epoll监控的文件描述符</span></span><br><span class="line"><span class="comment">     * @param op 操作类型 (EPOLL_CTL_ADD/MOD/DEL)</span></span><br><span class="line"><span class="comment">     * @param fd 要操作的文件描述符</span></span><br><span class="line"><span class="comment">     * @param event 要监控的事件标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EpollCtl</span><span class="params">(<span class="type">int</span> op, <span class="type">int</span> fd, <span class="type">uint32_t</span> event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(op == EPOLL_CTL_DEL)&#123;</span><br><span class="line">            <span class="comment">// 删除操作不需要event参数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, op, fd, <span class="literal">nullptr</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;epoll control false, errno: %d, errstr: %s&quot;</span>, </span><br><span class="line">                   errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">            ev.data.fd = fd;    <span class="comment">// 关联文件描述符</span></span><br><span class="line">            ev.events = event;    <span class="comment">// 设置监听事件</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, op, fd, &amp;ev))&#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;epoll control false, errno: %d, errstr: %s&quot;</span>, </span><br><span class="line">                   errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数：关闭epoll文件描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~<span class="built_in">Epoll</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(epfd);  <span class="comment">// 确保资源释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epfd;      <span class="comment">// epoll文件描述符</span></span><br><span class="line">    <span class="type">int</span> timeout;   <span class="comment">// epoll_wait超时时间(毫秒)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4><span id="设计说明">设计说明</span></h4><ol><li><p><strong>资源管理</strong>：</p><ul><li>遵循RAII原则，构造函数创建epoll实例，析构函数自动释放</li><li>继承<code>nocopy</code>禁止拷贝构造和赋值，避免文件描述符重复关闭</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>所有epoll系统调用都有错误日志记录</li><li>创建失败直接退出程序（生产环境可改为异常）</li></ul></li><li><p><strong>线程安全</strong>：</p><ul><li>日志中包含线程ID，便于多线程调试</li><li>类本身无状态依赖，可在多线程环境使用不同实例</li></ul></li><li><p><strong>接口设计</strong>：</p><ul><li><code>EpollWait()</code>：封装epoll_wait，返回就绪事件数</li><li><code>EpollCtl()</code>：统一处理三种控制操作，自动处理DEL特殊情况</li></ul></li></ol><p>该接口封装在前面章节已经讲解过，主要用于管理事件监听和处理。</p><h3><span id="定时器管理系统设计解析">定时器管理系统设计解析</span></h3><h4><span id="timer定时器结构设计">Timer定时器结构设计</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIMER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIMER_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;connection.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明避免循环依赖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器节点结构体</span></span><br><span class="line"><span class="comment"> * @note 存储连接的生命周期状态信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数初始化连接状态</span></span><br><span class="line">    <span class="built_in">Timer</span>(<span class="type">int</span> expired_time_, <span class="type">int</span> cnt_, std::shared_ptr&lt;Connection&gt; connect_)</span><br><span class="line">    :<span class="built_in">expired_time</span>(expired_time_),  <span class="comment">// 绝对过期时间戳</span></span><br><span class="line">    <span class="built_in">cnt</span>(cnt_),                     <span class="comment">// 连续活跃次数计数器</span></span><br><span class="line">    <span class="built_in">connect</span>(connect_)&#123;&#125;            <span class="comment">// 管理的连接对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> expired_time;              <span class="comment">// Unix时间戳格式的过期时间</span></span><br><span class="line">    <span class="type">int</span> cnt;                       <span class="comment">// 累计活跃次数（用于奖励机制）</span></span><br><span class="line">    std::shared_ptr&lt;Connection&gt; connect; <span class="comment">// 关联的连接智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器比较仿函数</span></span><br><span class="line"><span class="comment"> * @note 用于构建最小堆（最早过期时间在堆顶）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">time_cmp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Timer&gt; t1, <span class="type">const</span> std::shared_ptr&lt;Timer&gt; t2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：通过大于号实现最小堆</span></span><br><span class="line">        <span class="keyword">return</span> t1-&gt;expired_time &gt; t2-&gt;expired_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4><span id="timermanager定时器管理器设计">TimerManager定时器管理器设计</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIMER_MANAGER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIMER_MANAGER_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认配置常量</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> default_alive_gap = <span class="number">10</span>;  <span class="comment">// 默认存活周期（秒）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> default_alive_cnt = <span class="number">5</span>;   <span class="comment">// 重置阈值（次）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器管理核心类</span></span><br><span class="line"><span class="comment"> * @note 采用最小堆+哈希表双结构实现高效管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化存活周期和计数阈值</span></span><br><span class="line">    <span class="built_in">TimerManager</span>(<span class="type">int</span> gap = default_alive_gap, <span class="type">int</span> cnt = default_alive_cnt)</span><br><span class="line">        : <span class="built_in">alive_gap</span>(gap),</span><br><span class="line">          <span class="built_in">alive_cnt</span>(cnt) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加新连接定时器</span></span><br><span class="line"><span class="comment">     * @param connect 要管理的连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(std::shared_ptr&lt;Connection&gt; connect)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建新定时器（当前时间+存活周期）</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;Timer&gt; <span class="title">timer</span><span class="params">(<span class="keyword">new</span> Timer(std::time(<span class="literal">nullptr</span>) + alive_gap, <span class="number">0</span>, connect))</span></span>;</span><br><span class="line">        timers.<span class="built_in">emplace</span>(timer);                <span class="comment">// 插入最小堆</span></span><br><span class="line">        timer_map[connect-&gt;<span class="built_in">Sockfd</span>()] = timer; <span class="comment">// 建立socket到定时器的映射</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检查堆顶是否过期</span></span><br><span class="line"><span class="comment">     * @return true表示存在过期连接需要处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsTopExpired</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!timers.<span class="built_in">empty</span>() &amp;&amp; timers.<span class="built_in">top</span>()-&gt;expired_time &lt;= std::<span class="built_in">time</span>(<span class="literal">nullptr</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = (timers.<span class="built_in">top</span>()-&gt;connect)-&gt;<span class="built_in">Sockfd</span>();</span><br><span class="line">            <span class="comment">// 处理惰性删除</span></span><br><span class="line">            <span class="keyword">if</span>(timer_map.<span class="built_in">find</span>(sockfd) == timer_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                timers.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(timers.<span class="built_in">top</span>()-&gt;cnt != timer_map[sockfd]-&gt;cnt || timers.<span class="built_in">top</span>()-&gt;expired_time != timer_map[sockfd]-&gt;expired_time)</span><br><span class="line">            &#123;</span><br><span class="line">                timers.<span class="built_in">pop</span>();</span><br><span class="line">                timers.<span class="built_in">emplace</span>(timer_map[sockfd]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timers.<span class="built_in">top</span>()-&gt;cnt &gt;= <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> timer = timers.<span class="built_in">top</span>();</span><br><span class="line">                timer-&gt;expired_time = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>) + alive_gap;</span><br><span class="line">                timer-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">                timers.<span class="built_in">emplace</span>(timer);</span><br><span class="line">                timer_map[sockfd] = timer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 惰性删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LazyDelete</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">        timer_map.<span class="built_in">erase</span>(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取堆顶定时器（不弹出）</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Timer&gt; <span class="title">GetTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timers.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 更新连接活跃时间</span></span><br><span class="line"><span class="comment">     * @param sockfd 要更新的socket描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateTime</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检测链接是否已被删除</span></span><br><span class="line">        <span class="keyword">if</span>(timer_map.<span class="built_in">find</span>(sockfd) == timer_map.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(timers.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 创建新的 Timer（避免共享指针副作用）</span></span><br><span class="line">        <span class="keyword">auto</span> new_timer = std::<span class="built_in">make_shared</span>&lt;Timer&gt;(</span><br><span class="line">        std::<span class="built_in">time</span>(<span class="literal">nullptr</span>) + alive_gap,</span><br><span class="line">        timer_map[sockfd]-&gt;cnt + <span class="number">1</span>,</span><br><span class="line">        timer_map[sockfd]-&gt;connect</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 timer_map</span></span><br><span class="line">        timer_map[sockfd] = new_timer;</span><br><span class="line">        timer_map[sockfd]-&gt;cnt++;       <span class="comment">// 增加活跃计数</span></span><br><span class="line">        timer_map[sockfd]-&gt;expired_time = <span class="built_in">time</span>(<span class="literal">nullptr</span>) + alive_gap; <span class="comment">// 重置过期时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据结构</span></span><br><span class="line">    std::priority_queue&lt;std::shared_ptr&lt;Timer&gt;, </span><br><span class="line">                       std::vector&lt;std::shared_ptr&lt;Timer&gt;&gt;, </span><br><span class="line">                       time_cmp&gt; timers;  <span class="comment">// 最小堆</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::shared_ptr&lt;Timer&gt;&gt; timer_map;  <span class="comment">// 哈希表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置参数</span></span><br><span class="line">    <span class="type">int</span> alive_gap;  <span class="comment">// 存活周期（秒）</span></span><br><span class="line">    <span class="type">int</span> alive_cnt;  <span class="comment">// 重置阈值（次）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5><span id="惰性处理机制详解">惰性处理机制详解</span></h5><ol><li><p><strong>延迟验证设计</strong>：</p><ul><li>只在检查堆顶时处理过期（<code>IsTopExpired</code>）</li><li>非堆顶元素即使过期也暂不处理</li><li>降低频繁检查带来的CPU开销</li></ul></li><li><p><strong>状态同步策略</strong>：</p><ul><li>哈希表存储最新状态</li><li>堆中元素可能滞后（通过<code>cnt/expired_time</code>以及哈希表中是否存有该元素来比较检测）</li><li>发现状态不一致时重新入堆</li></ul></li><li><p><strong>奖励机制实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timers.<span class="built_in">top</span>()-&gt;cnt &gt;= alive_cnt) &#123;</span><br><span class="line">    <span class="comment">//...重置计数器</span></span><br><span class="line">    timer-&gt;expired_time = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>) + alive_gap;</span><br><span class="line">    timer-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>活跃连接获得生命周期重置</li><li>避免健康连接被误清理</li></ul></li></ol><h5><span id="堆处理精妙设计">堆处理精妙设计</span></h5><ol><li><p><strong>双数据结构配合</strong>：</p><ul><li>最小堆：快速获取最早过期连接（O(1)）</li><li>哈希表：快速查找特定连接（O(1)）</li></ul></li><li><p><strong>堆更新优化</strong>：</p><ul><li>不直接修改堆元素，而是重新插入</li><li>通过状态比较发现过期版本</li><li>摊还时间复杂度为O(logN)</li></ul></li><li><p><strong>批量处理能力</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!timers.<span class="built_in">empty</span>() &amp;&amp; timers.<span class="built_in">top</span>()-&gt;expired_time &lt;= curr_time) &#123;</span><br><span class="line">    <span class="comment">// 批量处理所有过期连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>单次操作可处理多个过期连接</li></ul><p>该设计完美平衡了精度和效率，特别适合高频网络通信场景，其中：</p><ul><li>健康连接通过奖励机制长期保持</li><li>僵尸连接被快速识别清理</li><li>系统开销随活跃连接数线性增长</li></ul><h3><span id="监听器listener类实现解析">监听器(Listener)类实现解析</span></h3><h4><span id="类功能概述">类功能概述</span></h4><p>Listener类封装了TCP服务端的监听逻辑，主要职责包括：</p><ol><li>初始化监听socket（非阻塞模式）</li><li>持续接受客户端连接</li><li>将新连接信息通过环形队列传递给I&#x2F;O线程</li><li>通过Connection弱引用实现与EventLoop的低耦合交互</li></ol><h4><span id="代码详细注释">代码详细注释</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LISTENER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LISTENER_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span>         <span class="comment">// TCP socket封装</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;event_loop.hpp&quot;</span>  <span class="comment">// 事件循环</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>         <span class="comment">// 日志系统</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">uint16_t</span> default_listen_port = <span class="number">6349</span>; <span class="comment">// 默认监听端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief TCP监听器类</span></span><br><span class="line"><span class="comment"> * @note 通过环形队列实现与I/O线程的解耦</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Listener</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     * @param port 监听端口号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Listener</span>(<span class="type">uint16_t</span> port = default_listen_port)</span><br><span class="line">        : <span class="built_in">port_</span>(port),</span><br><span class="line">        <span class="built_in">sock_</span>(<span class="keyword">new</span> <span class="built_in">Sock</span>()) <span class="comment">// 创建TCP socket封装对象</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 初始化监听socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sock_-&gt;<span class="built_in">Socket</span>();  <span class="comment">// 创建socket</span></span><br><span class="line">        sock_-&gt;<span class="built_in">Bind</span>(port_); <span class="comment">// 绑定端口</span></span><br><span class="line">        sock_-&gt;<span class="built_in">Listen</span>();    <span class="comment">// 开始监听</span></span><br><span class="line">        <span class="built_in">SetNonBlockOrDie</span>(sock_-&gt;<span class="built_in">GetSockfd</span>()); <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 接受客户端连接的主循环</span></span><br><span class="line"><span class="comment">     * @param conn 持有EventLoop引用的Connection对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accepter</span><span class="params">(std::weak_ptr&lt;Connection&gt; conn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> connection = conn.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> listen_sockfd = sock_-&gt;<span class="built_in">GetSockfd</span>();</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">            <span class="comment">// 非阻塞accept</span></span><br><span class="line">            <span class="type">int</span> client_sockfd = <span class="built_in">accept</span>(listen_sockfd, (sockaddr *)&amp;client, &amp;len);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EWOULDBLOCK)</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 无新连接时退出循环</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 被信号中断则重试</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 记录accept错误日志</span></span><br><span class="line">                    <span class="built_in">lg</span>(Error, <span class="string">&quot;listening sock accept false, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取客户端地址信息</span></span><br><span class="line">            std::string client_ip;</span><br><span class="line">            <span class="type">uint16_t</span> client_port;</span><br><span class="line">            Sock::<span class="built_in">GetAddrAndPort</span>(client, client_ip, client_port);</span><br><span class="line">            <span class="built_in">lg</span>(Info, <span class="string">&quot;accept a new client [%s: %d]&quot;</span>, client_ip.<span class="built_in">c_str</span>(), client_port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置客户端socket为非阻塞</span></span><br><span class="line">            <span class="built_in">SetNonBlockOrDie</span>(client_sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过EventLoop的环形队列传递连接信息</span></span><br><span class="line">            <span class="keyword">auto</span> event_loop = connection-&gt;el.<span class="built_in">lock</span>();</span><br><span class="line">            ClientInf ci&#123;</span><br><span class="line">                .sockfd = client_sockfd,</span><br><span class="line">                .client_ip = client_ip,</span><br><span class="line">                .client_port = client_port</span><br><span class="line">            &#125;;</span><br><span class="line">            event_loop-&gt;rq_-&gt;<span class="built_in">Push</span>(ci); <span class="comment">// 入队操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取监听socket文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sock_-&gt;<span class="built_in">GetSockfd</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint16_t</span> port_;             <span class="comment">// 监听端口</span></span><br><span class="line">    std::shared_ptr&lt;Sock&gt; sock_; <span class="comment">// TCP socket封装对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4><span id="关键设计亮点">关键设计亮点</span></h4><h5><span id="低耦合实现方式">低耦合实现方式</span></h5><ol><li><p><strong>弱引用传递</strong>：</p><ul><li>通过<code>std::weak_ptr&lt;Connection&gt;</code>获取EventLoop引用</li><li>避免循环依赖，不增加引用计数</li></ul></li><li><p><strong>环形队列中介</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event_loop-&gt;rq_-&gt;<span class="built_in">Push</span>(ci);</span><br></pre></td></tr></table></figure><ul><li>新连接信息通过环形队列传递</li><li>监听线程与I&#x2F;O线程完全解耦</li></ul></li><li><p><strong>非阻塞设计</strong>：</p><ul><li>监听socket设置为非阻塞模式</li><li>批量接受连接后立即退出循环</li></ul></li></ol><h5><span id="异常处理机制">异常处理机制</span></h5><ol><li><strong>EWOULDBLOCK处理</strong>：<ul><li>非阻塞模式下正常情况处理</li></ul></li><li><strong>EINTR处理</strong>：<ul><li>系统调用被信号中断时自动重试</li></ul></li><li><strong>错误隔离</strong>：<ul><li>单个accept失败不影响后续连接</li></ul></li></ol><h5><span id="性能优化点">性能优化点</span></h5><ol><li><p><strong>批量接受连接</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> client_sockfd = <span class="built_in">accept</span>(...);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单次调用处理多个等待连接</li></ul></li><li><p><strong>零拷贝传递</strong>：</p><ul><li>仅传递socket fd和地址信息</li><li>避免数据复制开销</li></ul></li></ol><p>该实现完美体现了Reactor模式的精髓，通过：</p><ul><li>非阻塞I&#x2F;O提高吞吐量</li><li>队列缓冲实现生产消费者模式</li><li>弱引用保持组件独立性</li></ul><p>使得监听器可以高效稳定地处理海量连接请求。</p><h3><span id="事件循环器eventloop核心实现解析">事件循环器(EventLoop)核心实现解析</span></h3><h4><span id="类功能概述">类功能概述</span></h4><p>EventLoop是Reactor模式的核心组件，主要职责包括：</p><ol><li>管理所有连接的生命周期</li><li>处理epoll事件分发</li><li>集成定时器管理</li><li>提供协议处理接口(OnMessage)</li><li>支持任务队列集成(TaskPush)</li></ol><h4><span id="数据结构定义">数据结构定义</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端信息结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ClientInf</span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;            <span class="comment">// 客户端socket描述符</span></span><br><span class="line">    std::string client_ip; <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="type">uint16_t</span> client_port;  <span class="comment">// 客户端端口号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务回调类型定义</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">task_t</span> = std::function&lt;<span class="built_in">void</span>(std::weak_ptr&lt;RingQueue&lt;ClientInf&gt;&gt;, </span><br><span class="line">                                std::weak_ptr&lt;EventLoop&gt;)&gt;;</span><br></pre></td></tr></table></figure><h4><span id="核心方法实现">核心方法实现</span></h4><h5><span id="1-连接管理">1. 连接管理</span></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 添加新连接并注册事件回调</span></span><br><span class="line"><span class="comment"> * @param sock 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param event 监听事件类型(EPOLLIN/OUT等)</span></span><br><span class="line"><span class="comment"> * @param recv_cb 读事件回调</span></span><br><span class="line"><span class="comment"> * @param send_cb 写事件回调</span></span><br><span class="line"><span class="comment"> * @param except_cb 异常回调</span></span><br><span class="line"><span class="comment"> * @param ip 客户端IP(可选)</span></span><br><span class="line"><span class="comment"> * @param port 客户端端口(可选)</span></span><br><span class="line"><span class="comment"> * @param is_listensock 是否监听socket(不加入定时器)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(<span class="type">int</span> sock, <span class="type">uint32_t</span> event, <span class="type">func_t</span> recv_cb, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">func_t</span> send_cb, <span class="type">func_t</span> except_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> std::string &amp;ip = <span class="string">&quot;0.0.0.0&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint16_t</span> port = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">bool</span> is_listensock = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建新连接对象</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Connection&gt; <span class="title">new_connect</span><span class="params">(<span class="keyword">new</span> Connection(sock))</span></span>;</span><br><span class="line">    <span class="comment">// 设置反向引用</span></span><br><span class="line">    new_connect-&gt;el = <span class="built_in">shared_from_this</span>(); </span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    new_connect-&gt;recv_cb = recv_cb;</span><br><span class="line">    new_connect-&gt;send_cb = send_cb;</span><br><span class="line">    new_connect-&gt;except_cb = except_cb;</span><br><span class="line">    <span class="comment">// 记录客户端信息</span></span><br><span class="line">    new_connect-&gt;ip_ = ip;</span><br><span class="line">    new_connect-&gt;port_ = port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非监听socket加入定时管理</span></span><br><span class="line">    <span class="keyword">if</span>(!is_listensock) tm_-&gt;<span class="built_in">Push</span>(new_connect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到连接表</span></span><br><span class="line">    connections_[sock] = new_connect;</span><br><span class="line">    <span class="comment">// 注册epoll事件</span></span><br><span class="line">    epoller_-&gt;<span class="built_in">EpollCtl</span>(EPOLL_CTL_ADD, sock, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="2-网络ix2fo处理">2. 网络I&#x2F;O处理</span></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取客户端数据(非阻塞模式)</span></span><br><span class="line"><span class="comment"> * @param connect 连接弱引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Recv</span><span class="params">(std::weak_ptr&lt;Connection&gt; connect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> connection = connect.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="type">int</span> sock = connection-&gt;<span class="built_in">Sockfd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[n] = <span class="number">0</span>;</span><br><span class="line">            connection-&gt;<span class="built_in">AppendInBuffer</span>(buffer); <span class="comment">// 追加到输入缓冲区</span></span><br><span class="line">            <span class="built_in">lg</span>(Debug, <span class="string">&quot;thread-%d, recv message from client: %s&quot;</span>, </span><br><span class="line">               <span class="built_in">pthread_self</span>(), buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>) &#123; <span class="comment">// 客户端关闭连接</span></span><br><span class="line">            <span class="built_in">lg</span>(Info, <span class="string">&quot;client [%s: %d] quit&quot;</span>, </span><br><span class="line">               connection-&gt;ip_.<span class="built_in">c_str</span>(), connection-&gt;port_);</span><br><span class="line">            connection-&gt;<span class="built_in">except_cb</span>(connection);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 错误处理</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EWOULDBLOCK) <span class="keyword">break</span>; <span class="comment">// 无数据可读</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(errno == EINTR) <span class="keyword">continue</span>; <span class="comment">// 被信号中断</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;recv from client [%s: %d] false&quot;</span>, </span><br><span class="line">                   connection-&gt;ip_.<span class="built_in">c_str</span>(), connection-&gt;port_);</span><br><span class="line">                connection-&gt;<span class="built_in">except_cb</span>(connection);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发上层协议处理</span></span><br><span class="line">    <span class="keyword">if</span>(OnMessage_) <span class="built_in">OnMessage_</span>(connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送数据到客户端(非阻塞模式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::weak_ptr&lt;Connection&gt; connect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> connection = connect.<span class="built_in">lock</span>();</span><br><span class="line">    std::string &amp;outbuffer = connection-&gt;<span class="built_in">OutBuffer</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">send</span>(connection-&gt;<span class="built_in">Sockfd</span>(), </span><br><span class="line">                         outbuffer.<span class="built_in">c_str</span>(), </span><br><span class="line">                         outbuffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outbuffer.<span class="built_in">erase</span>(<span class="number">0</span>, n); <span class="comment">// 移除已发送数据</span></span><br><span class="line">            <span class="keyword">if</span>(outbuffer.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 不应发生的情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EWOULDBLOCK) <span class="keyword">break</span>; <span class="comment">// 写缓冲区满</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(errno == EINTR) <span class="keyword">continue</span>; <span class="comment">// 被信号中断</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;send to client [%s: %d] false&quot;</span>,</span><br><span class="line">                   connection-&gt;ip_.<span class="built_in">c_str</span>(), connection-&gt;port_);</span><br><span class="line">                connection-&gt;<span class="built_in">except_cb</span>(connection);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态调整EPOLLOUT事件监听</span></span><br><span class="line">    <span class="keyword">if</span>(!outbuffer.<span class="built_in">empty</span>() &amp;&amp; !connection-&gt;write_care_) &#123;</span><br><span class="line">        <span class="comment">// 开启写事件监听(当缓冲区有数据时)</span></span><br><span class="line">        epoller_-&gt;<span class="built_in">EpollCtl</span>(EPOLL_CTL_MOD,</span><br><span class="line">                          connection-&gt;<span class="built_in">Sockfd</span>(), </span><br><span class="line">                          EPOLLIN | EPOLLOUT | EPOLLET);</span><br><span class="line">        connection-&gt;write_care_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(outbuffer.<span class="built_in">empty</span>() &amp;&amp; connection-&gt;write_care_) &#123;</span><br><span class="line">        <span class="comment">// 关闭写事件监听(当缓冲区空时)</span></span><br><span class="line">        epoller_-&gt;<span class="built_in">EpollCtl</span>(EPOLL_CTL_MOD,</span><br><span class="line">                          connection-&gt;<span class="built_in">Sockfd</span>(), </span><br><span class="line">                          EPOLLIN | EPOLLET);</span><br><span class="line">        connection-&gt;write_care_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="3-事件分发核心">3. 事件分发核心</span></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 事件分发处理(核心方法)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisPatcher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 等待epoll事件(阻塞调用)</span></span><br><span class="line">    <span class="type">int</span> n = epoller_-&gt;<span class="built_in">EpollWait</span>(recvs, max_fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> events = recvs[i].events;</span><br><span class="line">        <span class="type">int</span> sockfd = recvs[i].data.fd;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 异常事件转化为读写事件处理</span></span><br><span class="line">        <span class="keyword">if</span>(events &amp; (EPOLLERR | EPOLLHUP)) </span><br><span class="line">            events |= (EPOLLIN | EPOLLOUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理读事件</span></span><br><span class="line">        <span class="keyword">if</span>(events &amp; EPOLLIN &amp;&amp; connections_[sockfd]-&gt;recv_cb) &#123;</span><br><span class="line">            connections_[sockfd]-&gt;<span class="built_in">recv_cb</span>(connections_[sockfd]);</span><br><span class="line">            tm_-&gt;<span class="built_in">UpdateTime</span>(sockfd); <span class="comment">// 更新活跃时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理写事件</span></span><br><span class="line">        <span class="keyword">if</span>(events &amp; EPOLLOUT &amp;&amp; connections_[sockfd]-&gt;send_cb) &#123;</span><br><span class="line">            connections_[sockfd]-&gt;<span class="built_in">send_cb</span>(connections_[sockfd]);</span><br><span class="line">            tm_-&gt;<span class="built_in">UpdateTime</span>(sockfd); <span class="comment">// 更新活跃时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="4-定时器集成">4. 定时器集成</span></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检查并处理过期连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expired_check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tm_-&gt;<span class="built_in">IsTopExpired</span>()) &#123; <span class="comment">// 检查堆顶是否过期</span></span><br><span class="line">        <span class="keyword">auto</span> top_time = tm_-&gt;<span class="built_in">GetTop</span>()-&gt;connect;</span><br><span class="line">        <span class="type">int</span> sockfd = top_time-&gt;<span class="built_in">Sockfd</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果连接仍存在则触发异常关闭</span></span><br><span class="line">        <span class="keyword">if</span>(connections_.<span class="built_in">find</span>(sockfd) != connections_.<span class="built_in">end</span>())</span><br><span class="line">            connections_[sockfd]-&gt;<span class="built_in">except_cb</span>(top_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="5-主事件循环">5. 主事件循环</span></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 事件主循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 从任务队列获取新连接(如果有TaskPush回调)</span></span><br><span class="line">        <span class="keyword">if</span>(TaskPush_) <span class="built_in">TaskPush_</span>(rq_, <span class="built_in">shared_from_this</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理epoll事件</span></span><br><span class="line">        <span class="built_in">DisPatcher</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查过期连接</span></span><br><span class="line">        <span class="built_in">Expired_check</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="关键设计解析">关键设计解析</span></h4><h5><span id="双回调接口设计">双回调接口设计</span></h5><ol><li><p><strong>OnMessage回调</strong>：</p><ul><li>由上层协议提供</li><li>在数据接收完成后触发</li><li>处理协议解析和业务逻辑</li></ul></li><li><p><strong>TaskPush回调</strong>：</p><ul><li>用户自定义实现</li><li>从环形队列获取新连接</li><li>示例实现：</li></ul></li></ol><h5><span id="定时器集成策略">定时器集成策略</span></h5><ol><li><p><strong>活跃度更新</strong>：</p><ul><li>每次I&#x2F;O操作后调用<code>tm_-&gt;UpdateTime()</code></li><li>重置连接的过期时间</li></ul></li><li><p><strong>惰性检查</strong>：</p><ul><li>只在事件循环间隙检查</li><li>避免频繁的定时器操作影响I&#x2F;O性能</li></ul></li><li><p><strong>异常统一处理</strong>：</p><ul><li>过期连接通过<code>except_cb</code>统一清理</li><li>保证资源释放的一致性</li></ul></li></ol><h5><span id="性能优化点">性能优化点</span></h5><ol><li><p><strong>边缘触发(EPOLLET)</strong>：</p><ul><li>减少epoll事件触发次数</li><li>需要配合非阻塞I&#x2F;O</li></ul></li><li><p><strong>动态事件注册</strong>：</p><ul><li>只在需要时监听EPOLLOUT</li><li>减少不必要的epoll事件</li></ul></li><li><p><strong>批量事件处理</strong>：</p><ul><li>单次epoll_wait处理多个事件</li><li>减少系统调用次数</li></ul></li></ol><p>该实现通过清晰的接口划分和高效的事件处理机制，完美支持了高并发网络编程的需求，同时保持了良好的扩展性和可维护性。</p><h4><span id="完整代码">完整代码</span></h4><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _EVENT_LOOP_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EVENT_LOOP_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoll.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ring_queue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer_manager.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;connection.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ClientInf</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerManager</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">task_t</span> = std::function&lt;<span class="built_in">void</span>(std::weak_ptr&lt;RingQueue&lt;ClientInf&gt;&gt;, std::weak_ptr&lt;EventLoop&gt;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> max_fd = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">uint16_t</span> default_port = <span class="number">7777</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">thread_local</span> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ClientInf</span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    std::string client_ip;</span><br><span class="line">    <span class="type">uint16_t</span> client_port;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;EventLoop&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 当 Task_Push 为空时，即代表不从上层循环队列当中获取任务，即主任务循环器的选择，因为主任务循环器只负责任务 Push，不参与 Pop</span></span><br><span class="line">    <span class="built_in">EventLoop</span>(std::shared_ptr&lt;RingQueue&lt;ClientInf&gt;&gt; rq = <span class="literal">nullptr</span>, <span class="type">func_t</span> OnMessage = <span class="literal">nullptr</span>, <span class="type">task_t</span> TaskPush = <span class="literal">nullptr</span>)</span><br><span class="line">    :<span class="built_in">epoller_</span>(<span class="keyword">new</span> <span class="built_in">Epoll</span>()),</span><br><span class="line">    <span class="built_in">OnMessage_</span>(OnMessage),</span><br><span class="line">    <span class="built_in">TaskPush_</span>(TaskPush),</span><br><span class="line">    <span class="built_in">rq_</span>(rq),</span><br><span class="line">    <span class="built_in">tm_</span>(<span class="keyword">new</span> <span class="built_in">TimerManager</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(<span class="type">int</span> sock, <span class="type">uint32_t</span> event, <span class="type">func_t</span> recv_cb, <span class="type">func_t</span> send_cb, <span class="type">func_t</span> except_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> std::string &amp;ip = <span class="string">&quot;0.0.0.0&quot;</span>, <span class="type">uint16_t</span> port = <span class="number">0</span>, <span class="type">bool</span> is_listensock = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Connection&gt; <span class="title">new_connect</span><span class="params">(<span class="keyword">new</span> Connection(sock))</span></span>;</span><br><span class="line">        new_connect-&gt;el = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        new_connect-&gt;recv_cb = recv_cb;</span><br><span class="line">        new_connect-&gt;send_cb = send_cb;</span><br><span class="line">        new_connect-&gt;except_cb = except_cb;</span><br><span class="line">        new_connect-&gt;ip_ = ip;</span><br><span class="line">        new_connect-&gt;port_ = port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!is_listensock) tm_-&gt;<span class="built_in">Push</span>(new_connect);</span><br><span class="line">        connections_[sock] = new_connect;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        epoller_-&gt;<span class="built_in">EpollCtl</span>(EPOLL_CTL_ADD, sock, event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recv</span><span class="params">(std::weak_ptr&lt;Connection&gt; connect)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> connection = connect.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> sock = connection-&gt;<span class="built_in">Sockfd</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buffer[n] = <span class="number">0</span>;</span><br><span class="line">                connection-&gt;<span class="built_in">AppendInBuffer</span>(buffer);</span><br><span class="line">                <span class="built_in">lg</span>(Debug, <span class="string">&quot;thread-%d, recv message from client: %s&quot;</span>, <span class="built_in">pthread_self</span>(),buffer);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;client [%s: %d] quit&quot;</span>, connection-&gt;ip_.<span class="built_in">c_str</span>(), connection-&gt;port_);</span><br><span class="line">                connection-&gt;<span class="built_in">except_cb</span>(connection);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EWOULDBLOCK) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(errno == EINTR) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">lg</span>(Error, <span class="string">&quot;recv from client [%s: %d] false&quot;</span>, connection-&gt;ip_.<span class="built_in">c_str</span>(), connection-&gt;port_);</span><br><span class="line">                    connection-&gt;<span class="built_in">except_cb</span>(connection);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(OnMessage_)</span><br><span class="line">        <span class="built_in">OnMessage_</span>(connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::weak_ptr&lt;Connection&gt; connect)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> connection = connect.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">        std::string &amp;outbuffer = connection-&gt;<span class="built_in">OutBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">send</span>(connection-&gt;<span class="built_in">Sockfd</span>(), outbuffer.<span class="built_in">c_str</span>(), outbuffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                outbuffer.<span class="built_in">erase</span>(<span class="number">0</span>, n);</span><br><span class="line">                <span class="keyword">if</span>(outbuffer.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EWOULDBLOCK) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(errno == EINTR) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">lg</span>(Error, <span class="string">&quot;send to client [%s: %d] false&quot;</span>, connection-&gt;ip_.<span class="built_in">c_str</span>(), connection-&gt;port_);</span><br><span class="line">                    connection-&gt;<span class="built_in">except_cb</span>(connection);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写缓冲满</span></span><br><span class="line">            <span class="keyword">if</span>(!outbuffer.<span class="built_in">empty</span>() &amp;&amp; !connection-&gt;write_care_)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 开启写时间关心</span></span><br><span class="line">                epoller_-&gt;<span class="built_in">EpollCtl</span>(EPOLL_CTL_MOD,connection-&gt;<span class="built_in">Sockfd</span>(), EPOLLIN | EPOLLOUT | EPOLLET);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(outbuffer.<span class="built_in">empty</span>() &amp;&amp; connection-&gt;write_care_)&#123;</span><br><span class="line">                <span class="comment">// 关闭写事件特别关心</span></span><br><span class="line">                epoller_-&gt;<span class="built_in">EpollCtl</span>(EPOLL_CTL_MOD,connection-&gt;<span class="built_in">Sockfd</span>(), EPOLLIN | EPOLLET);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Except</span><span class="params">(std::weak_ptr&lt;Connection&gt; connect)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> connection = connect.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fd = connection-&gt;<span class="built_in">Sockfd</span>();</span><br><span class="line">        <span class="built_in">lg</span>(Warning, <span class="string">&quot;client [%s: %d] handler exception&quot;</span>, connection-&gt;ip_.<span class="built_in">c_str</span>(), connection-&gt;port_);</span><br><span class="line"></span><br><span class="line">        epoller_-&gt;<span class="built_in">EpollCtl</span>(EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">lg</span>(Debug, <span class="string">&quot;client [%s: %d] close done&quot;</span>, connection-&gt;ip_.<span class="built_in">c_str</span>(), connection-&gt;port_);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        connections_.<span class="built_in">erase</span>(fd);</span><br><span class="line">        tm_-&gt;<span class="built_in">LazyDelete</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisPatcher</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = epoller_-&gt;<span class="built_in">EpollWait</span>(recvs, max_fd);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> events = recvs[i].events;</span><br><span class="line">            <span class="type">int</span> sockfd = recvs[i].data.fd;</span><br><span class="line">            <span class="comment">// 异常事件转化为读写问题处理</span></span><br><span class="line">            <span class="keyword">if</span>(events &amp; (EPOLLERR | EPOLLHUP)) events |= (EPOLLIN | EPOLLOUT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(events &amp; EPOLLIN &amp;&amp; connections_[sockfd]-&gt;recv_cb) &#123;</span><br><span class="line">                connections_[sockfd]-&gt;<span class="built_in">recv_cb</span>(connections_[sockfd]);</span><br><span class="line">                tm_-&gt;<span class="built_in">UpdateTime</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(events &amp; EPOLLOUT &amp;&amp; connections_[sockfd]-&gt;send_cb) &#123;</span><br><span class="line">                connections_[sockfd]-&gt;<span class="built_in">send_cb</span>(connections_[sockfd]);</span><br><span class="line">                tm_-&gt;<span class="built_in">UpdateTime</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Expired_check</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(tm_-&gt;<span class="built_in">IsTopExpired</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> top_time = tm_-&gt;<span class="built_in">GetTop</span>()-&gt;connect;</span><br><span class="line">            <span class="type">int</span> sockfd = top_time-&gt;<span class="built_in">Sockfd</span>();</span><br><span class="line">            <span class="comment">// 找不到说明是客户端主动释放的</span></span><br><span class="line">            <span class="keyword">if</span>(connections_.<span class="built_in">find</span>(sockfd) != connections_.<span class="built_in">end</span>())</span><br><span class="line">            connections_[sockfd]-&gt;<span class="built_in">except_cb</span>(top_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(TaskPush_) <span class="built_in">TaskPush_</span>(rq_, <span class="built_in">shared_from_this</span>());</span><br><span class="line">            <span class="built_in">DisPatcher</span>();</span><br><span class="line">            <span class="built_in">Expired_check</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;RingQueue&lt;ClientInf&gt;&gt; rq_;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::shared_ptr&lt;Connection&gt;&gt; connections_;</span><br><span class="line">    std::shared_ptr&lt;Epoll&gt; epoller_;</span><br><span class="line">    std::shared_ptr&lt;TimerManager&gt; tm_;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> recvs[max_fd];</span><br><span class="line">    <span class="type">func_t</span> OnMessage_;</span><br><span class="line">    <span class="type">task_t</span> TaskPush_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>    </div></div><p>而后，我们将之前的计算服务协议以及基于信号量的循环队列集成到该EventLoop中，形成一个完整的网络服务框架。</p><p>计算服务协议讲解链接跳转：<a href="https://liujiaxuan69.github.io/2025/07/31/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/protocol/">计算服务协议</a></p><p>基于信号量的环形队列讲解链接跳转：<a href="https://liujiaxuan69.github.io/2025/07/26/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_sem/">基于信号量的环形队列</a></p><p>下面我们将这些组合起来，就是实现了完整的Reactor模式的网络服务框架：</p><h3><span id="服务端主程序实现解析">服务端主程序实现解析</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;event_loop.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ring_queue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;listener.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_cal.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> default_thread_num = <span class="number">5</span>;  <span class="comment">// 默认工作线程数</span></span><br><span class="line"></span><br><span class="line">ServerCal sc;  <span class="comment">// 业务逻辑处理器实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 消息处理回调函数</span></span><br><span class="line"><span class="comment"> * @param wconnectiion 客户端连接弱引用</span></span><br><span class="line"><span class="comment"> * @note 处理客户端输入并返回计算结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageHandler</span><span class="params">(std::weak_ptr&lt;Connection&gt; wconnectiion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> connection = wconnectiion.<span class="built_in">lock</span>();</span><br><span class="line">    std::string &amp;inf = connection-&gt;<span class="built_in">Inbuffer</span>();  <span class="comment">// 获取输入缓冲区</span></span><br><span class="line">    std::string outinf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        outinf = sc.<span class="built_in">Calculator</span>(inf);  <span class="comment">// 调用业务逻辑处理</span></span><br><span class="line">        <span class="keyword">if</span> (outinf.<span class="built_in">empty</span>()) <span class="keyword">return</span>;   <span class="comment">// 无输出则结束</span></span><br><span class="line">        </span><br><span class="line">        connection-&gt;<span class="built_in">AppendOutBuffer</span>(outinf);  <span class="comment">// 写入输出缓冲区</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过EventLoop发送响应</span></span><br><span class="line">        <span class="keyword">auto</span> wsender = connection-&gt;el;</span><br><span class="line">        <span class="keyword">auto</span> sender = wsender.<span class="built_in">lock</span>();</span><br><span class="line">        sender-&gt;<span class="built_in">Send</span>(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务获取回调函数</span></span><br><span class="line"><span class="comment"> * @param wrq 环形队列弱引用</span></span><br><span class="line"><span class="comment"> * @param wel 事件循环弱引用</span></span><br><span class="line"><span class="comment"> * @note 从队列获取新连接并注册到EventLoop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskPush</span><span class="params">(std::weak_ptr&lt;RingQueue&lt;ClientInf&gt;&gt; wrq, std::weak_ptr&lt;EventLoop&gt; wel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> rq = wrq.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">auto</span> el = wel.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> client_inf = rq-&gt;<span class="built_in">Pop</span>()) &#123;  <span class="comment">// 从队列获取新连接</span></span><br><span class="line">        el-&gt;<span class="built_in">AddConnection</span>(</span><br><span class="line">            client_inf-&gt;sockfd, </span><br><span class="line">            EPOLLIN | EPOLLET,  <span class="comment">// 边缘触发模式</span></span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EventLoop::Recv, el, std::placeholders::_1),  <span class="comment">// 读回调</span></span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EventLoop::Send, el, std::placeholders::_1),  <span class="comment">// 写回调</span></span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EventLoop::Except, el, std::placeholders::_1), <span class="comment">// 异常回调</span></span><br><span class="line">            client_inf-&gt;client_ip, </span><br><span class="line">            client_inf-&gt;client_port</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 监听线程处理函数</span></span><br><span class="line"><span class="comment"> * @param rq 环形队列</span></span><br><span class="line"><span class="comment"> * @param port 监听端口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListenHandler</span><span class="params">(std::shared_ptr&lt;RingQueue&lt;ClientInf&gt;&gt; rq, <span class="type">uint16_t</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Listener&gt; <span class="title">lt</span><span class="params">(<span class="keyword">new</span> Listener(port))</span></span>;  <span class="comment">// 创建监听器</span></span><br><span class="line">    lt-&gt;<span class="built_in">Init</span>();  <span class="comment">// 初始化监听socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主EventLoop只负责监听</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;EventLoop&gt; <span class="title">baser</span><span class="params">(<span class="keyword">new</span> EventLoop(rq))</span></span>;</span><br><span class="line">    baser-&gt;<span class="built_in">AddConnection</span>(</span><br><span class="line">        lt-&gt;<span class="built_in">Fd</span>(), </span><br><span class="line">        EPOLLIN | EPOLLET, </span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;Listener::Accepter, lt, std::placeholders::_1),  <span class="comment">// 接受新连接</span></span><br><span class="line">        <span class="literal">nullptr</span>,  <span class="comment">// 无需写回调</span></span><br><span class="line">        <span class="literal">nullptr</span>,  <span class="comment">// 无需异常回调</span></span><br><span class="line">        <span class="string">&quot;0.0.0.0&quot;</span>, </span><br><span class="line">        <span class="number">0</span>, </span><br><span class="line">        <span class="literal">true</span>  <span class="comment">// 标记为监听socket</span></span><br><span class="line">    );</span><br><span class="line">    baser-&gt;<span class="built_in">Loop</span>();  <span class="comment">// 启动事件循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 工作线程处理函数</span></span><br><span class="line"><span class="comment"> * @param rq 环形队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventHandler</span><span class="params">(std::shared_ptr&lt;RingQueue&lt;ClientInf&gt;&gt; rq)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建工作EventLoop，设置消息处理和任务获取回调</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;EventLoop&gt; <span class="title">task_handler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> EventLoop(rq, MessageHandler, TaskPush)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    task_handler-&gt;<span class="built_in">Loop</span>();  <span class="comment">// 启动事件循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数处理</span></span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>) port = <span class="number">6667</span>;  <span class="comment">// 默认端口</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">2</span>) port = std::<span class="built_in">stoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; [port]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建环形队列</span></span><br><span class="line">    std::shared_ptr&lt;RingQueue&lt;ClientInf&gt;&gt; <span class="built_in">rq</span>(<span class="keyword">new</span> RingQueue&lt;ClientInf&gt;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动监听线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">base_thread</span><span class="params">(ListenHandler, rq, port)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建工作线程池</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; default_thread_num; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(std::<span class="built_in">thread</span>(EventHandler, rq));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    base_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="核心架构说明">核心架构说明</span></h3><ol><li><p><strong>线程分工</strong>：</p><ul><li><strong>监听线程</strong>：专门处理新连接接入，通过<code>Listener</code>将连接信息放入环形队列</li><li><strong>工作线程</strong>：从队列获取连接，通过<code>EventLoop</code>处理具体业务</li></ul></li><li><p><strong>回调机制</strong>：</p><ul><li><code>MessageHandler</code>：处理客户端请求并返回计算结果</li><li><code>TaskPush</code>：将新连接注册到工作线程的EventLoop</li></ul></li><li><p><strong>关键组件</strong>：</p><ul><li><code>RingQueue</code>：线程安全的环形队列，连接监听线程和工作线程</li><li><code>EventLoop</code>：事件驱动核心，每个工作线程独立实例</li><li><code>Listener</code>：封装监听socket处理</li></ul></li><li><p><strong>业务处理</strong>：</p><ul><li>通过<code>ServerCal</code>类实现具体业务逻辑</li><li>计算结果通过<code>EventLoop::Send</code>返回客户端</li></ul></li></ol><p>详细代码链接请查看：<a href="https://github.com/LiuJiaxuan69/Reactor">完整代码</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> IO </tag>
            
            <tag> Reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux IO 多路转接--Epoll</title>
      <link href="/2025/08/02/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/Epoll/"/>
      <url>/2025/08/02/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/Epoll/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#epoll-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3">epoll 工作原理详解</a><ul><li><a href="#epoll-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">epoll 的核心数据结构</a></li><li><a href="#epoll-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">epoll 的工作流程</a></li><li><a href="#%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8A%BF">关键设计优势</a></li><li><a href="#%E5%AF%B9%E6%AF%94-selectpoll">对比 select&#x2F;poll</a></li><li><a href="#%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91et-vs-%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91lt">边缘触发（ET） vs 水平触发（LT）</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#epoll-%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">Epoll 接口介绍</a><ul><li><a href="#epoll_create-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><code>epoll_create</code> 函数详解</a></li><li><a href="#epoll_ctl-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><code>epoll_ctl</code> 函数详解</a></li><li><a href="#epoll_wait-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><code>epoll_wait</code> 函数详解</a></li><li><a href="#%E5%9F%BA%E4%BA%8E-epoll-%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0">基于 <code>epoll</code> 的多人聊天服务器实现</a></li></ul></li></ul><!-- tocstop --><h2><span id="epoll-工作原理详解">epoll 工作原理详解</span></h2><p>epoll 是 Linux 高效 I&#x2F;O 多路复用的核心机制，其设计通过 <strong>红黑树 + 就绪链表</strong> 实现高性能事件管理。以下是其核心工作原理：</p><hr><h3><span id="epoll-的核心数据结构">epoll 的核心数据结构</span></h3><p><strong>(1) <code>eventpoll</code> 结构体（epoll 实例）</strong></p><p>每个 <code>epoll</code> 实例（由 <code>epoll_create</code> 创建）对应一个 <code>eventpoll</code> 结构体，包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span>      <span class="comment">// 红黑树根节点（存储所有监控的 fd）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span>   <span class="comment">// 就绪链表（存放已触发的事件）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>红黑树 (<code>rbr</code>)</strong>：存储所有通过 <code>epoll_ctl</code> 注册的文件描述符（<code>fd</code>），以 <code>epitem</code> 为节点。</li><li><strong>就绪链表 (<code>rdlist</code>)</strong>：存放所有已触发事件的 <code>epitem</code>。</li></ul><p><strong>(2) <code>epitem</code> 结构体（事件项）</strong></p><p>每个被监控的 <code>fd</code> 对应一个 <code>epitem</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>    <span class="title">rbn</span>;</span>      <span class="comment">// 红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">rdllink</span>;</span>  <span class="comment">// 就绪链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span>    <span class="comment">// 关联的 fd 信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>  *<span class="title">ep</span>;</span>      <span class="comment">// 所属的 epoll 实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span>   <span class="comment">// 监控的事件类型（如 EPOLLIN）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3><span id="epoll-的工作流程">epoll 的工作流程</span></h3><p><strong>步骤 1：创建 epoll 实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>内核创建 <code>eventpoll</code> 结构体，初始化红黑树 (<code>rbr</code>) 和就绪链表 (<code>rdlist</code>)。</li></ul><p><strong>步骤 2：注册监控事件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br></pre></td></tr></table></figure><ol><li>将 <code>fd</code> 封装为 <code>epitem</code> 节点。</li><li>将 <code>epitem</code> 插入红黑树（<code>rbr</code>）。</li><li>内核为 <code>fd</code> 注册回调函数 <code>ep_poll_callback</code>，当 <code>fd</code> 有事件发生时，该回调会被触发。</li></ol><p><strong>步骤 3：事件触发与回调</strong></p><ul><li>当 <code>fd</code> 发生事件（如数据到达），内核调用 <code>ep_poll_callback</code>：<ol><li>将对应的 <code>epitem</code> 从红黑树移到就绪链表 (<code>rdlist</code>)。</li><li>唤醒阻塞在 <code>epoll_wait</code> 的进程。</li></ol></li></ul><p><strong>步骤 4：获取就绪事件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epoll_wait(epfd, events, maxevents, timeout);</span><br></pre></td></tr></table></figure><ol><li>检查就绪链表 (<code>rdlist</code>)：<ul><li>若不为空，将事件拷贝到用户空间。</li><li>若为空，进程阻塞等待。</li></ul></li><li>返回就绪事件的数量。</li></ol><hr><h3><span id="关键设计优势">关键设计优势</span></h3><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th><th><strong>时间复杂度</strong></th></tr></thead><tbody><tr><td><strong>红黑树 (<code>rbr</code>)</strong></td><td>存储所有监控的 <code>fd</code>，支持快速查找、插入、删除</td><td>O(log n)</td></tr><tr><td><strong>就绪链表 (<code>rdlist</code>)</strong></td><td>存放已触发的事件，<code>epoll_wait</code> 直接读取此链表</td><td>O(1)</td></tr><tr><td><strong>回调机制</strong></td><td>事件发生时通过回调函数 <code>ep_poll_callback</code> 将 <code>epitem</code> 加入就绪链表，避免轮询</td><td>O(1)</td></tr></tbody></table><p>为什么高效呢？</p><ol><li><p><strong>红黑树管理监控的 fd</strong>  </p><ul><li>插入&#x2F;删除&#x2F;查找的时间复杂度为 O(log n)，适合管理大量 fd。</li><li>自动去重（重复添加的 fd 会被识别）。</li></ul></li><li><p><strong>就绪链表直接返回事件</strong>  </p><ul><li><code>epoll_wait</code> 只需检查链表是否为空，无需遍历所有 fd。</li></ul></li><li><p><strong>回调驱动</strong>  </p><ul><li>事件发生时立即通知，无需轮询所有 fd（对比 <code>select</code>&#x2F;<code>poll</code> 的 O(n) 复杂度）。</li></ul></li></ol><hr><h3><span id="对比-selectx2fpoll">对比 select&#x2F;poll</span></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>select&#x2F;poll</strong></th><th><strong>epoll</strong></th></tr></thead><tbody><tr><td><strong>监控 fd 数量</strong></td><td>有限制（如 1024）</td><td>无限制（仅受系统内存限制）</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(n)（每次遍历所有 fd）</td><td>O(1)（仅处理就绪事件）</td></tr><tr><td><strong>fd 管理方式</strong></td><td>每次调用需重新传入 fd 列表</td><td>内核维护红黑树，只需增量操作</td></tr><tr><td><strong>适用场景</strong></td><td>低并发、fd 数量少</td><td>高并发（如 Nginx、Redis）</td></tr></tbody></table><hr><h3><span id="边缘触发et-vs-水平触发lt">边缘触发（ET） vs 水平触发（LT）</span></h3><ul><li><p><strong>ET 模式</strong>：<br>事件仅触发一次，需非阻塞 I&#x2F;O + 循环读&#x2F;写，避免数据残留。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ev.events = EPOLLIN | EPOLLET;  <span class="comment">// 边缘触发</span></span><br></pre></td></tr></table></figure></li><li><p><strong>LT 模式</strong>：<br>只要条件满足（如缓冲区有数据），会持续触发事件（默认模式）。</p></li></ul><hr><h3><span id="总结">总结</span></h3><ol><li><strong>epoll 通过红黑树 + 就绪链表实现高效事件管理</strong>。</li><li><strong>回调机制避免轮询</strong>，适合高并发场景。</li><li><strong>ET 模式性能更高</strong>，但需正确处理数据。</li><li><strong>核心操作</strong>：<ul><li><code>epoll_create</code>：创建实例。</li><li><code>epoll_ctl</code>：管理监控的 fd。</li><li><code>epoll_wait</code>：获取就绪事件。</li></ul></li></ol><h2><span id="epoll-接口介绍">Epoll 接口介绍</span></h2><h3><span id="epoll_create-函数详解"><code>epoll_create</code> 函数详解</span></h3><p><code>epoll_create</code> 是 Linux 系统提供的 <strong>I&#x2F;O 多路复用</strong> 机制的核心函数之一，用于创建一个 <strong><code>epoll</code> 实例</strong>（即 <code>epoll</code> 文件描述符），后续可以通过 <code>epoll_ctl</code> 和 <code>epoll_wait</code> 管理并监控多个文件描述符（如 socket）的 I&#x2F;O 事件。</p><hr><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;  <span class="comment">// Linux 2.6.8 之前需要指定 size</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;  <span class="comment">// 更现代的版本</span></span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><ul><li><p><strong><code>size</code></strong> (已废弃，但需 &gt; 0)<br>早期内核用此参数预估监控的文件描述符数量，但自 Linux 2.6.8 起，内核会动态调整大小，此参数仅需传递一个大于 0 的值（通常填 1）。</p></li><li><p><strong><code>flags</code></strong> (仅 <code>epoll_create1</code>)<br>可选标志位：</p><ul><li><code>0</code>：默认行为（同 <code>epoll_create</code>）。</li><li><code>EPOLL_CLOEXEC</code>：设置文件描述符的 <code>close-on-exec</code> 标志（进程执行 <code>exec</code> 时自动关闭 <code>epoll</code> 实例）。</li></ul></li></ul><hr><h4><span id="返回值">返回值</span></h4><ul><li><strong>成功</strong>：返回一个 <strong><code>epoll</code> 文件描述符</strong>（非负整数），后续通过此 fd 操作 <code>epoll</code> 实例。</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code>（如 <code>EMFILE</code> 表示进程打开的文件描述符已达上限）。</li></ul><hr><h4><span id="核心作用">核心作用</span></h4><ol><li><p><strong>创建 <code>epoll</code> 实例</strong><br>内核会分配一个事件表（红黑树 + 就绪链表），用于存储和管理待监控的文件描述符。</p></li><li><p><strong>返回文件描述符</strong><br>该 fd 用于后续的 <code>epoll_ctl</code>（增删改监控事件）和 <code>epoll_wait</code>（等待事件触发）。</p></li></ol><hr><h4><span id="使用示例">使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);  <span class="comment">// 创建 epoll 实例</span></span><br><span class="line"><span class="keyword">if</span> (epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续通过 epoll_ctl 添加监控的 fd</span></span><br><span class="line"><span class="comment">// 通过 epoll_wait 等待事件</span></span><br></pre></td></tr></table></figure><hr><h4><span id="注意事项">注意事项</span></h4><ol><li><p><strong><code>size</code> 参数已过时</strong><br>在较新内核中，<code>size</code> 仅需传递一个正整数（如 1），实际监控数量由内核动态管理。</p></li><li><p><strong>务必关闭 <code>epoll</code> 实例</strong><br>使用完毕后应调用 <code>close(epfd)</code> 释放资源，否则会导致文件描述符泄漏。</p></li><li><p><strong>优先使用 <code>epoll_create1</code></strong>  </p><ul><li><code>epoll_create1(0)</code> 等价于 <code>epoll_create(1)</code>。  </li><li><code>epoll_create1(EPOLL_CLOEXEC)</code> 可避免 <code>exec</code> 后的 fd 泄漏。</li></ul></li><li><p><strong>性能优势</strong><br><code>epoll</code> 比 <code>select</code>&#x2F;<code>poll</code> 更高效，尤其适合高并发场景（如 Web 服务器）。</p></li></ol><hr><h4><span id="常见问题">常见问题</span></h4><p><strong>Q1: 为什么 <code>epoll_create</code> 的 <code>size</code> 参数不再有用？</strong></p><ul><li>早期内核用 <code>size</code> 预分配空间，但现代内核改为动态调整，只需传递一个合法值（如 1）。</li></ul><p><strong>Q2: <code>epoll_create</code> 和 <code>epoll_create1</code> 的区别？</strong></p><ul><li><code>epoll_create1</code> 支持 <code>EPOLL_CLOEXEC</code> 标志，更安全且符合现代编程习惯。</li></ul><p><strong>Q3: <code>epoll</code> 实例的数量限制？</strong></p><ul><li>受系统全局限制（<code>/proc/sys/fs/epoll/max_user_instances</code>），默认通常足够大。</li></ul><p>在 <code>Debian</code> 中文件名叫 <code>max_user_watches</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/web_io/Epoll</span><br><span class="line">╰─➤  cat /proc/sys/fs/epoll/max_user_watches</span><br><span class="line">408820</span><br></pre></td></tr></table></figure><hr><h4><span id="总结">总结</span></h4><table><thead><tr><th><strong>关键点</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>函数作用</strong></td><td>创建 <code>epoll</code> 实例，用于高效监控大量文件描述符的 I&#x2F;O 事件。</td></tr><tr><td><strong>推荐函数</strong></td><td>优先使用 <code>epoll_create1(0)</code> 或 <code>epoll_create1(EPOLL_CLOEXEC)</code>。</td></tr><tr><td><strong>返回值</strong></td><td>成功返回 <code>epoll</code> 文件描述符，失败返回 <code>-1</code>。</td></tr><tr><td><strong>后续操作</strong></td><td>通过 <code>epoll_ctl</code> 管理监控列表，<code>epoll_wait</code> 等待事件。</td></tr><tr><td><strong>资源释放</strong></td><td>必须调用 <code>close(epfd)</code> 关闭 <code>epoll</code> 实例。</td></tr></tbody></table><h3><span id="epoll_ctl-函数详解"><code>epoll_ctl</code> 函数详解</span></h3><p><code>epoll_ctl</code> 是 Linux <strong>epoll 机制</strong>的核心函数之一，用于 <strong>管理 <code>epoll</code> 实例监控的文件描述符（fd）</strong>。它负责向 <code>epoll</code> 实例 <strong>添加、修改或删除</strong> 需要监控的 fd 及其关注的事件（如可读、可写、异常等）。</p><hr><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th><strong>参数</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>epfd</code></td><td><code>int</code></td><td><code>epoll</code> 实例的文件描述符（由 <code>epoll_create</code> 创建）</td></tr><tr><td><code>op</code></td><td><code>int</code></td><td>操作类型：<br>• <code>EPOLL_CTL_ADD</code>（添加 fd）<br>• <code>EPOLL_CTL_MOD</code>（修改 fd）<br>• <code>EPOLL_CTL_DEL</code>（删除 fd）</td></tr><tr><td><code>fd</code></td><td><code>int</code></td><td>需要监控的目标文件描述符（如 socket fd）</td></tr><tr><td><code>event</code></td><td><code>struct epoll_event*</code></td><td>监控的事件配置（<code>EPOLL_CTL_DEL</code> 时可设为 <code>NULL</code>）</td></tr></tbody></table><h4><span id="struct-epoll_event-结构体"><code>struct epoll_event</code> 结构体</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;  <span class="comment">// 监控的事件类型（如 EPOLLIN、EPOLLOUT）</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;    <span class="comment">// 用户数据（通常用于存储 fd 或回调信息）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>    *ptr;</span><br><span class="line">    <span class="type">int</span>      fd;         <span class="comment">// 常用：关联的文件描述符</span></span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><hr><h4><span id="事件类型events-字段">事件类型（<code>events</code> 字段）</span></h4><p><code>events</code> 是一个位掩码，常用标志包括：</p><table><thead><tr><th><strong>事件类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>EPOLLIN</code></td><td>监控 fd 是否可读（有数据到达）</td></tr><tr><td><code>EPOLLOUT</code></td><td>监控 fd 是否可写（发送缓冲区空闲）</td></tr><tr><td><code>EPOLLERR</code></td><td>监控 fd 是否发生错误（默认自动监控，无需显式设置）</td></tr><tr><td><code>EPOLLHUP</code></td><td>监控 fd 是否被挂断（如对端关闭连接）</td></tr><tr><td><code>EPOLLET</code></td><td>设置为边缘触发（Edge-Triggered）模式（默认是水平触发 LT）</td></tr><tr><td><code>EPOLLONESHOT</code></td><td>事件触发后自动从监控列表中移除（需重新 <code>EPOLL_CTL_MOD</code> 才能再次监控）</td></tr></tbody></table><hr><h4><span id="返回值">返回值</span></h4><ul><li><strong>成功</strong>：返回 <code>0</code>。</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code>，常见错误：<ul><li><code>EBADF</code>：<code>epfd</code> 或 <code>fd</code> 是无效文件描述符。</li><li><code>EEXIST</code>：<code>EPOLL_CTL_ADD</code> 时 <code>fd</code> 已存在。</li><li><code>ENOENT</code>：<code>EPOLL_CTL_MOD</code> 或 <code>EPOLL_CTL_DEL</code> 时 <code>fd</code> 未注册。</li></ul></li></ul><hr><h4><span id="使用示例">使用示例</span></h4><p>(1) 添加监控的 socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);  <span class="comment">// 创建 epoll 实例</span></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建 socket</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLET;  <span class="comment">// 监控可读事件 + 边缘触发</span></span><br><span class="line">ev.data.fd = sockfd;            <span class="comment">// 保存 socket fd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 修改监控事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ev.events = EPOLLIN | EPOLLOUT;  <span class="comment">// 增加监控可写事件</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev);</span><br></pre></td></tr></table></figure><p>(3) 删除监控的 fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);  <span class="comment">// event 参数可忽略</span></span><br></pre></td></tr></table></figure><hr><h4><span id="关键机制">关键机制</span></h4><ol><li><p><strong>高效的事件管理</strong><br><code>epoll_ctl</code> 通过内核维护的红黑树管理监控的 fd，插入&#x2F;删除&#x2F;查找的时间复杂度为 O(log n)。</p></li><li><p><strong>边缘触发（ET） vs 水平触发（LT）</strong>  </p><ul><li><strong>ET 模式</strong>（<code>EPOLLET</code>）：事件仅在状态变化时触发一次，需非阻塞 I&#x2F;O + 循环读&#x2F;写。</li><li><strong>LT 模式</strong>（默认）：只要条件满足（如缓冲区有数据），会持续触发事件。</li></ul></li><li><p><strong><code>epoll_data</code> 的用途</strong><br>可通过 <code>data.fd</code> 或 <code>data.ptr</code> 在事件触发时快速定位关联对象（如 socket 或回调函数）。</p></li></ol><hr><h4><span id="完整工作流程">完整工作流程</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. epoll_create()   → 创建 epoll 实例</span><br><span class="line">2. epoll_ctl()      → 添加/修改/删除监控的 fd</span><br><span class="line">3. epoll_wait()     → 阻塞等待事件就绪</span><br><span class="line">4. 处理事件          → 根据 event.data 找到对应 fd 处理 I/O</span><br><span class="line">5. 循环 2-4         → 持续监控</span><br></pre></td></tr></table></figure><hr><h4><span id="常见问题">常见问题</span></h4><p>Q1: 为什么 <code>EPOLLERR</code> 和 <code>EPOLLHUP</code> 无需显式设置？ </p><ul><li>内核会自动监控这些事件，即使未设置，<code>epoll_wait</code> 也会返回它们。</li></ul><p>Q2: <code>EPOLLONESHOT</code> 的作用？</p><ul><li>确保事件只触发一次（如避免多线程同时处理同一个 fd），需重新 <code>EPOLL_CTL_MOD</code> 后才能再次触发。</li></ul><p>Q3: 如何监控多个事件？</p><ul><li>用位或操作组合：<code>ev.events = EPOLLIN | EPOLLOUT | EPOLLET;</code>。</li></ul><hr><h4><span id="总结">总结</span></h4><table><thead><tr><th><strong>操作</strong></th><th><strong>函数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>创建 epoll 实例</td><td><code>epoll_create1</code></td><td>初始化事件监控表</td></tr><tr><td>管理监控的 fd</td><td><code>epoll_ctl</code></td><td>增删改 fd 及其关注的事件</td></tr><tr><td>等待事件</td><td><code>epoll_wait</code></td><td>获取就绪的 fd 列表</td></tr></tbody></table><h3><span id="epoll_wait-函数详解"><code>epoll_wait</code> 函数详解</span></h3><p><code>epoll_wait</code> 是 Linux <strong>epoll 机制</strong>的核心函数，用于 <strong>阻塞等待并获取 I&#x2F;O 就绪的事件</strong>。它是实现高并发事件驱动的关键，相比 <code>select</code>&#x2F;<code>poll</code> 具有更高的效率。</p><hr><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd,                      <span class="comment">// epoll 实例的文件描述符</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events,     <span class="comment">// 存放就绪事件的数组</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents,                  <span class="comment">// 每次最多返回的事件数量</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout                     <span class="comment">// 超时时间（毫秒）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th><strong>参数</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>epfd</code></td><td><code>int</code></td><td><code>epoll</code> 实例的文件描述符（由 <code>epoll_create</code> 创建）</td></tr><tr><td><code>events</code></td><td><code>struct epoll_event*</code></td><td><strong>输出参数</strong>，用于存储就绪事件的数组</td></tr><tr><td><code>maxevents</code></td><td><code>int</code></td><td>每次调用最多返回的事件数量（必须 ≤ <code>events</code> 数组的大小）</td></tr><tr><td><code>timeout</code></td><td><code>int</code></td><td>超时时间（毫秒）：<br>• <code>-1</code>：无限阻塞<br>• <code>0</code>：立即返回（非阻塞）<br>• <code>&gt;0</code>：指定超时时间</td></tr></tbody></table><h4><span id="返回值">返回值</span></h4><ul><li><strong>成功</strong>：返回就绪事件的数量（≥0）。</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code>（如 <code>EINTR</code> 表示被信号中断）。</li></ul><hr><h4><span id="核心工作原理">核心工作原理</span></h4><p><code>epoll_wait</code> 的工作流程如下：</p><p>(1) 检查就绪链表</p><ul><li>内核首先检查 <code>eventpoll</code> 结构体中的 <strong>就绪链表 (<code>rdlist</code>)</strong>。<ul><li>如果链表 <strong>非空</strong>，说明有事件已触发，直接将这些事件拷贝到用户空间的 <code>events</code> 数组。</li><li>如果链表 <strong>为空</strong>，则根据 <code>timeout</code> 决定是否阻塞等待。</li></ul></li></ul><p>(2) 阻塞与唤醒</p><ul><li><p><strong>阻塞</strong>：若就绪链表为空，且 <code>timeout != 0</code>，当前线程&#x2F;进程会被阻塞，直到：</p><ul><li>有事件触发（通过回调函数 <code>ep_poll_callback</code> 将事件加入 <code>rdlist</code>）。</li><li>超时时间到达。</li><li>被信号中断（返回 <code>EINTR</code>）。</li></ul></li><li><p><strong>唤醒</strong>：当监控的 <code>fd</code> 发生事件时，内核调用 <code>ep_poll_callback</code>：</p><ol><li>将对应的 <code>epitem</code> 从红黑树移到 <code>rdlist</code>。</li><li>唤醒阻塞在 <code>epoll_wait</code> 的线程&#x2F;进程。</li></ol></li></ul><p>(3) 返回就绪事件</p><ul><li>将 <code>rdlist</code> 中的事件拷贝到 <code>events</code> 数组，并返回就绪事件的数量。</li><li><strong>时间复杂度</strong>：O(1)（直接遍历就绪链表，无需扫描所有监控的 <code>fd</code>）。</li></ul><hr><h4><span id="使用示例">使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);  <span class="comment">// 创建 epoll 实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[10];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加监控的 fd（示例为标准输入）</span></span><br><span class="line">    ev.events = EPOLLIN;  <span class="comment">// 监控可读事件</span></span><br><span class="line">    ev.data.fd = STDIN_FILENO;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待事件（阻塞直到有输入）</span></span><br><span class="line">        <span class="type">int</span> n = epoll_wait(epfd, events, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理就绪事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Input: %s&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4><span id="关键特性">关键特性</span></h4><p>(1) 高效的事件获取</p><ul><li><strong>直接访问就绪链表</strong>：无需遍历所有监控的 <code>fd</code>（对比 <code>select</code>&#x2F;<code>poll</code> 的 O(n) 复杂度）。</li><li><strong>零拷贝</strong>：内核将就绪事件从 <code>rdlist</code> 直接拷贝到用户空间。</li></ul><p>(2) 支持高并发</p><ul><li>仅处理实际触发的事件，适合管理 <strong>数十万并发连接</strong>（如 Nginx、Redis）。</li></ul><p>(3) 触发模式</p><ul><li><strong>水平触发（LT，默认）</strong>：<br>只要 <code>fd</code> 满足就绪条件（如缓冲区有数据），<code>epoll_wait</code> 会持续返回该事件。</li><li><strong>边缘触发（ET）</strong>：<br>仅在 <code>fd</code> 状态变化时触发一次，需配合非阻塞 I&#x2F;O 循环读&#x2F;写。</li></ul><hr><h4><span id="常见问题">常见问题</span></h4><p><strong>Q1: <code>epoll_wait</code> 和 <code>select</code>&#x2F;<code>poll</code> 的区别？</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><code>select</code>&#x2F;<code>poll</code></th><th><code>epoll_wait</code></th></tr></thead><tbody><tr><td><strong>时间复杂度</strong></td><td>O(n)（遍历所有 fd）</td><td>O(1)（仅处理就绪事件）</td></tr><tr><td><strong>fd 数量限制</strong></td><td>有限制（如 1024）</td><td>无限制（受系统内存约束）</td></tr><tr><td><strong>效率</strong></td><td>低（每次需重新传入 fd 集合）</td><td>高（内核维护监控列表）</td></tr></tbody></table><p><strong>Q2: 为什么 <code>epoll_wait</code> 需要指定 <code>maxevents</code>？</strong></p><ul><li>防止用户空间 <code>events</code> 数组溢出（内核最多返回 <code>maxevents</code> 个事件）。</li></ul><p><strong>Q3: 如何实现非阻塞调用？</strong></p><ul><li>设置 <code>timeout = 0</code>，此时 <code>epoll_wait</code> 会立即返回（无论是否有事件）。</li></ul><hr><h4><span id="总结">总结</span></h4><table><thead><tr><th><strong>关键点</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>等待并返回就绪的 I&#x2F;O 事件</td></tr><tr><td><strong>高效原因</strong></td><td>基于就绪链表（O(1) 时间复杂度），无需轮询</td></tr><tr><td><strong>触发模式</strong></td><td>水平触发（LT，默认）或边缘触发（ET）</td></tr><tr><td><strong>超时控制</strong></td><td><code>-1</code>（阻塞）、<code>0</code>（非阻塞）、<code>&gt;0</code>（毫秒超时）</td></tr><tr><td><strong>适用场景</strong></td><td>高并发服务器（如 Nginx、Redis）</td></tr></tbody></table><h3><span id="基于-epoll-的多人聊天服务器实现">基于 <code>epoll</code> 的多人聊天服务器实现</span></h3><p>和基于 <code>poll</code> 的实现大多相同，但在服务端的是线上有本质区别，前者需要自己管理客户端对应的 <code>fd</code>，而后者则不需要。</p><p>首先我们封装一下 <code>Epoll</code> 接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _EPOLL_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EPOLL_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span>  <span class="comment">// epoll相关系统调用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nocopy.hpp&quot;</span>   <span class="comment">// 禁止拷贝的基类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>      <span class="comment">// 日志模块</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的epoll_wait超时时间（毫秒）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">int</span> default_time_out = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码枚举</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    epoll_create_error = <span class="number">1</span>,  <span class="comment">// epoll创建失败的错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Epoll事件管理类（继承nocopy禁止拷贝）</span></span><br><span class="line"><span class="comment"> * @note 封装epoll_create/epoll_ctl/epoll_wait操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoll</span>: <span class="keyword">public</span> nocopy  <span class="comment">// 禁止拷贝构造和赋值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数：创建epoll实例</span></span><br><span class="line"><span class="comment">     * @note 失败时直接退出程序（严重错误）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Epoll</span>()</span><br><span class="line">    : <span class="built_in">timeout</span>(default_time_out)  <span class="comment">// 初始化超时时间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建epoll实例（参数0表示默认行为）</span></span><br><span class="line">        epfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">lg</span>(Error, <span class="string">&quot;epoll_create false, errno: %d, errstr: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">exit</span>(epoll_create_error);  <span class="comment">// 创建失败直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;epoll create success, epoll fd: %d&quot;</span>, epfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 等待就绪事件</span></span><br><span class="line"><span class="comment">     * @param events 输出参数，存放就绪事件的数组</span></span><br><span class="line"><span class="comment">     * @param num 数组的最大容量</span></span><br><span class="line"><span class="comment">     * @return 就绪事件的数量（失败返回-1）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">EpollWait</span><span class="params">(<span class="keyword">struct</span> epoll_event events[], <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(epfd, events, num, timeout);  <span class="comment">// 阻塞等待事件</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">lg</span>(Error, <span class="string">&quot;epoll_wait false, errno: %d, errstr: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;  <span class="comment">// 返回就绪事件数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 控制epoll监控的文件描述符</span></span><br><span class="line"><span class="comment">     * @param op 操作类型（EPOLL_CTL_ADD/MOD/DEL）</span></span><br><span class="line"><span class="comment">     * @param fd 目标文件描述符</span></span><br><span class="line"><span class="comment">     * @param event 监控的事件标志（EPOLLIN/EPOLLOUT等）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EpollCtl</span><span class="params">(<span class="type">int</span> op, <span class="type">int</span> fd, <span class="type">uint32_t</span> event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(op == EPOLL_CTL_DEL) &#123;</span><br><span class="line">            <span class="comment">// 删除操作不需要event参数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, op, fd, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;epoll control false, errno: %d, errstr: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加/修改操作需要设置event</span></span><br><span class="line">            <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">            ev.data.fd = fd;    <span class="comment">// 保存fd到用户数据字段</span></span><br><span class="line">            ev.events = event;  <span class="comment">// 设置监控的事件类型</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epfd, op, fd, &amp;ev)) &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;epoll control false, errno: %d, errstr: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数：关闭epoll实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~<span class="built_in">Epoll</span>() &#123;</span><br><span class="line">        <span class="built_in">close</span>(epfd);  <span class="comment">// 释放epoll文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epfd;      <span class="comment">// epoll实例的文件描述符</span></span><br><span class="line">    <span class="type">int</span> timeout;   <span class="comment">// epoll_wait的超时时间（毫秒）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>设计说明</strong></p><ol><li><p><strong>禁止拷贝（继承nocopy）</strong>  </p><ul><li>通过继承禁止拷贝构造和赋值，避免多个对象管理同一个epoll实例导致资源冲突。</li></ul></li><li><p><strong>RAII管理资源</strong>  </p><ul><li>构造函数创建epoll实例，析构函数自动关闭，避免资源泄漏。</li></ul></li><li><p><strong>错误处理</strong>  </p><ul><li>关键操作（如<code>epoll_create1</code>）失败时直接退出，非关键操作（如<code>epoll_ctl</code>）仅记录错误。</li></ul></li><li><p><strong>接口封装</strong>  </p><ul><li><code>EpollWait</code>：封装<code>epoll_wait</code>，返回就绪事件数。</li><li><code>EpollCtl</code>：统一处理<code>EPOLL_CTL_ADD/MOD/DEL</code>操作，简化调用。</li></ul></li></ol><p>利用这份包装，我们就可以非常方便地实现基于 <code>epoll</code> 的服务器了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _POLL_SERVER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POLL_SERVER_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span>  <span class="comment">// 用于存储客户端信息的哈希表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span>        <span class="comment">// TCP基础操作封装</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoll.hpp&quot;</span>      <span class="comment">// Epoll封装类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">size_t</span> max_fd_sz = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;  <span class="comment">// 最大文件描述符数量（1024）</span></span><br><span class="line"><span class="type">const</span> <span class="type">u_int16_t</span> default_port = <span class="number">8888</span>;         <span class="comment">// 默认服务端口</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> default_fd = <span class="number">-1</span>;                   <span class="comment">// 无效文件描述符标识</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> none_event = <span class="number">0</span>;                    <span class="comment">// 无事件标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端信息结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_inf</span> &#123;</span><br><span class="line">    std::string client_addr;  <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="type">u_int16_t</span> client_port;    <span class="comment">// 客户端端口号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于Epoll的TCP服务器类</span></span><br><span class="line"><span class="comment"> * @note 使用Epoll实现高并发事件处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EpollServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     * @param port 服务器监听端口（默认8888）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">EpollServer</span>(<span class="type">u_int16_t</span> port = default_port)</span><br><span class="line">        : <span class="built_in">port_</span>(port)  <span class="comment">// 初始化端口</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 初始化服务器</span></span><br><span class="line"><span class="comment">     * @note 创建监听socket并加入epoll监控</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建监听socket</span></span><br><span class="line">        listen_sockfd = tcp::<span class="built_in">Socket</span>();</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;listening sock create success, sockfd: %d&quot;</span>, listen_sockfd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 绑定端口</span></span><br><span class="line">        tcp::<span class="built_in">Bind</span>(listen_sockfd, port_);</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;listening sock bind success&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 开始监听</span></span><br><span class="line">        tcp::<span class="built_in">Listen</span>(listen_sockfd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 将监听socket加入epoll监控（关注可读事件）</span></span><br><span class="line">        ep.<span class="built_in">EpollCtl</span>(EPOLL_CTL_ADD, listen_sockfd, EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 启动服务器主循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待事件（recvs数组用于接收就绪事件）</span></span><br><span class="line">            <span class="type">int</span> n = ep.<span class="built_in">EpollWait</span>(recvs, max_fd_sz);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;None client join and no client send message&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;Get a new link&quot;</span>);</span><br><span class="line">                <span class="built_in">Dispatcher</span>(n);  <span class="comment">// 处理就绪事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 事件分发器</span></span><br><span class="line"><span class="comment">     * @param size 就绪事件数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> events = recvs[i].events;</span><br><span class="line">            <span class="type">int</span> fd = recvs[i].data.fd;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (events &amp; EPOLLIN) &#123;  <span class="comment">// 可读事件</span></span><br><span class="line">                <span class="keyword">if</span> (fd == listen_sockfd) &#123;</span><br><span class="line">                    <span class="built_in">Accept</span>(size);  <span class="comment">// 处理新连接</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">Recv</span>(i);      <span class="comment">// 处理客户端数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 接受新客户端连接</span></span><br><span class="line"><span class="comment">     * @param size 当前就绪事件数量（未使用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接受新连接</span></span><br><span class="line">        <span class="type">int</span> client_sockfd = <span class="built_in">accept</span>(listen_sockfd, (sockaddr *)&amp;client, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">lg</span>(Error, <span class="string">&quot;listening sock accept false, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取客户端地址信息</span></span><br><span class="line">        std::string client_addr;</span><br><span class="line">        <span class="type">u_int16_t</span> client_port;</span><br><span class="line">        tcp::<span class="built_in">GetAddrAndPort</span>(client, client_addr, client_port);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 存储客户端信息</span></span><br><span class="line">        clients[client_sockfd] = client_inf&#123;</span><br><span class="line">            client_addr: client_addr,</span><br><span class="line">            client_port: client_port</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;accept a new client [%s: %d]&quot;</span>, client_addr.<span class="built_in">c_str</span>(), client_port);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将新socket加入epoll监控</span></span><br><span class="line">        ep.<span class="built_in">EpollCtl</span>(EPOLL_CTL_ADD, client_sockfd, EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 处理客户端数据</span></span><br><span class="line"><span class="comment">     * @param client_pos 就绪事件数组中的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recv</span><span class="params">(<span class="type">int</span> client_pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sockfd = recvs[client_pos].data.fd;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, client_buffer, <span class="built_in">sizeof</span>(client_buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;  <span class="comment">// 接收错误</span></span><br><span class="line">            <span class="built_in">lg</span>(Error, <span class="string">&quot;recv false, errno: %d, errstr: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// 客户端断开连接</span></span><br><span class="line">            <span class="built_in">lg</span>(Info, <span class="string">&quot;client [%s: %d] quit, bye!&quot;</span>, </span><br><span class="line">                clients[sockfd].client_addr.<span class="built_in">c_str</span>(), </span><br><span class="line">                clients[sockfd].client_port);</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 从epoll监控中移除并清理客户端信息</span></span><br><span class="line">            ep.<span class="built_in">EpollCtl</span>(EPOLL_CTL_DEL, sockfd, <span class="number">-1</span>);</span><br><span class="line">            clients.<span class="built_in">erase</span>(sockfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 正常收到数据</span></span><br><span class="line">            client_buffer[n] = <span class="number">0</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构造广播消息（格式：[IP:Port]# 消息内容）</span></span><br><span class="line">            std::string out_buffer = <span class="string">&quot;[&quot;</span> + clients[sockfd].client_addr + <span class="string">&quot;: &quot;</span> + </span><br><span class="line">                                    std::<span class="built_in">to_string</span>(clients[sockfd].client_port) + <span class="string">&quot;]# &quot;</span> + </span><br><span class="line">                                    client_buffer;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 广播给所有客户端</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[fd, inf] : clients) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">send</span>(fd, out_buffer.<span class="built_in">c_str</span>(), out_buffer.<span class="built_in">size</span>(), <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">lg</span>(Error, <span class="string">&quot;send data to client [%s: %d] false&quot;</span>, </span><br><span class="line">                        inf.client_addr.<span class="built_in">c_str</span>(), inf.client_port);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> listen_sockfd;                      <span class="comment">// 监听socket文件描述符</span></span><br><span class="line">    <span class="type">u_int16_t</span> port_;                        <span class="comment">// 服务端口号</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, client_inf&gt; clients;  <span class="comment">// 客户端信息表（fd -&gt; 信息）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> recvs[max_fd_sz];    <span class="comment">// 就绪事件数组</span></span><br><span class="line">    <span class="type">char</span> client_buffer[<span class="number">1024</span>];               <span class="comment">// 数据接收缓冲区</span></span><br><span class="line">    Epoll ep;                              <span class="comment">// Epoll实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>设计说明</strong></p><ol><li><p><strong>Epoll核心机制</strong>  </p><ul><li>使用<code>Epoll</code>类封装<code>epoll_create</code>&#x2F;<code>epoll_ctl</code>&#x2F;<code>epoll_wait</code>操作。</li><li>监听socket和客户端socket均通过<code>EPOLL_CTL_ADD</code>加入监控。</li></ul></li><li><p><strong>事件处理流程</strong>  </p><ul><li><code>EpollWait</code>获取就绪事件 → <code>Dispatcher</code>分发事件 → <code>Accept</code>或<code>Recv</code>处理。</li></ul></li><li><p><strong>客户端管理</strong>  </p><ul><li>使用<code>unordered_map</code>存储客户端信息（<code>fd</code>为键，<code>client_inf</code>为值）。</li><li>客户端断开时自动清理资源（<code>EPOLL_CTL_DEL</code> + <code>erase</code>）。</li></ul></li><li><p><strong>广播功能</strong>  </p><ul><li>收到消息后，遍历<code>clients</code>表向所有客户端发送数据。</li></ul></li><li><p><strong>错误处理</strong>  </p><ul><li>关键操作（如<code>accept</code>、<code>recv</code>）均记录错误日志。</li></ul></li></ol><p>最终实现效果和 <code>poll</code> 版本的完全相同</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux IO 多路转接--Poll</title>
      <link href="/2025/08/01/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/poll/"/>
      <url>/2025/08/01/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/poll/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#poll-%E5%87%BD%E6%95%B0"><code>poll</code> 函数</a><ul><li><a href="#poll-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><code>poll</code> 函数原型</a></li><li><a href="#struct-pollfd-%E7%BB%93%E6%9E%84%E4%BD%93"><code>struct pollfd</code> 结构体</a></li><li><a href="#poll-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><code>poll</code> 的工作流程</a></li><li><a href="#poll-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E7%9B%91%E6%8E%A7%E5%A4%9A%E4%B8%AA-fd"><code>poll</code> 示例代码（监控多个 FD）</a></li></ul></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0">服务端实现</a><ul><li><a href="#tcphpp">tcp.hpp</a></li><li><a href="#poll_serverhpp">poll_server.hpp</a></li><li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81">客户端代码</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95">代码测试</a></li></ul></li></ul><!-- tocstop --><h2><span id="poll-函数"><code>poll</code> 函数</span></h2><p><code>poll</code> 是 Linux&#x2F;Unix 系统中的一种 <strong>I&#x2F;O 多路复用</strong> 机制，用于同时监控多个文件描述符（FD）的 <strong>可读、可写、错误等事件</strong>。相比 <code>select</code>，<code>poll</code> 没有 FD 数量限制（<code>select</code> 默认限制为 1024），并且使用更灵活的结构体数组管理 FD。</p><hr><h3><span id="poll-函数原型"><code>poll</code> 函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>fds</code></strong></td><td><code>struct pollfd *</code></td><td><strong>结构体数组</strong>，每个元素描述一个 FD 及其关注的事件</td></tr><tr><td><strong><code>nfds</code></strong></td><td><code>nfds_t</code></td><td>指定 <code>fds</code> 数组中 <strong>有效元素的数量</strong>（即监控的 FD 数量）</td></tr><tr><td><strong><code>timeout</code></strong></td><td><code>int</code></td><td><strong>超时时间（毫秒）</strong>：<br> - <code>-1</code>：阻塞等待，直到有事件发生<br> - <code>0</code>：立即返回（非阻塞轮询）<br> - <code>&gt;0</code>：等待指定毫秒后返回</td></tr></tbody></table><h4><span id="返回值">返回值</span></h4><ul><li><strong><code>&gt;0</code></strong>：返回 <strong>就绪的 FD 数量</strong>（即 <code>revents</code> 被设置的 FD 数量）。</li><li><strong><code>0</code></strong>：超时且无事件发生。</li><li><strong><code>-1</code></strong>：出错，并设置 <code>errno</code>（如 <code>EINTR</code> 被信号中断）。</li></ul><hr><h3><span id="struct-pollfd-结构体"><code>struct pollfd</code> 结构体</span></h3><p><code>poll</code> 的核心是 <strong><code>struct pollfd</code></strong> 数组，每个结构体描述一个 FD 及其关注的事件。</p><h4><span id="结构体定义">结构体定义</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* 要监控的事件（输入） */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* 实际发生的事件（输出） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4><span id="字段说明">字段说明</span></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>fd</code></strong></td><td><code>int</code></td><td><strong>文件描述符</strong>（如 socket、pipe 等）<br> - 如果 <code>fd = -1</code>，<code>poll</code> 会忽略该结构体</td></tr><tr><td><strong><code>events</code></strong></td><td><code>short</code></td><td><strong>要监控的事件</strong>（用户设置）<br> - 使用 <code>POLLIN</code>、<code>POLLOUT</code> 等宏组合</td></tr><tr><td><strong><code>revents</code></strong></td><td><code>short</code></td><td><strong>实际发生的事件</strong>（内核返回）<br> - 由 <code>poll</code> 填充，表示哪些事件已就绪</td></tr></tbody></table><hr><h4><span id="events-和-revents-的可用事件"><code>events</code> 和 <code>revents</code> 的可用事件</span></h4><p><code>events</code> 和 <code>revents</code> 使用相同的宏定义，但：</p><ul><li><code>events</code> 是 <strong>输入参数</strong>（告诉 <code>poll</code> 要监控哪些事件）。</li><li><code>revents</code> 是 <strong>输出参数</strong>（<code>poll</code> 返回时填充哪些事件真正发生）。</li></ul><p>他们都是通过位图管理的，每个事件对应一个位，多个事件通过位运算组合。</p><h4><span id="常用事件宏">常用事件宏</span></h4><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>POLLIN</code></strong></td><td>数据可读（如 TCP 接收缓冲区非空）</td></tr><tr><td><strong><code>POLLOUT</code></strong></td><td>数据可写（如 TCP 发送缓冲区未满）</td></tr><tr><td><strong><code>POLLERR</code></strong></td><td>发生错误（仅 <code>revents</code> 可用）</td></tr><tr><td><strong><code>POLLHUP</code></strong></td><td>连接挂断（如对端关闭）</td></tr><tr><td><strong><code>POLLNVAL</code></strong></td><td>FD 未打开（<code>fd</code> 无效，仅 <code>revents</code> 可用）</td></tr></tbody></table><h4><span id="示例">示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN | POLLOUT;  <span class="comment">// 监控可读和可写</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = poll(fds, <span class="number">1</span>, <span class="number">1000</span>);      <span class="comment">// 等待 1 秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">    <span class="comment">// sockfd 可读，调用 recv()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLOUT) &#123;</span><br><span class="line">    <span class="comment">// sockfd 可写，调用 send()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLERR) &#123;</span><br><span class="line">    <span class="comment">// 发生错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="poll-的工作流程"><code>poll</code> 的工作流程</span></h3><ol><li><strong>初始化 <code>struct pollfd</code> 数组</strong>，设置 <code>fd</code> 和 <code>events</code>。</li><li><strong>调用 <code>poll</code></strong>，传入数组、FD 数量和超时时间。</li><li><strong><code>poll</code> 阻塞</strong>，直到：<ul><li>有 FD 就绪。</li><li>超时（<code>timeout</code> 毫秒）。</li><li>被信号中断（返回 <code>-1</code>，<code>errno = EINTR</code>）。</li></ul></li><li><strong>检查 <code>revents</code></strong>，处理就绪的 FD。</li><li><strong>循环调用 <code>poll</code></strong>，继续监控。</li></ol><hr><h3><span id="poll-示例代码监控多个-fd"><code>poll</code> 示例代码（监控多个 FD）</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控 stdin（文件描述符 0）</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = STDIN_FILENO;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控 stdout（文件描述符 1）</span></span><br><span class="line">    fds[<span class="number">1</span>].fd = STDOUT_FILENO;</span><br><span class="line">    fds[<span class="number">1</span>].events = POLLOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = poll(fds, <span class="number">2</span>, <span class="number">3000</span>); <span class="comment">// 3 秒超时</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Timeout!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 stdin 是否可读</span></span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;stdin is readable!\n&quot;</span>);</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">            read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 stdout 是否可写</span></span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLOUT) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;stdout is writable!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们利用<code>poll</code>来实现一个简单的 <code>TCP</code> 多用户通信服务器程序</p><h2><span id="服务端实现">服务端实现</span></h2><h3><span id="tcphpp">tcp.hpp</span></h3><p>这里的 <code>TCP</code> 接口封装和之前的接口想同，没有影响的可以展开看看</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TCP_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TCP_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// sockaddr_in结构体定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// 网络地址转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>       <span class="comment">// bzero函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>       <span class="comment">// 自定义日志头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码枚举定义</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    socket_error = <span class="number">1</span>,  <span class="comment">// socket创建失败</span></span><br><span class="line">    bind_error,       <span class="comment">// bind失败</span></span><br><span class="line">    listen_error,      <span class="comment">// listen失败</span></span><br><span class="line">    connect_error,     <span class="comment">// connect失败</span></span><br><span class="line">    accept_error,      <span class="comment">// accept失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程本地存储的地址缓冲区，用于IP地址转换</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">thread_local</span> <span class="type">char</span> addr_buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP网络操作命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> tcp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建TCP socket</span></span><br><span class="line">    <span class="comment">// 返回值: 成功返回socket文件描述符，失败退出程序</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建IPv4 TCP socket</span></span><br><span class="line">        <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(socket_error);  <span class="comment">// 创建失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sockfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到指定端口</span></span><br><span class="line">    <span class="comment">// 参数: sockfd - socket文件描述符</span></span><br><span class="line">    <span class="comment">//       port - 要绑定的端口号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;  <span class="comment">// IPv4地址结构</span></span><br><span class="line">        <span class="built_in">bzero</span>(&amp;local, <span class="built_in">sizeof</span>(local));  <span class="comment">// 清空结构体</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置地址族、IP地址和端口</span></span><br><span class="line">        local.sin_family = AF_INET;           <span class="comment">// IPv4</span></span><br><span class="line">        local.sin_addr.s_addr = INADDR_ANY;   <span class="comment">// 监听所有网络接口</span></span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port);         <span class="comment">// 主机字节序转网络字节序</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定socket</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)(&amp;local), <span class="built_in">sizeof</span>(local));</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(bind_error);  <span class="comment">// 绑定失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从sockaddr_in结构体中提取IP和端口</span></span><br><span class="line">    <span class="comment">// 参数: addr_in - 网络地址结构体</span></span><br><span class="line">    <span class="comment">//       ip - 输出参数，存储IP地址字符串</span></span><br><span class="line">    <span class="comment">//       port - 输出参数，存储端口号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetAddrAndPort</span><span class="params">(<span class="keyword">struct</span> sockaddr_in &amp;addr_in, std::string &amp;ip, <span class="type">uint16_t</span> &amp;port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        port = <span class="built_in">ntohs</span>(addr_in.sin_port);  <span class="comment">// 网络字节序转主机字节序</span></span><br><span class="line">        <span class="comment">// 将IP地址转换为点分十进制字符串</span></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr_in.sin_addr, addr_buffer, <span class="built_in">sizeof</span>(addr_buffer) - <span class="number">1</span>);</span><br><span class="line">        ip = addr_buffer;  <span class="comment">// 存储到输出参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听socket连接</span></span><br><span class="line">    <span class="comment">// 参数: listen_sock - 监听socket</span></span><br><span class="line">    <span class="comment">//       backlog - 最大挂起连接数，默认为10</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> listen_sock, <span class="type">int</span> backlog = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">listen</span>(listen_sock, backlog);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(listen_error);  <span class="comment">// 监听失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="comment">// 参数: sockfd - 客户端socket</span></span><br><span class="line">    <span class="comment">//       server_ip - 服务器IP地址</span></span><br><span class="line">    <span class="comment">//       server_port - 服务器端口号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> std::string &amp;server_ip, <span class="type">const</span> <span class="type">u_int16_t</span> &amp;server_port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;  <span class="comment">// 服务器地址结构</span></span><br><span class="line">        <span class="built_in">bzero</span>(&amp;server, <span class="built_in">sizeof</span>(server));  <span class="comment">// 清空结构体</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置服务器地址信息</span></span><br><span class="line">        server.sin_port = <span class="built_in">htons</span>(server_port);        <span class="comment">// 端口号转网络字节序</span></span><br><span class="line">        server.sin_family = AF_INET;                  <span class="comment">// IPv4</span></span><br><span class="line">        server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>());  <span class="comment">// IP地址转换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发起连接</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="built_in">sizeof</span>(server));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(connect_error);  <span class="comment">// 连接失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line">    <span class="comment">// 参数: listen_sockfd - 监听socket</span></span><br><span class="line">    <span class="comment">//       client_addr - 输出参数，存储客户端地址信息</span></span><br><span class="line">    <span class="comment">// 返回值: 成功返回连接socket文件描述符，失败退出程序</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> listen_sockfd, sockaddr_in &amp;client_addr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);  <span class="comment">// 地址结构长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">accept</span>(listen_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(accept_error);  <span class="comment">// 接受失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;  <span class="comment">// 返回新连接的socket描述符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>    </div></div><h3><span id="poll_serverhpp">poll_server.hpp</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _POLL_SERVER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POLL_SERVER_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span>          <span class="comment">// poll函数相关头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>    <span class="comment">// socket相关操作头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span>         <span class="comment">// 自定义TCP工具函数头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器配置常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">size_t</span> max_fd_sz = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;  <span class="comment">// 最大监控文件描述符数量(1024)</span></span><br><span class="line"><span class="type">const</span> <span class="type">u_int16_t</span> default_port = <span class="number">8888</span>;         <span class="comment">// 默认服务端口号</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> default_fd = <span class="number">-1</span>;                   <span class="comment">// 无效文件描述符标识</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> none_event = <span class="number">0</span>;                    <span class="comment">// 无事件标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端信息结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_inf</span> &#123;</span><br><span class="line">    std::string client_addr;  <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="type">u_int16_t</span> client_port;    <span class="comment">// 客户端端口号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于poll的TCP聊天服务器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PollServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，可指定端口号(默认8888)</span></span><br><span class="line">    <span class="built_in">PollServer</span>(<span class="type">u_int16_t</span> port = default_port)</span><br><span class="line">        : <span class="built_in">cur_sz</span>(<span class="number">0</span>),          <span class="comment">// 初始化当前监控数量为0</span></span><br><span class="line">          <span class="built_in">port_</span>(port)         <span class="comment">// 设置服务端口号</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建监听套接字</span></span><br><span class="line">        listen_sockfd = tcp::<span class="built_in">Socket</span>();</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;listening sock create success, sockfd: %d&quot;</span>, listen_sockfd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 绑定端口</span></span><br><span class="line">        tcp::<span class="built_in">Bind</span>(listen_sockfd, port_);</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;listening sock bind success&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 开始监听连接</span></span><br><span class="line">        tcp::<span class="built_in">Listen</span>(listen_sockfd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 初始化poll监控数组</span></span><br><span class="line">        event_fds[<span class="number">0</span>].fd = listen_sockfd;  <span class="comment">// 监听套接字放在数组首位</span></span><br><span class="line">        event_fds[<span class="number">0</span>].events = POLLIN;      <span class="comment">// 监听读事件(新连接)</span></span><br><span class="line">        ++cur_sz;                          <span class="comment">// 监控数量增加</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化其余位置为无效状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; max_fd_sz; ++i) &#123;</span><br><span class="line">            event_fds[i].fd = default_fd;    <span class="comment">// 标记为无效fd</span></span><br><span class="line">            event_fds[i].events = none_event; <span class="comment">// 不监听任何事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器主循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用poll监控所有文件描述符，超时时间3秒</span></span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">poll</span>(event_fds, cur_sz, <span class="number">3000</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;  <span class="comment">// poll出错</span></span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;poll false, errno: %d, errstr: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// 超时，无事件发生</span></span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;None client join and no client send message&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// 有事件发生</span></span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;Get a new link&quot;</span>);</span><br><span class="line">                <span class="built_in">Dispatcher</span>();  <span class="comment">// 处理事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 事件分发处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有监控的文件描述符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur_sz; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event_fds[i].fd == default_fd)  <span class="comment">// 跳过无效fd</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 检查是否有读事件发生</span></span><br><span class="line">            <span class="keyword">if</span> (event_fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;    <span class="comment">// 监听套接字有事件(新连接)</span></span><br><span class="line">                    <span class="built_in">Accept</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;           <span class="comment">// 客户端套接字有事件(数据到达)</span></span><br><span class="line">                    <span class="built_in">Recv</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受新客户端连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否达到最大连接数</span></span><br><span class="line">        <span class="keyword">if</span> (cur_sz == max_fd_sz) &#123;</span><br><span class="line">            <span class="built_in">lg</span>(Warning, <span class="string">&quot;The client is full, the connection is refused&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接受新连接</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">        <span class="type">int</span> client_sockfd = <span class="built_in">accept</span>(listen_sockfd, (sockaddr*)&amp;client, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>) &#123;  <span class="comment">// 接受连接失败</span></span><br><span class="line">            <span class="built_in">lg</span>(Error, <span class="string">&quot;listening sock accept false, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取客户端地址信息</span></span><br><span class="line">        std::string client_addr;</span><br><span class="line">        <span class="type">u_int16_t</span> client_port;</span><br><span class="line">        tcp::<span class="built_in">GetAddrAndPort</span>(client, client_addr, client_port);</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;accept a new client [%s: %d]&quot;</span>, client_addr.<span class="built_in">c_str</span>(), client_port);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在poll数组中寻找空闲位置存放新连接</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cur_sz; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == cur_sz)  <span class="comment">// 需要扩容监控数组</span></span><br><span class="line">                ++cur_sz;</span><br><span class="line">            <span class="keyword">if</span> (event_fds[i].fd == default_fd) &#123;  <span class="comment">// 找到空闲位置</span></span><br><span class="line">                event_fds[i].fd = client_sockfd;   <span class="comment">// 设置客户端fd</span></span><br><span class="line">                event_fds[i].events = POLLIN;     <span class="comment">// 监听读事件</span></span><br><span class="line">                event_fds[i].revents = none_event; <span class="comment">// 重置事件标志</span></span><br><span class="line">                clients[i].client_addr = client_addr;    <span class="comment">// 保存客户端地址</span></span><br><span class="line">                clients[i].client_port = client_port;    <span class="comment">// 保存客户端端口</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端数据并广播</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recv</span><span class="params">(<span class="type">int</span> client_pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sockfd = event_fds[client_pos].fd;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收客户端数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, client_buffer, <span class="built_in">sizeof</span>(client_buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;  <span class="comment">// 接收出错</span></span><br><span class="line">            <span class="built_in">lg</span>(Error, <span class="string">&quot;recv false, errno: %d, errstr: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// 客户端关闭连接</span></span><br><span class="line">            <span class="built_in">lg</span>(Info, <span class="string">&quot;client [%s: %d] quit, bye!&quot;</span>, </span><br><span class="line">                clients[client_pos].client_addr.<span class="built_in">c_str</span>(), </span><br><span class="line">                clients[client_pos].client_port);</span><br><span class="line">            event_fds[client_pos].fd = default_fd;  <span class="comment">// 标记为无效</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 成功接收数据</span></span><br><span class="line">            client_buffer[n] = <span class="number">0</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 广播给所有客户端(简单群聊功能)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cur_sz; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event_fds[i].fd != default_fd) &#123;  <span class="comment">// 只发给有效客户端</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">send</span>(event_fds[i].fd, client_buffer, n, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">lg</span>(Error, <span class="string">&quot;send data to client [%s: %d] false&quot;</span>, </span><br><span class="line">                            clients[i].client_addr.<span class="built_in">c_str</span>(), </span><br><span class="line">                            clients[i].client_port);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> cur_sz;                   <span class="comment">// 当前监控的文件描述符数量</span></span><br><span class="line">    <span class="type">int</span> listen_sockfd;               <span class="comment">// 监听套接字文件描述符</span></span><br><span class="line">    <span class="type">u_int16_t</span> port_;                 <span class="comment">// 服务端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> event_fds[max_fd_sz];  <span class="comment">// poll监控的文件描述符数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">client_inf</span> clients[max_fd_sz]; <span class="comment">// 客户端信息数组</span></span><br><span class="line">    <span class="type">char</span> client_buffer[<span class="number">1024</span>];        <span class="comment">// 数据接收缓冲区</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>代码整体结构</p><ol><li><p><strong>基础架构</strong>：</p><ul><li>使用poll I&#x2F;O多路复用技术实现TCP聊天服务器</li><li>支持同时处理多个客户端连接</li><li>实现简单的群聊功能(一个客户端发消息，所有客户端都能收到)</li></ul></li><li><p><strong>核心机制</strong>：</p><ul><li>使用固定大小的数组管理所有客户端连接(max_fd_sz&#x3D;1024)</li><li>主循环通过poll监控所有活跃连接</li><li>采用事件驱动模型，只有发生实际I&#x2F;O时才进行处理</li></ul></li><li><p><strong>关键数据结构</strong>：</p><ul><li><code>pollfd</code>数组：监控所有socket的文件描述符和事件状态</li><li><code>client_inf</code>数组：存储每个客户端的地址信息</li><li>环形缓冲区：用于临时存储接收到的消息</li></ul></li><li><p><strong>工作流程</strong>：</p><ul><li>初始化监听socket并加入poll监控</li><li>主循环中调用poll等待事件</li><li>有新连接时accept并加入监控</li><li>有数据到达时读取并广播给所有客户端</li><li>客户端断开时清理资源</li></ul></li></ol><h3><span id="客户端代码">客户端代码</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP客户端实现 - 支持断线重连的简易聊天客户端</span></span><br><span class="line"><span class="comment"> * 功能：连接服务器，发送消息并接收服务器回显</span></span><br><span class="line"><span class="comment"> * 编译：g++ client.cpp -o client -lpthread</span></span><br><span class="line"><span class="comment"> * 使用：./client &lt;server_ip&gt; &lt;server_port&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带重试机制的连接函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr_in &amp;server)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">5</span>;  <span class="comment">// 最大重试次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接服务器，失败时自动重试</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="built_in">sizeof</span>(server)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;  <span class="comment">// 重试次数耗尽</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sorry, I am unable to connect to the designated server\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Try to reconnect..., %d chances remaining\n&quot;</span>, cnt);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 间隔2秒重试</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 连接成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息接收处理线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Handler</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd, <span class="type">const</span> std::string server_ip, <span class="type">const</span> <span class="type">u_int16_t</span> server_port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 接收服务器消息(不关心发送方信息)</span></span><br><span class="line">        <span class="type">ssize_t</span> m = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;  <span class="comment">// 收到有效消息</span></span><br><span class="line">            buffer[m] = <span class="number">0</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;server echo# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;  <span class="comment">// 服务器关闭连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server [%s: %d] quit\n&quot;</span>, server_ip.<span class="built_in">c_str</span>(), server_port);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试重新连接</span></span><br><span class="line">            <span class="type">int</span> sockfd = tcp::<span class="built_in">Socket</span>();</span><br><span class="line">            sockaddr_in server_addr&#123;&#125;;</span><br><span class="line">            server_addr.sin_family = AF_INET;</span><br><span class="line">            server_addr.sin_port = <span class="built_in">htons</span>(server_port);</span><br><span class="line">            <span class="built_in">inet_pton</span>(AF_INET, server_ip.<span class="built_in">c_str</span>(), &amp;server_addr.sin_addr); </span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 等待1秒后再试</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Connect</span>(sockfd, server_addr) == <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 重连成功则继续</span></span><br><span class="line">                </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">// 重连失败退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 接收出错</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; server_ip server_port&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    string server_ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint16_t</span> server_port = <span class="built_in">stoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;server, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(server_port);      <span class="comment">// 设置端口</span></span><br><span class="line">    server.sin_family = AF_INET;               <span class="comment">// IPv4协议</span></span><br><span class="line">    server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>());  <span class="comment">// IP地址转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字并连接服务器</span></span><br><span class="line">    <span class="type">int</span> sockfd = tcp::<span class="built_in">Socket</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Connect</span>(sockfd, server) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动接收线程</span></span><br><span class="line">    <span class="function">thread <span class="title">receiver</span><span class="params">(Handler, sockfd, server_ip, server_port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程处理用户输入和发送</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string inbuffer;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);  <span class="comment">// 微小延迟避免CPU占用过高</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter# &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, inbuffer);  <span class="comment">// 获取用户输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送消息到服务器</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">send</span>(sockfd, inbuffer.<span class="built_in">c_str</span>(), inbuffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver.<span class="built_in">join</span>();  <span class="comment">// 等待接收线程结束(实际不会执行到这里)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能说明</p><ol><li><p><strong>核心功能</strong>：</p><ul><li>实现了一个支持断线自动重连的TCP聊天客户端</li><li>采用多线程架构：主线程处理用户输入，子线程接收服务器消息</li><li>支持基本的命令行参数配置（服务器IP和端口）</li></ul></li><li><p><strong>关键特性</strong>：</p><ul><li>自动重连机制：连接失败时自动重试5次（间隔2秒）</li><li>断线恢复：检测到服务器断开后自动尝试重新连接</li><li>简单交互界面：显示输入提示和服务器回显</li></ul></li><li><p><strong>工作流程</strong>：</p><ul><li>启动时连接指定服务器</li><li>成功连接后：<ul><li>主线程：循环读取用户输入并发送到服务器</li><li>子线程：循环接收服务器消息并显示</li></ul></li><li>连接断开时：<ul><li>自动尝试重新建立连接</li><li>重连失败则退出程序</li></ul></li></ul></li></ol><h3><span id="代码测试">代码测试</span></h3><p>而后，我们将服务端和客户端启动后即可实现双方的通信了，服务端创建和调用实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;poll_server.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        port = <span class="number">7777</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        port = <span class="built_in">stoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;(default port: 8080)&quot;</span> &lt;&lt; endl &lt;&lt; </span><br><span class="line">        <span class="string">&quot;OR&quot;</span> &lt;&lt; endl &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; port&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">unique_ptr&lt;PollServer&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> PollServer(port))</span></span>;</span><br><span class="line">    ps-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    ps-&gt;<span class="built_in">Start</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们对代码进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端1</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/web_io/Poll</span><br><span class="line">╰─➤  ./poll_client.o 127.0.0.1 7777</span><br><span class="line">Please Enter# 123</span><br><span class="line">server echo# 123Please Enter#</span><br><span class="line">hello</span><br><span class="line">Please Enter# server echo# hello</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端2</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/web_io/Poll</span><br><span class="line">╰─➤  ./poll_client.o 127.0.0.1 7777</span><br><span class="line">Please Enter# server echo# 123</span><br><span class="line">server echo# hello</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端3</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/web_io/Poll</span><br><span class="line">╰─➤  ./poll_client.o 127.0.0.1 7777</span><br><span class="line">Please Enter# server echo# 123</span><br><span class="line">server echo# hello</span><br></pre></td></tr></table></figure><p>客户端1 的数据可以顺利发送给其他两个客户端</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义协议 &amp;&amp; 序列化与反序列化</title>
      <link href="/2025/07/31/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/protocol/"/>
      <url>/2025/07/31/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/protocol/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE">网络通信中的自定义协议</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE">什么是自定义协议</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%B4%A0">自定义协议的设计要素</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">自定义协议的实现方式</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">自定义协议中的序列化和反序列化</a><ul><li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%9C%E7%94%A8">序列化的概念与作用</a></li><li><a href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%9C%E7%94%A8">反序列化的概念与作用</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F">常见的序列化方式</a></li></ul></li><li><a href="#%E7%AE%80%E5%8D%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0">简单自定义协议实现</a><ul><li><a href="#tcphpp">tcp.hpp</a></li><li><a href="#protocolhpp">protocol.hpp</a></li><li><a href="#server_calhpp">server_cal.hpp</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81">添加注释后的代码</a></li><li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF">服务端</a></li><li><a href="#json%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AE%9E%E7%8E%B0">JSON格式化实现</a></li></ul></li></ul><!-- tocstop --><h2><span id="网络通信中的自定义协议">网络通信中的自定义协议</span></h2><h3><span id="什么是自定义协议">什么是自定义协议</span></h3><p>自定义协议是指在网络通信中，开发者根据特定应用需求自行设计的数据交换规则和格式。与HTTP、FTP等标准协议不同，自定义协议通常针对特定场景优化，具有更高的灵活性和效率。</p><p>自定义协议的主要特点包括：</p><ol><li>专为特定应用场景设计</li><li>通常比通用协议更高效</li><li>可以根据需求自由定义数据格式</li><li>需要通信双方都实现协议解析逻辑</li></ol><h3><span id="自定义协议的设计要素">自定义协议的设计要素</span></h3><p>设计一个良好的自定义协议需要考虑以下要素：</p><ol><li><strong>消息边界</strong>：如何确定一个完整消息的开始和结束</li><li><strong>消息格式</strong>：消息头(Header)和消息体(Body)的结构</li><li><strong>编解码方式</strong>：数据如何编码传输和解码读取</li><li><strong>错误处理</strong>：如何处理不完整或错误的消息</li><li><strong>扩展性</strong>：如何支持未来可能的协议升级</li></ol><h3><span id="自定义协议的实现方式">自定义协议的实现方式</span></h3><p>常见的自定义协议实现方式包括：</p><ol><li><strong>基于TCP的二进制协议</strong>：如游戏、即时通讯等高性能场景</li><li><strong>基于文本的协议</strong>：如SMTP等人类可读的协议</li><li><strong>混合型协议</strong>：头部使用二进制，正文使用文本或二进制</li></ol><h2><span id="自定义协议中的序列化和反序列化">自定义协议中的序列化和反序列化</span></h2><h3><span id="序列化的概念与作用">序列化的概念与作用</span></h3><p>序列化(Serialization)是指将数据结构或对象状态转换为可以存储或传输的格式的过程。在网络通信中，序列化主要用于：</p><ol><li>将内存中的对象转换为字节流以便网络传输</li><li>保持数据的完整性和结构</li><li>实现跨平台、跨语言的数据交换</li></ol><h3><span id="反序列化的概念与作用">反序列化的概念与作用</span></h3><p>反序列化(Deserialization)是序列化的逆过程，将字节流转换回原始的数据结构或对象。其主要作用包括：</p><ol><li>重建发送端的数据结构</li><li>验证数据的完整性和正确性</li><li>恢复对象的完整状态</li></ol><h3><span id="常见的序列化方式">常见的序列化方式</span></h3><p>自定义协议中常用的序列化方式包括：</p><ol><li><p><strong>二进制序列化</strong>：</p><ul><li>直接内存拷贝</li><li>Protocol Buffers</li><li>Thrift</li><li>FlatBuffers</li></ul></li><li><p><strong>文本序列化</strong>：</p><ul><li>JSON</li><li>XML</li><li>YAML</li></ul></li><li><p><strong>混合序列化</strong>：</p><ul><li>MessagePack</li><li>BSON</li></ul></li></ol><h2><span id="简单自定义协议实现">简单自定义协议实现</span></h2><p>该自定义协议中同样采用了序列化和反序列化的手段处理数据，实现了远程计算器功能，我们首先使用纯手搓的序列化及反序列化手段来实现：</p><p>首先我们实现一个 <code>TCP</code> 接口包装：</p><h3><span id="tcphpp">tcp.hpp</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TCP_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TCP_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// sockaddr_in结构体定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// 网络地址转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>       <span class="comment">// bzero函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>       <span class="comment">// 自定义日志头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码枚举定义</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    socket_error = <span class="number">1</span>,  <span class="comment">// socket创建失败</span></span><br><span class="line">    bind_error,       <span class="comment">// bind失败</span></span><br><span class="line">    listen_error,      <span class="comment">// listen失败</span></span><br><span class="line">    connect_error,     <span class="comment">// connect失败</span></span><br><span class="line">    accept_error,      <span class="comment">// accept失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程本地存储的地址缓冲区，用于IP地址转换</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">thread_local</span> <span class="type">char</span> addr_buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP网络操作命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> tcp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建TCP socket</span></span><br><span class="line">    <span class="comment">// 返回值: 成功返回socket文件描述符，失败退出程序</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建IPv4 TCP socket</span></span><br><span class="line">        <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(socket_error);  <span class="comment">// 创建失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sockfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到指定端口</span></span><br><span class="line">    <span class="comment">// 参数: sockfd - socket文件描述符</span></span><br><span class="line">    <span class="comment">//       port - 要绑定的端口号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;  <span class="comment">// IPv4地址结构</span></span><br><span class="line">        <span class="built_in">bzero</span>(&amp;local, <span class="built_in">sizeof</span>(local));  <span class="comment">// 清空结构体</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置地址族、IP地址和端口</span></span><br><span class="line">        local.sin_family = AF_INET;           <span class="comment">// IPv4</span></span><br><span class="line">        local.sin_addr.s_addr = INADDR_ANY;   <span class="comment">// 监听所有网络接口</span></span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port);         <span class="comment">// 主机字节序转网络字节序</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定socket</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)(&amp;local), <span class="built_in">sizeof</span>(local));</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(bind_error);  <span class="comment">// 绑定失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从sockaddr_in结构体中提取IP和端口</span></span><br><span class="line">    <span class="comment">// 参数: addr_in - 网络地址结构体</span></span><br><span class="line">    <span class="comment">//       ip - 输出参数，存储IP地址字符串</span></span><br><span class="line">    <span class="comment">//       port - 输出参数，存储端口号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetAddrAndPort</span><span class="params">(<span class="keyword">struct</span> sockaddr_in &amp;addr_in, std::string &amp;ip, <span class="type">uint16_t</span> &amp;port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        port = <span class="built_in">ntohs</span>(addr_in.sin_port);  <span class="comment">// 网络字节序转主机字节序</span></span><br><span class="line">        <span class="comment">// 将IP地址转换为点分十进制字符串</span></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr_in.sin_addr, addr_buffer, <span class="built_in">sizeof</span>(addr_buffer) - <span class="number">1</span>);</span><br><span class="line">        ip = addr_buffer;  <span class="comment">// 存储到输出参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听socket连接</span></span><br><span class="line">    <span class="comment">// 参数: listen_sock - 监听socket</span></span><br><span class="line">    <span class="comment">//       backlog - 最大挂起连接数，默认为10</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> listen_sock, <span class="type">int</span> backlog = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">listen</span>(listen_sock, backlog);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(listen_error);  <span class="comment">// 监听失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="comment">// 参数: sockfd - 客户端socket</span></span><br><span class="line">    <span class="comment">//       server_ip - 服务器IP地址</span></span><br><span class="line">    <span class="comment">//       server_port - 服务器端口号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> std::string &amp;server_ip, <span class="type">const</span> <span class="type">u_int16_t</span> &amp;server_port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;  <span class="comment">// 服务器地址结构</span></span><br><span class="line">        <span class="built_in">bzero</span>(&amp;server, <span class="built_in">sizeof</span>(server));  <span class="comment">// 清空结构体</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置服务器地址信息</span></span><br><span class="line">        server.sin_port = <span class="built_in">htons</span>(server_port);        <span class="comment">// 端口号转网络字节序</span></span><br><span class="line">        server.sin_family = AF_INET;                  <span class="comment">// IPv4</span></span><br><span class="line">        server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>());  <span class="comment">// IP地址转换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发起连接</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="built_in">sizeof</span>(server));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(connect_error);  <span class="comment">// 连接失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line">    <span class="comment">// 参数: listen_sockfd - 监听socket</span></span><br><span class="line">    <span class="comment">//       client_addr - 输出参数，存储客户端地址信息</span></span><br><span class="line">    <span class="comment">// 返回值: 成功返回连接socket文件描述符，失败退出程序</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> listen_sockfd, sockaddr_in &amp;client_addr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);  <span class="comment">// 地址结构长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">accept</span>(listen_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(accept_error);  <span class="comment">// 接受失败退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;  <span class="comment">// 返回新连接的socket描述符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后是我们的重头戏：自定义协议实现：</p><h3><span id="protocolhpp">protocol.hpp</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PROTOCOL_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PROTOCOL_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议分隔符定义</span></span><br><span class="line"><span class="type">const</span> std::string blank_space_sep = <span class="string">&quot; &quot;</span>;  <span class="comment">// 字段间分隔符（空格）</span></span><br><span class="line"><span class="type">const</span> std::string protocol_sep = <span class="string">&quot;\n&quot;</span>;    <span class="comment">// 协议分隔符（换行）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码枚举</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    divide_by_zero_error = <span class="number">1</span>,  <span class="comment">// 除零错误</span></span><br><span class="line">    operator_identify,         <span class="comment">// 操作符识别错误</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议解码函数</span></span><br><span class="line"><span class="comment">// 格式: &quot;长度\n内容\n&quot;</span></span><br><span class="line"><span class="comment">// 参数: package - 输入的网络数据包</span></span><br><span class="line"><span class="comment">//       content - 输出的解码后内容</span></span><br><span class="line"><span class="comment">// 返回值: 解码成功返回true，失败返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Decode</span><span class="params">(std::string &amp;package, std::string &amp;content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找第一个分隔符位置</span></span><br><span class="line">    <span class="type">size_t</span> pos = package.<span class="built_in">find</span>(protocol_sep);</span><br><span class="line">    <span class="keyword">if</span>(pos == std::string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取内容长度</span></span><br><span class="line">    <span class="type">size_t</span> size = std::<span class="built_in">stoi</span>(package.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找第二个分隔符位置</span></span><br><span class="line">    <span class="type">size_t</span> n_pos = package.<span class="built_in">find</span>(protocol_sep, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> total_len = pos + size + <span class="number">2</span>;  <span class="comment">// 计算完整消息长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证消息格式是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(n_pos + <span class="number">1</span> != total_len) &#123;</span><br><span class="line">        <span class="comment">// 格式错误，清空数据包</span></span><br><span class="line">        package.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提取消息内容</span></span><br><span class="line">    content = package.<span class="built_in">substr</span>(pos + <span class="number">1</span>, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除已处理的部分</span></span><br><span class="line">    package.<span class="built_in">erase</span>(<span class="number">0</span>, total_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议编码函数</span></span><br><span class="line"><span class="comment">// 格式: &quot;长度\n内容\n&quot;</span></span><br><span class="line"><span class="comment">// 参数: content - 要编码的内容</span></span><br><span class="line"><span class="comment">// 返回值: 编码后的字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">Encode</span><span class="params">(std::string &amp;content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string ret = std::<span class="built_in">to_string</span>(content.<span class="built_in">size</span>());  <span class="comment">// 添加长度</span></span><br><span class="line">    ret += protocol_sep;                               <span class="comment">// 添加分隔符</span></span><br><span class="line">    ret += content;                                    <span class="comment">// 添加内容</span></span><br><span class="line">    ret += protocol_sep;                               <span class="comment">// 添加结束分隔符</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求类（客户端→服务端）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，默认值表示无效请求</span></span><br><span class="line">    <span class="built_in">Request</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">char</span> op = <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    :<span class="built_in">x_</span>(x),</span><br><span class="line">    <span class="built_in">y_</span>(y),</span><br><span class="line">    <span class="built_in">op_</span>(op)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化方法：将对象转换为字符串</span></span><br><span class="line">    <span class="comment">// 格式: &quot;x op y&quot;（如 &quot;10 + 20&quot;）</span></span><br><span class="line">    <span class="function">std::string <span class="title">Serialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string ret = std::<span class="built_in">to_string</span>(x_);</span><br><span class="line">        ret += blank_space_sep;</span><br><span class="line">        ret += op_;</span><br><span class="line">        ret += blank_space_sep;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(y_);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化方法：从字符串解析对象</span></span><br><span class="line">    <span class="comment">// 参数: in - 输入字符串（格式必须为 &quot;x op y&quot;）</span></span><br><span class="line">    <span class="comment">// 返回值: 解析成功返回true，失败返回false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Deserialize</span><span class="params">(std::string &amp;in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 查找第一个空格位置</span></span><br><span class="line">        <span class="type">size_t</span> pos = in.<span class="built_in">find</span>(blank_space_sep);</span><br><span class="line">        <span class="keyword">if</span>(pos == std::string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析第一个操作数</span></span><br><span class="line">        x_ = std::<span class="built_in">stoi</span>(in.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找第二个空格位置</span></span><br><span class="line">        <span class="type">size_t</span> npos = in.<span class="built_in">find</span>(blank_space_sep, pos + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(npos == std::string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析操作符</span></span><br><span class="line">        op_ = in[pos + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析第二个操作数</span></span><br><span class="line">        y_ = std::<span class="built_in">stoi</span>(in.<span class="built_in">substr</span>(npos + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x_;     <span class="comment">// 第一个操作数</span></span><br><span class="line">    <span class="type">int</span> y_;     <span class="comment">// 第二个操作数</span></span><br><span class="line">    <span class="type">char</span> op_;   <span class="comment">// 操作符（+,-,*,/等）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应类（服务端→客户端）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Response</span>(<span class="type">int</span> res = <span class="number">0</span>, <span class="type">int</span> code = <span class="number">0</span>)</span><br><span class="line">    :<span class="built_in">res_</span>(res),</span><br><span class="line">    <span class="built_in">code_</span>(code)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化方法：将对象转换为字符串</span></span><br><span class="line">    <span class="comment">// 格式: &quot;result code&quot;（如 &quot;30 0&quot;）</span></span><br><span class="line">    <span class="function">std::string <span class="title">Serialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string ret = std::<span class="built_in">to_string</span>(res_);</span><br><span class="line">        ret += blank_space_sep;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(code_);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化方法：从字符串解析对象</span></span><br><span class="line">    <span class="comment">// 参数: in - 输入字符串（格式必须为 &quot;result code&quot;）</span></span><br><span class="line">    <span class="comment">// 返回值: 解析成功返回true，失败返回false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Deserialize</span><span class="params">(std::string &amp;in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 查找空格位置</span></span><br><span class="line">        <span class="type">size_t</span> pos = in.<span class="built_in">find</span>(blank_space_sep);</span><br><span class="line">        <span class="keyword">if</span>(pos == std::string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析计算结果</span></span><br><span class="line">        res_ = std::<span class="built_in">stoi</span>(in.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析状态码</span></span><br><span class="line">        code_ = std::<span class="built_in">stoi</span>(in.<span class="built_in">substr</span>(pos + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res_;    <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="type">int</span> code_;   <span class="comment">// 状态码（0表示成功，非0表示错误）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4><span id="代码概述">代码概述</span></h4><ol><li><p><strong>协议格式</strong>：</p><ul><li>外层协议格式：<code>&quot;长度\n内容\n&quot;</code>（如 <code>&quot;7\n10 + 20\n&quot;</code>）</li><li>请求格式：<code>&quot;x op y&quot;</code>（如 <code>&quot;10 + 20&quot;</code>）</li><li>响应格式：<code>&quot;result code&quot;</code>（如 <code>&quot;30 0&quot;</code>）</li></ul></li><li><p><strong>主要功能</strong>：</p><ul><li><code>Encode/Decode</code>：处理网络传输层面的封包&#x2F;解包</li><li><code>Request</code>：表示客户端请求，包含两个操作数和一个运算符</li><li><code>Response</code>：表示服务端响应，包含计算结果和状态码</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>使用简单的文本协议，便于调试</li><li>包含基本的错误检测机制</li><li>支持序列化和反序列化操作</li><li>使用空格和换行符作为分隔符</li></ul></li></ol><h3><span id="server_calhpp">server_cal.hpp</span></h3><p>以下是添加了详细注释的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SERVER_CAL_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SERVER_CAL_HPP_ 1;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;protocol.hpp&quot;</span>  <span class="comment">// 包含之前定义的自定义协议头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算器服务端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerCal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 辅助计算函数，处理具体运算逻辑</span></span><br><span class="line">    <span class="comment">// 参数: req - 包含计算请求的Request对象</span></span><br><span class="line">    <span class="comment">// 返回值: 包含计算结果和状态的Response对象</span></span><br><span class="line">    <span class="function">Response <span class="title">CalculatorHelper</span><span class="params">(<span class="type">const</span> Request &amp;req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Response <span class="title">resp</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 初始化响应对象，默认结果0，状态码0(成功)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据操作符执行不同运算</span></span><br><span class="line">        <span class="keyword">switch</span> (req.op_)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            resp.res_ = req.x_ + req.y_;  <span class="comment">// 加法运算</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            resp.res_ = req.x_ - req.y_;  <span class="comment">// 减法运算</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            resp.res_ = req.x_ * req.y_;  <span class="comment">// 乘法运算</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 除法运算，检查除数是否为0</span></span><br><span class="line">            <span class="keyword">if</span> (req.y_ == <span class="number">0</span>)</span><br><span class="line">                resp.code_ = divide_by_zero_error;  <span class="comment">// 除零错误</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                resp.res_ = req.x_ / req.y_;  <span class="comment">// 正常除法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取模运算，检查模数是否为0</span></span><br><span class="line">            <span class="keyword">if</span> (req.y_ == <span class="number">0</span>)</span><br><span class="line">                resp.code_ = divide_by_zero_error;  <span class="comment">// 除零错误</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                resp.res_ = req.x_ % req.y_;  <span class="comment">// 正常取模</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            resp.code_ = operator_identify;  <span class="comment">// 未知操作符错误</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主计算函数，处理协议解码和编码</span></span><br><span class="line">    <span class="comment">// 参数: package - 网络接收到的原始数据包</span></span><br><span class="line">    <span class="comment">// 返回值: 编码后的响应字符串，出错返回空字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">Calculator</span><span class="params">(std::string &amp;package)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string content;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 解码网络数据包</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Decode</span>(package, content))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 解码失败返回空字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 反序列化请求内容</span></span><br><span class="line">        Request req;</span><br><span class="line">        <span class="keyword">if</span>(!req.<span class="built_in">Deserialize</span>(content)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 反序列化失败返回空字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 执行计算逻辑</span></span><br><span class="line">        Response resp = <span class="built_in">CalculatorHelper</span>(req);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 序列化响应结果</span></span><br><span class="line">        content = resp.<span class="built_in">Serialize</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 编码为网络协议格式</span></span><br><span class="line">        content = <span class="built_in">Encode</span>(content);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4><span id="代码功能概述">代码功能概述</span></h4><p>这段代码实现了一个简单的网络计算器服务端，主要功能包括：</p><ol><li><p><strong>核心计算功能</strong>：</p><ul><li>支持加(+)、减(-)、乘(*)、除(&#x2F;)、取模(%)五种运算</li><li>处理除零错误和无效操作符等异常情况</li></ul></li><li><p><strong>协议处理流程</strong>：</p><ul><li>接收网络数据包 → 解码 → 反序列化为请求对象 → 执行计算 → 序列化响应 → 编码为网络格式</li><li>使用之前定义的<code>protocol.hpp</code>中的协议格式</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>解码失败时返回空字符串</li><li>反序列化失败时返回空字符串</li><li>运算错误通过Response的状态码返回</li></ul></li><li><p><strong>设计特点</strong>：</p><ul><li>将协议处理和业务逻辑分离（Calculator和CalculatorHelper分工明确）</li><li>使用状态码表示运算结果状态</li><li>严格遵循自定义协议的格式要求</li></ul></li></ol><p>这样后，我们就可以通过将 <code>std::string ServerCal::Calculator(std::string &amp;package)</code> 包装起来传递给 <code>TCP</code> 服务器从而使得服务器与协议功能解耦合</p><h3><span id></span></h3><h3><span id="添加注释后的代码">添加注释后的代码</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TCPSERVERHPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TCPSERVERHPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span>    <span class="comment">// TCP基础操作封装</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>    <span class="comment">// 日志模块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 函数对象支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">u_int16_t</span> default_port = <span class="number">7777</span>; <span class="comment">// 默认服务端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义协议处理函数类型（输入请求包，返回响应包）</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = std::function&lt;std::<span class="built_in">string</span> (std::string &amp;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化端口和协议处理回调</span></span><br><span class="line">    <span class="built_in">TcpServer</span>(<span class="type">int</span> port = default_port, <span class="type">func_t</span> cal = <span class="literal">nullptr</span>)</span><br><span class="line">    :<span class="built_in">port_</span>(port),</span><br><span class="line">    <span class="built_in">cal_</span>(cal)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器：创建监听socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        listen_sockfd_ = tcp::<span class="built_in">Socket</span>();  <span class="comment">// 创建socket</span></span><br><span class="line">        tcp::<span class="built_in">Bind</span>(listen_sockfd_, port_); <span class="comment">// 绑定端口</span></span><br><span class="line">        tcp::<span class="built_in">Listen</span>(listen_sockfd_);      <span class="comment">// 开始监听</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务主循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client; <span class="comment">// 客户端地址信息</span></span><br><span class="line">        <span class="type">int</span> client_sockfd = tcp::<span class="built_in">Accept</span>(listen_sockfd_, client); <span class="comment">// 接受连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// 接收缓冲区</span></span><br><span class="line">        std::string ip;    <span class="comment">// 客户端IP</span></span><br><span class="line">        <span class="type">u_int16_t</span> port;    <span class="comment">// 客户端端口</span></span><br><span class="line">        tcp::<span class="built_in">GetAddrAndPort</span>(client, ip, port); <span class="comment">// 获取客户端地址</span></span><br><span class="line">        </span><br><span class="line">        std::string package; <span class="comment">// 累积接收的数据包</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收客户端数据</span></span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">recv</span>(client_sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;recv data failed. client [%s: %d]&quot;</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123; <span class="comment">// 客户端断开连接</span></span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;client [%s: %d] quit&quot;</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">                <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                buffer[n] = <span class="number">0</span>; <span class="comment">// 添加字符串结束符</span></span><br><span class="line">                package += buffer; <span class="comment">// 累积数据</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 处理完整数据包（可能包含多个请求）</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::string resp = <span class="built_in">cal_</span>(package); <span class="comment">// 调用协议处理回调</span></span><br><span class="line">                    <span class="keyword">if</span>(resp.<span class="built_in">empty</span>()) <span class="keyword">break</span>; <span class="comment">// 无完整包可处理时退出</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 发送响应</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">send</span>(client_sockfd, resp.<span class="built_in">c_str</span>(), resp.<span class="built_in">size</span>(), <span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">lg</span>(Error, <span class="string">&quot;send failed. client [%s: %d]&quot;</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> listen_sockfd_; <span class="comment">// 监听socket描述符</span></span><br><span class="line">    <span class="type">u_int16_t</span> port_;    <span class="comment">// 服务端口</span></span><br><span class="line">    <span class="type">func_t</span> cal_;        <span class="comment">// 协议处理回调函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4><span id="服务器解耦合设计特点">服务器解耦合设计特点</span></h4><ol><li><p><strong>回调机制设计</strong>：</p><ul><li>通过<code>func_t</code>函数对象类型定义协议处理接口</li><li>构造函数接收外部传入的<code>std::string (std::string&amp;)</code>类型函数</li><li>实际处理时调用<code>cal_(package)</code>触发业务逻辑</li></ul></li><li><p><strong>与ServerCal的协作</strong>：</p><ul><li>使用时将<code>ServerCal::Calculator</code>方法绑定给<code>cal_</code>成员</li><li>服务器仅负责：接收原始数据 → 累积数据包 → 调用回调 → 返回响应</li><li>协议解析和业务处理完全由外部<code>Calculator</code>实现</li></ul></li><li><p><strong>优势体现</strong>：</p><ul><li>服务器不感知具体协议格式（如换行分隔符等）</li><li>可灵活更换不同的协议处理器（只需符合函数签名）</li><li>业务逻辑变更不影响网络通信层</li><li>便于单元测试（可mock协议处理器）</li></ul></li><li><p><strong>数据处理流程</strong>：</p><pre class="mermaid">   flowchart TD A[网络层 TcpServer] -->|接收原始字节流| B[协议层 Decode] B -->|完整数据包| C[协议解析 Deserialize] C -->|Request对象| D[业务逻辑 CalculatorHelper] D -->|Response对象| E[协议组装 Serialize] E -->|响应字节流| F[协议层 Encode] F -->|发送数据| A</pre></li></ol><p>这种设计遵循了单一职责原则，使网络IO处理与协议解析分离，提高了代码的可维护性和扩展性。</p><h3><span id="客户端">客户端</span></h3><p>以下是添加了详细注释的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;protocol.hpp&quot;</span>  <span class="comment">// 自定义协议头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span>      <span class="comment">// TCP网络操作头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验：需要服务器IP和端口</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;\nUsage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; server_ip server_port\n&quot;</span></span><br><span class="line">              &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析命令行参数</span></span><br><span class="line">    std::string serverip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint16_t</span> serverport = std::<span class="built_in">stoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket并连接服务器</span></span><br><span class="line">    <span class="type">int</span> sockfd = tcp::<span class="built_in">Socket</span>();</span><br><span class="line">    tcp::<span class="built_in">Connect</span>(sockfd, serverip, serverport);</span><br><span class="line"></span><br><span class="line">    std::string recv_str;  <span class="comment">// 接收数据缓冲区</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];     <span class="comment">// 临时接收缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环：持续与服务器交互</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 获取用户输入</span></span><br><span class="line">        <span class="type">int</span> x, y; </span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter x: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter y: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; y;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter op: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 构造请求并序列化</span></span><br><span class="line">        <span class="function">Request <span class="title">req</span><span class="params">(x, y, op)</span></span>;</span><br><span class="line">        string content = req.<span class="built_in">Serialize</span>();  <span class="comment">// 序列化为&quot;x op y&quot;格式</span></span><br><span class="line">        content = <span class="built_in">Encode</span>(content);        <span class="comment">// 添加协议头尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 发送请求到服务器</span></span><br><span class="line">        <span class="built_in">send</span>(sockfd, content.<span class="built_in">c_str</span>(), content.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 接收服务器响应</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[n] = <span class="number">0</span>;          <span class="comment">// 添加字符串结束符</span></span><br><span class="line">        recv_str += buffer;      <span class="comment">// 累积接收的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 解析并处理响应</span></span><br><span class="line">        Response resp;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string content;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">Decode</span>(recv_str, content)) <span class="keyword">break</span>;  <span class="comment">// 解码协议</span></span><br><span class="line">            </span><br><span class="line">            resp.<span class="built_in">Deserialize</span>(content);  <span class="comment">// 反序列化响应数据</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; resp.res_ &lt;&lt; <span class="string">&quot;, code: &quot;</span> &lt;&lt; resp.code_ &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="代码实现思路说明">代码实现思路说明</span></h4><ol><li><p><strong>基本流程</strong>：</p><ul><li>接收用户输入的两个数字和运算符</li><li>将输入序列化为协议格式并发送给服务器</li><li>接收服务器响应并解析显示结果</li><li>循环这个过程实现持续计算</li></ul></li><li><p><strong>协议处理</strong>：</p><ul><li>使用<code>Request</code>类序列化用户输入（格式：”x op y”）</li><li>通过<code>Encode</code>添加协议头尾（长度前缀和分隔符）</li><li>接收时使用<code>Decode</code>解析完整数据包</li><li>用<code>Response</code>类解析服务器返回的结果和状态码</li></ul></li><li><p><strong>网络通信</strong>：</p><ul><li>使用TCP socket连接服务器</li><li>发送序列化后的请求数据</li><li>接收响应数据并累积（处理可能的分包情况）</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>遵循严格的协议格式</li><li>支持持续交互（不退出）</li><li>基本的错误处理（接收错误退出）</li><li>显示完整的计算结果和状态码</li></ul></li></ol><h3><span id="服务端">服务端</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>           <span class="comment">// 智能指针头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_cal.hpp&quot;</span>   <span class="comment">// 计算器服务实现</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcpserver.hpp&quot;</span>    <span class="comment">// TCP服务器实现</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 参数检查：需要指定服务端口</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;\nUsage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; server_port\n&quot;</span></span><br><span class="line">              &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建计算器服务实例</span></span><br><span class="line">    ServerCal sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP服务器实例：</span></span><br><span class="line">    <span class="comment">// 1. 使用unique_ptr管理资源</span></span><br><span class="line">    <span class="comment">// 2. 端口号从命令行参数获取</span></span><br><span class="line">    <span class="comment">// 3. 绑定ServerCal::Calculator方法作为协议处理器</span></span><br><span class="line">    <span class="function">unique_ptr&lt;TcpServer&gt; <span class="title">ts</span><span class="params">(<span class="keyword">new</span> TcpServer(</span></span></span><br><span class="line"><span class="params"><span class="function">        stoi(argv[<span class="number">1</span>]),                      <span class="comment">// 服务端口</span></span></span></span><br><span class="line"><span class="params"><span class="function">        bind(&amp;ServerCal::Calculator,        <span class="comment">// 绑定成员函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">             &amp;sc,                          <span class="comment">// 对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">             placeholders::_1)             <span class="comment">// 占位符表示参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器（创建socket+绑定端口+监听）</span></span><br><span class="line">    ts-&gt;<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器主循环</span></span><br><span class="line">    ts-&gt;<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就讲自定义协议的计算服务实现了，下面我们来测试一下这段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/protocol</span><br><span class="line">╰─➤  ./client_cal.o 82.156.255.140 7788</span><br><span class="line">Please Enter x: 1</span><br><span class="line">Please Enter y: 2</span><br><span class="line">Please Enter op: +</span><br><span class="line">result: 3, code: 0</span><br><span class="line">Please Enter x: 3</span><br><span class="line">Please Enter y: 2</span><br><span class="line">Please Enter op: -</span><br><span class="line">result: 1, code: 0</span><br><span class="line">Please Enter x: 1</span><br><span class="line">Please Enter y: 4</span><br><span class="line">Please Enter op: /</span><br><span class="line">result: 0, code: 0</span><br><span class="line">Please Enter x: 3</span><br><span class="line">Please Enter y: 0</span><br><span class="line">Please Enter op: /</span><br><span class="line">result: 0, code: 1</span><br><span class="line">Please Enter x: 2</span><br><span class="line">Please Enter y: 3</span><br><span class="line">Please Enter op: %</span><br><span class="line">result: 2, code: 0</span><br><span class="line">Please Enter x: 2</span><br><span class="line">Please Enter y: 0</span><br><span class="line">Please Enter op: %</span><br><span class="line">result: 0, code: 1</span><br><span class="line">Please Enter x: 2</span><br><span class="line">Please Enter y: 1</span><br><span class="line">Please Enter op: &amp;</span><br><span class="line">result: 0, code: 2</span><br></pre></td></tr></table></figure><p>客户端若输入的不是数字，就会导致未定义行为，因为我们对 <code>x</code> 和 <code>y</code> 的类型定义的是 <code>int</code> 类型，因此我们可以将 <code>x</code> 和 <code>y</code> 的类型定义为 <code>string</code> 类型，然后通过 <code>std::stoi()</code> 函数来转换为 <code>int</code> 类型，如果转换失败，就说明输入的不是数字，我们就可以提示用户重新输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">string x_str, y_str;</span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 输入x并验证</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please Enter x: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; x_str;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">stoi</span>(x_str);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 转换成功则退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Invalid number! Please enter an integer.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入y并验证</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please Enter y: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; y_str;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="built_in">stoi</span>(y_str);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 转换成功则退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid number! Please enter an integer.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后，我们就可以正确处理客户端的输入错误了，而且这些检查都是在客户端做的，而不是让数据传递带服务端再做检查，一举两得</p><p>测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/protocol</span><br><span class="line">╰─➤  ./client_cal.o 82.156.255.140 7788</span><br><span class="line">Please Enter x: 1</span><br><span class="line">Please Enter y: +</span><br><span class="line">Invalid number! Please enter an integer.</span><br><span class="line">Please Enter y: %</span><br><span class="line">Invalid number! Please enter an integer.</span><br><span class="line">Please Enter y: 3</span><br><span class="line">Please Enter op: (</span><br><span class="line">result: 0, code: 2</span><br><span class="line">Please Enter x: 3</span><br><span class="line">Please Enter y: 2</span><br><span class="line">Please Enter op: +</span><br><span class="line">result: 5, code: 0</span><br></pre></td></tr></table></figure><p>当然，序列化和反序列化是可以通过更简单的方式来处理的，我们可以利用一些比较成熟的序列化技术来更简单地实现序列化：</p><p>下面我们使用 <code>JSON</code> 来对数据进行序列化和反序列化：</p><h3><span id="json格式化实现">JSON格式化实现</span></h3><p>以下是添加了详细注释的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PROTOCOL_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PROTOCOL_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jsoncpp/json/json.h&gt;</span>  <span class="comment">// JSON库头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分隔符定义（虽然改用JSON后部分不再需要，但保留协议兼容性）</span></span><br><span class="line"><span class="type">const</span> std::string blank_space_sep = <span class="string">&quot; &quot;</span>;  <span class="comment">// 空格分隔符</span></span><br><span class="line"><span class="type">const</span> std::string protocol_sep = <span class="string">&quot;\n&quot;</span>;    <span class="comment">// 协议分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码枚举</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    divide_by_zero_error = <span class="number">1</span>,  <span class="comment">// 除零错误</span></span><br><span class="line">    operator_identify,         <span class="comment">// 操作符识别错误</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 协议解码函数（兼容旧协议）</span></span><br><span class="line"><span class="comment"> * 参数: package - 输入的数据包</span></span><br><span class="line"><span class="comment"> *       content - 输出的解码后内容</span></span><br><span class="line"><span class="comment"> * 返回值: 解码成功返回true，失败返回false</span></span><br><span class="line"><span class="comment"> * 注意: 改用JSON后不再严格检查格式，但仍保留长度前缀机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Decode</span><span class="params">(std::string &amp;package, std::string &amp;content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找第一个分隔符位置</span></span><br><span class="line">    <span class="type">size_t</span> pos = package.<span class="built_in">find</span>(protocol_sep);</span><br><span class="line">    <span class="keyword">if</span>(pos == std::string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取JSON内容长度</span></span><br><span class="line">    <span class="type">size_t</span> size = std::<span class="built_in">stoi</span>(package.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">    <span class="type">size_t</span> total_len = pos + size + <span class="number">2</span>;  <span class="comment">// 计算总长度(长度+分隔符+内容+分隔符)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提取JSON内容</span></span><br><span class="line">    content = package.<span class="built_in">substr</span>(pos + <span class="number">1</span>, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除已处理的数据</span></span><br><span class="line">    package.<span class="built_in">erase</span>(<span class="number">0</span>, total_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 协议编码函数</span></span><br><span class="line"><span class="comment"> * 参数: content - 要编码的JSON内容</span></span><br><span class="line"><span class="comment"> * 返回值: 添加长度前缀的协议字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">Encode</span><span class="params">(std::string &amp;content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string ret = std::<span class="built_in">to_string</span>(content.<span class="built_in">size</span>());  <span class="comment">// 添加长度前缀</span></span><br><span class="line">    ret += protocol_sep;                               <span class="comment">// 添加分隔符</span></span><br><span class="line">    ret += content;                                    <span class="comment">// 添加JSON内容</span></span><br><span class="line">    ret += protocol_sep;                               <span class="comment">// 添加结束分隔符</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求类（客户端→服务端）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（默认值表示无效请求）</span></span><br><span class="line">    <span class="built_in">Request</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">char</span> op = <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    :<span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">op_</span>(op)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 序列化为JSON字符串</span></span><br><span class="line"><span class="comment">     * 格式: &#123;&quot;x&quot;:数值, &quot;y&quot;:数值, &quot;op&quot;:操作符&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">std::string <span class="title">Serialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Json::Value root;          <span class="comment">// 创建JSON根节点</span></span><br><span class="line">        root[<span class="string">&quot;x&quot;</span>] = x_;           <span class="comment">// 添加x字段</span></span><br><span class="line">        root[<span class="string">&quot;y&quot;</span>] = y_;           <span class="comment">// 添加y字段</span></span><br><span class="line">        root[<span class="string">&quot;op&quot;</span>] = op_;         <span class="comment">// 添加op字段</span></span><br><span class="line">        Json::StyledWriter w;      <span class="comment">// 使用格式化写入器</span></span><br><span class="line">        <span class="keyword">return</span> w.<span class="built_in">write</span>(root);      <span class="comment">// 生成JSON字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从JSON字符串反序列化</span></span><br><span class="line"><span class="comment">     * 参数: in - 输入的JSON字符串</span></span><br><span class="line"><span class="comment">     * 返回值: 解析成功返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Deserialize</span><span class="params">(std::string &amp;in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Json::Value root;         <span class="comment">// 创建JSON根节点</span></span><br><span class="line">        Json::Reader r;          <span class="comment">// JSON解析器</span></span><br><span class="line">        <span class="keyword">if</span>(!r.<span class="built_in">parse</span>(in, root))   <span class="comment">// 解析JSON</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        x_ = root[<span class="string">&quot;x&quot;</span>].<span class="built_in">asInt</span>();   <span class="comment">// 读取x值</span></span><br><span class="line">        y_ = root[<span class="string">&quot;y&quot;</span>].<span class="built_in">asInt</span>();   <span class="comment">// 读取y值</span></span><br><span class="line">        op_ = root[<span class="string">&quot;op&quot;</span>].<span class="built_in">asInt</span>(); <span class="comment">// 读取op值(注意: 这里可能有类型问题)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x_;     <span class="comment">// 第一个操作数</span></span><br><span class="line">    <span class="type">int</span> y_;     <span class="comment">// 第二个操作数</span></span><br><span class="line">    <span class="type">char</span> op_;   <span class="comment">// 操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应类（服务端→客户端）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Response</span>(<span class="type">int</span> res = <span class="number">0</span>, <span class="type">int</span> code = <span class="number">0</span>)</span><br><span class="line">    :<span class="built_in">res_</span>(res), <span class="built_in">code_</span>(code)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 序列化为JSON字符串</span></span><br><span class="line"><span class="comment">     * 格式: &#123;&quot;res&quot;:结果, &quot;code&quot;:状态码&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">std::string <span class="title">Serialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Json::Value root;</span><br><span class="line">        root[<span class="string">&quot;res&quot;</span>] = res_;       <span class="comment">// 添加结果字段</span></span><br><span class="line">        root[<span class="string">&quot;code&quot;</span>] = code_;     <span class="comment">// 添加状态码字段</span></span><br><span class="line">        Json::StyledWriter w;</span><br><span class="line">        <span class="keyword">return</span> w.<span class="built_in">write</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从JSON字符串反序列化</span></span><br><span class="line"><span class="comment">     * 参数: in - 输入的JSON字符串</span></span><br><span class="line"><span class="comment">     * 返回值: 解析成功返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Deserialize</span><span class="params">(std::string &amp;in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Json::Value root;</span><br><span class="line">        Json::Reader r;</span><br><span class="line">        <span class="keyword">if</span>(!r.<span class="built_in">parse</span>(in, root))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        res_ = root[<span class="string">&quot;res&quot;</span>].<span class="built_in">asInt</span>();    <span class="comment">// 读取结果值</span></span><br><span class="line">        code_ = root[<span class="string">&quot;code&quot;</span>].<span class="built_in">asInt</span>();  <span class="comment">// 读取状态码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res_;    <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="type">int</span> code_;   <span class="comment">// 状态码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol><li><p><strong>JSON序列化</strong>：</p><ul><li>使用<code>Json::Value</code>作为数据容器</li><li><code>StyledWriter</code>生成格式化的JSON字符串</li><li><code>Reader</code>解析JSON字符串</li></ul></li><li><p><strong>协议兼容性</strong>：</p><ul><li>保留原有的长度前缀机制</li><li>外层协议格式不变，仅内容改为JSON</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>更易扩展新字段</li><li>数据结构更清晰</li><li>支持嵌套复杂数据结构</li><li>跨语言兼容性更好</li></ul></li></ol><p>学会合理地使用外部工具，是一个程序员的必备技能</p><p>下面是整个服务器客户端的数据处理流程图，希望对你有帮助：</p><pre class="mermaid">flowchart LR    subgraph 客户端        A[启动客户端] --> B[建立TCP连接]        B --> C[输入x,y,op]        subgraph 接收循环[接收响应循环]        C --> D[序列化Request为JSON]        D --> E[添加长度前缀协议封装]        E --> F[发送数据]        F --> G{接收数据}        G -->|成功| H[累积到recv_buffer]                    H --> I{尝试解码}            I -->|完整包| J[解析JSON响应]            I -->|不完整| C            J --> K[显示结果]            K --> I        end    end    subgraph 服务端        M[启动服务] --> N[监听端口]        N --> O[接受连接]                subgraph 处理循环[请求处理循环]            O --> P{接收数据}            P -->|成功| Q[累积到recv_buffer]            Q --> R{尝试解码}            R -->|完整包| S[解析JSON请求]            R -->|不完整| P            S --> T[执行计算逻辑]            T --> U[序列化Response为JSON]            U --> V[添加长度前缀协议封装]            V --> W[发送响应]            W --> R            P -->|失败| X[关闭连接]        end    end    客户端 -- 请求 --> 服务端    服务端 -- 响应 --> 客户端</pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket 套接字编程-TCP</title>
      <link href="/2025/07/29/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/socket_tcp/"/>
      <url>/2025/07/29/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/socket_tcp/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%9F%BA%E7%A1%80%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1">基础通信框架设计</a><ul><li><a href="#tcphpp">tcp.hpp</a></li><li><a href="#tcp_serverhpp">tcp_server.hpp</a></li><li><a href="#%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95">功能测试</a></li></ul></li><li><a href="#%E5%88%A9%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E6%89%B9%E9%87%8F%E8%BF%9E%E6%8E%A5">利用线程池处理批量连接</a></li><li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B7%BB%E5%8A%A0%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6">客户端添加重连机制</a></li><li><a href="#%E5%B0%81%E8%A3%85%E6%88%90%E7%AE%80%E5%8D%95%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1">封装成简单的聊天服务</a></li></ul><!-- tocstop --><p>接下来，我将实现一个基于 <code>TCP</code> 的 <code>Socket</code> 套接字编程示例。这个示例将包括一个简单的服务器和客户端，服务器将监听特定端口，客户端将连接到该端口并发送消息。</p><h2><span id="基础通信框架设计">基础通信框架设计</span></h2><h3><span id="tcphpp">tcp.hpp</span></h3><p>这是一个简单的 <code>TCP</code> 网络编程工具头文件，封装了基本的 <code>TCP socket</code> 操作，包括创建 <code>socket</code> 、绑定端口、监听连接和建立连接等功能。代码使用了 <code>C++</code> 风格封装，同时底层调用 <code>Linux</code> 系统socket API。</p><p>文件结构：</p><ul><li>头文件保护宏：防止重复包含</li><li>必要的系统头文件引入</li><li>错误码枚举定义</li><li>线程本地存储的地址缓冲区</li><li><code>tcp</code> 命名空间包含所有功能函数</li></ul><p>详细注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TCP_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TCP_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入必要的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  <span class="comment">// socket相关系统调用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// 互联网地址族</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// 地址转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>       <span class="comment">// bzero等字符串操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>       <span class="comment">// 自定义日志头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码枚举定义</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    socket_error = <span class="number">1</span>,  <span class="comment">// socket创建失败</span></span><br><span class="line">    bind_error,        <span class="comment">// 绑定端口失败</span></span><br><span class="line">    listen_error,      <span class="comment">// 监听失败</span></span><br><span class="line">    connect_error,     <span class="comment">// 连接失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程本地存储的地址缓冲区，用于地址转换</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">thread_local</span> <span class="type">char</span> addr_buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP相关功能封装命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> tcp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建TCP socket</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建IPv4的TCP socket</span></span><br><span class="line">        <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);      <span class="comment">// 打印错误信息</span></span><br><span class="line">            <span class="built_in">exit</span>(socket_error);    <span class="comment">// 退出程序并返回错误码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sockfd;             <span class="comment">// 返回socket文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到指定端口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;  <span class="comment">// 定义IPv4地址结构</span></span><br><span class="line">        <span class="built_in">bzero</span>(&amp;local, <span class="built_in">sizeof</span>(local));  <span class="comment">// 清空结构体</span></span><br><span class="line">        local.sin_family = AF_INET;    <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">        local.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 监听所有网络接口</span></span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 将端口号转换为网络字节序</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定socket到地址</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)(&amp;local), <span class="built_in">sizeof</span>(local));</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(bind_error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从sockaddr_in结构体提取IP地址和端口号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetAddrAndPort</span><span class="params">(<span class="keyword">struct</span> sockaddr_in &amp;addr_in, std::string &amp;addr, <span class="type">uint16_t</span> &amp;port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        port = <span class="built_in">ntohs</span>(addr_in.sin_port);  <span class="comment">// 网络字节序转主机字节序</span></span><br><span class="line">        <span class="comment">// 将IP地址从二进制转换为点分十进制字符串</span></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr_in.sin_addr, addr_buffer, <span class="built_in">sizeof</span>(addr_buffer) - <span class="number">1</span>);</span><br><span class="line">        addr = addr_buffer;  <span class="comment">// 将结果存入输出参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听socket连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> listen_sock, <span class="type">int</span> backlog = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 设置监听队列长度为backlog(默认10)</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">listen</span>(listen_sock, backlog);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(listen_error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到指定服务器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">int</span> sockfd, sockaddr_in &amp;server)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试建立TCP连接</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="built_in">sizeof</span>(server));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(connect_error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>功能说明：</p><ol><li>Socket() - 创建 <code>TCP socket</code> 文件描述符</li><li>Bind() - 将 <code>socket</code> 绑定到指定端口</li><li>Listen() - 开始监听连接请求</li><li>Connect() - 作为客户端连接到服务器</li><li>GetAddrAndPort() - 辅助函数，用于从地址结构中提取可读的IP和端口</li></ol><h3><span id="tcp_serverhpp">tcp_server.hpp</span></h3><p>这是一个简单的<code>TCP</code>服务器实现，基于之前封装的<code>tcp.hpp</code>基础功能。它提供了完整的服务器工作流程，包括初始化、监听和客户端请求处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TCP_SERVER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TCP_SERVER_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span>   <span class="comment">// 引入之前封装的TCP基础功能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>   <span class="comment">// 引入日志功能</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">u_int16_t</span> default_port = <span class="number">8888</span>;  <span class="comment">// 默认监听端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP服务器类封装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，可指定端口(默认使用default_port)</span></span><br><span class="line">    <span class="built_in">TcpServer</span>(<span class="type">u_int16_t</span> port = default_port)</span><br><span class="line">        : <span class="built_in">port_</span>(port)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        listen_sockfd_ = tcp::<span class="built_in">Socket</span>();  <span class="comment">// 创建监听socket</span></span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;listening sock create success, sockfd: %d&quot;</span>, listen_sockfd_);</span><br><span class="line">        tcp::<span class="built_in">Bind</span>(listen_sockfd_, port_);  <span class="comment">// 绑定端口</span></span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;listening sock bind success&quot;</span>);</span><br><span class="line">        tcp::<span class="built_in">Listen</span>(listen_sockfd_);      <span class="comment">// 开始监听</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器主循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)  <span class="comment">// 无限循环接受客户端连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;   <span class="comment">// 客户端地址结构</span></span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">            <span class="comment">// 接受客户端连接</span></span><br><span class="line">            <span class="type">int</span> client_sockfd = <span class="built_in">accept</span>(listen_sockfd_, (sockaddr *)&amp;client, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;listening sock accept false, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取客户端地址和端口信息</span></span><br><span class="line">            std::string client_addr;</span><br><span class="line">            <span class="type">u_int16_t</span> client_port;</span><br><span class="line">            tcp::<span class="built_in">GetAddrAndPort</span>(client, client_addr, client_port);</span><br><span class="line">            <span class="built_in">lg</span>(Info, <span class="string">&quot;accept a new client [%s: %d]&quot;</span>, client_addr.<span class="built_in">c_str</span>(), client_port);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理客户端请求</span></span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">Server</span>(client_sockfd, buffer, <span class="built_in">sizeof</span>(buffer), client_addr, client_port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端连接的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Server</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;client_sockfd, <span class="type">char</span> *buffer, <span class="type">size_t</span> len, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> std::string &amp;client_addr = <span class="string">&quot;*&quot;</span>, <span class="type">const</span> <span class="type">u_int16_t</span> client_port = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否需要打印客户端信息</span></span><br><span class="line">        <span class="type">bool</span> print_inf = !(client_addr == <span class="string">&quot;*&quot;</span> || client_port == <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)  <span class="comment">// 与客户端的通信循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收客户端数据</span></span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(client_sockfd, buffer, len - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">-1</span>)  <span class="comment">// 接收错误</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (print_inf)</span><br><span class="line">                    <span class="built_in">lg</span>(Error, <span class="string">&quot;accept error, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)  <span class="comment">// 客户端断开连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (print_inf)</span><br><span class="line">                    <span class="built_in">lg</span>(Info, <span class="string">&quot;client [%s: %d] quit&quot;</span>, client_addr.<span class="built_in">c_str</span>(), client_port);</span><br><span class="line">                <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 正常接收数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                buffer[n] = <span class="number">0</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">                <span class="keyword">if</span> (print_inf)</span><br><span class="line">                    <span class="built_in">lg</span>(Info, <span class="string">&quot;server get a message from client [%s: %d]: %s&quot;</span>, </span><br><span class="line">                       client_addr.<span class="built_in">c_str</span>(), client_port, buffer);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 回显数据给客户端</span></span><br><span class="line">                <span class="type">ssize_t</span> m = <span class="built_in">send</span>(client_sockfd, buffer, n, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (m == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">lg</span>(Error, <span class="string">&quot;send error, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">u_int16_t</span> port_;         <span class="comment">// 服务器监听端口</span></span><br><span class="line">    <span class="type">int</span> listen_sockfd_;      <span class="comment">// 监听socket文件描述符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>主要组件：</p><ol><li><p><code>TcpServer</code>类：封装了<code>TCP</code>服务器的核心功能</p><ul><li>构造函数：可以指定监听端口，默认使用<code>8888</code></li><li><code>Init()</code>方法：初始化服务器，创建<code>socket</code>、绑定端口并开始监听</li><li><code>Start()</code>方法：启动服务器主循环，接受客户端连接</li><li><code>Server()</code>方法：处理单个客户端连接</li></ul></li><li><p>成员变量：</p><ul><li><code>port_</code>：服务器监听端口</li><li><code>listen_sockfd_</code>：监听<code>socket</code>的文件描述符</li></ul></li></ol><p>工作流程：</p><ol><li>创建<code>TcpServer</code>实例时指定端口（可选）</li><li>调用<code>Init()</code>初始化服务器</li><li>调用<code>Start()</code>启动服务器主循环<ul><li>使用<code>accept()</code>接受客户端连接</li><li>为每个客户端创建连接并调用<code>Server()</code>处理</li></ul></li><li>在<code>Server()</code>方法中：<ul><li>使用<code>recv()</code>接收客户端数据</li><li>使用<code>send()</code>回显数据给客户端</li><li>检测连接断开情况并关闭<code>socket</code></li></ul></li></ol><p>功能特点：</p><ul><li>使用<code>lg</code>宏记录日志信息</li><li>支持显示客户端地址和端口</li><li>简单的回显服务器功能</li><li>基本的错误处理和日志记录</li></ul><h3><span id="功能测试">功能测试</span></h3><p>下面这两段代码利用上面的头文件分别实现了客户端和服务端：</p><p>客户端代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span>  <span class="comment">// 引入自定义的TCP封装库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数是否正确（需要服务器IP和端口两个参数）</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; server_ip server_port&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令行参数获取服务器IP和端口</span></span><br><span class="line">    string server_ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint16_t</span> server_port = <span class="built_in">stoi</span>(argv[<span class="number">2</span>]);  <span class="comment">// 将端口字符串转换为整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端socket</span></span><br><span class="line">    <span class="type">int</span> sockfd = tcp::<span class="built_in">Socket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;server, <span class="built_in">sizeof</span>(server));  <span class="comment">// 清空结构体</span></span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(server_port);  <span class="comment">// 设置端口（转换为网络字节序）</span></span><br><span class="line">    server.sin_family = AF_INET;  <span class="comment">// 使用IPv4协议</span></span><br><span class="line">    server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>());  <span class="comment">// 设置服务器IP地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    tcp::<span class="built_in">Connect</span>(sockfd, server);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环：与服务器交互</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string inbuffer;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter# &quot;</span>;  <span class="comment">// 提示用户输入</span></span><br><span class="line">        <span class="built_in">getline</span>(cin, inbuffer);    <span class="comment">// 获取用户输入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据到服务器</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">send</span>(sockfd, inbuffer.<span class="built_in">c_str</span>(), inbuffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)  <span class="comment">// 发送成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">1024</span>];  <span class="comment">// 接收缓冲区</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 接收服务器回应（这里定义但不使用temp，因为TCP不需要关心发送方信息）</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> temp;</span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(temp);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">            <span class="type">ssize_t</span> m = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (m &gt; <span class="number">0</span>)  <span class="comment">// 成功接收到数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                buffer[m] = <span class="number">0</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;server echo# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;  <span class="comment">// 打印服务器回应</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)  <span class="comment">// 服务器关闭连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;server [%s: %d] quit&quot;</span>, server_ip.<span class="built_in">c_str</span>(), server_port);</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 接收出错</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 发送失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>       <span class="comment">// 用于智能指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_server.hpp&quot;</span> <span class="comment">// 引入自定义的TCP服务器类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> port; <span class="comment">// 声明端口变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理命令行参数</span></span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>) <span class="comment">// 如果没有参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        port = <span class="number">8080</span>; <span class="comment">// 使用默认端口8080</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">2</span>) <span class="comment">// 如果有一个参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        port = <span class="built_in">stoi</span>(argv[<span class="number">1</span>]); <span class="comment">// 将参数转换为整数作为端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果参数过多</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 显示用法说明</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;(default port: 8080)&quot;</span> &lt;&lt; endl </span><br><span class="line">             &lt;&lt; <span class="string">&quot;OR&quot;</span> &lt;&lt; endl </span><br><span class="line">             &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; port&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 非正常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用unique_ptr智能指针创建TcpServer实例</span></span><br><span class="line">    <span class="comment">// 这样可以自动管理内存，避免内存泄漏</span></span><br><span class="line">    <span class="function">unique_ptr&lt;TcpServer&gt; <span class="title">us</span><span class="params">(<span class="keyword">new</span> TcpServer(port))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器</span></span><br><span class="line">    us-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动服务器主循环</span></span><br><span class="line">    us-&gt;<span class="built_in">Start</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试，客户端与服务端可以正常通信：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp</span><br><span class="line">╰─➤  ./tcp_client.o 127.0.0.1 7777</span><br><span class="line">Please Enter# hello!</span><br><span class="line">server echo# hello!</span><br><span class="line">Please Enter# I am a human</span><br><span class="line">server echo# I am a human</span><br><span class="line">Please Enter# bye!</span><br><span class="line">server echo# bye!</span><br><span class="line">Please Enter# ^C</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp  </span><br><span class="line">╰─➤  ./main.o 7777                </span><br><span class="line">[Info][2025-7-29 22:11:38] listening sock create success, sockfd: 3</span><br><span class="line">[Info][2025-7-29 22:11:38] listening sock bind success</span><br><span class="line">[Info][2025-7-29 22:11:41] accept a new client [127.0.0.1: 59872]</span><br><span class="line">[Info][2025-7-29 22:11:46] server get a message from client [127.0.0.1: 59872]: hello!</span><br><span class="line">[Info][2025-7-29 22:11:54] server get a message from client [127.0.0.1: 59872]: I am a human</span><br><span class="line">[Info][2025-7-29 22:12:5] server get a message from client [127.0.0.1: 59872]: bye!</span><br><span class="line">[Info][2025-7-29 22:12:8] client [127.0.0.1: 59872] quit</span><br></pre></td></tr></table></figure><h2><span id="利用线程池处理批量连接">利用线程池处理批量连接</span></h2><p>线程池代码如下：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREAD_POOL_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREAD_POOL_HPP_ 1;  <span class="comment">// 防止头文件重复包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>          <span class="comment">// POSIX线程库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span>      <span class="comment">// 哈希表，用于存储线程信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>              <span class="comment">// 任务队列</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> default_cap = <span class="number">20</span>; <span class="comment">// 默认线程池容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动加解锁的RAII封装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockGuard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数自动加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockGuard</span><span class="params">(<span class="type">pthread_mutex_t</span> &amp;mtx)</span></span></span><br><span class="line"><span class="function">        : mtx_(mtx)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mtx_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数自动解锁</span></span><br><span class="line">    ~<span class="built_in">LockGuard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mtx_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">LockGuard</span>(<span class="type">const</span> LockGuard &amp;) = <span class="keyword">delete</span>;            </span><br><span class="line">    LockGuard &amp;<span class="keyword">operator</span>=(<span class="type">const</span> LockGuard &amp;) = <span class="keyword">delete</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> &amp;mtx_;  <span class="comment">// 引用管理的互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 检查任务队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmptyQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tasks_.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从任务队列头部取出一个任务</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T task = tasks_.<span class="built_in">front</span>();</span><br><span class="line">        tasks_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程数据传递结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_data</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::string name;    <span class="comment">// 线程名称</span></span><br><span class="line">        ThreadPool&lt;T&gt; *tp;   <span class="comment">// 所属线程池指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取线程池单例（线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadPool&lt;T&gt; &amp;<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// C++11后静态局部变量初始化是线程安全的</span></span><br><span class="line">        <span class="type">static</span> ThreadPool&lt;T&gt; tp;</span><br><span class="line">        <span class="keyword">return</span> tp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        running_ = <span class="literal">true</span>;  <span class="comment">// 设置运行标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建指定数量的工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cap_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string name = <span class="string">&quot;thread-&quot;</span> + std::<span class="built_in">to_string</span>(i);  <span class="comment">// 生成线程名</span></span><br><span class="line">            <span class="type">pthread_t</span> tid;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建线程数据</span></span><br><span class="line">            thread_data *td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">                name : name,</span><br><span class="line">                tp : <span class="keyword">this</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建线程</span></span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, ThreadHandler, (<span class="type">void</span> *)(td));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录线程信息</span></span><br><span class="line">            threads_[tid] = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向线程池添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T &amp;task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">LockGuard <span class="title">lg</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 加锁保护</span></span><br><span class="line">            tasks_.<span class="built_in">push</span>(task);   <span class="comment">// 任务入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先释放锁后唤醒，提高并发效率</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_);  <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">End</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">LockGuard <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            running_ = <span class="literal">false</span>;  <span class="comment">// 设置停止标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 广播唤醒所有等待线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_broadcast</span>(&amp;cond_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[tid, name] : threads_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        threads_.<span class="built_in">clear</span>();  <span class="comment">// 清空线程记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程处理函数（静态成员函数）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">ThreadHandler</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程数据</span></span><br><span class="line">        thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(args);</span><br><span class="line">        ThreadPool&lt;T&gt; *tp = td-&gt;tp;</span><br><span class="line">        std::string thread_name = td-&gt;name;</span><br><span class="line">        T task;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">LockGuard <span class="title">lg</span><span class="params">(tp-&gt;mtx_)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 等待条件：任务队列不为空或线程池停止</span></span><br><span class="line">                <span class="keyword">while</span> (tp-&gt;<span class="built_in">IsEmptyQueue</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tp-&gt;running_)</span><br><span class="line">                        <span class="built_in">pthread_cond_wait</span>(&amp;tp-&gt;cond_, &amp;tp-&gt;mtx_);  <span class="comment">// 等待任务</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">delete</span> td;  <span class="comment">// 清理线程数据</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 线程退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取任务</span></span><br><span class="line">                task = tp-&gt;<span class="built_in">Pop</span>();</span><br><span class="line">            &#125;  <span class="comment">// 自动解锁</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出任务结果（假设T类型有GetResult方法）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, thread_name.<span class="built_in">c_str</span>(), task.<span class="built_in">GetResult</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> td;  <span class="comment">// 理论上不会执行到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数（单例模式）</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> cap = default_cap)</span><br><span class="line">        : <span class="built_in">cap_</span>(cap),          <span class="comment">// 线程容量</span></span><br><span class="line">          <span class="built_in">running_</span>(<span class="literal">false</span>)     <span class="comment">// 初始状态为未运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mtx_, <span class="literal">nullptr</span>);    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;cond_, <span class="literal">nullptr</span>);    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (running_)</span><br><span class="line">            <span class="built_in">End</span>();  <span class="comment">// 如果还在运行，先停止</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mtx_);   <span class="comment">// 销毁互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;cond_);   <span class="comment">// 销毁条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">const</span> ThreadPool&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">pthread_t</span>, std::string&gt; threads_;  <span class="comment">// 线程ID与名称映射</span></span><br><span class="line">    <span class="type">size_t</span> cap_;                     <span class="comment">// 线程池容量</span></span><br><span class="line">    std::queue&lt;T&gt; tasks_;            <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mtx_;            <span class="comment">// 保护任务队列的互斥锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> cond_;            <span class="comment">// 任务通知条件变量</span></span><br><span class="line">    <span class="type">bool</span> running_;                   <span class="comment">// 线程池运行标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock_ = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>    </div></div><p>如果对线程池实现不清楚的，可以跳转查看：<a href="https://liujiaxuan69.github.io/2025/07/27/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_pool/" title="跳转到线程池实现">线程池实现</a></p><p>我们需要给线程池传递一个任务对象，因此需要定义一个任务类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TASK_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TASK_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  <span class="comment">// socket相关系统调用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">// 标准库函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>       <span class="comment">// 自定义日志功能</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程本地存储的缓冲区，每个线程独立一份，避免竞争</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务处理类，封装客户端请求处理逻辑</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 用于处理单个客户端的通信任务，支持函数对象调用方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     * @param client_sockfd 客户端socket文件描述符</span></span><br><span class="line"><span class="comment">     * @param client_addr 客户端IP地址（默认&quot;*&quot;表示不指定）</span></span><br><span class="line"><span class="comment">     * @param client_port 客户端端口号（默认-1表示不指定）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> client_sockfd = <span class="number">-1</span>, std::string client_addr = <span class="string">&quot;*&quot;</span>, <span class="type">u_int16_t</span> client_port = <span class="number">-1</span>)</span><br><span class="line">    : <span class="built_in">client_sockfd_</span>(client_sockfd),</span><br><span class="line">      <span class="built_in">client_addr_</span>(client_addr),</span><br><span class="line">      <span class="built_in">client_port_</span>(client_port)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 处理客户端请求的核心方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 接收客户端消息</span></span><br><span class="line"><span class="comment">     * 2. 记录日志</span></span><br><span class="line"><span class="comment">     * 3. 回显消息给客户端</span></span><br><span class="line"><span class="comment">     * 4. 关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Server</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否需要打印客户端信息（当有具体客户端信息时需要打印）</span></span><br><span class="line">        <span class="type">bool</span> print_inf = !(client_addr_ == <span class="string">&quot;*&quot;</span> || client_port_ == <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收客户端数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(client_sockfd_, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)  <span class="comment">// 接收出错</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (print_inf)</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;accept error, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)  <span class="comment">// 客户端关闭连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (print_inf)</span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;client [%s: %d] quit&quot;</span>, client_addr_.<span class="built_in">c_str</span>(), client_port_);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 正常接收数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="number">0</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (print_inf)</span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;server get a message from client [%s: %d]: %s&quot;</span>, </span><br><span class="line">                   client_addr_.<span class="built_in">c_str</span>(), client_port_, buffer);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 回显数据给客户端</span></span><br><span class="line">            <span class="type">ssize_t</span> m = <span class="built_in">send</span>(client_sockfd_, buffer, n, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">-1</span>)  <span class="comment">// 发送失败</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;send error, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭客户端连接</span></span><br><span class="line">        <span class="built_in">close</span>(client_sockfd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 函数对象运算符重载</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使Task对象可以像函数一样被调用，便于线程池等场景使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Server</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> client_sockfd_;        <span class="comment">// 客户端socket文件描述符</span></span><br><span class="line">    std::string client_addr_;  <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="type">u_int16_t</span> client_port_;    <span class="comment">// 客户端端口号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而后，我们只需要将客户的信息传递到任务类中，将该任务传递到线程池中即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">            <span class="type">int</span> client_sockfd = <span class="built_in">accept</span>(listen_sockfd_, (sockaddr *)&amp;client, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;listening sock accept false, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">            std::string client_addr;</span><br><span class="line">            <span class="type">u_int16_t</span> client_port;</span><br><span class="line">            tcp::<span class="built_in">GetAddrAndPort</span>(client, client_addr, client_port);</span><br><span class="line">            <span class="built_in">lg</span>(Info, <span class="string">&quot;accept a new client [%s: %d]&quot;</span>, client_addr.<span class="built_in">c_str</span>(), client_port);</span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">/* 被修改部分 */</span></span><br><span class="line">            <span class="comment">// Server(client_sockfd, buffer, sizeof(buffer), client_addr, client_port);</span></span><br><span class="line">            <span class="function">Task <span class="title">t</span><span class="params">(client_sockfd, client_addr, client_port)</span></span>;</span><br><span class="line">            ThreadPool&lt;Task&gt;::<span class="built_in">GetInstance</span>().<span class="built_in">Push</span>(t);</span><br><span class="line">            <span class="comment">/* END */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端中，我们需要将套接字创建和连接服务端放到循环内部，从而使得每次发送信息都会建立一个新的连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建套接字并连接服务器（移到循环内部）</span></span><br><span class="line">        <span class="type">int</span> sockfd = tcp::<span class="built_in">Socket</span>();</span><br><span class="line">        tcp::<span class="built_in">Connect</span>(sockfd, server);</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行后，我们会发现客户端每次发送信息都会建立一个新的连接，利用线程池，避免了一个用户一个线程从而使得资源耗尽的情况。线程池会将资源均匀分给所有的在线用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp  </span><br><span class="line">╰─➤  ./main.o 7777                </span><br><span class="line">[Info][2025-7-29 22:51:24] listening sock create success, sockfd: 3</span><br><span class="line">[Info][2025-7-29 22:51:24] listening sock bind success</span><br><span class="line">[Info][2025-7-29 22:51:27] accept a new client [127.0.0.1: 38302]</span><br><span class="line">[Info][2025-7-29 22:51:28] server get a message from client [127.0.0.1: 38302]: 123</span><br><span class="line">[Info][2025-7-29 22:51:28] accept a new client [127.0.0.1: 38308]</span><br><span class="line">[Info][2025-7-29 22:51:29] server get a message from client [127.0.0.1: 38308]: 412</span><br><span class="line">[Info][2025-7-29 22:51:29] accept a new client [127.0.0.1: 33648]</span><br><span class="line">[Info][2025-7-29 22:51:30] server get a message from client [127.0.0.1: 33648]: 2342</span><br><span class="line">[Info][2025-7-29 22:51:30] accept a new client [127.0.0.1: 33654]</span><br><span class="line">[Info][2025-7-29 22:51:31] server get a message from client [127.0.0.1: 33654]: 12412</span><br></pre></td></tr></table></figure><h2><span id="客户端添加重连机制">客户端添加重连机制</span></h2><p>我们将 <code>Connect</code> 函数修改为循环检测，给予用户5次机会，每隔2秒重新连接一次，当次数耗尽则终止客户端进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有5次重连机会，每次间隔一秒</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="built_in">sizeof</span>(server)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 进来了说明 connect 连接失败，我们尝试重连</span></span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sorry, I am unable to connect to the designated server\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Try to reconnect..., %d chances remaining\n&quot;</span>, cnt);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp  </span><br><span class="line">╰─➤  ./main.o 7777</span><br><span class="line">[Info][2025-7-29 23:37:22] listening sock create success, sockfd: 3</span><br><span class="line">[Info][2025-7-29 23:37:22] listening sock bind success</span><br><span class="line">[Info][2025-7-29 23:37:24] accept a new client [127.0.0.1: 44352]</span><br><span class="line">[Info][2025-7-29 23:37:26] server get a message from client [127.0.0.1: 44352]: 123</span><br><span class="line">[Info][2025-7-29 23:37:26] accept a new client [127.0.0.1: 44360]</span><br><span class="line">^C        # 服务端故意断开连接</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp  </span><br><span class="line">╰─➤  ./main.o 7777</span><br><span class="line">[Info][2025-7-29 23:37:32] listening sock create success, sockfd: 3</span><br><span class="line">[Info][2025-7-29 23:37:32] listening sock bind success</span><br><span class="line">[Info][2025-7-29 23:37:32] accept a new client [127.0.0.1: 52752]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp</span><br><span class="line">╰─➤  ./tcp_client.o 127.0.0.1 7777</span><br><span class="line">Please Enter# 123</span><br><span class="line">server echo# 123</span><br><span class="line">Please Enter# 124</span><br><span class="line">server [127.0.0.1: 7777] quit</span><br><span class="line">Try to reconnect..., 4 chances remaining</span><br><span class="line">Try to reconnect..., 3 chances remaining</span><br><span class="line">Try to reconnect..., 2 chances remaining</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重连成功</span></span><br><span class="line">Please Enter#</span><br></pre></td></tr></table></figure><h2><span id="封装成简单的聊天服务">封装成简单的聊天服务</span></h2><p>1.客户端修改</p><p>封装成聊天服务需要做的是将收到的信号广播出去，那么，首先我们需要保证客户端的发送数据和接收数据两个行为隔离，这样才能保证用户在发送数据的同时可以接收其他客户端的数据。</p><p>我们通过创建一个线程来实现任务分离，线程通过客户端创建的套接字接收数据，又因为客户端发送一条消息后就会关闭该套接字，因为每次发送完数据后需要回收线程并在下一个循环再创建一个线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理服务器响应的线程函数</span></span><br><span class="line"><span class="comment"> * @param sockfd 客户端套接字描述符</span></span><br><span class="line"><span class="comment"> * @param server_ip 服务器IP地址</span></span><br><span class="line"><span class="comment"> * @param server_port 服务器端口号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Handler</span><span class="params">(<span class="type">const</span> <span class="type">int</span> sockfd, <span class="type">const</span> std::string server_ip, <span class="type">const</span> <span class="type">u_int16_t</span> server_port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];  <span class="comment">// 接收缓冲区</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> temp;  <span class="comment">// 临时存储对端地址(实际未使用)</span></span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(temp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从服务器接收数据(不关心发送方信息)</span></span><br><span class="line">        <span class="type">ssize_t</span> m = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">0</span>)  <span class="comment">// 成功接收到数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[m] = <span class="number">0</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;server echo# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;  <span class="comment">// 打印服务器响应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)  <span class="comment">// 连接已关闭</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server [%s: %d] quit\n&quot;</span>, server_ip.<span class="built_in">c_str</span>(), server_port);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 接收出错</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; server_ip server_port&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析命令行参数</span></span><br><span class="line">    string server_ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint16_t</span> server_port = <span class="built_in">stoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;server, <span class="built_in">sizeof</span>(server));  <span class="comment">// 清空结构体</span></span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(server_port);  <span class="comment">// 设置端口(网络字节序)</span></span><br><span class="line">    server.sin_family = AF_INET;  <span class="comment">// IPv4地址族</span></span><br><span class="line">    server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>());  <span class="comment">// 设置IP地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主循环: 允许用户多次发送请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建TCP套接字</span></span><br><span class="line">        <span class="type">int</span> sockfd = tcp::<span class="built_in">Socket</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建接收线程(在连接前创建以便及时接收响应)</span></span><br><span class="line">        <span class="function">thread <span class="title">receiver</span><span class="params">(Handler, sockfd, server_ip, server_port)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接重试机制(最多尝试5次)</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试连接服务器</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="built_in">sizeof</span>(server)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 连接失败，进行重试</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>)  <span class="comment">// 重试次数用尽</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Sorry, I am unable to connect to the designated server\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Try to reconnect..., %d chances remaining\n&quot;</span>, cnt);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 等待2秒后重试</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取用户输入</span></span><br><span class="line">        string inbuffer;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter# &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, inbuffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送数据到服务器</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">send</span>(sockfd, inbuffer.<span class="built_in">c_str</span>(), inbuffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭套接字并等待接收线程结束</span></span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        receiver.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.服务端修改</p><p>服务端需要在 <code>TcpServer</code> 类当中添加两个函数，一个用于广播数据，另一个用于删除用户，我们利用 <code>unordered_set</code> 来存储所有用户的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcpserver.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TCP_SERVER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TCP_SERVER_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含必要的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp.hpp&quot;</span>          <span class="comment">// TCP基础操作封装</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>          <span class="comment">// 日志模块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_pool.hpp&quot;</span>  <span class="comment">// 线程池实现</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.hpp&quot;</span>         <span class="comment">// 任务类定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span>    <span class="comment">// 哈希集合</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>           <span class="comment">// 互斥锁</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认端口号定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">u_int16_t</span> default_port = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器类</span></span><br><span class="line"><span class="comment"> * 实现多客户端连接管理和消息广播功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * @param port 服务器监听端口，默认为default_port</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">TcpServer</span>(<span class="type">u_int16_t</span> port = default_port)</span><br><span class="line">        : <span class="built_in">port_</span>(port)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化服务器</span></span><br><span class="line"><span class="comment">     * 1. 创建监听套接字</span></span><br><span class="line"><span class="comment">     * 2. 绑定端口</span></span><br><span class="line"><span class="comment">     * 3. 开始监听</span></span><br><span class="line"><span class="comment">     * 4. 启动线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        listen_sockfd_ = tcp::<span class="built_in">Socket</span>();  <span class="comment">// 创建监听套接字</span></span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;listening sock create success, sockfd: %d&quot;</span>, listen_sockfd_);</span><br><span class="line">        tcp::<span class="built_in">Bind</span>(listen_sockfd_, port_);  <span class="comment">// 绑定端口</span></span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;listening sock bind success&quot;</span>);</span><br><span class="line">        tcp::<span class="built_in">Listen</span>(listen_sockfd_);       <span class="comment">// 开始监听</span></span><br><span class="line">        ThreadPool&lt;Task&gt;::<span class="built_in">GetInstance</span>().<span class="built_in">Start</span>();  <span class="comment">// 启动线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务器主循环</span></span><br><span class="line"><span class="comment">     * 1. 接受客户端连接</span></span><br><span class="line"><span class="comment">     * 2. 记录客户端信息</span></span><br><span class="line"><span class="comment">     * 3. 创建任务并提交到线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)  <span class="comment">// 主循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;      <span class="comment">// 客户端地址信息</span></span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 接受客户端连接</span></span><br><span class="line">            <span class="type">int</span> client_sockfd = <span class="built_in">accept</span>(listen_sockfd_, (sockaddr *)&amp;client, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>)  <span class="comment">// 接受连接失败</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;listening sock accept false, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 线程安全地添加客户端套接字到集合</span></span><br><span class="line">            mtx_.<span class="built_in">lock</span>();</span><br><span class="line">            client_sockfds_.<span class="built_in">insert</span>(client_sockfd);</span><br><span class="line">            mtx_.<span class="built_in">unlock</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取客户端地址和端口信息</span></span><br><span class="line">            std::string client_addr;</span><br><span class="line">            <span class="type">u_int16_t</span> client_port;</span><br><span class="line">            tcp::<span class="built_in">GetAddrAndPort</span>(client, client_addr, client_port);</span><br><span class="line">            <span class="built_in">lg</span>(Info, <span class="string">&quot;accept a new client [%s: %d]&quot;</span>, client_addr.<span class="built_in">c_str</span>(), client_port);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建任务对象并提交到线程池</span></span><br><span class="line">            <span class="function">Task <span class="title">t</span><span class="params">(client_sockfd, </span></span></span><br><span class="line"><span class="params"><span class="function">                  std::bind(&amp;TcpServer::broadcast, <span class="keyword">this</span>, std::placeholders::_1),  <span class="comment">// 绑定广播回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  std::bind(&amp;TcpServer::delete_client, <span class="keyword">this</span>, std::placeholders::_1),  <span class="comment">// 绑定删除客户端回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  client_addr, </span></span></span><br><span class="line"><span class="params"><span class="function">                  client_port)</span></span>;</span><br><span class="line">            ThreadPool&lt;Task&gt;::<span class="built_in">GetInstance</span>().<span class="built_in">Push</span>(t);  <span class="comment">// 提交任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播消息给所有客户端</span></span><br><span class="line"><span class="comment">     * @param buffer 要广播的消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">broadcast</span><span class="params">(std::string buffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mtx_.<span class="built_in">lock</span>();  <span class="comment">// 加锁保护客户端集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> sockfd: client_sockfds_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">send</span>(sockfd, buffer.<span class="built_in">c_str</span>(), buffer.<span class="built_in">size</span>(), <span class="number">0</span>);  <span class="comment">// 发送消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        mtx_.<span class="built_in">unlock</span>();  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从客户端集合中删除指定客户端</span></span><br><span class="line"><span class="comment">     * @param sockfd 要删除的客户端套接字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_client</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mtx_.<span class="built_in">lock</span>();  <span class="comment">// 加锁保护客户端集合</span></span><br><span class="line">        client_sockfds_.<span class="built_in">erase</span>(sockfd);  <span class="comment">// 删除客户端</span></span><br><span class="line">        mtx_.<span class="built_in">unlock</span>();  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">u_int16_t</span> port_;                <span class="comment">// 服务器监听端口</span></span><br><span class="line">    <span class="type">int</span> listen_sockfd_;             <span class="comment">// 监听套接字描述符</span></span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; client_sockfds_;  <span class="comment">// 已连接客户端套接字集合</span></span><br><span class="line">    std::mutex mtx_;                <span class="comment">// 保护client_sockfds_的互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>利用包装器将广播函数和删除用户函数传递给 <code>Task</code> 类使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TASK_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TASK_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  <span class="comment">// 套接字相关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>    <span class="comment">// 函数对象</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>       <span class="comment">// 日志模块</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程本地存储的缓冲区，每个线程独立一份</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数对象类型</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = std::function&lt;<span class="built_in">void</span>(std::string)&gt;;   <span class="comment">// 广播消息的函数类型</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">func2_t</span> = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;          <span class="comment">// 删除客户端的函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务类 - 处理客户端请求的单元</span></span><br><span class="line"><span class="comment"> * 封装了客户端通信逻辑和回调机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * @param client_sockfd 客户端套接字描述符，默认-1</span></span><br><span class="line"><span class="comment">     * @param broadcast 广播消息的回调函数，默认nullptr</span></span><br><span class="line"><span class="comment">     * @param delete_client 删除客户端的回调函数，默认nullptr</span></span><br><span class="line"><span class="comment">     * @param client_addr 客户端地址，默认&quot;*&quot;</span></span><br><span class="line"><span class="comment">     * @param client_port 客户端端口，默认-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> client_sockfd = <span class="number">-1</span>, </span><br><span class="line">         <span class="type">func_t</span> broadcast = <span class="literal">nullptr</span>, </span><br><span class="line">         <span class="type">func2_t</span> delete_client = <span class="literal">nullptr</span>, </span><br><span class="line">         std::string client_addr = <span class="string">&quot;*&quot;</span>, </span><br><span class="line">         <span class="type">u_int16_t</span> client_port = <span class="number">-1</span>)</span><br><span class="line">        : <span class="built_in">client_sockfd_</span>(client_sockfd),</span><br><span class="line">          <span class="built_in">broadcast_</span>(broadcast),</span><br><span class="line">          <span class="built_in">delete_client_</span>(delete_client),</span><br><span class="line">          <span class="built_in">client_addr_</span>(client_addr),</span><br><span class="line">          <span class="built_in">client_port_</span>(client_port) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器端处理客户端请求的核心方法</span></span><br><span class="line"><span class="comment">     * 1. 接收客户端消息</span></span><br><span class="line"><span class="comment">     * 2. 处理接收结果</span></span><br><span class="line"><span class="comment">     * 3. 调用广播回调</span></span><br><span class="line"><span class="comment">     * 4. 关闭连接并清理客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Server</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否需要打印客户端信息</span></span><br><span class="line">        <span class="type">bool</span> print_inf = !(client_addr_ == <span class="string">&quot;*&quot;</span> || client_port_ == <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收客户端数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(client_sockfd_, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)  <span class="comment">// 接收错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (print_inf)</span><br><span class="line">                <span class="built_in">lg</span>(Error, <span class="string">&quot;accept error, [%d]: %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)  <span class="comment">// 客户端关闭连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (print_inf)</span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;client [%s: %d] quit&quot;</span>, client_addr_.<span class="built_in">c_str</span>(), client_port_);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 成功接收数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[n] = <span class="number">0</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">            <span class="keyword">if</span> (print_inf)</span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;server get a message from client [%s: %d]: %s&quot;</span>, </span><br><span class="line">                    client_addr_.<span class="built_in">c_str</span>(), client_port_, buffer);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构造响应消息</span></span><br><span class="line">            std::string outbuffer = <span class="string">&quot;[&quot;</span> + client_addr_ + <span class="string">&quot;: &quot;</span> + std::<span class="built_in">to_string</span>(client_port_) + <span class="string">&quot;]:&quot;</span> + buffer;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用广播回调函数</span></span><br><span class="line">            <span class="built_in">broadcast_</span>(outbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭客户端连接</span></span><br><span class="line">        <span class="built_in">close</span>(client_sockfd_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用删除客户端回调</span></span><br><span class="line">        <span class="built_in">delete_client_</span>(client_sockfd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数调用运算符重载</span></span><br><span class="line"><span class="comment">     * 使Task对象可以像函数一样被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Server</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> client_sockfd_;          <span class="comment">// 客户端套接字描述符</span></span><br><span class="line">    std::string client_addr_;    <span class="comment">// 客户端IP地址</span></span><br><span class="line">    <span class="type">u_int16_t</span> client_port_;      <span class="comment">// 客户端端口号</span></span><br><span class="line">    <span class="type">func_t</span> broadcast_;           <span class="comment">// 广播消息的回调函数</span></span><br><span class="line">    <span class="type">func2_t</span> delete_client_;      <span class="comment">// 删除客户端的回调函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>终于，我们的聊天服务大功告成，接下来让我们测试一下通信能力如何：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp  </span><br><span class="line">╰─➤  ./main.o 7777</span><br><span class="line">[Info][2025-7-30 1:1:47] listening sock create success, sockfd: 3</span><br><span class="line">[Info][2025-7-30 1:1:47] listening sock bind success</span><br><span class="line">[Info][2025-7-30 1:1:59] accept a new client [127.0.0.1: 40718]</span><br><span class="line">[Info][2025-7-30 1:2:7] accept a new client [127.0.0.1: 40732]</span><br><span class="line">[Info][2025-7-30 1:2:23] server get a message from client [127.0.0.1: 40718]: hello, how are you?</span><br><span class="line">[Info][2025-7-30 1:2:23] accept a new client [127.0.0.1: 46856]</span><br><span class="line">[Info][2025-7-30 1:2:44] server get a message from client [127.0.0.1: 40732]: I am fine, thank you!</span><br><span class="line">[Info][2025-7-30 1:2:44] accept a new client [127.0.0.1: 59586]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端1</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp</span><br><span class="line">╰─➤  ./tcp_client.o 127.0.0.1 7777</span><br><span class="line">Please Enter# hello, how are you?</span><br><span class="line">server echo# [127.0.0.1: 40718]$hello, how are you?</span><br><span class="line">Please Enter# server echo# [127.0.0.1: 40732]$I am fine, thank you!</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端2</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/tcp</span><br><span class="line">╰─➤  ./tcp_client.o 127.0.0.1 7777</span><br><span class="line">Please Enter# server echo# [127.0.0.1: 40718]$hello, how are you?</span><br><span class="line">I am fine, thank you!</span><br><span class="line">server echo# [127.0.0.1: 40732]$I am fine, thank you!</span><br><span class="line">Please Enter#</span><br></pre></td></tr></table></figure><p>因为消息都打印在同一个会话上，难免会出现信息混乱，若想要实现信息不混乱，可以选择将数据分离到两个会话窗口中，这里就不做扩展了</p><p>感谢各位的阅读，希望对你有帮助！有问题欢迎在下面评论区讨论！</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket 套接字编程-UDP</title>
      <link href="/2025/07/28/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/socket_udp/"/>
      <url>/2025/07/28/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/socket_udp/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#socket-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3">Socket 函数详解</a><ul><li><a href="#socket-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">Socket 的基本概念</a></li><li><a href="#socket-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">Socket 的核心函数</a></li><li><a href="#socket-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">Socket 工作流程</a></li><li><a href="#tcp-%E6%9C%8D%E5%8A%A1%E5%99%A8">TCP 服务器</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#udp-%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3"><strong>UDP 收发数据接口详解</strong></a><ul><li><a href="#1-recvfrom-%E6%8E%A5%E6%94%B6-udp-%E6%95%B0%E6%8D%AE">1. <code>recvfrom</code> —— 接收 UDP 数据</a></li><li><a href="#2-sendto-%E5%8F%91%E9%80%81-udp-%E6%95%B0%E6%8D%AE">2. <code>sendto</code> —— 发送 UDP 数据</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-udp-%E9%9C%80%E8%A6%81-recvfrom-%E5%92%8C-sendto">为什么 UDP 需要 <code>recvfrom</code> 和 <code>sendto</code>？</a></li><li><a href="#%E5%AF%B9%E6%AF%94-tcp"><strong>对比 TCP</strong></a></li></ul></li><li><a href="#udp-%E9%80%9A%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0">UDP 通信服务实现</a><ul><li><a href="#udphpp">udp.hpp</a></li><li><a href="#udp_serverhpp">udp_server.hpp</a></li><li><a href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><strong>关键代码解析</strong></a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><strong>工作流程</strong></a></li><li><a href="#udp_clientcc">udp_client.cc</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA"><strong>工作流程图示</strong></a></li></ul></li></ul><!-- tocstop --><h2><span id="socket-函数详解">Socket 函数详解</span></h2><p>Socket（套接字）是网络编程的核心接口，用于实现不同主机之间的进程通信（<strong>IPC，Inter-Process Communication</strong>）。它提供了一种标准的 API，使应用程序能够通过 TCP&#x2F;IP、UDP 或其他协议进行网络数据传输。</p><hr><h3><span id="socket-的基本概念">Socket 的基本概念</span></h3><p>Socket 可以看作是两个进程（客户端和服务器）之间的<strong>通信端点（Endpoint）</strong>，它封装了 IP 地址和端口号，使得数据可以在网络上传输。</p><ul><li><strong>IP 地址</strong>：标识网络上的主机（如 <code>192.168.1.1</code> 或 <code>google.com</code>）。</li><li><strong>端口号（Port）</strong>：标识主机上的具体服务（如 HTTP:80、SSH:22）。</li></ul><p>Socket 通常用于：</p><ul><li><strong>TCP（可靠传输）</strong>：如 HTTP、FTP、SSH。</li><li><strong>UDP（无连接传输）</strong>：如 DNS、视频流、在线游戏。</li></ul><hr><h3><span id="socket-的核心函数">Socket 的核心函数</span></h3><p>(1) <code>socket()</code> - 创建套接字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：创建一个 Socket 文件描述符（fd）。</li><li><strong>参数</strong>：<ul><li><code>domain</code>：协议族（<code>AF_INET</code> 表示 IPv4，<code>AF_INET6</code> 表示 IPv6）。</li><li><code>type</code>：通信类型：<ul><li><code>SOCK_STREAM</code>（TCP，可靠连接）</li><li><code>SOCK_DGRAM</code>（UDP，无连接）</li></ul></li><li><code>protocol</code>：通常设为 <code>0</code>（自动选择）。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功：返回 Socket 文件描述符（<code>int</code>）。</li><li>失败：返回 <code>-1</code>，并设置 <code>errno</code>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(2) <code>bind()</code> - 绑定 IP 和端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：将 Socket 绑定到特定的 IP 地址和端口（服务器端使用）。</li><li><strong>参数</strong>：<ul><li><code>sockfd</code>：Socket 文件描述符。</li><li><code>addr</code>：指向 <code>sockaddr</code> 结构的指针（存储 IP 和端口）。</li><li><code>addrlen</code>：<code>sockaddr</code> 结构的大小。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功：<code>0</code>。</li><li>失败：<code>-1</code>，并设置 <code>errno</code>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定所有网卡</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">8080</span>);        <span class="comment">// 绑定 8080 端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(3) <code>listen()</code> - 监听连接（TCP 服务器）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：使 Socket 进入监听状态，等待客户端连接（仅用于 TCP）。</li><li><strong>参数</strong>：<ul><li><code>sockfd</code>：Socket 文件描述符。</li><li><code>backlog</code>：等待连接队列的最大长度。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功：<code>0</code>。</li><li>失败：<code>-1</code>，并设置 <code>errno</code>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(4) <code>accept()</code> - 接受连接（TCP 服务器）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：接受客户端的连接请求，返回一个新的 Socket 用于通信。</li><li><strong>参数</strong>：<ul><li><code>sockfd</code>：监听 Socket。</li><li><code>addr</code>：存储客户端地址信息（可设为 <code>NULL</code>）。</li><li><code>addrlen</code>：客户端地址结构的大小（可设为 <code>NULL</code>）。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功：返回一个新的 Socket 文件描述符（用于数据传输）。</li><li>失败：<code>-1</code>，并设置 <code>errno</code>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"><span class="type">int</span> client_sock = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line"><span class="keyword">if</span> (client_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(5) <code>connect()</code> - 连接服务器（TCP 客户端）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：客户端连接服务器（仅用于 TCP）。</li><li><strong>参数</strong>：<ul><li><code>sockfd</code>：Socket 文件描述符。</li><li><code>addr</code>：服务器地址信息。</li><li><code>addrlen</code>：地址结构大小。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功：<code>0</code>。</li><li>失败：<code>-1</code>，并设置 <code>errno</code>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);  <span class="comment">// 连接本地 8080 端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;connect failed&quot;</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(6) <code>send()</code> &#x2F; <code>recv()</code> - TCP 数据收发</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：TCP 方式发送&#x2F;接收数据。</li><li><strong>参数</strong>：<ul><li><code>sockfd</code>：Socket 文件描述符。</li><li><code>buf</code>：数据缓冲区。</li><li><code>len</code>：数据长度。</li><li><code>flags</code>：通常设为 <code>0</code>（阻塞模式）。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功：返回实际发送&#x2F;接收的字节数。</li><li>失败：<code>-1</code>，并设置 <code>errno</code>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">ssize_t</span> bytes_received = recv(client_sock, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (bytes_received == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;recv failed&quot;</span>);</span><br><span class="line">    close(client_sock);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">buffer[bytes_received] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串终止</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br></pre></td></tr></table></figure><hr><p>(7) <code>sendto()</code> &#x2F; <code>recvfrom()</code> - UDP 数据收发</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：UDP 方式发送&#x2F;接收数据（不需要 <code>connect</code>）。</li><li><strong>参数</strong>：<ul><li><code>dest_addr</code> &#x2F; <code>src_addr</code>：目标&#x2F;源地址。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;Hello UDP Server!&quot;</span>;</span><br><span class="line">sendto(sockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>,</span><br><span class="line">       (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure><hr><h3><span id="socket-工作流程">Socket 工作流程</span></h3><h3><span id="tcp-服务器">TCP 服务器</span></h3><ol><li><code>socket()</code> → 创建 Socket</li><li><code>bind()</code> → 绑定 IP 和端口</li><li><code>listen()</code> → 开始监听</li><li><code>accept()</code> → 接受客户端连接</li><li><code>recv()</code> &#x2F; <code>send()</code> → 数据通信</li><li><code>close()</code> → 关闭 Socket</li></ol><h4><span id="tcp-客户端">TCP 客户端</span></h4><ol><li><code>socket()</code> → 创建 Socket</li><li><code>connect()</code> → 连接服务器</li><li><code>send()</code> &#x2F; <code>recv()</code> → 数据通信</li><li><code>close()</code> → 关闭 Socket</li></ol><h4><span id="udp-服务器x2f客户端">UDP 服务器&#x2F;客户端</span></h4><ol><li><code>socket()</code> → 创建 Socket</li><li><code>bind()</code>（客户端可选，但一般是不需要的）</li><li><code>sendto()</code> &#x2F; <code>recvfrom()</code> → 直接发送&#x2F;接收数据</li><li><code>close()</code> → 关闭 Socket</li></ol><hr><h3><span id="总结">总结</span></h3><table><thead><tr><th>函数</th><th>用途</th><th>适用协议</th></tr></thead><tbody><tr><td><code>socket()</code></td><td>创建 Socket</td><td>TCP&#x2F;UDP</td></tr><tr><td><code>bind()</code></td><td>绑定 IP 和端口</td><td>TCP&#x2F;UDP（服务器）</td></tr><tr><td><code>listen()</code></td><td>监听连接</td><td>TCP（服务器）</td></tr><tr><td><code>accept()</code></td><td>接受连接</td><td>TCP（服务器）</td></tr><tr><td><code>connect()</code></td><td>连接服务器</td><td>TCP（客户端）</td></tr><tr><td><code>send()</code> &#x2F; <code>recv()</code></td><td>TCP 数据收发</td><td>TCP</td></tr><tr><td><code>sendto()</code> &#x2F; <code>recvfrom()</code></td><td>UDP 数据收发</td><td>UDP</td></tr><tr><td><code>close()</code></td><td>关闭 Socket</td><td>TCP&#x2F;UDP</td></tr></tbody></table><p>下面是对 UDP 收发数据接口的详细说明</p><h2><span id="udp-收发数据接口详解"><strong>UDP 收发数据接口详解</strong></span></h2><p>由于 <strong>UDP（User Datagram Protocol）是无连接的协议</strong>，每次发送和接收数据时都需要明确指定或获取对方的地址信息。因此，UDP 通信主要使用以下两个接口：</p><ol><li><strong><code>recvfrom</code></strong> —— 接收数据，并获取发送方的地址信息。</li><li><strong><code>sendto</code></strong> —— 发送数据，并指定目标地址信息。</li></ol><hr><h3><span id="1-recvfrom-接收-udp-数据">1. <code>recvfrom</code> —— 接收 UDP 数据</span></h3><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> sockfd,                   <span class="comment">// UDP 套接字描述符</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *buf,                    <span class="comment">// 接收数据的缓冲区</span></span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> len,                  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> flags,                   <span class="comment">// 控制选项（通常设为 0）</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *src_addr,    <span class="comment">// 保存发送方的地址信息</span></span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> *addrlen           <span class="comment">// 地址结构体的长度（输入输出参数）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><strong><code>sockfd</code></strong>：UDP 套接字描述符（由 <code>socket(AF_INET, SOCK_DGRAM, 0)</code> 创建）。</li><li><strong><code>buf</code></strong>：存放接收数据的缓冲区。</li><li><strong><code>len</code></strong>：缓冲区的最大容量。</li><li><strong><code>flags</code></strong>：控制选项（如 <code>MSG_WAITALL</code>、<code>MSG_PEEK</code>，通常设为 <code>0</code>）。</li><li><strong><code>src_addr</code></strong>：用于保存发送方的地址（<code>struct sockaddr_in</code> 或 <code>struct sockaddr</code>）。</li><li><strong><code>addrlen</code></strong>：输入时为 <code>src_addr</code> 的大小，输出时为实际接收到的地址长度。</li></ul><p><strong>返回值</strong></p><ul><li><strong>成功</strong>：返回接收到的字节数（<code>&gt;0</code>）。</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code>（如 <code>EAGAIN</code>、<code>ECONNREFUSED</code>）。</li></ul><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> recv_len = recvfrom(</span><br><span class="line">        sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addr_len</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (recv_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received %zd bytes from %s:%d\n&quot;</span>, </span><br><span class="line">           recv_len, </span><br><span class="line">           inet_ntoa(client_addr.sin_addr), </span><br><span class="line">           ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="2-sendto-发送-udp-数据">2. <code>sendto</code> —— 发送 UDP 数据</span></h3><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> sockfd,                   <span class="comment">// UDP 套接字描述符</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *buf,             <span class="comment">// 要发送的数据</span></span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> len,                  <span class="comment">// 数据长度</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> flags,                   <span class="comment">// 控制选项（通常设为 0）</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr,  <span class="comment">// 目标地址</span></span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> addrlen            <span class="comment">// 目标地址长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><strong><code>sockfd</code></strong>：UDP 套接字描述符。</li><li><strong><code>buf</code></strong>：要发送的数据缓冲区。</li><li><strong><code>len</code></strong>：数据长度。</li><li><strong><code>flags</code></strong>：控制选项（通常设为 <code>0</code>）。</li><li><strong><code>dest_addr</code></strong>：目标地址（<code>struct sockaddr_in</code> 或 <code>struct sockaddr</code>）。</li><li><strong><code>addrlen</code></strong>：目标地址的长度。</li></ul><p><strong>返回值</strong></p><ul><li><strong>成功</strong>：返回发送的字节数（<code>&gt;=0</code>）。</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code>（如 <code>EMSGSIZE</code>、<code>ENOBUFS</code>）。</li></ul><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *msg = <span class="string">&quot;Hello, UDP Server!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> sent_len = sendto(</span><br><span class="line">        sockfd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sent_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent %zd bytes to server\n&quot;</span>, sent_len);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="为什么-udp-需要-recvfrom-和-sendto">为什么 UDP 需要 <code>recvfrom</code> 和 <code>sendto</code>？</span></h3><p>由于 <strong>UDP 是无连接的协议</strong>，每次通信时都需要明确：</p><ol><li><strong>接收数据时</strong>：要知道数据是谁发来的（<code>recvfrom</code> 返回 <code>src_addr</code>）。</li><li><strong>发送数据时</strong>：要指定数据发给谁（<code>sendto</code> 需要 <code>dest_addr</code>）。</li></ol><h3><span id="对比-tcp"><strong>对比 TCP</strong></span></h3><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td><strong>连接方式</strong></td><td>面向连接（<code>connect</code>&#x2F;<code>accept</code>）</td><td>无连接</td></tr><tr><td><strong>收发接口</strong></td><td><code>send</code>&#x2F;<code>recv</code></td><td><code>sendto</code>&#x2F;<code>recvfrom</code></td></tr><tr><td><strong>地址管理</strong></td><td>连接建立后自动维护</td><td>每次通信需手动指定</td></tr></tbody></table><hr><blockquote><ul><li><strong><code>recvfrom</code></strong>：用于接收 UDP 数据，并获取发送方的地址。</li><li><strong><code>sendto</code></strong>：用于发送 UDP 数据，并指定目标地址。</li><li><strong>UDP 是无连接的</strong>，因此每次通信都需要显式处理地址信息，而 TCP 是面向连接的，地址信息在建立连接后自动维护。</li></ul></blockquote><h2><span id="udp-通信服务实现">UDP 通信服务实现</span></h2><p>以下是对这段 UDP 封装代码的详细介绍和注释说明：</p><hr><h3><span id="udphpp">udp.hpp</span></h3><p>这段代码实现了一个简单的 UDP 网络通信封装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _UDP_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UDP_HPP_ 1  <span class="comment">// 头文件保护宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  <span class="comment">// socket相关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>   <span class="comment">// sockaddr_in结构体</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>    <span class="comment">// inet_ntop等转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>        <span class="comment">// bzero函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误码枚举</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    socket_error = <span class="number">1</span>,  <span class="comment">// socket创建失败</span></span><br><span class="line">    bind_error,        <span class="comment">// 绑定端口失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">char</span> addr_buffer[<span class="number">1024</span>];  <span class="comment">// 全局缓冲区（用于地址转换）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> udp &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建UDP Socket</span></span><br><span class="line"><span class="comment">     * @return 成功返回socket文件描述符，失败退出程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建IPv4 UDP Socket</span></span><br><span class="line">        <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);      <span class="comment">// 打印错误信息</span></span><br><span class="line">            <span class="built_in">exit</span>(socket_error);    <span class="comment">// 退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sockfd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定Socket到指定端口</span></span><br><span class="line"><span class="comment">     * @param sockfd  Socket文件描述符</span></span><br><span class="line"><span class="comment">     * @param port    要绑定的端口号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;local, <span class="built_in">sizeof</span>(local));  <span class="comment">// 清空结构体</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置地址族和端口</span></span><br><span class="line">        local.sin_family = AF_INET;           <span class="comment">// IPv4</span></span><br><span class="line">        local.sin_addr.s_addr = INADDR_ANY;   <span class="comment">// 监听所有网卡</span></span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port);         <span class="comment">// 端口转为网络字节序</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行绑定</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)(&amp;local), <span class="built_in">sizeof</span>(local));</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(bind_error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从sockaddr_in结构体解析IP和端口</span></span><br><span class="line"><span class="comment">     * @param addr_in  输入的网络地址结构体</span></span><br><span class="line"><span class="comment">     * @param addr     输出的IP字符串</span></span><br><span class="line"><span class="comment">     * @param port     输出的端口号（主机字节序）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetAddrAndPort</span><span class="params">(<span class="keyword">struct</span> sockaddr_in &amp;addr_in, std::string &amp;addr, <span class="type">uint16_t</span> &amp;port)</span> </span>&#123;</span><br><span class="line">        port = <span class="built_in">ntohs</span>(addr_in.sin_port);  <span class="comment">// 端口转为主机字节序</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将二进制IP转为字符串</span></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr_in.sin_addr, addr_buffer, <span class="built_in">sizeof</span>(addr_buffer) - <span class="number">1</span>);</span><br><span class="line">        addr = addr_buffer;  <span class="comment">// 存储结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><ol><li><p><strong><code>Socket()</code> 函数</strong></p><ul><li>使用 <code>socket(AF_INET, SOCK_DGRAM, 0)</code> 创建 <strong>UDP Socket</strong></li><li>失败时通过 <code>perror</code> 输出错误信息并退出</li></ul></li><li><p><strong><code>Bind()</code> 函数</strong></p><ul><li><code>INADDR_ANY</code> 表示监听所有网卡（包括公网和本地）</li><li><code>htons(port)</code> 将端口转为网络字节序（大端）</li><li><code>bind()</code> 将Socket与地址绑定</li></ul></li><li><p><strong><code>GetAddrAndPort()</code> 函数</strong></p><ul><li><code>ntohs()</code> 将网络字节序端口转为主机字节序</li><li><code>inet_ntop()</code> 将二进制IP地址转为可读字符串</li></ul></li><li><p><strong>全局缓冲区</strong></p><ul><li><code>addr_buffer</code> 用于临时存储IP字符串</li><li>注意：多线程环境下建议改用局部变量</li></ul></li></ol><p>以下是对这段 UDP 服务端代码的详细注释和解释：</p><hr><h3><span id="udp_serverhpp">udp_server.hpp</span></h3><p>该代码实现了一个简单的 UDP 服务端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _UDP_SERVER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UDP_SERVER_HPP_ 1  <span class="comment">// 头文件保护宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// close函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp.hpp&quot;</span>       <span class="comment">// UDP基础封装</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span>       <span class="comment">// 日志模块</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> defaultport = <span class="number">8080</span>;  <span class="comment">// 默认监听端口</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> default_size = <span class="number">1024</span>; <span class="comment">// 接收缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UdpServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * @param port 监听端口（默认8080）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">UdpServer</span>(<span class="type">uint16_t</span> port = defaultport) </span><br><span class="line">        : <span class="built_in">port_</span>(port) &#123;&#125;  <span class="comment">// 初始化端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化Socket和绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建UDP Socket</span></span><br><span class="line">        sockfd_ = udp::<span class="built_in">Socket</span>();</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;socket success, sockfd: %d&quot;</span>, sockfd_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 绑定端口</span></span><br><span class="line">        udp::<span class="built_in">Bind</span>(sockfd_, port_);</span><br><span class="line">        <span class="built_in">lg</span>(Info, <span class="string">&quot;socket bind success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务主循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> buffer[default_size];  <span class="comment">// 接收缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">// 持续监听</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;  <span class="comment">// 客户端地址</span></span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 接收数据（阻塞式）</span></span><br><span class="line">            <span class="type">ssize_t</span> n = <span class="built_in">recvfrom</span>(sockfd_, buffer, default_size - <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">                                (<span class="keyword">struct</span> sockaddr*)&amp;peer, &amp;len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;  <span class="comment">// 接收成功</span></span><br><span class="line">                buffer[n] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串终止</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 解析客户端地址</span></span><br><span class="line">                std::string addr;</span><br><span class="line">                <span class="type">uint16_t</span> port;</span><br><span class="line">                udp::<span class="built_in">GetAddrAndPort</span>(peer, addr, port);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 记录日志</span></span><br><span class="line">                <span class="built_in">lg</span>(Info, <span class="string">&quot;UDP Server Get a message from [%s: %d]: %s&quot;</span>, </span><br><span class="line">                    addr.<span class="built_in">c_str</span>(), port, buffer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 回显数据</span></span><br><span class="line">                <span class="built_in">sendto</span>(sockfd_, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>, </span><br><span class="line">                      (<span class="keyword">struct</span> sockaddr*)&amp;peer, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 析构函数（关闭Socket）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~<span class="built_in">UdpServer</span>() &#123;</span><br><span class="line">        <span class="built_in">close</span>(sockfd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint16_t</span> port_;  <span class="comment">// 监听端口</span></span><br><span class="line">    <span class="type">int</span> sockfd_;     <span class="comment">// Socket文件描述符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><h3><span id="关键代码解析"><strong>关键代码解析</strong></span></h3><table><thead><tr><th>代码段</th><th>功能说明</th></tr></thead><tbody><tr><td><code>udp::Socket()</code></td><td>创建UDP Socket（<code>SOCK_DGRAM</code>）</td></tr><tr><td><code>udp::Bind()</code></td><td>绑定到<code>INADDR_ANY</code>（所有网卡）和指定端口</td></tr><tr><td><code>recvfrom()</code></td><td>接收客户端数据，同时获取客户端地址</td></tr><tr><td><code>udp::GetAddrAndPort()</code></td><td>从<code>sockaddr_in</code>解析IP和端口</td></tr><tr><td><code>sendto()</code></td><td>将数据回发给原客户端</td></tr><tr><td><code>lg(Info,...)</code></td><td>记录通信日志（依赖外部日志模块）</td></tr></tbody></table><hr><h3><span id="工作流程"><strong>工作流程</strong></span></h3><ol><li><p><strong>初始化阶段</strong></p><pre class="mermaid">   sequenceDiagram    UdpServer->>+udp::Socket: 创建Socket    UdpServer->>+udp::Bind: 绑定端口</pre></li><li><p><strong>运行阶段</strong></p><pre class="mermaid">   sequenceDiagram    Client->>UdpServer: 发送UDP数据包    UdpServer->>UdpServer: 记录客户端地址和消息    UdpServer->>Client: 回显相同数据</pre></li></ol><h3><span id="udp_clientcc">udp_client.cc</span></h3><p>以下是一个简单的UDP客户端示例代码，用于与服务器进行交互：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp.hpp&quot;</span>  <span class="comment">// 引入自定义UDP封装</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; server_ip server_port&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 解析命令行参数</span></span><br><span class="line">    string server_ip = argv[<span class="number">1</span>];          <span class="comment">// 服务器IP地址</span></span><br><span class="line">    <span class="type">uint16_t</span> server_port = <span class="built_in">stoi</span>(argv[<span class="number">2</span>]);<span class="comment">// 服务器端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建UDP Socket</span></span><br><span class="line">    <span class="type">int</span> sockfd = udp::<span class="built_in">Socket</span>();          <span class="comment">// 调用封装函数创建Socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 配置服务器地址结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;server, <span class="built_in">sizeof</span>(server));      <span class="comment">// 清空结构体</span></span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(server_port); <span class="comment">// 设置端口（转为网络字节序）</span></span><br><span class="line">    server.sin_family = AF_INET;         <span class="comment">// IPv4地址族</span></span><br><span class="line">    server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>()); <span class="comment">// 转换IP为二进制格式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 主交互循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 5.1 获取用户输入</span></span><br><span class="line">        string inbuffer;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter# &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, inbuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.2 发送数据到服务器</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">sendto</span>(sockfd, inbuffer.<span class="built_in">c_str</span>(), inbuffer.<span class="built_in">size</span>(), <span class="number">0</span>,</span><br><span class="line">                          (<span class="keyword">struct</span> sockaddr*)&amp;server, <span class="built_in">sizeof</span>(server));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;  <span class="comment">// 发送成功</span></span><br><span class="line">            <span class="comment">// 5.3 准备接收回显</span></span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> temp;    <span class="comment">// 临时存储回复方地址（未使用）</span></span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.4 接收服务器回复</span></span><br><span class="line">            <span class="type">ssize_t</span> m = <span class="built_in">recvfrom</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                               (<span class="keyword">struct</span> sockaddr*)&amp;temp, &amp;len);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;  <span class="comment">// 接收成功</span></span><br><span class="line">                buffer[m] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加字符串终止符</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;server echo# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 发送失败则退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 关闭Socket</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4><span id="核心功能">核心功能</span></h4><ul><li>实现一个 <strong>UDP 客户端</strong>，能够：<ul><li>通过命令行参数指定服务器地址和端口</li><li>交互式发送用户输入的消息</li><li>接收并显示服务器的回显（Echo）</li></ul></li></ul><h4><span id="关键步骤">关键步骤</span></h4><table><thead><tr><th>步骤</th><th>关键函数&#x2F;操作</th><th>说明</th></tr></thead><tbody><tr><td>参数检查</td><td><code>argc != 3</code></td><td>确保输入格式正确</td></tr><tr><td>创建Socket</td><td><code>udp::Socket()</code></td><td>创建UDP套接字</td></tr><tr><td>地址配置</td><td><code>inet_addr()</code> + <code>htons()</code></td><td>将字符串IP和端口转为网络格式</td></tr><tr><td>数据发送</td><td><code>sendto()</code></td><td>发送数据到指定服务器</td></tr><tr><td>数据接收</td><td><code>recvfrom()</code></td><td>接收服务器回复（不验证来源）</td></tr><tr><td>资源清理</td><td><code>close()</code></td><td>关闭Socket</td></tr></tbody></table><hr><h3><span id="工作流程图示"><strong>工作流程图示</strong></span></h3><pre class="mermaid">sequenceDiagram    participant User    participant Client    participant Server    User->>Client: 输入消息    Client->>Server: sendto(message)    Server->>Client: recvfrom(echo)    Client->>User: 打印回显</pre><p>通过主函数挂起服务端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp_server.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        port = <span class="number">8080</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        port = <span class="built_in">stoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;(default port: 8080)&quot;</span> &lt;&lt; endl &lt;&lt; </span><br><span class="line">        <span class="string">&quot;OR&quot;</span> &lt;&lt; endl &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; port&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">UdpServer <span class="title">us</span><span class="params">(port)</span></span>;</span><br><span class="line">    us.<span class="built_in">Init</span>();</span><br><span class="line">    us.<span class="built_in">Start</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后我们进行通信，可以看到通信正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/udp</span><br><span class="line">╰─➤  ./udp_client.o 82.156.255.140 8888</span><br><span class="line">Please Enter# 1234</span><br><span class="line">server echo# 1234</span><br><span class="line">Please Enter# 12345</span><br><span class="line">server echo# 12345</span><br><span class="line">Please Enter# Liu Jiaxuan say: Hello!</span><br><span class="line">server echo# Liu Jiaxuan say: Hello!</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/udp  </span><br><span class="line">╰─➤  ./main.o 8888</span><br><span class="line">[Info][2025-7-28 23:43:22] socket success, sockfd: 3</span><br><span class="line">[Info][2025-7-28 23:43:22] socket bind success</span><br><span class="line">[Info][2025-7-28 23:43:30] UDP Server Get a message from [82.156.255.140: 55472]: 1234</span><br><span class="line">[Info][2025-7-28 23:43:32] UDP Server Get a message from [82.156.255.140: 55472]: 12345</span><br><span class="line">[Info][2025-7-28 23:43:56] UDP Server Get a message from [82.156.255.140: 55472]: Liu Jiaxuan say: Hello!</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程池</title>
      <link href="/2025/07/27/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_pool/"/>
      <url>/2025/07/27/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_pool/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E8%AE%A1">传统线程池设计</a><ul><li><a href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0">1. 线程池概述</a></li><li><a href="#2-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90">2. 核心实现分析</a></li><li><a href="#3-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7">3. 关键特性</a></li><li><a href="#4-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">4. 使用示例</a></li></ul></li><li><a href="#%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0">基于环形队列（信号量）的线程池</a><ul><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li><li><a href="#%E4%B8%80-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">一、设计思想</a></li><li><a href="#%E4%BA%8C-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90">二、关键组件解析</a></li><li><a href="#%E4%B8%89-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">三、工作流程</a></li><li><a href="#%E5%9B%9B-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%82%B9">四、性能优化点</a></li></ul></li></ul><!-- tocstop --><h2><span id="传统线程池设计">传统线程池设计</span></h2><h3><span id="1-线程池概述">1. 线程池概述</span></h3><p>线程池是一种多线程处理形式，它维护一组线程等待分配可并发执行的任务。这种技术避免了频繁创建和销毁线程的开销，提高了系统性能，特别是在需要处理大量短时任务的场景中。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREAD_POOL_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREAD_POOL_HPP_ 1;  <span class="comment">// 防止头文件重复包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>          <span class="comment">// POSIX线程库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span>      <span class="comment">// 哈希表，用于存储线程信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>              <span class="comment">// 任务队列</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> default_cap = <span class="number">20</span>; <span class="comment">// 默认线程池容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动加解锁的RAII封装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockGuard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数自动加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockGuard</span><span class="params">(<span class="type">pthread_mutex_t</span> &amp;mtx)</span></span></span><br><span class="line"><span class="function">        : mtx_(mtx)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mtx_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数自动解锁</span></span><br><span class="line">    ~<span class="built_in">LockGuard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mtx_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">LockGuard</span>(<span class="type">const</span> LockGuard &amp;) = <span class="keyword">delete</span>;            </span><br><span class="line">    LockGuard &amp;<span class="keyword">operator</span>=(<span class="type">const</span> LockGuard &amp;) = <span class="keyword">delete</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> &amp;mtx_;  <span class="comment">// 引用管理的互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 检查任务队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmptyQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tasks_.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从任务队列头部取出一个任务</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T task = tasks_.<span class="built_in">front</span>();</span><br><span class="line">        tasks_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程数据传递结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_data</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::string name;    <span class="comment">// 线程名称</span></span><br><span class="line">        ThreadPool&lt;T&gt; *tp;   <span class="comment">// 所属线程池指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取线程池单例（线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadPool&lt;T&gt; &amp;<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// C++11后静态局部变量初始化是线程安全的</span></span><br><span class="line">        <span class="type">static</span> ThreadPool&lt;T&gt; tp;</span><br><span class="line">        <span class="keyword">return</span> tp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        running_ = <span class="literal">true</span>;  <span class="comment">// 设置运行标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建指定数量的工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cap_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            std::string name = <span class="string">&quot;thread-&quot;</span> + std::<span class="built_in">to_string</span>(i);  <span class="comment">// 生成线程名</span></span><br><span class="line">            <span class="type">pthread_t</span> tid;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建线程数据</span></span><br><span class="line">            thread_data *td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">                name : name,</span><br><span class="line">                tp : <span class="keyword">this</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建线程</span></span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, ThreadHandler, (<span class="type">void</span> *)(td));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录线程信息</span></span><br><span class="line">            threads_[tid] = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向线程池添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T &amp;task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">LockGuard <span class="title">lg</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 加锁保护</span></span><br><span class="line">            tasks_.<span class="built_in">push</span>(task);   <span class="comment">// 任务入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先释放锁后唤醒，提高并发效率</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_);  <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">End</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">LockGuard <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            running_ = <span class="literal">false</span>;  <span class="comment">// 设置停止标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 广播唤醒所有等待线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_broadcast</span>(&amp;cond_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[tid, name] : threads_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        threads_.<span class="built_in">clear</span>();  <span class="comment">// 清空线程记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程处理函数（静态成员函数）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">ThreadHandler</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程数据</span></span><br><span class="line">        thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(args);</span><br><span class="line">        ThreadPool&lt;T&gt; *tp = td-&gt;tp;</span><br><span class="line">        std::string thread_name = td-&gt;name;</span><br><span class="line">        T task;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">LockGuard <span class="title">lg</span><span class="params">(tp-&gt;mtx_)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 等待条件：任务队列不为空或线程池停止</span></span><br><span class="line">                <span class="keyword">while</span> (tp-&gt;<span class="built_in">IsEmptyQueue</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tp-&gt;running_)</span><br><span class="line">                        <span class="built_in">pthread_cond_wait</span>(&amp;tp-&gt;cond_, &amp;tp-&gt;mtx_);  <span class="comment">// 等待任务</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">delete</span> td;  <span class="comment">// 清理线程数据</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 线程退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取任务</span></span><br><span class="line">                task = tp-&gt;<span class="built_in">Pop</span>();</span><br><span class="line">            &#125;  <span class="comment">// 自动解锁</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出任务结果（假设T类型有GetResult方法）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, thread_name.<span class="built_in">c_str</span>(), task.<span class="built_in">GetResult</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> td;  <span class="comment">// 理论上不会执行到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数（单例模式）</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> cap = default_cap)</span><br><span class="line">        : <span class="built_in">cap_</span>(cap),          <span class="comment">// 线程容量</span></span><br><span class="line">          <span class="built_in">running_</span>(<span class="literal">false</span>)     <span class="comment">// 初始状态为未运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mtx_, <span class="literal">nullptr</span>);    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;cond_, <span class="literal">nullptr</span>);    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (running_)</span><br><span class="line">            <span class="built_in">End</span>();  <span class="comment">// 如果还在运行，先停止</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mtx_);   <span class="comment">// 销毁互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;cond_);   <span class="comment">// 销毁条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">const</span> ThreadPool&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">pthread_t</span>, std::string&gt; threads_;  <span class="comment">// 线程ID与名称映射</span></span><br><span class="line">    <span class="type">size_t</span> cap_;                     <span class="comment">// 线程池容量</span></span><br><span class="line">    std::queue&lt;T&gt; tasks_;            <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mtx_;            <span class="comment">// 保护任务队列的互斥锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> cond_;            <span class="comment">// 任务通知条件变量</span></span><br><span class="line">    <span class="type">bool</span> running_;                   <span class="comment">// 线程池运行标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock_ = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3><span id="2-核心实现分析">2. 核心实现分析</span></h3><h4><span id="21-线程安全设计">2.1 线程安全设计</span></h4><ul><li><strong>互斥锁保护</strong>：使用<code>pthread_mutex_t</code>保护共享资源（任务队列）</li><li><strong>条件变量</strong>：<code>pthread_cond_t</code>实现线程间的任务通知机制</li><li><strong>RAII锁</strong>：<code>LockGuard</code>类实现自动加解锁，防止死锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockGuard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockGuard</span><span class="params">(<span class="type">pthread_mutex_t</span> &amp;mtx)</span> : mtx_(mtx) &#123;</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mtx_);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LockGuard</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mtx_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4><span id="22-任务管理">2.2 任务管理</span></h4><ul><li>任务队列：使用<code>std::queue</code>存储待处理任务</li><li>任务添加：<code>Push()</code>方法线程安全地添加任务</li><li>任务获取：工作线程通过<code>Pop()</code>获取任务</li></ul><h4><span id="23-线程管理">2.3 线程管理</span></h4><ul><li>线程创建：<code>Start()</code>方法创建指定数量的工作线程</li><li>线程回收：<code>End()</code>方法安全终止所有线程</li><li>线程命名：使用哈希表记录线程ID与名称的映射</li></ul><h3><span id="3-关键特性">3. 关键特性</span></h3><ol><li><p><strong>单例模式</strong>：确保全局唯一线程池实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ThreadPool&lt;T&gt; &amp;<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> ThreadPool&lt;T&gt; tp;</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优雅停机</strong>：</p><ul><li>设置<code>running_</code>标志位</li><li>广播条件变量唤醒所有线程</li><li>等待所有线程结束</li></ul></li><li><p><strong>高效唤醒机制</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T &amp;task)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">LockGuard <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        tasks_.<span class="built_in">push</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;cond_); <span class="comment">// 在锁外唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3><span id="4-使用示例">4. 使用示例</span></h3><p>我们仍然使用之前的任务类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TASK_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TASK_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">calc_error</span>&#123;</span><br><span class="line">    division_by_zero_error = <span class="number">1</span>,</span><br><span class="line">    operator_error,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> num1 = <span class="number">0</span>, <span class="type">int</span> num2 = <span class="number">0</span>, <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    :<span class="built_in">num1_</span>(num1),</span><br><span class="line">    <span class="built_in">num2_</span>(num2),</span><br><span class="line">    <span class="built_in">op_</span>(op)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        exitcode_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op_)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            result_ = num1_ + num2_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            result_ = num1_ - num2_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            result_ = num1_ * num2_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(num2_ == <span class="number">0</span>)&#123;</span><br><span class="line">                result_ = <span class="number">0</span>;</span><br><span class="line">                exitcode_ = calc_error::division_by_zero_error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> result_ = num1_ / num2_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(num2_ == <span class="number">0</span>)&#123;</span><br><span class="line">                result_ = <span class="number">0</span>;</span><br><span class="line">                exitcode_ = calc_error::division_by_zero_error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> result_ = num1_ % num2_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result_ = <span class="number">0</span>;</span><br><span class="line">            exitcode_ = calc_error::operator_error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string ret = std::<span class="built_in">to_string</span>(num1_);</span><br><span class="line">        ret += op_;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(num2_);</span><br><span class="line">        ret += <span class="string">&quot;=&quot;</span>;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(result_);</span><br><span class="line">        ret += <span class="string">&quot;[code: &quot;</span>;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(exitcode_);</span><br><span class="line">        ret += <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string ret = std::<span class="built_in">to_string</span>(num1_);</span><br><span class="line">        ret += op_;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(num2_);</span><br><span class="line">        ret += <span class="string">&quot;=?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num1_, num2_;</span><br><span class="line">    <span class="type">char</span> op_;</span><br><span class="line">    <span class="type">int</span> result_;</span><br><span class="line">    <span class="type">int</span> exitcode_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>测试主函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_pool.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> total_task = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_cons;</span><br><span class="line"><span class="type">sem_t</span> sem_pro;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> opers[] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;%&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start_time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">elapsed</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过的毫秒数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">elapsed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">return</span> std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过的秒数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">elapsedSeconds</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">elapsed</span>() / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Producer</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(args);</span><br><span class="line">    string name = td-&gt;name;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sem_trywait</span>(&amp;sem_pro)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">int</span> num1 = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">        <span class="type">char</span> op = opers[<span class="built_in">rand</span>() % <span class="number">5</span>];</span><br><span class="line">        Task task&#123;num1, num2, op&#125;;</span><br><span class="line">        ThreadPool&lt;Task&gt;::<span class="built_in">GetInstance</span>().<span class="built_in">Push</span>(task);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, name.<span class="built_in">c_str</span>(), task.<span class="built_in">GetTask</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem_cons, <span class="number">0</span>, total_task);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem_pro, <span class="number">0</span>, total_task);</span><br><span class="line">    ThreadPool&lt;Task&gt;::<span class="built_in">GetInstance</span>().<span class="built_in">Start</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= thread_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;producer-&quot;</span> + <span class="built_in">to_string</span>(i);</span><br><span class="line">        thread_data *td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            name: name</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Producer, (<span class="type">void</span>*)(td));</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        Timer time;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tid: tids) <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样有一个计时器，不过这里的计时器用处不是很大，因为并没有值得对比的其他类型的线程池，不过我们可以和之前的阻塞队列和环形队列相对比，因为它们都属于是一种生产者-消费者模型。</p><p>上面的测试用例是为了查看一下打印结果，验证该线程池是否能够正常工作，我们看一下打印结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">thread-1: 0*6=0[code: 0]</span><br><span class="line">thread-1: 2+7=9[code: 0]</span><br><span class="line">producer-1: 0*6=?</span><br><span class="line">producer-9: 2+7=?</span><br><span class="line">thread-3: 6+9=15[code: 0]</span><br><span class="line">producer-10: 6+9=?</span><br><span class="line">thread-4: 4/6=0[code: 0]</span><br><span class="line">producer-11: 4/6=?</span><br><span class="line">thread-5: 5+2=7[code: 0]</span><br><span class="line">producer-12: 5+2=?</span><br><span class="line">thread-6: 6*2=12[code: 0]</span><br><span class="line">producer-10: 6*2=?</span><br><span class="line">thread-8: 9-3=6[code: 0]</span><br><span class="line">thread-7: 4%8=4[code: 0]</span><br><span class="line">producer-1: 4%8=?</span><br><span class="line">producer-9: 9-3=?</span><br><span class="line">thread-9: 8-7=1[code: 0]</span><br><span class="line">producer-10: 8-7=?</span><br><span class="line">thread-10: 5*8=40[code: 0]</span><br><span class="line">producer-11: 5*8=?</span><br><span class="line">thread-11: 6/1=6[code: 0]</span><br><span class="line">producer-12: 6/1=?</span><br><span class="line">producer-1: 8*3=?</span><br><span class="line">thread-12: 8*3=24[code: 0]</span><br><span class="line">producer-9: 5%1=?</span><br><span class="line">thread-13: 5%1=0[code: 0]</span><br><span class="line">producer-15: 8*8=?</span><br><span class="line">thread-19: 8*8=64[code: 0]</span><br><span class="line">producer-10: 5+5=?</span><br><span class="line">thread-14: 5+5=10[code: 0]</span><br><span class="line">producer-1: 5%3=?</span><br><span class="line">thread-15: 5%3=2[code: 0]</span><br><span class="line">producer-11: 5*9=?</span><br><span class="line">thread-16: 5*9=45[code: 0]</span><br><span class="line">producer-13: 5+6=?</span><br><span class="line">thread-17: 5+6=11[code: 0]</span><br><span class="line">producer-14: 1+7=?</span><br><span class="line">thread-18: 1+7=8[code: 0]</span><br><span class="line">producer-2: 1/3=?</span><br><span class="line">thread-20: 1/3=0[code: 0]</span><br><span class="line">0.928079</span><br></pre></td></tr></table></figure><p>接下来，我们和前面的阻塞队列和环形队列进行比较，我们修改一下测试用例，让生产者和消费者数量相等，任务数量也相等，然后我们比较一下它们的执行时间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了任务总量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> total_task = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">// 将打印信息屏蔽掉了</span></span><br><span class="line"><span class="comment">// main.cc</span></span><br><span class="line"><span class="comment">// printf(&quot;%s: %s\n&quot;, name.c_str(), task.GetTask().c_str());</span></span><br><span class="line"><span class="comment">// thread.hpp</span></span><br><span class="line"><span class="comment">// printf(&quot;%s: %s\n&quot;, thread_name.c_str(), task.GetResult().c_str());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task.hpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 给任务同样增加延迟，统一变数</span></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试后结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">676.78</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">905.2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">724.741</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第四次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">813.893</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第五次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">923.235</span><br></pre></td></tr></table></figure><p>平均用时：（676.78 + 905.2 + 724.741 + 813.893 + 923.235）&#x2F; 5 &#x3D; 811.8774</p><p>可以看到，效率肯定不如环形队列，因为环形队列极大减少了消费者和生产者之间的冲突，只有在队列为空为满的时候才会等待</p><p>既然如此，我们为何不试试利用环形队列来实现线程池呢？</p><p>说干就干，利用信号量来大幅度降低 <code>Push</code> 和 <code>Pop</code> 锁冲突的开销，我们来实现一个基于环形队列的线程池</p><h2><span id="基于环形队列信号量的线程池">基于环形队列（信号量）的线程池</span></h2><h3><span id="代码实现">代码实现</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREAD_POOL_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREAD_POOL_HPP_ 1;  <span class="comment">// 头文件保护宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>          <span class="comment">// POSIX线程库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span>      <span class="comment">// 线程管理容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>              <span class="comment">// 任务队列（已弃用）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span>        <span class="comment">// 信号量支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> default_cap = <span class="number">20</span>; <span class="comment">// 默认线程数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RAII互斥锁封装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockGuard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockGuard</span><span class="params">(<span class="type">pthread_mutex_t</span> &amp;mtx)</span></span></span><br><span class="line"><span class="function">        : push_mtx_(mtx) &#123;</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;push_mtx_);  <span class="comment">// 构造时加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LockGuard</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;push_mtx_); <span class="comment">// 析构时解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值</span></span><br><span class="line">    <span class="built_in">LockGuard</span>(<span class="type">const</span> LockGuard &amp;) = <span class="keyword">delete</span>;            </span><br><span class="line">    LockGuard &amp;<span class="keyword">operator</span>=(<span class="type">const</span> LockGuard &amp;) = <span class="keyword">delete</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> &amp;push_mtx_;  <span class="comment">// 管理的互斥锁引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 从环形队列取出任务</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T task = tasks_[pop_pos_];       <span class="comment">// 获取当前读位置任务</span></span><br><span class="line">        pop_pos_ = (pop_pos_ + <span class="number">1</span>) % task_cap_; <span class="comment">// 环形递增读指针</span></span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装sem_wait（P操作）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="type">sem_t</span> &amp;sem)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装sem_post（V操作）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="type">sem_t</span> &amp;sem)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程上下文数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_data</span> &#123;</span><br><span class="line">        std::string name;    <span class="comment">// 线程名称</span></span><br><span class="line">        ThreadPool&lt;T&gt; *tp;   <span class="comment">// 所属线程池指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例（线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadPool&lt;T&gt; &amp;<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> ThreadPool&lt;T&gt; tp;  <span class="comment">// C++11保证静态变量线程安全</span></span><br><span class="line">        <span class="keyword">return</span> tp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cap_; ++i) &#123;</span><br><span class="line">            std::string name = <span class="string">&quot;thread-&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">            <span class="type">pthread_t</span> tid;</span><br><span class="line">            <span class="comment">// 创建线程上下文数据</span></span><br><span class="line">            thread_data *td = <span class="keyword">new</span> thread_data&#123; name, <span class="keyword">this</span> &#125;;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, ThreadHandler, td);</span><br><span class="line">            threads_[tid] = name;  <span class="comment">// 记录线程信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T &amp;task)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">P</span>(push_sem_);  <span class="comment">// 等待空闲槽位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">LockGuard <span class="title">lg</span><span class="params">(push_mtx_)</span></span>;  <span class="comment">// 保护写指针</span></span><br><span class="line">            tasks_[push_pos_] = task; <span class="comment">// 写入任务</span></span><br><span class="line">            push_pos_ = (push_pos_ + <span class="number">1</span>) % task_cap_; <span class="comment">// 环形递增写指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">V</span>(pop_sem_);  <span class="comment">// 通知有新任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">End</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">LockGuard <span class="title">pop_lg</span><span class="params">(pop_mtx_)</span></span>;</span><br><span class="line">            running_ = <span class="literal">false</span>;  <span class="comment">// 设置停止标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程退出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[tid, name] : threads_) &#123;</span><br><span class="line">            <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threads_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程处理函数（静态方法）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">ThreadHandler</span><span class="params">(<span class="type">void</span> *args)</span> </span>&#123;</span><br><span class="line">        thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(args);</span><br><span class="line">        ThreadPool&lt;T&gt; *tp = td-&gt;tp;</span><br><span class="line">        T task;</span><br><span class="line">        <span class="type">int</span> wait_ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 非阻塞式获取任务</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                wait_ret = <span class="built_in">sem_trywait</span>(&amp;tp-&gt;pop_sem_);  <span class="comment">// 尝试获取任务</span></span><br><span class="line">                <span class="keyword">if</span> (wait_ret == <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">// 成功获取</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN) &#123;     <span class="comment">// 无任务可用</span></span><br><span class="line">                    <span class="keyword">if</span> (!tp-&gt;running_) &#123;    <span class="comment">// 检查停止标志</span></span><br><span class="line">                        <span class="keyword">delete</span> td;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nullptr</span>;     <span class="comment">// 安全退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">usleep</span>(<span class="number">1000</span>);          <span class="comment">// 避免忙等待</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// 其他错误</span></span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;sem_trywait&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理任务</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">LockGuard <span class="title">lg</span><span class="params">(tp-&gt;pop_mtx_)</span></span>;  <span class="comment">// 保护读指针</span></span><br><span class="line">                task = tp-&gt;<span class="built_in">Pop</span>();           <span class="comment">// 取出任务</span></span><br><span class="line">            &#125;</span><br><span class="line">            tp-&gt;<span class="built_in">V</span>(tp-&gt;push_sem_);  <span class="comment">// 释放一个空槽位</span></span><br><span class="line">            <span class="built_in">task</span>();                <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> td;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数（单例模式）</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> cap = default_cap, <span class="type">size_t</span> task_cap = <span class="number">10</span>)</span><br><span class="line">        : <span class="built_in">cap_</span>(cap),              <span class="comment">// 线程数量</span></span><br><span class="line">          <span class="built_in">task_cap_</span>(task_cap),    <span class="comment">// 环形队列容量</span></span><br><span class="line">          <span class="built_in">running_</span>(<span class="literal">false</span>),        <span class="comment">// 初始状态</span></span><br><span class="line">          <span class="built_in">push_pos_</span>(<span class="number">0</span>),           <span class="comment">// 写指针初始化</span></span><br><span class="line">          <span class="built_in">pop_pos_</span>(<span class="number">0</span>),            <span class="comment">// 读指针初始化</span></span><br><span class="line">          <span class="built_in">tasks_</span>(task_cap)        <span class="comment">// 预分配队列空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;push_mtx_, <span class="literal">nullptr</span>);  <span class="comment">// 写互斥锁初始化</span></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;pop_mtx_, <span class="literal">nullptr</span>);   <span class="comment">// 读互斥锁初始化</span></span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;push_sem_, <span class="number">0</span>, task_cap);       <span class="comment">// 空槽位信号量（初始=容量）</span></span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;pop_sem_, <span class="number">0</span>, <span class="number">0</span>);               <span class="comment">// 任务信号量（初始=0）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (running_) <span class="built_in">End</span>();  <span class="comment">// 确保资源释放</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;push_mtx_);</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;pop_mtx_);</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;push_sem_);</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;pop_sem_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">const</span> ThreadPool&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程管理</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">pthread_t</span>, std::string&gt; threads_;  <span class="comment">// 线程记录</span></span><br><span class="line">    <span class="type">size_t</span> cap_;          <span class="comment">// 线程数量上限</span></span><br><span class="line">    <span class="type">size_t</span> task_cap_;     <span class="comment">// 环形队列容量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环形队列控制</span></span><br><span class="line">    <span class="type">size_t</span> push_pos_;     <span class="comment">// 写位置指针</span></span><br><span class="line">    <span class="type">size_t</span> pop_pos_;      <span class="comment">// 读位置指针</span></span><br><span class="line">    std::vector&lt;T&gt; tasks_;<span class="comment">// 环形队列容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步机制</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> push_mtx_;  <span class="comment">// 写指针互斥锁</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> pop_mtx_;   <span class="comment">// 读指针互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> push_sem_;      <span class="comment">// 空槽位信号量（生产者）</span></span><br><span class="line">    <span class="type">sem_t</span> pop_sem_;       <span class="comment">// 任务信号量（消费者）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> running_;        <span class="comment">// 运行状态标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><h3><span id="一-设计思想">一、设计思想</span></h3><ol><li><p><strong>生产者-消费者模型优化</strong></p><ul><li>传统队列需要同时锁住头尾指针，而环形队列通过<strong>固定大小预分配内存</strong> + <strong>读写指针分离</strong>，实现：<ul><li>生产者只修改<code>push_pos_</code>（写指针）</li><li>消费者只修改<code>pop_pos_</code>（读指针）</li><li>读写操作<strong>完全解耦</strong>，无需竞争同一把锁</li></ul></li></ul></li><li><p><strong>信号量控制流量</strong></p><ul><li><code>push_sem_</code>：剩余空闲槽位数（初始&#x3D;队列容量）</li><li><code>pop_sem_</code>：待消费任务数（初始&#x3D;0）</li><li>通过<code>P/V</code>操作自动阻塞&#x2F;唤醒线程，比条件变量更高效</li></ul></li><li><p><strong>无锁化尝试</strong></p><ul><li>使用<code>sem_trywait</code> + <code>usleep</code>实现<strong>非阻塞等待</strong>，避免线程在<code>sem_wait</code>中永久阻塞</li><li>单生产者&#x2F;消费者场景下可完全去除互斥锁（当前实现保留锁是为兼容多生产者场景）</li></ul></li></ol><hr><h3><span id="二-关键组件解析">二、关键组件解析</span></h3><h4><span id="1-环形队列核心结构">1. 环形队列核心结构</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> push_pos_;        <span class="comment">// 写指针（生产者专用）</span></span><br><span class="line"><span class="type">size_t</span> pop_pos_;         <span class="comment">// 读指针（消费者专用）</span></span><br><span class="line">std::vector&lt;T&gt; tasks_;   <span class="comment">// 预分配环形缓冲区</span></span><br><span class="line"><span class="type">size_t</span> task_cap_;        <span class="comment">// 队列容量</span></span><br></pre></td></tr></table></figure><ul><li><strong>环形计算</strong>：<code>pos = (pos + 1) % task_cap_</code> 实现指针回绕</li><li><strong>内存预分配</strong>：避免动态内存申请的开销</li></ul><h4><span id="2-同步机制">2. 同步机制</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> push_sem_;         <span class="comment">// 空闲槽位信号量</span></span><br><span class="line"><span class="type">sem_t</span> pop_sem_;          <span class="comment">// 任务信号量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> push_mtx_;<span class="comment">// 写互斥锁（多生产者时需要）</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> pop_mtx_; <span class="comment">// 读互斥锁（多消费者时需要）</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>信号量初始化</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem_init</span>(&amp;push_sem_, <span class="number">0</span>, task_cap_); <span class="comment">// 初始有task_cap_个空位</span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;pop_sem_, <span class="number">0</span>, <span class="number">0</span>);          <span class="comment">// 初始0个任务</span></span><br></pre></td></tr></table></figure></li></ul><h4><span id="3-线程控制">3. 线程控制</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> running_;           <span class="comment">// 线程池启停标志</span></span><br><span class="line">unordered_map&lt;<span class="type">pthread_t</span>, string&gt; threads_; <span class="comment">// 线程记录表</span></span><br></pre></td></tr></table></figure><ul><li><strong>优雅停止</strong>：<ul><li>设置<code>running_=false</code></li><li>通过<code>sem_post</code>唤醒所有阻塞线程</li><li>线程检查到<code>running_==false</code>且队列空时退出</li></ul></li></ul><hr><h3><span id="三-工作流程">三、工作流程</span></h3><h4><span id="生产者提交任务push">生产者提交任务（Push）</span></h4><pre class="mermaid">sequenceDiagram    participant Producer    participant push_sem_    participant Queue    participant pop_sem_        Producer->>push_sem_: P() 等待空槽    activate push_sem_    push_sem_-->>Producer: 获得空槽    deactivate push_sem_        Producer->>Queue: 加锁写入任务    Producer->>pop_sem_: V() 通知有新任务</pre><h4><span id="消费者处理任务threadhandler">消费者处理任务（ThreadHandler）</span></h4><pre class="mermaid">sequenceDiagram    participant Consumer    participant pop_sem_    participant Queue    participant push_sem_        loop 非阻塞等待        Consumer->>pop_sem_: sem_trywait()        alt 获取成功            pop_sem_-->>Consumer: 获得任务        else 无任务            Consumer->>running_: 检查停止标志        end    end        Consumer->>Queue: 加锁取出任务    Consumer->>push_sem_: V() 释放空槽    Consumer->>Task: 执行任务</pre><hr><h3><span id="四-性能优化点">四、性能优化点</span></h3><ol><li><p><strong>锁粒度最小化</strong></p><ul><li>写操作只锁<code>push_mtx_</code>（保护<code>push_pos_</code>）</li><li>读操作只锁<code>pop_mtx_</code>（保护<code>pop_pos_</code>）</li></ul></li><li><p><strong>缓存友好设计</strong></p><ul><li><code>std::vector</code>连续内存布局</li><li>读写指针原子操作（可升级为<code>atomic&lt;size_t&gt;</code>）</li></ul></li><li><p><strong>避免惊群效应</strong></p><ul><li>精准的<code>sem_post</code>唤醒（传统条件变量会唤醒所有等待线程）</li></ul></li></ol><p>我们来看一下这个程序的效率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">659.121</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">624.264</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">607.972</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第四次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">551.506</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第五次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">610.404</span><br></pre></td></tr></table></figure><p>平均用时：（659.121+624.264+607.972+551.506+610.404）&#x2F;5 &#x3D; 607.576ms</p><p>与传统的线程池相比，性能提升了不少</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程信号量（POSIX）--优化多生产者-消费者框架</title>
      <link href="/2025/07/26/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_sem/"/>
      <url>/2025/07/26/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_sem/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#posix%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore">POSIX线程信号量（Semaphore）</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li><li><a href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">核心函数</a></li><li><a href="#%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">典型使用场景</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81">信号量 vs 互斥锁</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li></ul></li><li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者-消费者问题</a><ul><li><a href="#1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90">1. 核心组件解析</a></li><li><a href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3">2. 工作原理详解</a></li><li><a href="#3-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%89%B9%E6%80%A7">3. 环形队列特性</a></li><li><a href="#4-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%82%B9">4. 性能优化点</a></li></ul></li></ul><!-- tocstop --><h2><span id="posix线程信号量semaphore">POSIX线程信号量（Semaphore）</span></h2><h3><span id="基本概念">基本概念</span></h3><p>POSIX信号量是一种用于线程同步的机制，主要用于控制对共享资源的访问。它维护一个计数器，提供两种基本操作：</p><ul><li><strong>P操作（wait）</strong>：计数器减1，如果计数器为0则阻塞</li><li><strong>V操作（post）</strong>：计数器加1，唤醒等待的线程</li></ul><h3><span id="核心函数">核心函数</span></h3><h4><span id="sem_init-初始化信号量"><code>sem_init()</code> - 初始化信号量</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>sem</code>：信号量指针</li><li><code>pshared</code>：0表示线程间共享（进程间使用设为非零）</li><li><code>value</code>：信号量初始值</li></ul><h4><span id="sem_wait-p操作获取资源"><code>sem_wait()</code> - P操作（获取资源）</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>原子地减少信号量值</li><li>如果值为0则阻塞，直到信号量变为正数</li></ul><h4><span id="sem_post-v操作释放资源"><code>sem_post()</code> - V操作（释放资源）</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>原子地增加信号量值</li><li>如果有线程在等待，唤醒其中一个</li></ul><h4><span id="sem_destroy-销毁信号量"><code>sem_destroy()</code> - 销毁信号量</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h3><span id="典型使用场景">典型使用场景</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;  <span class="comment">// 声明信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量（初始值为1）</span></span><br><span class="line">sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;sem);  <span class="comment">// P操作</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    sem_post(&amp;sem);  <span class="comment">// V操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;sem);  <span class="comment">// P操作</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    sem_post(&amp;sem);  <span class="comment">// V操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁信号量</span></span><br><span class="line">sem_destroy(&amp;sem);</span><br></pre></td></tr></table></figure><h3><span id="信号量-vs-互斥锁">信号量 vs 互斥锁</span></h3><table><thead><tr><th>特性</th><th>信号量</th><th>互斥锁</th></tr></thead><tbody><tr><td>初始值</td><td>可设为任意非负整数</td><td>通常初始为1（解锁状态）</td></tr><tr><td>所有者</td><td>无所有者概念</td><td>有所有者（哪个线程锁定）</td></tr><tr><td>操作</td><td>post&#x2F;wait</td><td>lock&#x2F;unlock</td></tr><tr><td>主要用途</td><td>资源计数&#x2F;同步</td><td>保护临界区</td></tr></tbody></table><h3><span id="注意事项">注意事项</span></h3><ol><li>必须正确初始化信号量</li><li>避免死锁（特别是多个信号量使用时）</li><li>信号量没有自动释放机制（不像互斥锁的pthread_mutex_trylock）</li><li>销毁正在被等待的信号量会导致未定义行为</li></ol><p>POSIX信号量为线程同步提供了灵活的计数机制，特别适合需要控制多个线程访问多个资源实例的场景。</p><p>下面我们基于 POSIX 线程信号量设计一个环形队列来处理生产者消费者问题：</p><p>环形队列采用数组模拟，用模运算来模拟环状特性</p><p><img src="/img/Linux/thread/ring_queue.png" alt="ring_queue"></p><p>环形结构起始状态和结束状态都是⼀样的，不好判断为空或者为满，所以可以通过加计数器或者标记位来判断满或者空。另外也可以预留⼀个空的位置，作为满的状态</p><p><img src="/img/Linux/thread/ring_queue2.png" alt="ring_queue"></p><h2><span id="生产者-消费者问题">生产者-消费者问题</span></h2><p>下面我将详细讲解基于环形队列(RingQueue)实现的生产者-消费者模型，并对代码进行完整注释和分析。</p><h3><span id="1-核心组件解析">1. 核心组件解析</span></h3><h4><span id="11-lockguard-raii锁守卫类">1.1 LockGuard - RAII锁守卫类</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockGuard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockGuard</span><span class="params">(<span class="type">pthread_mutex_t</span> &amp;mtx)</span> : mtx_(mtx) &#123;</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mtx_);  <span class="comment">// 构造时自动加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LockGuard</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mtx_); <span class="comment">// 析构时自动解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">LockGuard</span>(<span class="type">const</span> LockGuard&amp;) = <span class="keyword">delete</span>;            </span><br><span class="line">    LockGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LockGuard&amp;) = <span class="keyword">delete</span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> &amp;mtx_;  <span class="comment">// 引用外部互斥锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>采用RAII(资源获取即初始化)技术管理互斥锁</li><li>构造时自动加锁，析构时自动解锁，避免忘记解锁</li><li>禁用拷贝构造和赋值，确保锁管理的唯一性</li></ul><h4><span id="12-ringqueue-环形队列模板类">1.2 RingQueue - 环形队列模板类</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RingQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 封装信号量P操作(等待)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="type">sem_t</span> &amp;sem)</span> </span>&#123; <span class="built_in">sem_wait</span>(&amp;sem); &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 封装信号量V操作(释放)  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="type">sem_t</span> &amp;sem)</span> </span>&#123; <span class="built_in">sem_post</span>(&amp;sem); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">RingQueue</span>(<span class="type">size_t</span> cap = <span class="number">10</span>) </span><br><span class="line">        : <span class="built_in">cap_</span>(cap), <span class="built_in">c_index_</span>(<span class="number">0</span>), <span class="built_in">p_index_</span>(<span class="number">0</span>), <span class="built_in">queue</span>(cap) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;p_mutex_, <span class="literal">nullptr</span>);  <span class="comment">// 生产者互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;c_mutex_, <span class="literal">nullptr</span>);  <span class="comment">// 消费者互斥锁</span></span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;space_sem_, <span class="number">0</span>, cap_);          <span class="comment">// 空间信号量(初始=容量)</span></span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;data_sem_, <span class="number">0</span>, <span class="number">0</span>);              <span class="comment">// 数据信号量(初始=0)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">RingQueue</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;p_mutex_);</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;c_mutex_);</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;space_sem_);</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;data_sem_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生产者接口：添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T &amp; task)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">P</span>(space_sem_);  <span class="comment">// 等待有空闲空间</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">LockGuard <span class="title">lg</span><span class="params">(p_mutex_)</span></span>;  <span class="comment">// 加生产者锁</span></span><br><span class="line">            queue[p_index_] = task;  <span class="comment">// 放入任务</span></span><br><span class="line">            p_index_ = (p_index_ + <span class="number">1</span>) % cap_;  <span class="comment">// 更新生产者索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">V</span>(data_sem_);  <span class="comment">// 增加数据信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消费者接口：获取任务</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T task;</span><br><span class="line">        <span class="built_in">P</span>(data_sem_);  <span class="comment">// 等待有数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">LockGuard <span class="title">lg</span><span class="params">(c_mutex_)</span></span>;  <span class="comment">// 加消费者锁</span></span><br><span class="line">            task = queue[c_index_];  <span class="comment">// 取出任务</span></span><br><span class="line">            c_index_ = (c_index_ + <span class="number">1</span>) % cap_;  <span class="comment">// 更新消费者索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">V</span>(space_sem_);  <span class="comment">// 增加空间信号量</span></span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> space_sem_;        <span class="comment">// 空间信号量(剩余可生产空间)</span></span><br><span class="line">    <span class="type">sem_t</span> data_sem_;         <span class="comment">// 数据信号量(现有可消费数据)</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> p_mutex_; <span class="comment">// 生产者互斥锁</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> c_mutex_; <span class="comment">// 消费者互斥锁</span></span><br><span class="line">    <span class="type">size_t</span> cap_;             <span class="comment">// 队列容量</span></span><br><span class="line">    <span class="type">size_t</span> c_index_;         <span class="comment">// 消费者索引</span></span><br><span class="line">    <span class="type">size_t</span> p_index_;         <span class="comment">// 生产者索引</span></span><br><span class="line">    std::vector&lt;T&gt; queue;    <span class="comment">// 底层存储容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="2-工作原理详解">2. 工作原理详解</span></h3><h4><span id="21-同步机制设计">2.1 同步机制设计</span></h4><ol><li><p><strong>双信号量控制</strong>：</p><ul><li><code>space_sem_</code>：表示剩余可生产空间，初始值为队列容量</li><li><code>data_sem_</code>：表示现有可消费数据，初始值为0</li></ul></li><li><p><strong>双互斥锁设计</strong>：</p><ul><li><code>p_mutex_</code>：保护生产者端的队列操作</li><li><code>c_mutex_</code>：保护消费者端的队列操作</li><li>生产者和消费者使用不同的锁，提高并发性能</li></ul></li></ol><h4><span id="22-生产者流程push">2.2 生产者流程(Push)</span></h4><ol><li><code>P(space_sem_)</code>：等待有空闲位置(信号量&gt;0)</li><li>获取生产者锁<code>p_mutex_</code></li><li>将任务放入队列<code>p_index_</code>位置</li><li>更新生产者索引(环形计算)</li><li>释放生产者锁</li><li><code>V(data_sem_)</code>：增加可消费数据计数</li></ol><h4><span id="23-消费者流程pop">2.3 消费者流程(Pop)</span></h4><ol><li><code>P(data_sem_)</code>：等待有可消费数据(信号量&gt;0)</li><li>获取消费者锁<code>c_mutex_</code></li><li>从队列<code>c_index_</code>位置取出任务</li><li>更新消费者索引(环形计算)</li><li>释放消费者锁</li><li><code>V(space_sem_)</code>：增加可用空间计数</li></ol><h3><span id="3-环形队列特性">3. 环形队列特性</span></h3><ol><li><p><strong>索引计算</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_index_ = (p_index_ + <span class="number">1</span>) % cap_;  <span class="comment">// 生产者索引更新</span></span><br><span class="line">c_index_ = (c_index_ + <span class="number">1</span>) % cap_;  <span class="comment">// 消费者索引更新</span></span><br></pre></td></tr></table></figure><ul><li>通过取模运算实现环形缓冲区</li><li>当索引到达末尾时自动回到开头</li></ul></li><li><p><strong>读写分离</strong>：</p><ul><li>生产者和消费者使用不同的索引</li><li>读写操作不会互相干扰</li></ul></li></ol><h3><span id="4-性能优化点">4. 性能优化点</span></h3><ol><li><p><strong>锁分离</strong>：</p><ul><li>生产者和消费者使用不同的互斥锁</li><li>减少锁竞争，提高并发性能</li></ul></li><li><p><strong>RAII锁管理</strong>：</p><ul><li>使用LockGuard自动管理锁的生命周期</li><li>避免忘记解锁导致的死锁</li></ul></li><li><p><strong>信号量先行</strong>：</p><ul><li>先检查信号量再获取锁</li><li>减少持有锁时的等待时间</li></ul></li></ol><p>我们来测试一下修改后的模型和原先基于阻塞队列的模型相比哪一个更快一些：</p><p>基于阻塞队列的模型测试用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;block_queue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ring_queue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> consumer_num = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> producer_num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> total_task = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_cons;</span><br><span class="line"><span class="type">sem_t</span> sem_pro;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> opers[] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;%&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    BlockQueue&lt;Task&gt; *bq;</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start_time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">elapsed</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过的毫秒数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">elapsed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">return</span> std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过的秒数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">elapsedSeconds</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">elapsed</span>() / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Producer</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(args);</span><br><span class="line">    string name = td-&gt;name;</span><br><span class="line">    BlockQueue&lt;Task&gt; *bq = td-&gt;bq;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sem_trywait</span>(&amp;sem_pro)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">int</span> num1 = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">        <span class="type">char</span> op = opers[<span class="built_in">rand</span>() % <span class="number">5</span>];</span><br><span class="line">        Task task&#123;num1, num2, op&#125;;</span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; task.GetTask() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">        bq-&gt;<span class="built_in">Push</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Consumer</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(args);</span><br><span class="line">    string name = td-&gt;name;</span><br><span class="line">    BlockQueue&lt;Task&gt; *bq = td-&gt;bq;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sem_trywait</span>(&amp;sem_cons)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">        Task task = bq-&gt;<span class="built_in">Pop</span>();</span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; task.GetResult() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="function">BlockQueue&lt;Task&gt; <span class="title">bq</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">RingQueue&lt;Task&gt; <span class="title">rq</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem_cons, <span class="number">0</span>, total_task);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem_pro, <span class="number">0</span>, total_task);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= producer_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;producer-&quot;</span> + <span class="built_in">to_string</span>(i);</span><br><span class="line">        thread_data *td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            name: name,</span><br><span class="line">            bq: &amp;bq</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Producer, (<span class="type">void</span>*)(td));</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= consumer_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;consumer-&quot;</span> + <span class="built_in">to_string</span>(i);</span><br><span class="line">        thread_data *td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            name: name,</span><br><span class="line">            bq: &amp;bq</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Consumer, (<span class="type">void</span>*)(td));</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        Timer time;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tid: tids) <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">755.378</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">935.271</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">1158.35</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第四次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">925.125</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第五次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">1100.93</span><br></pre></td></tr></table></figure><p>平均用时：755.378 + 935.271 + 1158.35 + 925.125 + 1100.93 &#x3D; 5870.05 &#x2F; 5 &#x3D; 1174.01</p><p>基于环形队列的模型测试用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;block_queue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ring_queue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> consumer_num = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> producer_num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> total_task = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_cons;</span><br><span class="line"><span class="type">sem_t</span> sem_pro;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> opers[] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;%&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    RingQueue&lt;Task&gt; *rq;</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start_time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">elapsed</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过的毫秒数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">elapsed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">return</span> std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过的秒数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">elapsedSeconds</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">elapsed</span>() / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Producer</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(args);</span><br><span class="line">    string name = td-&gt;name;</span><br><span class="line">    RingQueue&lt;Task&gt; *rq = td-&gt;rq;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sem_trywait</span>(&amp;sem_pro)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">int</span> num1 = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">        <span class="type">char</span> op = opers[<span class="built_in">rand</span>() % <span class="number">5</span>];</span><br><span class="line">        Task task&#123;num1, num2, op&#125;;</span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; task.GetTask() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">        rq-&gt;<span class="built_in">Push</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Consumer</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(args);</span><br><span class="line">    string name = td-&gt;name;</span><br><span class="line">    RingQueue&lt;Task&gt; *rq = td-&gt;rq;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sem_trywait</span>(&amp;sem_cons)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">        Task task = rq-&gt;<span class="built_in">Pop</span>();</span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; task.GetResult() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="function">BlockQueue&lt;Task&gt; <span class="title">bq</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">RingQueue&lt;Task&gt; <span class="title">rq</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem_cons, <span class="number">0</span>, total_task);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem_pro, <span class="number">0</span>, total_task);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= consumer_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;producer-&quot;</span> + <span class="built_in">to_string</span>(i);</span><br><span class="line">        thread_data *td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            name: name,</span><br><span class="line">            rq: &amp;rq</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Producer, (<span class="type">void</span>*)(td));</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= producer_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;consumer-&quot;</span> + <span class="built_in">to_string</span>(i);</span><br><span class="line">        thread_data *td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            name: name,</span><br><span class="line">            rq: &amp;rq</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Consumer, (<span class="type">void</span>*)(td));</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        Timer time;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tid: tids) <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">685.519</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">688.496</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">655.452</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第四次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">684.919</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第五次</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/thread  </span><br><span class="line">╰─➤  ./cp.o</span><br><span class="line">665.94</span><br></pre></td></tr></table></figure><p>平均用时：685.519 + 688.496 + 655.452 + 684.919 + 665.94 &#x3D; 3380.326 &#x2F; 5 &#x3D; 676.0652</p><p>由此可见，在多生产者多消费者场景下，基于信号量的环形队列（RingQueue）通常比传统阻塞队列（BlockingQueue）有更好的性能表现，具体比较如下：</p><ol><li><strong>锁粒度差异</strong></li></ol><table><thead><tr><th>队列类型</th><th>锁机制</th><th>并发度影响</th></tr></thead><tbody><tr><td>传统阻塞队列</td><td>全局单一互斥锁</td><td>所有操作串行化，竞争激烈</td></tr><tr><td>环形队列</td><td>生产者&#x2F;消费者双锁分离</td><td>生产消费可并行</td></tr></tbody></table><ol start="2"><li><strong>系统调用开销</strong></li></ol><table><thead><tr><th>操作</th><th>阻塞队列</th><th>环形队列</th></tr></thead><tbody><tr><td>入队&#x2F;出队</td><td>可能触发线程调度</td><td>纯用户态操作(信号量)</td></tr><tr><td>临界区执行时间</td><td>较长(含动态内存分配)</td><td>极短(仅索引计算)</td></tr></tbody></table><p>因此，在大多数的多生产者多消费者场景下，更推荐使用基于信号量的环形队列模型。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程同步</title>
      <link href="/2025/07/26/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_syn/"/>
      <url>/2025/07/26/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_syn/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F">条件变量</a><ul><li><a href="#%E5%85%B3%E9%94%AE%E7%89%B9%E7%82%B9">关键特点</a></li><li><a href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">典型应用场景</a></li></ul></li><li><a href="#%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6">同步概念与竞态条件</a><ul><li><a href="#%E5%90%8C%E6%AD%A5">同步</a></li><li><a href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6">竞态条件</a></li></ul></li><li><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0">条件变量函数</a><ul><li><a href="#pthread_cond_init-%E4%B8%8E-pthread_cond_destroy"><code>pthread_cond_init</code> 与 <code>pthread_cond_destroy</code></a></li></ul></li><li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0">生产者-消费者模型实现</a><ul><li><a href="#%E4%BB%BB%E5%8A%A1%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0-taskhpp">任务定义实现 (Task.hpp)</a></li><li><a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0-block_queuehpp">阻塞队列实现 (block_queue.hpp)</a></li><li><a href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0-cpcc">主程序实现 (cp.cc)</a></li><li><a href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%A4%BA%E4%BE%8B">程序运行结果示例</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E7%89%B9%E7%82%B9%E5%88%86%E6%9E%90">实现特点分析</a></li></ul></li></ul><!-- tocstop --><h2><span id="条件变量">条件变量</span></h2><p>条件变量是一种线程同步机制，用于在多线程环境中实现线程间的协调和通信。它允许一个线程在某个条件不满足时进入等待状态，直到另一个线程修改了该条件并通知等待的线程。</p><h3><span id="关键特点">关键特点</span></h3><ol><li><strong>与互斥锁配合使用</strong>：条件变量通常与互斥锁（mutex）一起使用，以确保对共享资源的互斥访问。</li><li><strong>等待与通知机制</strong>：<ul><li><code>wait</code>：线程在条件不满足时释放互斥锁并进入等待状态。</li><li><code>notify</code>：当条件改变时，其他线程通过<code>notify_one</code>或<code>notify_all</code>唤醒等待的线程。</li></ul></li><li><strong>避免忙等待</strong>：条件变量通过让线程休眠来减少不必要的CPU资源消耗。</li></ol><h3><span id="典型应用场景">典型应用场景</span></h3><ul><li>生产者-消费者问题：当队列为空时，消费者线程等待；生产者线程添加数据后通知消费者。</li><li>任务调度：线程等待特定条件（如资源可用）后再继续执行。</li></ul><hr><h2><span id="同步概念与竞态条件">同步概念与竞态条件</span></h2><h3><span id="同步">同步</span></h3><p>同步是指在多线程环境中，通过某种机制确保线程以预期的顺序访问共享资源，从而避免数据不一致或逻辑错误。同步的核心目标是：</p><ol><li><strong>数据安全</strong>：防止多个线程同时修改共享数据导致冲突。</li><li><strong>有序访问</strong>：控制线程的执行顺序，例如某些操作必须在其他操作完成后才能执行。</li><li><strong>避免饥饿</strong>：确保所有线程都能公平地获得资源。</li></ol><h4><span id="常见同步工具">常见同步工具</span></h4><ul><li>互斥锁（Mutex）</li><li>信号量（Semaphore）</li><li>条件变量（Condition Variable）</li></ul><h3><span id="竞态条件">竞态条件</span></h3><p>竞态条件是指程序的输出或行为依赖于不可控的事件时序，通常因多个线程或进程对共享资源的访问顺序不确定而导致。</p><h2><span id="条件变量函数">条件变量函数</span></h2><h3><span id="pthread_cond_init-与-pthread_cond_destroy"><code>pthread_cond_init</code> 与 <code>pthread_cond_destroy</code></span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;  <span class="comment">// 初始化条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;                              <span class="comment">// 销毁条件变量</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 功能</span><br><span class="line"></span><br><span class="line">- **`pthread_cond_init`**：动态初始化一个条件变量（`<span class="type">pthread_cond_t</span>`），使其可用于线程同步。  </span><br><span class="line">- **`pthread_cond_destroy`**：销毁已初始化的条件变量，释放相关资源。  </span><br><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **`cond`**（`<span class="type">pthread_cond_t</span> *`）  </span><br><span class="line">   - 要初始化或销毁的条件变量指针。  </span><br><span class="line"><span class="number">2.</span> **`attr`**（`<span class="type">const</span> <span class="type">pthread_condattr_t</span> *`，仅 `init` 使用）  </span><br><span class="line">   - 条件变量属性，通常设为 `<span class="literal">NULL</span>` 表示默认属性。  </span><br><span class="line"></span><br><span class="line">#### 返回值</span><br><span class="line"></span><br><span class="line">- **成功**：返回 `<span class="number">0</span>`。  </span><br><span class="line">- **失败**：返回错误码（如 `EINVAL` 表示无效参数）。  </span><br><span class="line"></span><br><span class="line">#### 示例</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">    <span class="type">pthread_condattr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化条件变量属性（可选）</span></span><br><span class="line">    pthread_condattr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态初始化条件变量</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_cond_init(&amp;cond, &amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_cond_init failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用条件变量...（通常配合互斥锁和 pthread_cond_wait/signal）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量和属性</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_condattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化示例（无需 destroy）</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> static_cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 关键说明</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **静态初始化**：  </span><br><span class="line">   - 使用宏 `PTHREAD_COND_INITIALIZER` 直接初始化静态分配的条件变量，无需调用 `destroy`。  </span><br><span class="line">   ```c</span><br><span class="line">   <span class="type">pthread_cond_t</span> static_cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">   ```  </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> **动态初始化**：  </span><br><span class="line">   - 必须成对调用 `pthread_cond_init` 和 `pthread_cond_destroy`，避免资源泄漏。  </span><br><span class="line">   - 销毁后条件变量不可再使用，除非重新初始化。  </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> **线程安全**：  </span><br><span class="line">   - 初始化后的条件变量可被多线程使用，但需配合互斥锁（如 `<span class="type">pthread_mutex_t</span>`）实现同步。  </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> **错误处理**：  </span><br><span class="line">   - 检查返回值以确保操作成功，尤其在动态初始化时。  </span><br><span class="line"></span><br><span class="line">#### 注意事项</span><br><span class="line"></span><br><span class="line">- **`pthread_cond_destroy` 调用时机**：  </span><br><span class="line">  - 必须在所有线程结束使用条件变量后调用，否则行为未定义。  </span><br><span class="line">  - 若条件变量是静态初始化的（`PTHREAD_COND_INITIALIZER`），不可调用 `destroy`。  </span><br><span class="line"></span><br><span class="line">### `pthread_cond_wait`  </span><br><span class="line"></span><br><span class="line">#### 函数原型</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 功能</span><br><span class="line"></span><br><span class="line">使调用线程阻塞等待条件变量 `cond` 被唤醒，同时释放关联的互斥锁 `mutex`。当线程被唤醒后，该函数会重新获取 `mutex` 并返回。  </span><br><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **`cond`**（`<span class="type">pthread_cond_t</span> *`）  </span><br><span class="line">   - 指向已初始化的条件变量的指针。  </span><br><span class="line"><span class="number">2.</span> **`mutex`**（`<span class="type">pthread_mutex_t</span> *`）  </span><br><span class="line">   - 指向已锁定的互斥锁的指针，调用前必须由当前线程锁定。  </span><br><span class="line"></span><br><span class="line">#### 返回值</span><br><span class="line"></span><br><span class="line">- **成功**：返回 `<span class="number">0</span>`。  </span><br><span class="line">- **失败**：返回错误码（如 `EINVAL` 表示参数无效）。  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 关键行为</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **原子操作**：  </span><br><span class="line">   - **释放 `mutex`**：在进入等待状态前，自动释放 `mutex`，允许其他线程操作共享数据。  </span><br><span class="line">   - **重新获取 `mutex`**：被唤醒后，函数返回前会自动重新锁定 `mutex`。  </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> **虚假唤醒**：  </span><br><span class="line">   - 即使没有其他线程调用 `pthread_cond_signal` 或 `pthread_cond_broadcast`，线程也可能被唤醒。因此，条件判断必须使用 **`<span class="keyword">while</span>` 循环**而非 `<span class="keyword">if</span>`。</span><br><span class="line">   - 在调用 `pthread_cond_broadcast` 的情况下，所有等待线程都会被唤醒，其中一些线程可能在条件未满足时继续执行，导致竞态条件。 </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> **典型使用模式**：  </span><br><span class="line">   ```c</span><br><span class="line">   <span class="title function_">pthread_mutex_lock</span><span class="params">(&amp;mutex)</span>;</span><br><span class="line">   <span class="keyword">while</span> (condition_is_false) &#123;  <span class="comment">// 必须用 while 检查条件</span></span><br><span class="line">       pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 操作共享数据...</span></span><br><span class="line">   pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">   ```  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 示例</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (shared_data == <span class="number">0</span>) &#123;  <span class="comment">// 必须循环检查条件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer: Waiting for data...\n&quot;</span>);</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Consumer: Received data %d\n&quot;</span>, shared_data);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    shared_data = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Producer: Sending data...\n&quot;</span>);</span><br><span class="line">    pthread_cond_signal(&amp;cond);  <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 输出示例</span><br><span class="line"></span><br><span class="line">```plaintext</span><br><span class="line">Consumer: Waiting <span class="keyword">for</span> data...</span><br><span class="line">Producer: Sending data...</span><br><span class="line">Consumer: Received data <span class="number">42</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 注意事项</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **必须持有 `mutex`**：  </span><br><span class="line">   - 调用 `pthread_cond_wait` 前，线程必须已锁定 `mutex`，否则行为未定义。  </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> **条件检查**：  </span><br><span class="line">   - 必须使用 `<span class="keyword">while</span>` 循环检查条件，防止虚假唤醒导致逻辑错误。  </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> **性能优化**：  </span><br><span class="line">   - 在复杂场景中，可结合 `pthread_cond_broadcast`（唤醒所有等待线程）和 `pthread_cond_signal`（唤醒一个线程）选择唤醒策略。  </span><br><span class="line"></span><br><span class="line">### `pthread_cond_signal` 和 `pthread_cond_broadcast`</span><br><span class="line"></span><br><span class="line">#### 函数原型</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;    <span class="comment">// 唤醒至少一个等待线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>; <span class="comment">// 唤醒所有等待线程</span></span><br></pre></td></tr></table></figure><h4><span id="功能">功能</span></h4><p>这两个函数用于唤醒正在等待条件变量 <code>cond</code> 的线程：</p><ul><li><code>pthread_cond_signal</code>：唤醒至少一个等待该条件变量的线程（具体唤醒哪个由系统调度决定）</li><li><code>pthread_cond_broadcast</code>：唤醒所有等待该条件变量的线程</li></ul><h4><span id="参数">参数</span></h4><ul><li><strong><code>cond</code></strong>（<code>pthread_cond_t *</code>）：指向已初始化的条件变量的指针</li></ul><h4><span id="返回值">返回值</span></h4><ul><li>成功返回0</li><li>失败返回错误码（如EINVAL表示参数无效）</li></ul><h4><span id="关键区别">关键区别</span></h4><table><thead><tr><th>特性</th><th>pthread_cond_signal</th><th>pthread_cond_broadcast</th></tr></thead><tbody><tr><td>唤醒线程数量</td><td>至少一个</td><td>所有</td></tr><tr><td>性能影响</td><td>较低</td><td>较高</td></tr><tr><td>适用场景</td><td>单个资源可用</td><td>多个资源可用&#x2F;状态改变</td></tr></tbody></table><h4><span id="典型使用模式">典型使用模式</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 修改共享条件</span></span><br><span class="line">shared_condition = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 唤醒等待者</span></span><br><span class="line">pthread_cond_signal(&amp;cond);  <span class="comment">// 或 broadcast</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><h4><span id="示例">示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> data_ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* id)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (!data_ready) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld: got data\n&quot;</span>, (<span class="type">long</span>)id);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建3个工作线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);  <span class="comment">// 确保所有线程都进入等待</span></span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    data_ready = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// pthread_cond_signal(&amp;cond);  // 只会唤醒一个线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;cond);  <span class="comment">// 会唤醒所有线程</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li><p><strong>调用时机</strong>：</p><ul><li>通常在修改完条件变量关联的共享数据后调用</li><li>可以在持有或不持有互斥锁时调用，但通常建议在持有锁时调用以避免竞态条件</li></ul></li><li><p><strong>性能考虑</strong>：</p><ul><li><code>signal</code> 性能更高，适合只需唤醒一个线程的情况</li><li><code>broadcast</code> 会产生”惊群效应”，适合需要通知所有等待线程的场景</li></ul></li><li><p><strong>调用位置</strong>：</p><ul><li>可以在临界区内或外调用，但通常放在临界区内更安全</li></ul></li></ol><h4><span id="选择建议">选择建议</span></h4><ul><li>当只有一个线程能处理当前条件变化时，使用<code>signal</code></li><li>当条件变化允许&#x2F;需要多个线程响应时，使用<code>broadcast</code></li><li>当不确定时，使用<code>broadcast</code>更安全但性能较低</li></ul><h4><span id="常见使用场景">常见使用场景</span></h4><ul><li><code>signal</code>：生产者-消费者模型（单个资源）</li><li><code>broadcast</code>：读写锁实现、屏障同步、多个等待者需要响应状态变化</li></ul><h2><span id="生产者-消费者模型实现">生产者-消费者模型实现</span></h2><p>下面我将完整展示一个基于POSIX线程的生产者-消费者模型实现，包含任务定义、阻塞队列和主程序三个部分。</p><h3><span id="任务定义实现-taskhpp">任务定义实现 (Task.hpp)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TASK_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TASK_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算错误码枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">calc_error</span> &#123;</span><br><span class="line">    division_by_zero_error = <span class="number">1</span>,</span><br><span class="line">    operator_error,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数初始化运算数和操作符</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">char</span> op)</span><br><span class="line">        : <span class="built_in">num1_</span>(num1), <span class="built_in">num2_</span>(num2), <span class="built_in">op_</span>(op),</span><br><span class="line">          <span class="built_in">result_</span>(<span class="number">0</span>), <span class="built_in">exitcode_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 执行计算任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exitcode_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op_) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                result_ = num1_ + num2_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                result_ = num1_ - num2_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                result_ = num1_ * num2_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(num2_ == <span class="number">0</span>) &#123;</span><br><span class="line">                    result_ = <span class="number">0</span>;</span><br><span class="line">                    exitcode_ = division_by_zero_error;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result_ = num1_ / num2_;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">              <span class="keyword">if</span>(num2_ == <span class="number">0</span>)&#123;</span><br><span class="line">                  result_ = <span class="number">0</span>;</span><br><span class="line">                  exitcode_ = calc_error::division_by_zero_error;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> result_ = num1_ % num2_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result_ = <span class="number">0</span>;</span><br><span class="line">                exitcode_ = operator_error;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运算结果字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::string ret = std::<span class="built_in">to_string</span>(num1_);</span><br><span class="line">        ret += op_;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(num2_);</span><br><span class="line">        ret += <span class="string">&quot;=&quot;</span>;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(result_);</span><br><span class="line">        ret += <span class="string">&quot;[code: &quot;</span>;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(exitcode_);</span><br><span class="line">        ret += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务描述字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::string ret = std::<span class="built_in">to_string</span>(num1_);</span><br><span class="line">        ret += op_;</span><br><span class="line">        ret += std::<span class="built_in">to_string</span>(num2_);</span><br><span class="line">        ret += <span class="string">&quot;=?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num1_, num2_;    <span class="comment">// 运算数</span></span><br><span class="line">    <span class="type">char</span> op_;            <span class="comment">// 操作符</span></span><br><span class="line">    <span class="type">int</span> result_;         <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="type">int</span> exitcode_;       <span class="comment">// 错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3><span id="阻塞队列实现-block_queuehpp">阻塞队列实现 (block_queue.hpp)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BLOCK_QUEUE_CPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BLOCK_QUEUE_CPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程安全的阻塞队列模板类</span></span><br><span class="line"><span class="comment"> * @tparam T 队列元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     * @param cap 队列容量，默认为10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BlockQueue</span><span class="params">(u_int cap = <span class="number">10</span>)</span> : cap_(cap) &#123;</span></span><br><span class="line">        <span class="comment">// 初始化互斥锁和条件变量</span></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mtx_, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;c_cond_, <span class="literal">nullptr</span>);  <span class="comment">// 消费者条件变量</span></span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;p_cond_, <span class="literal">nullptr</span>);  <span class="comment">// 生产者条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~<span class="built_in">BlockQueue</span>() &#123;</span><br><span class="line">        <span class="comment">// 销毁互斥锁和条件变量</span></span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mtx_);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;c_cond_);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;p_cond_);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 向队列中添加元素</span></span><br><span class="line"><span class="comment">     * @param task 要添加的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; task)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mtx_);  <span class="comment">// 加锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果队列已满，生产者等待</span></span><br><span class="line">        <span class="keyword">while</span>(task_queue.<span class="built_in">size</span>() &gt;= cap_) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;p_cond_, &amp;mtx_);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        task_queue.<span class="built_in">push</span>(task);  <span class="comment">// 添加元素到队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知消费者有数据可取</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;c_cond_);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mtx_);  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从队列中取出元素</span></span><br><span class="line"><span class="comment">     * @return 队列首元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mtx_);  <span class="comment">// 加锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果队列为空，消费者等待</span></span><br><span class="line">        <span class="keyword">while</span>(task_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;c_cond_, &amp;mtx_);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        T task = task_queue.<span class="built_in">front</span>();  <span class="comment">// 获取队列首元素</span></span><br><span class="line">        task_queue.<span class="built_in">pop</span>();            <span class="comment">// 移除队列首元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知生产者有空位可生产</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;p_cond_);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mtx_);  <span class="comment">// 解锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; task_queue;  <span class="comment">// 底层队列容器</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mtx_;      <span class="comment">// 互斥锁，保护队列操作</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> c_cond_;    <span class="comment">// 消费者条件变量</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> p_cond_;    <span class="comment">// 生产者条件变量</span></span><br><span class="line">    u_int cap_;               <span class="comment">// 队列容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3><span id="主程序实现-cpcc">主程序实现 (cp.cc)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;block_queue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局输出互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> consumer_num = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> producer_num = <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> opers[] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;%&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程参数结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    BlockQueue&lt;Task&gt;* bq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Producer</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>* td = <span class="built_in">static_cast</span>&lt;thread_data*&gt;(args);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10000</span>);  <span class="comment">// 10ms延迟</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 生成随机任务</span></span><br><span class="line">        <span class="type">int</span> num1 = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">        <span class="type">char</span> op = opers[<span class="built_in">rand</span>() % <span class="number">5</span>];</span><br><span class="line">        Task task&#123;num1, num2, op&#125;;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 同步输出</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        std::cout &lt;&lt; td-&gt;name &lt;&lt; <span class="string">&quot; 生产: &quot;</span> &lt;&lt; task.<span class="built_in">GetTask</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">      </span><br><span class="line">        td-&gt;bq-&gt;<span class="built_in">Push</span>(task);  <span class="comment">// 放入队列</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 控制生产速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Consumer</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>* td = <span class="built_in">static_cast</span>&lt;thread_data*&gt;(args);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10000</span>);  <span class="comment">// 10ms延迟</span></span><br><span class="line">      </span><br><span class="line">        Task task = td-&gt;bq-&gt;<span class="built_in">Pop</span>();  <span class="comment">// 获取任务</span></span><br><span class="line">        <span class="built_in">task</span>();  <span class="comment">// 执行计算</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 同步输出结果</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        std::cout &lt;&lt; td-&gt;name &lt;&lt; <span class="string">&quot; 消费: &quot;</span> &lt;&lt; task.<span class="built_in">GetResult</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    BlockQueue&lt;Task&gt; bq;</span><br><span class="line">    std::vector&lt;<span class="type">pthread_t</span>&gt; tids;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建生产者线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= producer_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span>* td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            <span class="string">&quot;生产者-&quot;</span> + std::<span class="built_in">to_string</span>(i),</span><br><span class="line">            &amp;bq</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Producer, td);</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建消费者线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= consumer_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span>* td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            <span class="string">&quot;消费者-&quot;</span> + std::<span class="built_in">to_string</span>(i),</span><br><span class="line">            &amp;bq</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, Consumer, td);</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> tid : tids) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="程序运行结果示例">程序运行结果示例</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">生产者-1 生产: 3+7=?</span><br><span class="line">生产者-2 生产: 8-2=?</span><br><span class="line">消费者-1 消费: 3+7=10[code: 0]</span><br><span class="line">消费者-2 消费: 8-2=6[code: 0]</span><br><span class="line">生产者-3 生产: 5*4=?</span><br><span class="line">消费者-3 消费: 5*4=20[code: 0]</span><br><span class="line">生产者-4 生产: 9/3=?</span><br><span class="line">生产者-5 生产: 7%4=?</span><br><span class="line">消费者-1 消费: 9/3=3[code: 0]</span><br><span class="line">消费者-2 消费: 7%4=3[code: 0]</span><br><span class="line">生产者-1 生产: 2/0=?</span><br><span class="line">消费者-3 消费: 2/0=0[code: 1]</span><br><span class="line">生产者-2 生产: 6*3=?</span><br><span class="line">消费者-1 消费: 6*3=18[code: 0]</span><br></pre></td></tr></table></figure><h3><span id="实现特点分析">实现特点分析</span></h3><ol><li><p><strong>线程安全设计</strong>：</p><ul><li>使用互斥锁保护共享队列和标准输出</li><li>条件变量实现精确的线程唤醒机制</li></ul></li><li><p><strong>流量控制机制</strong>：</p><ul><li>当队列满时阻塞生产者线程</li><li>当队列空时阻塞消费者线程</li></ul></li><li><p><strong>任务处理流程</strong>：</p><ul><li>生产者生成随机算术运算任务</li><li>消费者执行运算并输出完整结果</li><li>包含完善的错误处理机制</li></ul></li><li><p><strong>资源管理</strong>：</p><ul><li>使用RAII风格管理互斥锁和条件变量</li><li>通过对象生命周期管理线程参数</li></ul></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程互斥</title>
      <link href="/2025/07/25/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_mutex/"/>
      <url>/2025/07/25/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_mutex/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3">进程线程间的互斥相关概念详解</a><ul><li><a href="#%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90">共享资源</a></li><li><a href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90">临界资源</a></li><li><a href="#%E4%B8%B4%E7%95%8C%E5%8C%BA">临界区</a></li><li><a href="#%E4%BA%92%E6%96%A5">互斥</a></li><li><a href="#%E5%8E%9F%E5%AD%90%E6%80%A7">原子性</a></li><li><a href="#%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">互斥的实现方式</a></li></ul></li><li><a href="#%E4%BA%92%E6%96%A5%E9%94%81-mutex">互斥锁 Mutex</a><ul><li><a href="#%E8%83%8C%E6%99%AF%E5%BC%95%E5%85%A5">背景引入</a></li><li><a href="#pthread_mutex_initializer-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F">PTHREAD_MUTEX_INITIALIZER 静态初始化方式</a></li><li><a href="#pthread_mutex_init-%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%92%E6%96%A5%E9%94%81">pthread_mutex_init 函数：初始化互斥锁</a></li><li><a href="#pthread_mutex_destroy-%E5%87%BD%E6%95%B0%E9%94%80%E6%AF%81%E4%BA%92%E6%96%A5%E9%94%81">pthread_mutex_destroy 函数：销毁互斥锁</a></li><li><a href="#pthread_mutex_lock-%E5%87%BD%E6%95%B0%E5%8A%A0%E9%94%81">pthread_mutex_lock 函数：加锁</a></li><li><a href="#pthread_mutex_unlock-%E5%87%BD%E6%95%B0%E8%A7%A3%E9%94%81">pthread_mutex_unlock 函数：解锁</a></li><li><a href="#pthread_mutex_trylock-%E5%87%BD%E6%95%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%8A%A0%E9%94%81">pthread_mutex_trylock 函数：非阻塞加锁</a></li></ul></li><li><a href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8">互斥锁的应用</a><ul><li><a href="#%E6%8A%A2%E7%A5%A8%E9%97%AE%E9%A2%98">抢票问题</a></li><li><a href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%B0%81%E8%A3%85">互斥锁的封装</a></li></ul></li></ul><!-- tocstop --><h2><span id="进程线程间的互斥相关概念详解">进程线程间的互斥相关概念详解</span></h2><h3><span id="共享资源">共享资源</span></h3><p>共享资源是指在多线程或多进程环境下，可以被多个执行流（线程或进程）共同访问的系统资源。这些资源可以是：</p><ul><li>内存区域</li><li>文件</li><li>硬件设备</li><li>数据库记录</li><li>变量或数据结构</li></ul><h3><span id="临界资源">临界资源</span></h3><p>临界资源是指那些在多线程执行流中需要被保护的共享资源。它们具有以下特点：</p><ol><li><strong>共享性</strong>：可以被多个线程访问</li><li><strong>排他性</strong>：在某一时刻只能被一个线程使用</li><li><strong>重要性</strong>：对这些资源的并发访问可能导致数据不一致或其他问题</li></ol><p><strong>例子</strong>：</p><ul><li>共享内存中的计数器变量</li><li>打印机设备</li><li>数据库中的某条记录</li></ul><h3><span id="临界区">临界区</span></h3><p>临界区是指每个线程内部访问临界资源的代码段。关键点包括：</p><ol><li><strong>位置</strong>：是代码的一部分，不是数据</li><li><strong>功能</strong>：包含对临界资源的访问或修改操作</li><li><strong>要求</strong>：需要确保同一时间只有一个线程能执行这段代码</li></ol><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界区开始</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">balance += amount;  <span class="comment">// 访问共享变量balance</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// 临界区结束</span></span><br></pre></td></tr></table></figure><h3><span id="互斥">互斥</span></h3><p>互斥是一种保证机制，确保在任何时刻只有一个执行流能够进入临界区并访问临界资源。互斥的特性包括：</p><ol><li><strong>排他性</strong>：一次只允许一个线程访问</li><li><strong>必要性</strong>：防止竞态条件(race condition)</li><li><strong>实现方式</strong>：通常通过锁机制实现</li></ol><p><strong>互斥的基本原则</strong>：</p><ul><li>空闲让进：当没有线程在临界区时，应允许一个请求进入的线程进入</li><li>忙则等待：当已有线程在临界区时，其他试图进入的线程必须等待</li><li>有限等待：等待进入临界区的线程应该在有限时间内获得机会</li><li>让权等待（可选）：等待的线程应释放CPU，避免忙等待</li></ul><h3><span id="原子性">原子性</span></h3><p>原子性是指操作不可被中断的特性，即一个操作要么完全执行，要么完全不执行，不会出现执行到一半被中断的情况。关键点：</p><ol><li><strong>不可分割</strong>：操作作为一个不可分割的单元执行</li><li><strong>状态二元</strong>：只有”完成”或”未完成”两种状态，没有中间状态</li><li><strong>重要性</strong>：是保证线程安全的基础</li></ol><p><strong>实现原子性的方法</strong>：</p><ul><li>硬件支持的原子指令（如x86的<code>LOCK</code>前缀指令）</li><li>使用互斥锁（mutex）保护非原子操作</li><li>事务内存（某些高级语言支持）</li></ul><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非原子操作（在多线程环境下可能出问题）</span></span><br><span class="line">counter++; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原子操作（C11标准）</span></span><br><span class="line">atomic_fetch_add(&amp;counter, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3><span id="互斥的实现方式">互斥的实现方式</span></h3><p>在实际编程中，实现互斥的常见方法包括：</p><ol><li><strong>互斥锁(Mutex)</strong>：最基本的互斥机制</li><li><strong>信号量(Semaphore)</strong>：更通用的同步机制</li><li><strong>自旋锁(Spinlock)</strong>：适用于短时间等待的场景</li><li><strong>读写锁(Read-Write Lock)</strong>：区分读写操作</li><li><strong>条件变量(Condition Variable)</strong>：配合互斥锁使用</li></ol><h2><span id="互斥锁-mutex">互斥锁 Mutex</span></h2><h3><span id="背景引入">背景引入</span></h3><h4><span id="线程数据的天然隔离">线程数据的天然隔离</span></h4><p>在大多数情况下，线程使用的数据都是<strong>局部变量</strong>，这些变量的地址空间位于线程的私有栈空间中。就像每个人都有自己的私人笔记本一样，这些局部变量：</p><ul><li>完全归属于创建它的线程</li><li>生命周期与线程执行周期绑定</li><li>其他线程根本无法直接访问</li><li>天然具备线程安全性</li></ul><p>这种隔离性是线程独立运作的基础，也是多线程编程中最理想的数据使用方式。</p><p>我们引入一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;      <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">10</span>; <span class="comment">// 定义线程数量为10</span></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">1000</span>;        <span class="comment">// 共享变量：总票数1000张</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程数据结构体，用于传递线程信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;        <span class="comment">// 线程ID</span></span><br><span class="line">    string name;          <span class="comment">// 线程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_routine</span><span class="params">(<span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将void*参数转换为thread_data*类型</span></span><br><span class="line">    thread_data* td = <span class="built_in">static_cast</span>&lt;thread_data*&gt;(data);</span><br><span class="line">    <span class="comment">// 获取当前线程ID</span></span><br><span class="line">    td-&gt;tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环抢票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查是否还有票</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>);  <span class="comment">// 模拟业务处理延迟(1毫秒)</span></span><br><span class="line">            tickets--;     <span class="comment">// 票数减1（临界区操作）</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出抢票信息</span></span><br><span class="line">            cout &lt;&lt; td-&gt;name &lt;&lt; <span class="string">&quot; get a ticket, &quot;</span> </span><br><span class="line">                 &lt;&lt; <span class="string">&quot;remaining tickets: &quot;</span> &lt;&lt; tickets &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 没有票了，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> td;      <span class="comment">// 释放线程数据内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 线程返回空指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;  <span class="comment">// 存储线程ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建10个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= thread_num; ++i) &#123;</span><br><span class="line">        string thread_name = <span class="string">&quot;thread-&quot;</span> + <span class="built_in">to_string</span>(i);  <span class="comment">// 生成线程名称</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;                                  <span class="comment">// 线程ID变量</span></span><br><span class="line">        <span class="comment">// 创建线程数据对象</span></span><br><span class="line">        thread_data* td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            name: thread_name  <span class="comment">// 初始化线程名称</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, thread_routine, td);</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);  <span class="comment">// 将线程ID加入向量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> tid : tids) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 主线程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="共享变量的现实需求">共享变量的现实需求</span></h4><p>然而，纯粹的隔离无法满足现实编程需求。想象一个团队协作的场景：我们需要多个线程共同处理同一批数据，或者需要线程间传递处理结果。这时就必须引入<strong>共享变量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享的票务资源</span></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">1000</span>;  </span><br></pre></td></tr></table></figure><p>共享变量就像办公室里的公共白板：</p><ul><li>所有团队成员（线程）都能看到并修改</li><li>是线程间通信的重要渠道</li><li>可以实现数据共享和协作处理</li></ul><h4><span id="并发操作引发的混乱">并发操作引发的混乱</span></h4><p>但当我们允许多个线程同时操作共享变量时，问题开始显现。以票务系统为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)&#123;      <span class="comment">// 检查票数</span></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1000</span>);     <span class="comment">// 模拟业务处理延迟</span></span><br><span class="line">    tickets--;        <span class="comment">// 修改票数</span></span><br><span class="line">    cout &lt;&lt; td-&gt;name &lt;&lt; <span class="string">&quot; get a ticket, &quot;</span> </span><br><span class="line">                 &lt;&lt; <span class="string">&quot;remaining tickets: &quot;</span> &lt;&lt; tickets &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段看似简单的代码在多线程环境下会引发多种问题：</p><ol><li><strong>检查-修改的非原子性</strong>：判断<code>tickets&gt;0</code>和实际<code>tickets--</code>不是原子操作</li><li><strong>线程调度的不确定性</strong>：线程可能在任意步骤被中断</li><li><strong>数据竞争的幽灵</strong>：多个线程可能同时认为自己抢到了最后一张票</li></ol><h4><span id="一个令人不安的实验结果">一个令人不安的实验结果</span></h4><p>当我运行这个票务程序时，观察到了这些异常现象：</p><ul><li><strong>票数超卖</strong>：剩余票数显示为负数</li><li><strong>数据不一致</strong>：控制台输出的剩余票数出现跳变</li><li><strong>结果不可复现</strong>：每次运行得到的最终结果都不相同</li></ul><p>这些现象正是并发编程中典型的**竞态条件(Race Condition)**症状，它们暴露了多线程环境下共享数据访问的根本问题：<strong>非受控的并发访问会导致不确定的行为和数据损坏</strong>。</p><p>结果展示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">thread-6 get a ticket, remaining tickets: 3</span><br><span class="line">thread-8 get a ticket, remaining tickets: 3</span><br><span class="line">thread-3 get a ticket, remaining tickets: 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果出现跳变</span></span><br><span class="line">thread-2 get a ticket, remaining tickets: 0</span><br><span class="line">thread-1 get a ticket, remaining tickets: 0</span><br><span class="line">thread-9 get a ticket, remaining tickets: 0</span><br><span class="line">thread-5 get a ticket, remaining tickets: 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">票数超卖（票数变为负数）</span></span><br><span class="line">thread-7 get a ticket, remaining tickets: -1</span><br><span class="line">thread-10 get a ticket, remaining tickets: -2</span><br><span class="line">thread-4 get a ticket, remaining tickets: -3</span><br><span class="line">thread-6 get a ticket, remaining tickets: -5</span><br><span class="line">thread-8 get a ticket, remaining tickets: -5</span><br></pre></td></tr></table></figure><h4><span id="问题本质的思考">问题本质的思考</span></h4><p>为什么单线程下运行良好的代码，在多线程环境下就会出现各种异常？核心原因在于：</p><ol><li><strong>操作的非原子性</strong>：高级语言的简单语句可能对应多条机器指令</li><li><strong>内存可见性问题</strong>：线程可能看到过期的数据副本</li><li><strong>编译器&#x2F;处理器的优化</strong>：指令重排等优化可能改变程序语义</li></ol><p>这些底层细节在单线程环境下被完美隐藏，但在多线程环境下却成为必须面对的挑战。我们需要一种机制来规范线程对共享资源的访问，这就是我们接下来要探讨的**互斥锁(Mutex)**解决方案。</p><h3><span id="pthread_mutex_initializer-静态初始化方式">PTHREAD_MUTEX_INITIALIZER 静态初始化方式</span></h3><h4><span id="基本语法格式">基本语法格式</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><h4><span id="核心特性">核心特性</span></h4><ol><li><strong>编译时初始化</strong>：在程序加载时由编译器自动完成初始化</li><li><strong>零成本抽象</strong>：不产生运行时初始化开销</li><li><strong>默认属性</strong>：使用所有属性为默认值的互斥锁<ul><li>类型：普通锁（PTHREAD_MUTEX_NORMAL）</li><li>进程共享：仅限同一进程内（PTHREAD_PROCESS_PRIVATE）</li><li>不具递归性</li></ul></li></ol><h4><span id="适用场景">适用场景</span></h4><ol><li><p><strong>全局&#x2F;静态互斥锁</strong>：在文件作用域或static存储期变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局范围的静态初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> global_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数内的静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> local_static_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>简单用例</strong>：不需要特殊属性的快速初始化</p></li><li><p><strong>单次初始化</strong>：生命周期与程序相同的锁</p></li></ol><h4><span id="典型使用示例">典型使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化全局互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> counter_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> shared_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">increment</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">        shared_counter++;</span><br><span class="line">        pthread_mutex_unlock(&amp;counter_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, increment, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, increment, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, shared_counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="使用限制">使用限制</span></h4><ol><li><p><strong>不可用于堆内存</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误用法！</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> *mutex = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line">*mutex = PTHREAD_MUTEX_INITIALIZER;  <span class="comment">// 未定义行为！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不可重复初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);  <span class="comment">// 错误！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不可跨模块依赖</strong>：不同编译单元间的初始化顺序不确定</p></li></ol><h4><span id="底层实现原理">底层实现原理</span></h4><p>在Linux glibc中的典型实现：</p><ol><li>宏展开为结构体初始化表达式</li><li>各字段被设置为表示”未锁定”状态的初始值</li><li>属性字段设为默认值</li></ol><h4><span id="特殊注意事项">特殊注意事项</span></h4><ol><li><p><strong>C++中的使用</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须放在全局/命名空间作用域</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> class_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类静态成员(C++17后可用inline)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> s_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">pthread_mutex_t</span> MyClass::s_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p><strong>与动态销毁的配合</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合法但不必要的操作</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex); </span><br><span class="line"><span class="comment">// 之后不能再使用该mutex</span></span><br></pre></td></tr></table></figure></li></ol><h4><span id="静态初始化的设计哲学">静态初始化的设计哲学</span></h4><ol><li><strong>RAII原则</strong>：利用语言特性自动管理资源</li><li><strong>零开销原则</strong>：不引入不必要的运行时成本</li><li><strong>简单性原则</strong>：为常见场景提供最简使用方式</li></ol><h3><span id="pthread_mutex_init-函数初始化互斥锁">pthread_mutex_init 函数：初始化互斥锁</span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><h4><span id="功能说明">功能说明</span></h4><p><code>pthread_mutex_init</code> 用于动态初始化一个互斥锁。与静态初始化（<code>PTHREAD_MUTEX_INITIALIZER</code>）不同，它允许：</p><ol><li>对互斥锁属性进行更精细的控制</li><li>在运行时动态创建互斥锁</li><li>初始化非全局&#x2F;静态存储期的互斥锁</li></ol><h4><span id="参数解析">参数解析</span></h4><ol><li><strong>mutex</strong>：指向要初始化的互斥锁对象的指针</li><li><strong>attr</strong>：指向互斥锁属性对象的指针，通常为：<ul><li><code>NULL</code>：使用默认属性</li><li>自定义属性对象：通过<code>pthread_mutexattr_init</code>创建</li></ul></li></ol><h4><span id="返回值">返回值</span></h4><ul><li>成功：返回0</li><li>失败：返回错误编号（非零值）</li></ul><h4><span id="基础使用示例">基础使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 使用默认属性初始化</span></span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Mutex initialization failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="带属性的初始化示例">带属性的初始化示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化属性对象</span></span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line"><span class="comment">// 设置互斥锁类型（如设置为递归锁）</span></span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义属性初始化互斥锁</span></span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_init(&amp;mutex, &amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Mutex initialization failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁属性对象（初始化后不再需要）</span></span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li><strong>一对一原则</strong>：每个<code>pthread_mutex_init</code>必须对应一个<code>pthread_mutex_destroy</code></li><li><strong>避免重复初始化</strong>：不要对已初始化的互斥锁再次初始化</li><li><strong>作用域管理</strong>：确保互斥锁在需要时已初始化，在不再使用时销毁</li><li><strong>错误检查</strong>：总是检查返回值以确保初始化成功</li></ol><h4><span id="典型应用场景">典型应用场景</span></h4><ol><li>动态创建的互斥锁（如堆分配的互斥锁）</li><li>需要非默认属性的互斥锁（如递归锁、进程共享锁等）</li><li>C++类中封装的互斥锁成员变量</li></ol><h4><span id="与静态初始化的对比">与静态初始化的对比</span></h4><table><thead><tr><th>特性</th><th>pthread_mutex_init</th><th>PTHREAD_MUTEX_INITIALIZER</th></tr></thead><tbody><tr><td>初始化时机</td><td>运行时动态初始化</td><td>编译时静态初始化</td></tr><tr><td>属性配置</td><td>支持自定义属性</td><td>仅默认属性</td></tr><tr><td>适用对象</td><td>任意存储期的对象</td><td>仅全局&#x2F;静态对象</td></tr><tr><td>错误检查</td><td>可检查返回值</td><td>无错误检查</td></tr></tbody></table><h4><span id="配套销毁函数">配套销毁函数</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>应在互斥锁不再使用时调用，释放相关资源。注意：</p><ul><li>确保没有线程持有或等待该锁</li><li>销毁后不应再使用该互斥锁</li><li>栈上的互斥锁在销毁前不能离开作用域</li></ul><h3><span id="pthread_mutex_destroy-函数销毁互斥锁">pthread_mutex_destroy 函数：销毁互斥锁</span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><h4><span id="功能说明">功能说明</span></h4><p><code>pthread_mutex_destroy</code> 用于销毁一个互斥锁，释放其占用的资源。</p><h4><span id="参数解析">参数解析</span></h4><ol><li><strong>mutex</strong>：指向要销毁的互斥锁对象的指针</li></ol><h4><span id="返回值">返回值</span></h4><ul><li>成功：返回0</li><li>失败：返回错误编号（非零值）</li></ul><p>该函数较为简单，故不做过多赘述。</p><h3><span id="pthread_mutex_lock-函数加锁">pthread_mutex_lock 函数：加锁</span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><h4><span id="核心功能">核心功能</span></h4><ol><li><strong>阻塞式获取锁</strong>：如果互斥锁已被其他线程持有，调用线程将进入阻塞状态</li><li><strong>原子性保证</strong>：确保锁的获取操作是原子的，不会出现竞争条件</li><li><strong>临界区保护</strong>：成功获取锁后，线程可以安全执行临界区代码</li></ol><h4><span id="参数说明">参数说明</span></h4><ul><li><code>mutex</code>：指向已初始化的互斥锁对象的指针</li></ul><h4><span id="返回值">返回值</span></h4><ul><li>成功：返回0</li><li>失败：返回错误编号（非零值），常见错误：<ul><li><code>EINVAL</code>：互斥锁未初始化</li><li><code>EDEADLK</code>：检测到死锁（某些实现）</li></ul></li></ul><h4><span id="基础使用模式">基础使用模式</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">critical_section</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 进入临界区前加锁</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 临界区代码 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 离开临界区后解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="底层工作原理">底层工作原理</span></h4><ol><li><strong>快速路径</strong>（无竞争时）：<ul><li>通过原子操作尝试获取锁</li><li>成功则立即返回</li></ul></li><li><strong>慢速路径</strong>（有竞争时）：<ul><li>线程进入等待队列</li><li>内核调度器将线程置为睡眠状态</li><li>当锁释放时唤醒等待线程</li></ul></li></ol><h4><span id="重要特性说明">重要特性说明</span></h4><ol><li><p><strong>线程阻塞行为</strong>：</p><ul><li>默认情况下会使调用线程进入睡眠状态</li><li>不消耗CPU资源等待</li><li>被唤醒后会自动重新尝试获取锁</li></ul></li><li><p><strong>锁的归属</strong>：</p><ul><li>锁与获取它的线程关联（某些类型）</li><li>同一线程重复加锁可能导致死锁（普通锁）</li></ul></li><li><p><strong>内存屏障作用</strong>：</p><ul><li>包含隐式的内存屏障（memory barrier）</li><li>保证临界区内的内存操作不会被重排序到锁外部</li></ul></li></ol><h4><span id="错误处理">错误处理</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(result) &#123;</span><br><span class="line">        <span class="keyword">case</span> EINVAL:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Mutex not initialized\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EDEADLK:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Deadlock detected\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Lock failed with error %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 适当的错误恢复处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="性能考量">性能考量</span></h4><ol><li><p><strong>临界区长度</strong>：</p><ul><li>应保持临界区尽可能短</li><li>只保护真正需要同步的操作</li></ul></li><li><p><strong>锁竞争</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不良实践：在临界区内执行耗时操作</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">process_large_file();  <span class="comment">// 长时间操作</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进方案</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="type">int</span> value = shared_value;  <span class="comment">// 快速获取值</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">process_value(value);  <span class="comment">// 耗时操作放在锁外</span></span><br></pre></td></tr></table></figure></li></ol><h4><span id="递归锁特殊行为">递归锁特殊行为</span></h4><p>当互斥锁被初始化为递归锁（PTHREAD_MUTEX_RECURSIVE）时：</p><ul><li><p>同一线程可以多次加锁</p></li><li><p>必须有相同次数的解锁操作</p></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);  <span class="comment">// 第一次加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);  <span class="comment">// 第二次加锁（仅递归锁允许）</span></span><br><span class="line"><span class="comment">/* 临界区代码 */</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);  <span class="comment">// 第一次解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);  <span class="comment">// 第二次解锁</span></span><br></pre></td></tr></table></figure></li></ul><h4><span id="系统级影响">系统级影响</span></h4><ol><li><strong>上下文切换</strong>：可能导致线程上下文切换开销</li><li><strong>调度延迟</strong>：高竞争时可能增加线程调度延迟</li><li><strong>优先级反转</strong>：可能引发优先级反转问题（需配合优先级继承机制）</li></ol><h3><span id="pthread_mutex_unlock-函数解锁">pthread_mutex_unlock 函数：解锁</span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><h4><span id="核心功能">核心功能</span></h4><ol><li><strong>释放锁</strong>：允许其他线程获取互斥锁</li><li><strong>唤醒等待线程</strong>：如果有线程在等待该锁，唤醒其中一个</li><li><strong>线程调度</strong>：被唤醒的线程可能立即运行</li></ol><h4><span id="参数说明">参数说明</span></h4><ul><li><code>mutex</code>：指向已初始化的互斥锁对象的指针</li></ul><h4><span id="返回值">返回值</span></h4><ul><li>成功：返回0</li><li>失败：返回错误编号（非零值），常见错误：<ul><li><code>EINVAL</code>：互斥锁未初始化</li><li><code>EPERM</code>：线程未持有该锁</li></ul></li></ul><p>与 <code>pthread_mutex_lock</code> 配套使用，不做过多赘述。</p><h3><span id="pthread_mutex_trylock-函数非阻塞加锁">pthread_mutex_trylock 函数：非阻塞加锁</span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><h4><span id="核心特性">核心特性</span></h4><ol><li><strong>非阻塞尝试</strong>：立即返回结果，不会使线程进入等待状态</li><li><strong>快速失败</strong>：当锁不可用时直接返回错误而非阻塞</li><li><strong>轻量级检查</strong>：比pthread_mutex_lock有更低的性能开销</li></ol><h4><span id="参数说明">参数说明</span></h4><ul><li><code>mutex</code>：指向已初始化的互斥锁对象的指针</li></ul><h4><span id="返回值">返回值</span></h4><ul><li>成功获取锁：返回0</li><li>锁已被占用：返回EBUSY（某些系统返回EAGAIN）</li><li>其他错误：返回对应错误码（如EINVAL表示未初始化）</li></ul><h4><span id="典型使用场景">典型使用场景</span></h4><ol><li><strong>避免死锁</strong>：在已持有某锁时尝试获取其他锁</li><li><strong>优化性能</strong>：非关键路径的优化尝试</li><li><strong>实时系统</strong>：不能接受阻塞的实时应用</li></ol><h4><span id="基础使用示例">基础使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">non_blocking_access</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 成功获取锁，执行临界区代码 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == EBUSY) &#123;</span><br><span class="line">        <span class="comment">/* 锁被占用，执行替代逻辑 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Resource busy, executing fallback\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 处理其他错误 */</span></span><br><span class="line">        perror(<span class="string">&quot;trylock failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="与lock的对比分析">与lock的对比分析</span></h4><table><thead><tr><th>特性</th><th>trylock</th><th>lock</th></tr></thead><tbody><tr><td>阻塞行为</td><td>永不阻塞</td><td>可能阻塞</td></tr><tr><td>返回值</td><td>成功&#x2F;忙&#x2F;错误</td><td>成功&#x2F;错误</td></tr><tr><td>性能开销</td><td>较低</td><td>较高（可能涉及上下文切换）</td></tr><tr><td>适用场景</td><td>非必须成功的访问</td><td>必须成功的访问</td></tr></tbody></table><h2><span id="互斥锁的应用">互斥锁的应用</span></h2><h3><span id="抢票问题">抢票问题</span></h3><p>下面我们针对前面那个抢票的例子使用互斥锁避免临界区被冲突访问：</p><p>情景再现：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;      <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">10</span>; <span class="comment">// 定义线程数量为10</span></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">1000</span>;        <span class="comment">// 共享变量：总票数1000张</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程数据结构体，用于传递线程信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;        <span class="comment">// 线程ID</span></span><br><span class="line">    string name;          <span class="comment">// 线程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_routine</span><span class="params">(<span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将void*参数转换为thread_data*类型</span></span><br><span class="line">    thread_data* td = <span class="built_in">static_cast</span>&lt;thread_data*&gt;(data);</span><br><span class="line">    <span class="comment">// 获取当前线程ID</span></span><br><span class="line">    td-&gt;tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环抢票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查是否还有票</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>);  <span class="comment">// 模拟业务处理延迟(1毫秒)</span></span><br><span class="line">            tickets--;     <span class="comment">// 票数减1（临界区操作）</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出抢票信息</span></span><br><span class="line">            cout &lt;&lt; td-&gt;name &lt;&lt; <span class="string">&quot; get a ticket, &quot;</span> </span><br><span class="line">                 &lt;&lt; <span class="string">&quot;remaining tickets: &quot;</span> &lt;&lt; tickets &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 没有票了，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> td;      <span class="comment">// 释放线程数据内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 线程返回空指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids;  <span class="comment">// 存储线程ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建10个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= thread_num; ++i) &#123;</span><br><span class="line">        string thread_name = <span class="string">&quot;thread-&quot;</span> + <span class="built_in">to_string</span>(i);  <span class="comment">// 生成线程名称</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;                                  <span class="comment">// 线程ID变量</span></span><br><span class="line">        <span class="comment">// 创建线程数据对象</span></span><br><span class="line">        thread_data* td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            name: thread_name  <span class="comment">// 初始化线程名称</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, thread_routine, td);</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid);  <span class="comment">// 将线程ID加入向量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> tid : tids) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 主线程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><p>接下来我们通过加锁来解决问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">// 初始化全局互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">10</span>; <span class="comment">// 定义线程数量为10</span></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">1000</span>;        <span class="comment">// 共享变量：总票数1000张</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程数据结构体，用于传递线程信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid; <span class="comment">// 线程ID</span></span><br><span class="line">    string name;   <span class="comment">// 线程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计时器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start_time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">elapsed</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过的毫秒数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">elapsed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">return</span> std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过的秒数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">elapsedSeconds</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">elapsed</span>() / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_routine</span><span class="params">(<span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将void*参数转换为thread_data*类型</span></span><br><span class="line">    thread_data *td = <span class="built_in">static_cast</span>&lt;thread_data *&gt;(data);</span><br><span class="line">    <span class="comment">// 获取当前线程ID</span></span><br><span class="line">    td-&gt;tid = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环抢票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查是否还有票</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>); <span class="comment">// 模拟业务处理延迟(1毫秒)</span></span><br><span class="line">            tickets--;    <span class="comment">// 票数减1（临界区操作）</span></span><br><span class="line">            <span class="comment">// 输出抢票信息</span></span><br><span class="line">            cout &lt;&lt; td-&gt;name &lt;&lt; <span class="string">&quot; get a ticket, &quot;</span></span><br><span class="line">                 &lt;&lt; <span class="string">&quot;remaining tickets: &quot;</span> &lt;&lt; tickets &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 没有票了，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> td;      <span class="comment">// 释放线程数据内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 线程返回空指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">pthread_t</span>&gt; tids; <span class="comment">// 存储线程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建10个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= thread_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string thread_name = <span class="string">&quot;thread-&quot;</span> + <span class="built_in">to_string</span>(i); <span class="comment">// 生成线程名称</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;                                 <span class="comment">// 线程ID变量</span></span><br><span class="line">        <span class="comment">// 创建线程数据对象</span></span><br><span class="line">        thread_data *td = <span class="keyword">new</span> thread_data&#123;</span><br><span class="line">            name : thread_name <span class="comment">// 初始化线程名称</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, thread_routine, td);</span><br><span class="line">        tids.<span class="built_in">push_back</span>(tid); <span class="comment">// 将线程ID加入向量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tid : tids)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 主线程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现程序运行没有任何问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread-1 get a ticket, remaining tickets: 3</span><br><span class="line">thread-1 get a ticket, remaining tickets: 2</span><br><span class="line">thread-1 get a ticket, remaining tickets: 1</span><br><span class="line">thread-1 get a ticket, remaining tickets: 0</span><br><span class="line">1084.92</span><br></pre></td></tr></table></figure><p>若不加锁，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread-8thread-2 get a ticket, remaining tickets: -4</span><br><span class="line">thread-5 get a ticket, remaining tickets: -6</span><br><span class="line">thread-3 get a ticket, remaining tickets: -7</span><br><span class="line">thread-6 get a ticket, remaining tickets: -8</span><br><span class="line">thread-9 get a ticket, remaining tickets: -8</span><br><span class="line"> get a ticket, remaining tickets: -8</span><br><span class="line">thread-10 get a ticket, remaining tickets: -9</span><br><span class="line">110.501</span><br></pre></td></tr></table></figure><p>可以发现，通过加互斥锁，结果变得正确，不过代价就是会消耗更多的时间，这也正是为什么在保证数据安全的前提下，临界区越小越好的原因</p><h3><span id="互斥锁的封装">互斥锁的封装</span></h3><p>接下来，我们尝试对 Linux 的锁进行封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOCK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOCK_H_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  <span class="comment">// POSIX线程库头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span>  <span class="comment">// 标准异常处理头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// 标准输入输出头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class Mutex</span></span><br><span class="line"><span class="comment"> * @brief 封装POSIX互斥锁的线程安全互斥量类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该类提供了基本的互斥锁功能，包括加锁、解锁和尝试加锁操作。</span></span><br><span class="line"><span class="comment"> * 使用RAII模式管理锁资源，确保锁的正确初始化和释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，初始化互斥锁</span></span><br><span class="line"><span class="comment">     * @throw std::exception 如果互斥锁初始化失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Mutex</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化互斥锁，使用默认属性(nullptr)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();  <span class="comment">// 初始化失败抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数，销毁互斥锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~<span class="built_in">Mutex</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);  <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和赋值运算符</span></span><br><span class="line">    <span class="built_in">Mutex</span>(<span class="type">const</span> Mutex&amp;) = <span class="keyword">delete</span>;            <span class="comment">// 拷贝构造禁用</span></span><br><span class="line">    Mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mutex&amp;) = <span class="keyword">delete</span>; <span class="comment">// 赋值操作禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 加锁操作（阻塞式）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果锁已被其他线程持有，调用线程将被阻塞直到获得锁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);  <span class="comment">// POSIX加锁操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 尝试加锁（非阻塞式）</span></span><br><span class="line"><span class="comment">     * @return bool 加锁成功返回true，失败返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_trylock</span>(&amp;mutex_) == <span class="number">0</span>;  <span class="comment">// 尝试加锁，不阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);  <span class="comment">// POSIX解锁操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取原生互斥锁句柄</span></span><br><span class="line"><span class="comment">     * @return pthread_mutex_t* 指向底层POSIX互斥锁的指针</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 用于需要与POSIX线程API直接交互的场景。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">pthread_mutex_t</span>* <span class="title">native_handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;mutex_;  <span class="comment">// 返回底层互斥锁指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;  <span class="comment">// POSIX互斥锁对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class LockGuard</span></span><br><span class="line"><span class="comment"> * @brief 互斥锁守卫类，实现RAII风格的锁管理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在构造时自动加锁，析构时自动解锁，确保锁的释放，</span></span><br><span class="line"><span class="comment"> * 即使在异常发生时也能保证锁被正确释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockGuard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数，自动加锁</span></span><br><span class="line"><span class="comment">     * @param mutex 要管理的互斥锁引用</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @note explicit关键字防止隐式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockGuard</span><span class="params">(Mutex &amp;mutex)</span> : mutex_(mutex)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        mutex_.<span class="built_in">lock</span>();  <span class="comment">// 构造时自动加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数，自动解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~<span class="built_in">LockGuard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();  <span class="comment">// 析构时自动解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和赋值运算符</span></span><br><span class="line">    <span class="built_in">LockGuard</span>(<span class="type">const</span> LockGuard&amp;) = <span class="keyword">delete</span>;            <span class="comment">// 拷贝构造禁用</span></span><br><span class="line">    LockGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LockGuard&amp;) = <span class="keyword">delete</span>; <span class="comment">// 赋值操作禁用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex &amp;mutex_;  <span class="comment">// 管理的互斥锁引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LOCK_H_</span></span></span><br></pre></td></tr></table></figure><p>我们将这个基于 RAII 自动化管理的锁运用到我们的抢票程序中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环抢票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查是否还有票</span></span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">        <span class="function">LockGuard <span class="title">lg</span><span class="params">(*td-&gt;mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>); <span class="comment">// 模拟业务处理延迟(1毫秒)</span></span><br><span class="line">            tickets--;    <span class="comment">// 票数减1（临界区操作）</span></span><br><span class="line">            <span class="comment">// 输出抢票信息</span></span><br><span class="line">            cout &lt;&lt; td-&gt;name &lt;&lt; <span class="string">&quot; get a ticket, &quot;</span></span><br><span class="line">                 &lt;&lt; <span class="string">&quot;remaining tickets: &quot;</span> &lt;&lt; tickets &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 没有票了，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，RAII 自动化管理只需要我们再循环开始处初始化变量即可，只要退出当前循环就一定会解锁，原先我们若在循环内部进行加锁和解锁操作，我们还需要关心 else 执行流中 break，因此需要额外在 else 分支中加上解锁操作。合理地利用 C++ 的特性来简化代码和增加代码健壮性是一个程序员的基本素养</p><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread-2 get a ticket, remaining tickets: 3</span><br><span class="line">thread-2 get a ticket, remaining tickets: 2</span><br><span class="line">thread-2 get a ticket, remaining tickets: 1</span><br><span class="line">thread-2 get a ticket, remaining tickets: 0</span><br><span class="line">1086.37</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 互斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程控制</title>
      <link href="/2025/07/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_control/"/>
      <url>/2025/07/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_control/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#posix-%E7%BA%BF%E7%A8%8B%E5%BA%93">POSIX 线程库</a><ul><li><a href="#%E4%BD%BF%E7%94%A8-pthread-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">使用 pthread 注意事项</a></li></ul></li><li><a href="#pthread_create-%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><code>pthread_create</code> 函数：线程创建</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B">函数原型</a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC">返回值</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF">常见错误</a></li></ul></li><li><a href="#pthread_exit-%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><code>pthread_exit</code> 函数：线程终止</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1">函数原型</a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-1">参数说明</a></li><li><a href="#%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7">关键特性</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1">使用示例</a></li><li><a href="#%E4%B8%8E-return-%E7%9A%84%E5%8C%BA%E5%88%AB">与 <code>return</code> 的区别</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1">注意事项</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#pthread_cancel-%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><code>pthread_cancel</code> 函数：线程取消</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2">函数原型</a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-2">参数说明</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC-1">返回值</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">线程取消的工作原理</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">相关函数</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2">使用示例</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">*注意事项</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1">常见问题</a></li><li><a href="#%E6%80%BB%E7%BB%93-1">总结</a></li></ul></li><li><a href="#pthread_cleanup_push-%E5%92%8C-pthread_cleanup_pop-%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E6%B8%85%E7%90%86"><code>pthread_cleanup_push</code> 和 <code>pthread_cleanup_pop</code> 函数：线程资源清理</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-3">函数原型</a></li><li><a href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD">核心功能</a></li><li><a href="#%E8%A7%A6%E5%8F%91%E6%B8%85%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5">触发清理的三种情况</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3">使用示例</a></li><li><a href="#%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">关键注意事项</a></li><li><a href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">典型应用场景</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2">常见问题</a></li><li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li></ul></li><li><a href="#pthread_join-%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><strong><code>pthread_join</code> 函数：线程等待与资源回收</strong></a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85">为什么需要线程等待？</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-4">函数原型</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">工作流程</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-4">使用示例</a></li><li><a href="#1%E7%BA%BF%E7%A8%8B%E5%BF%85%E9%A1%BB%E5%8F%AF%E8%BF%9E%E6%8E%A5joinable"><strong>（1）线程必须可连接（Joinable）</strong></a></li><li><a href="#2%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><strong>（2）返回值的内存管理</strong></a></li><li><a href="#3%E7%A6%81%E6%AD%A2%E9%87%8D%E5%A4%8D%E8%B0%83%E7%94%A8"><strong>（3）禁止重复调用</strong></a></li><li><a href="#4%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E9%97%AE%E9%A2%98"><strong>（4）主线程退出问题</strong></a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-3">常见问题</a></li><li><a href="#%E6%80%BB%E7%BB%93-3">总结</a></li></ul></li><li><a href="#pthread_detach-%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><strong><code>pthread_detach</code> 函数：线程分离</strong></a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB">为什么需要线程分离？</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-5">函数原型</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">使用方式</a></li><li><a href="#%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7-1">关键特性</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-5">使用示例</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2">注意事项</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-4">常见问题</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li><li><a href="#%E6%80%BB%E7%BB%93-4">总结</a></li></ul></li><li><a href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8tls%E6%8A%80%E6%9C%AF__thread-%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3">线程局部存储（TLS）技术：<code>__thread</code> 关键字详解</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8">为什么需要线程局部存储？</a></li><li><a href="#__thread-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><code>__thread</code> 的基本用法</a></li><li><a href="#%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7-2">关键特性</a></li><li><a href="#%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AF%B9%E6%AF%94">与相关技术的对比</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">使用注意事项</a></li><li><a href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1">典型应用场景</a></li><li><a href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">底层实现原理</a></li><li><a href="#%E6%80%BB%E7%BB%93-5">总结</a></li></ul></li></ul><!-- tocstop --><hr><h2><span id="posix-线程库">POSIX 线程库</span></h2><p>POSIX 线程库（通常称为 <strong>pthread</strong>）是 UNIX&#x2F;Linux 系统提供的 <strong>多线程编程标准接口</strong>，它定义了一套跨平台的线程操作函数，绝大多数函数以 <code>pthread_</code> 开头  </p><ul><li><strong>POSIX（Portable Operating System Interface）</strong> 是一套操作系统 API 标准，确保程序在不同 UNIX&#x2F;Linux 系统上的兼容性  </li><li><strong>pthread</strong> 是 POSIX 定义的线程管理库，提供 <strong>线程创建、同步、销毁</strong> 等功能  </li><li>几乎所有 Linux&#x2F;Unix 系统（包括 macOS）都支持 pthread，Windows 可通过 Cygwin、WSL 或第三方库（如 pthreads-win32）兼容</li></ul><hr><h3><span id="使用-pthread-注意事项">使用 pthread 注意事项</span></h3><ul><li><strong>头文件</strong>：<code>#include &lt;pthread.h&gt;</code>  </li><li><strong>编译选项</strong>：<code>gcc -lpthread</code>（必须链接 pthread 库，否则会报未定义错误）</li></ul><hr><h2><span id="pthread_create-函数线程创建"><code>pthread_create</code> 函数：线程创建</span></h2><p><code>pthread_create</code> 是 POSIX 线程库（pthread）中最重要的函数之一，用于<strong>创建一个新的线程</strong>它的作用类似于进程中的 <code>fork()</code>，但创建的是更轻量级的线程</p><hr><h3><span id="函数原型">函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_t</span>       *thread,         <span class="comment">// 输出参数，返回线程ID</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,     <span class="comment">// 线程属性（通常设为NULL）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="comment">// 线程要执行的函数</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span>            *arg            <span class="comment">// 传递给线程函数的参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><hr><h3><span id="参数说明">参数说明</span></h3><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>thread</code></strong></td><td><code>pthread_t *</code></td><td><strong>输出参数</strong>，用于存储新线程的 ID（唯一标识）</td></tr><tr><td><strong><code>attr</code></strong></td><td><code>const pthread_attr_t *</code></td><td><strong>线程属性</strong>（如栈大小、调度策略等），通常设为 <code>NULL</code>（使用默认属性）</td></tr><tr><td><strong><code>start_routine</code></strong></td><td><code>void *(*)(void *)</code></td><td><strong>线程入口函数</strong>（必须是 <code>void* func(void*)</code> 格式）</td></tr><tr><td><strong><code>arg</code></strong></td><td><code>void *</code></td><td><strong>传递给 <code>start_routine</code> 的参数</strong>（可以是任意类型，需强制转换）</td></tr></tbody></table><hr><h3><span id="返回值">返回值</span></h3><table><thead><tr><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>0</code></strong></td><td>成功创建线程</td></tr><tr><td><strong><code>非0</code></strong></td><td>失败，返回错误码（如 <code>EAGAIN</code> 表示资源不足）</td></tr></tbody></table><hr><h3><span id="使用示例">使用示例</span></h3><p>（1）传递单个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程要执行的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span> *)arg;  <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread: received %d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;  <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="type">int</span> arg = <span class="number">123</span>;  <span class="comment">// 传递给线程的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, &amp;arg);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread: created thread %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)tid);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);  <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）传递多个参数<br>如果需要传递多个参数，可以用结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义参数结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadArgs</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> *msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadArgs</span> *<span class="title">args</span> =</span> (<span class="keyword">struct</span> ThreadArgs *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread: %s, num=%d\n&quot;</span>, args-&gt;msg, args-&gt;num);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadArgs</span> <span class="title">args</span> =</span> &#123;<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>&#125;;  <span class="comment">// 初始化参数</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, &amp;args);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="注意事项">注意事项</span></h3><ol><li><p><strong>线程函数必须是 <code>void* func(void*)</code> 形式</strong>：</p><ul><li>返回值必须是 <code>void*</code>（可返回 <code>NULL</code>）</li><li>参数必须是 <code>void*</code>（需强制转换）</li></ul></li><li><p><strong>线程属性（<code>attr</code>）通常设为 <code>NULL</code></strong>：</p><ul><li>如果需要调整栈大小、调度策略等，可以使用 <code>pthread_attr_init()</code> 设置</li></ul></li><li><p><strong>线程结束时必须回收资源</strong>：</p><ul><li>使用 <code>pthread_join()</code> 等待线程结束（否则可能内存泄漏）</li><li>或者使用 <code>pthread_detach()</code> 让线程自动回收</li></ul></li><li><p><strong>主线程退出会导致所有线程终止</strong>：</p><ul><li>如果 <code>main()</code> 先退出，子线程可能被强制结束</li></ul></li></ol><hr><h3><span id="常见错误">常见错误</span></h3><table><thead><tr><th>错误</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td><strong><code>EAGAIN</code></strong></td><td>系统资源不足（如线程数超限）</td><td>减少线程数量或调整系统限制</td></tr><tr><td><strong><code>EINVAL</code></strong></td><td>无效的线程属性</td><td>检查 <code>attr</code> 是否正确初始化</td></tr><tr><td><strong><code>EPERM</code></strong></td><td>权限不足（如尝试修改调度策略）</td><td>以更高权限运行或调整策略</td></tr></tbody></table><hr><h2><span id="pthread_exit-函数线程终止"><code>pthread_exit</code> 函数：线程终止</span></h2><p><code>pthread_exit</code> 是 POSIX 线程库（pthread）中用于<strong>显式终止当前线程</strong>的函数它类似于进程中的 <code>exit()</code>，但仅影响当前线程，而非整个进程</p><hr><h3><span id="函数原型">函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *value_ptr)</span>;</span><br></pre></td></tr></table></figure><hr><h3><span id="参数说明">参数说明</span></h3><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>value_ptr</code></strong></td><td><code>void *</code></td><td>线程的返回值（可被其他线程通过 <code>pthread_join</code> 获取）<br><strong>注意：必须指向全局变量或堆内存，不能是线程栈上的局部变量！</strong></td></tr></tbody></table><hr><h3><span id="关键特性">关键特性</span></h3><ol><li><p><strong>终止当前线程</strong>：</p><ul><li>调用后，当前线程立即结束，但进程不会退出（除非是主线程调用了 <code>pthread_exit</code>）</li><li>类似于 <code>return</code>，但可以在线程函数的任意位置调用</li></ul></li><li><p><strong>返回值传递</strong>：</p><ul><li>通过 <code>value_ptr</code> 传递返回值，其他线程可用 <code>pthread_join</code> 接收</li><li>如果不需要返回值，可传 <code>NULL</code></li></ul></li><li><p><strong>资源清理</strong>：</p><ul><li>线程退出时会自动释放栈空间，但不会自动释放其他资源（如动态分配的内存、打开的文件等），需手动管理</li></ul></li></ol><hr><h3><span id="使用示例">使用示例</span></h3><p>（1）基本用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">42</span>);  <span class="comment">// 终止线程并返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span> *ret_val;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, &amp;ret_val);  <span class="comment">// 获取线程返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %ld\n&quot;</span>, (<span class="type">long</span>)ret_val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread is running</span><br><span class="line">Thread returned: 42</span><br></pre></td></tr></table></figure><p><strong>（2）错误用法（返回局部变量）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> local_var = <span class="number">42</span>;</span><br><span class="line">    pthread_exit(&amp;local_var);  <span class="comment">// 错误！局部变量会被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后果</strong>：其他线程通过 <code>pthread_join</code> 获取的指针指向无效内存，导致未定义行为</p><hr><h3><span id="与-return-的区别">与 <code>return</code> 的区别</span></h3><table><thead><tr><th>特性</th><th><code>pthread_exit</code></th><th><code>return</code></th></tr></thead><tbody><tr><td><strong>调用位置</strong></td><td>可在任意函数中调用</td><td>只能在线程函数中调用</td></tr><tr><td><strong>返回值处理</strong></td><td>显式传递返回值</td><td>隐式返回（需通过 <code>return</code> 语句）</td></tr><tr><td><strong>线程栈清理</strong></td><td>立即终止，栈空间回收</td><td>正常函数返回流程</td></tr></tbody></table><hr><h3><span id="注意事项">注意事项</span></h3><ol><li><p><strong>不要返回局部变量的指针</strong>：</p><ul><li>线程栈会在退出后被回收，指向局部变量的指针将失效</li><li>正确做法：返回 <code>malloc</code> 分配的内存或全局变量</li></ul></li><li><p><strong>主线程调用 <code>pthread_exit</code></strong>：</p><ul><li>主线程调用后，进程不会立即退出，直到所有线程结束</li><li>若主线程直接 <code>return</code> 或调用 <code>exit()</code>，所有线程会被强制终止</li></ul></li><li><p><strong>与 <code>pthread_join</code> 配合</strong>：</p><ul><li>返回值需通过 <code>pthread_join</code> 获取，否则可能内存泄漏（如果返回的是 <code>malloc</code> 分配的内存）</li></ul></li></ol><hr><h3><span id="常见问题">常见问题</span></h3><h4><span id="q1-为什么不能返回局部变量"><strong>Q1: 为什么不能返回局部变量？</strong></span></h4><ul><li>线程栈是线程私有的，退出后栈内存被回收，返回的指针指向无效地址</li></ul><h4><span id="q2-如何安全地返回数据"><strong>Q2: 如何安全地返回数据？</strong></span></h4><ul><li><p><strong>方法1</strong>：返回全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">42</span>;</span><br><span class="line">pthread_exit(&amp;global_var);  <span class="comment">// 安全</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法2</strong>：返回堆内存（需调用者释放）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *heap_var = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*heap_var = <span class="number">42</span>;</span><br><span class="line">pthread_exit(heap_var);  <span class="comment">// 需在 pthread_join 后 free</span></span><br></pre></td></tr></table></figure></li></ul><h4><span id="q3-主线程调用-pthread_exit-会怎样"><strong>Q3: 主线程调用 <code>pthread_exit</code> 会怎样？</strong></span></h4><ul><li>主线程变为“僵尸线程”，进程继续运行，直到所有线程退出，具体解释如下：</li></ul><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <p>当主线程（即程序初始创建的线程）调用 <code>pthread_exit</code> 退出时，其行为与普通线程调用 <code>pthread_exit</code> 类似，但需要注意以下几点关键影响：</p><hr><ol><li><strong>主线程终止，但进程可能继续运行</strong><ul><li>默认情况下，进程会等待所有线程（包括主线程）结束后才退出。如果其他线程仍在运行，进程会继续执行，直到所有线程退出。</li><li>这与主线程直接 <code>return</code> 或调用 <code>exit</code> 不同：<ul><li><code>exit</code> 会终止整个进程（包括所有线程）。</li><li><code>return</code> 从 <code>main</code> 函数返回时，会隐式调用 <code>exit</code>，导致进程结束。</li></ul></li></ul></li></ol><hr><ol start="2"><li><strong>主线程资源释放</strong><ul><li>主线程的栈和线程描述符会被释放，但进程的全局资源（如堆内存、打开的文件描述符等）会保留，直到进程退出。</li></ul></li></ol><hr><ol start="3"><li><strong>返回值处理</strong><ul><li>主线程通过 <code>pthread_exit</code> 传递的返回值（通过 <code>void*</code> 参数）可以被其他线程通过 <code>pthread_join</code> 获取。但如果主线程未被其他线程 <code>join</code>，返回值会被忽略。</li></ul></li></ol><hr><ol start="4"><li><strong>潜在风险</strong><ul><li><strong>僵尸进程风险</strong>：如果主线程退出后，其他线程因阻塞或死循环无法退出，进程会一直存在，成为“僵尸”。</li><li><strong>依赖主线程的操作失败</strong>：例如，某些GUI框架或库可能要求主线程负责事件循环，主线程退出会导致程序异常。</li></ul></li></ol><hr><p>示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程正在运行...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程结束\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程调用 pthread_exit\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 主线程退出，但进程继续</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码不会执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这行不会打印\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程调用 pthread_exit</span><br><span class="line">子线程正在运行...</span><br><span class="line">子线程结束         # 进程在此后退出</span><br></pre></td></tr></table></figure><hr><p>何时使用？</p><ul><li>需要让其他线程继续完成任务时，主线程可以调用 <code>pthread_exit</code> 退出。</li><li>但更常见的做法是让主线程通过 <code>pthread_join</code> 等待其他线程结束，以保持逻辑清晰。</li></ul><hr><p>总结</p><p>主线程调用 <code>pthread_exit</code> 会终止自身，但进程会持续到所有线程退出。需谨慎使用，避免资源泄漏或不可控的进程行为。在大多数场景下，显式地管理线程生命周期（如 <code>pthread_join</code>）是更安全的选择。</p>    </div></div><hr><h3><span id="总结">总结</span></h3><table><thead><tr><th>关键点</th><th>说明</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>显式终止当前线程，并可传递返回值</td></tr><tr><td><strong>返回值</strong></td><td>必须指向全局变量或堆内存，不能是局部变量</td></tr><tr><td><strong>资源管理</strong></td><td>不会自动释放非栈资源（如 <code>malloc</code> 内存）</td></tr><tr><td><strong>与 <code>return</code> 区别</strong></td><td><code>pthread_exit</code> 可在任意位置调用，<code>return</code> 需在函数末尾</td></tr></tbody></table><p>正确使用 <code>pthread_exit</code> 可以安全地终止线程并传递数据，但需注意内存管理的陷阱！</p><hr><h2><span id="pthread_cancel-函数线程取消"><code>pthread_cancel</code> 函数：线程取消</span></h2><p><code>pthread_cancel</code> 是 POSIX 线程库中用于<strong>请求取消另一个线程</strong>的函数它允许一个线程向目标线程发送取消请求，但目标线程是否立即终止取决于其取消状态和类型</p><hr><h3><span id="函数原型">函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><hr><h3><span id="参数说明">参数说明</span></h3><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>thread</code></strong></td><td><code>pthread_t</code></td><td>目标线程的 ID（通过 <code>pthread_create</code> 获取）</td></tr></tbody></table><hr><h3><span id="返回值">返回值</span></h3><table><thead><tr><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>0</code></strong></td><td>取消请求发送成功（不保证线程已终止）</td></tr><tr><td><strong><code>非0</code></strong></td><td>失败，返回错误码（如 <code>ESRCH</code> 表示线程不存在）</td></tr></tbody></table><hr><h3><span id="线程取消的工作原理">线程取消的工作原理</span></h3><p>线程取消是<strong>协作式</strong>的，目标线程需要响应取消请求才会终止具体行为由两个属性控制：</p><p>（1）取消状态（Enable&#x2F;Disable）**</p><ul><li><strong><code>PTHREAD_CANCEL_ENABLE</code></strong>（默认）：线程可被取消</li><li><strong><code>PTHREAD_CANCEL_DISABLE</code></strong>：忽略取消请求</li></ul><p>（2）取消类型（Deferred&#x2F;Asynchronous）**</p><ul><li><strong><code>PTHREAD_CANCEL_DEFERRED</code></strong>（默认）：延迟取消，线程在到达<strong>取消点</strong>（如 <code>sleep</code>、<code>read</code> 等系统调用）时终止</li><li><strong><code>PTHREAD_CANCEL_ASYNCHRONOUS</code></strong>：立即取消（危险！可能破坏数据一致性）</li></ul><hr><h3><span id="相关函数">相关函数</span></h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>pthread_setcancelstate()</code></td><td>设置取消状态（Enable&#x2F;Disable）</td></tr><tr><td><code>pthread_setcanceltype()</code></td><td>设置取消类型（Deferred&#x2F;Asynchronous）</td></tr><tr><td><code>pthread_testcancel()</code></td><td>手动插入取消点（检查是否收到取消请求）</td></tr></tbody></table><hr><h3><span id="使用示例">使用示例</span></h3><p>（1）基本用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，取消请求会在取消点（如sleep）生效</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);  <span class="comment">// 3秒后发送取消请求</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread canceled.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread canceled.</span><br></pre></td></tr></table></figure><p>（2）禁用取消请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running (cancel disabled)...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：<code>pthread_cancel</code> 调用无效，线程继续运行</p><hr><h3><span id="注意事项">*注意事项</span></h3><ol><li><p><strong>资源清理问题</strong>：</p><ul><li>线程被取消时不会自动释放锁或内存，可能导致死锁或泄漏</li><li>解决方案：使用 <strong>清理处理程序</strong>（<code>pthread_cleanup_push</code>&#x2F;<code>pthread_cleanup_pop</code>）</li></ul></li><li><p><strong>异步取消的风险</strong>：</p><ul><li><code>PTHREAD_CANCEL_ASYNCHRONOUS</code> 可能在线程执行任意指令时终止它，破坏数据一致性</li><li>仅在绝对必要时使用（如计算密集型且无共享数据的线程）</li></ul></li><li><p><strong>取消点的限制</strong>：</p><ul><li>如果线程长时间不调用取消点（如纯计算循环），取消请求会延迟生效</li><li>可手动插入 <code>pthread_testcancel()</code></li></ul></li></ol><hr><h3><span id="常见问题">常见问题</span></h3><h4><span id="q1-为什么线程没有立即终止"><strong>Q1: 为什么线程没有立即终止？</strong></span></h4><ul><li>目标线程可能禁用了取消（<code>PTHREAD_CANCEL_DISABLE</code>），或未到达取消点</li></ul><h4><span id="q2-如何安全地终止线程"><strong>Q2: 如何安全地终止线程？</strong></span></h4><ul><li><p>推荐使用<strong>协作式取消</strong>（通过共享变量通知线程退出循环）</p></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> thread_running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (thread_running) &#123;</span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程中：</span></span><br><span class="line">thread_running = <span class="number">0</span>;  <span class="comment">// 通知线程退出</span></span><br><span class="line">pthread_join(tid, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul><h4><span id="q3-取消后如何回收资源"><strong>Q3: 取消后如何回收资源？</strong></span></h4><ul><li><p>使用清理处理程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cleaning up: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *data = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, data);</span><br><span class="line">    <span class="comment">// 线程工作代码</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);  <span class="comment">// 执行清理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3><span id="总结">总结</span></h3><table><thead><tr><th>关键点</th><th>说明</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>向目标线程发送取消请求（协作式）</td></tr><tr><td><strong>取消控制</strong></td><td>通过状态（Enable&#x2F;Disable）和类型（Deferred&#x2F;Asynchronous）管理</td></tr><tr><td><strong>安全性</strong></td><td>默认延迟取消更安全，异步取消需谨慎</td></tr><tr><td><strong>资源管理</strong></td><td>必须手动处理锁、内存等资源的释放</td></tr></tbody></table><p><code>pthread_cancel</code> 是强制终止线程的最后手段，<strong>优先考虑协作式退出机制</strong>（如共享标志变量）</p><hr><h2><span id="pthread_cleanup_push-和-pthread_cleanup_pop-函数线程资源清理"><code>pthread_cleanup_push</code> 和 <code>pthread_cleanup_pop</code> 函数：线程资源清理</span></h2><p>这两个函数用于<strong>注册和触发线程清理处理程序</strong>，确保线程被取消或异常终止时能正确释放资源（如解锁互斥锁、关闭文件、释放堆内存等）它们是 POSIX 线程库中管理资源安全性的关键机制</p><hr><h3><span id="函数原型">函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure><hr><h3><span id="核心功能">核心功能</span></h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><strong><code>pthread_cleanup_push</code></strong></td><td>注册一个清理函数（如 <code>free</code> 或 <code>pthread_mutex_unlock</code>）</td></tr><tr><td><strong><code>pthread_cleanup_pop</code></strong></td><td>移除最近注册的清理函数，并可选是否立即执行它</td></tr></tbody></table><hr><h3><span id="触发清理的三种情况">触发清理的三种情况</span></h3><ol><li><strong>线程调用 <code>pthread_exit</code> 终止</strong></li><li><strong>线程被其他线程 <code>pthread_cancel</code> 取消</strong></li><li><strong>显式调用 <code>pthread_cleanup_pop(1)</code></strong>（参数为非0）</li></ol><blockquote><p><strong>注意</strong>：如果线程通过 <code>return</code> 正常退出，<strong>不会触发清理函数</strong>！</p></blockquote><hr><h3><span id="使用示例">使用示例</span></h3><p>（1）基本用法（释放动态内存）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_handler</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cleaning up: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);  <span class="comment">// 释放堆内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *data = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(data, <span class="string">&quot;Thread data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册清理函数</span></span><br><span class="line">    pthread_cleanup_push(cleanup_handler, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟线程工作（可能被取消）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Working with data: %s\n&quot;</span>, data);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须成对调用（即使不可达）</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);  <span class="comment">// 0表示不执行，仅出栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(tid);  <span class="comment">// 触发清理函数</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Working with data: Thread data</span><br><span class="line">Working with data: Thread data</span><br><span class="line">Working with data: Thread data</span><br><span class="line">Cleaning up: Thread data  # 线程取消时自动调用清理函数</span><br></pre></td></tr></table></figure><p>（2）保护互斥锁（避免死锁）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_unlock</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_unlock((<span class="type">pthread_mutex_t</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    pthread_cleanup_push(cleanup_unlock, &amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区操作（可能被取消）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Critical section\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);  <span class="comment">// 1表示执行清理函数（解锁）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="关键注意事项">关键注意事项</span></h3><ol><li><p><strong>必须成对使用</strong>：</p><ul><li><code>pthread_cleanup_push</code> 和 <code>pthread_cleanup_pop</code> 必须<strong>在同一个作用域内</strong>成对出现</li><li>它们实际上是宏，可能展开为 <code>&#123;</code> 和 <code>&#125;</code>，因此不允许跨函数或条件分支</li></ul></li><li><p><strong>执行顺序</strong>：</p><ul><li>清理函数按**栈顺序（后进先出）**执行</li></ul></li><li><p><strong><code>return</code> 的陷阱</strong>：</p><ul><li>如果线程通过 <code>return</code> 退出，清理函数不会执行！必须用 <code>pthread_exit</code> 或触发取消</li></ul></li><li><p><strong>与 C++ 析构函数的区别</strong>：</p><ul><li>C++ 局部对象的析构函数在线程 <code>return</code> 时仍会调用，但清理函数不会</li></ul></li></ol><hr><h3><span id="典型应用场景">典型应用场景</span></h3><table><thead><tr><th>场景</th><th>清理目标</th></tr></thead><tbody><tr><td><strong>动态内存管理</strong></td><td><code>free</code>、<code>delete</code></td></tr><tr><td><strong>文件操作</strong></td><td><code>fclose</code>、<code>close</code></td></tr><tr><td><strong>锁管理</strong></td><td><code>pthread_mutex_unlock</code>、<code>sem_post</code></td></tr><tr><td><strong>网络连接</strong></td><td><code>shutdown</code>、<code>close</code></td></tr></tbody></table><hr><h3><span id="常见问题">常见问题</span></h3><h4><span id="q1-为什么-pthread_cleanup_pop-需要参数"><strong>Q1: 为什么 <code>pthread_cleanup_pop</code> 需要参数？</strong></span></h4><ul><li>参数控制是否立即执行清理函数：<ul><li><code>pthread_cleanup_pop(1)</code>：执行并移除</li><li><code>pthread_cleanup_pop(0)</code>：仅移除（不执行）</li></ul></li></ul><h4><span id="q2-清理函数可以嵌套吗"><strong>Q2: 清理函数可以嵌套吗？</strong></span></h4><ul><li><p>可以，按注册的逆序执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_cleanup_push(cleanup1, arg1);</span><br><span class="line">pthread_cleanup_push(cleanup2, arg2);</span><br><span class="line">pthread_cleanup_pop(<span class="number">1</span>);  <span class="comment">// 执行 cleanup2</span></span><br><span class="line">pthread_cleanup_pop(<span class="number">1</span>);  <span class="comment">// 执行 cleanup1</span></span><br></pre></td></tr></table></figure></li></ul><h4><span id="q3-如果线程正常-return如何确保资源释放"><strong>Q3: 如果线程正常 <code>return</code>，如何确保资源释放？</strong></span></h4><ul><li>方案1：改用 <code>pthread_exit</code> 退出线程</li><li>方案2：在 <code>return</code> 前手动调用清理逻辑（不推荐，易遗漏）</li></ul><hr><h3><span id="总结">总结</span></h3><table><thead><tr><th>关键点</th><th>说明</th></tr></thead><tbody><tr><td><strong>核心作用</strong></td><td>确保线程异常终止时资源不被泄漏</td></tr><tr><td><strong>触发条件</strong></td><td><code>pthread_exit</code>、<code>pthread_cancel</code> 或显式 <code>pthread_cleanup_pop(1)</code></td></tr><tr><td><strong>必须成对</strong></td><td>严格在相同作用域内匹配使用</td></tr><tr><td><strong>执行顺序</strong></td><td>后进先出（LIFO）</td></tr></tbody></table><p><strong>正确使用这两个函数是编写健壮多线程程序的必备技能！</strong></p><hr><h2><span id="pthread_join-函数线程等待与资源回收"><strong><code>pthread_join</code> 函数：线程等待与资源回收</strong></span></h2><p><code>pthread_join</code> 是 POSIX 线程库中用于<strong>等待指定线程终止并回收其资源</strong>的关键函数它的作用类似于进程中的 <code>waitpid</code>，但针对的是线程级别的同步</p><hr><h3><span id="为什么需要线程等待">为什么需要线程等待？</span></h3><h4><span id="1资源回收"><strong>（1）资源回收</strong></span></h4><ul><li>线程退出后，其占用的<strong>栈空间</strong>和<strong>线程描述符</strong>不会自动释放</li><li>若不调用 <code>pthread_join</code>，会导致<strong>内存泄漏</strong>（类似进程的“僵尸线程”问题）</li></ul><h4><span id="2获取返回值"><strong>（2）获取返回值</strong></span></h4><ul><li>线程可以通过 <code>pthread_exit</code> 或 <code>return</code> 返回数据，<code>pthread_join</code> 是接收这些数据的唯一方式</li></ul><h4><span id="3同步控制"><strong>（3）同步控制</strong></span></h4><ul><li>确保主线程等待子线程完成特定任务后再继续执行</li></ul><hr><h3><span id="函数原型">函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **value_ptr)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>thread</code></strong></td><td>目标线程的 ID（由 <code>pthread_create</code> 返回）</td></tr><tr><td><strong><code>value_ptr</code></strong></td><td>指向指针的指针，用于接收线程返回值（可设为 <code>NULL</code>）</td></tr></tbody></table><p><strong>返回值</strong>：</p><ul><li><strong><code>0</code></strong>：成功</li><li><strong>非零</strong>：错误码（如 <code>ESRCH</code> 表示线程不存在）</li></ul><hr><h3><span id="工作流程">工作流程</span></h3><ol><li><strong>阻塞调用者</strong>：当前线程（通常是主线程）进入阻塞状态，直到目标线程结束</li><li><strong>回收资源</strong>：释放目标线程的栈和线程描述符</li><li><strong>获取返回值</strong>：如果 <code>value_ptr</code> 非 <code>NULL</code>，存储线程的返回值</li></ol><hr><h3><span id="使用示例">使用示例</span></h3><h4><span id="1基本用法等待线程结束"><strong>（1）基本用法（等待线程结束）</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is working...\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">42</span>);  <span class="comment">// 返回整数值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span> *ret_val;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, &amp;ret_val);  <span class="comment">// 阻塞等待线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %ld\n&quot;</span>, (<span class="type">long</span>)ret_val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread is working...</span><br><span class="line">Thread returned: 42</span><br></pre></td></tr></table></figure><h4><span id="2忽略返回值"><strong>（2）忽略返回值</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_join(tid, <span class="literal">NULL</span>);  <span class="comment">// 不关心返回值，仅回收资源</span></span><br></pre></td></tr></table></figure><h4><span id="3错误处理"><strong>（3）错误处理</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pthread_join(tid, &amp;ret_val) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_join failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4><span id="关键注意事项">关键注意事项</span></h4><h3><span id="1线程必须可连接joinable"><strong>（1）线程必须可连接（Joinable）</strong></span></h3><ul><li>默认情况下，线程是 <strong>可连接的</strong>（Joinable）</li><li>若线程被设置为 <strong>分离状态</strong>（<code>pthread_detach</code>），则不能再调用 <code>pthread_join</code>（否则返回 <code>EINVAL</code>）</li></ul><h3><span id="2返回值的内存管理"><strong>（2）返回值的内存管理</strong></span></h3><ul><li><p>如果线程返回的是 <code>malloc</code> 分配的堆内存，调用者需负责释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *result = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回堆内存指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程中：</span></span><br><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line">pthread_join(tid, (<span class="type">void</span> **)&amp;ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, *ptr);</span><br><span class="line"><span class="built_in">free</span>(ptr);  <span class="comment">// 必须手动释放！</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="3禁止重复调用"><strong>（3）禁止重复调用</strong></span></h3><ul><li>对同一个线程多次调用 <code>pthread_join</code> 会导致未定义行为</li></ul><h3><span id="4主线程退出问题"><strong>（4）主线程退出问题</strong></span></h3><ul><li>如果主线程直接 <code>exit</code> 或 <code>return</code>，所有子线程会被强制终止，可能导致资源泄漏</li><li><strong>解决方案</strong>：主线程应等待所有子线程结束后再退出</li></ul><hr><h3><span id="常见问题">常见问题</span></h3><h4><span id="q1-不调用-pthread_join-会怎样"><strong>Q1: 不调用 <code>pthread_join</code> 会怎样？</strong></span></h4><ul><li><strong>内存泄漏</strong>：线程的栈空间和描述符不会被回收</li><li><strong>无法获取返回值</strong>：线程的返回数据丢失</li></ul><h4><span id="q2-如何避免阻塞等待"><strong>Q2: 如何避免阻塞等待？</strong></span></h4><ul><li><p>使用 <code>pthread_detach</code> 让线程自动回收资源（但无法获取返回值）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(tid);  <span class="comment">// 线程退出后自动释放资源</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3><span id="总结">总结</span></h3><table><thead><tr><th>关键点</th><th>说明</th></tr></thead><tbody><tr><td><strong>核心作用</strong></td><td>等待线程终止 + 回收资源 + 获取返回值</td></tr><tr><td><strong>资源管理</strong></td><td>必须调用以避免内存泄漏</td></tr><tr><td><strong>同步控制</strong></td><td>确保线程间的执行顺序</td></tr><tr><td><strong>返回值</strong></td><td>需注意堆内存的释放责任</td></tr></tbody></table><p><strong>正确使用 <code>pthread_join</code> 是多线程编程中避免资源泄漏的基础！</strong></p><hr><h2><span id="pthread_detach-函数线程分离"><strong><code>pthread_detach</code> 函数：线程分离</strong></span></h2><p><code>pthread_detach</code> 是 POSIX 线程库中用于**将线程标记为”分离状态”**的函数，使得线程终止时系统自动回收其资源，无需其他线程调用 <code>pthread_join</code></p><hr><h3><span id="为什么需要线程分离">为什么需要线程分离？</span></h3><h4><span id="1默认问题"><strong>（1）默认问题</strong></span></h4><ul><li>新创建的线程默认是 <strong>可连接的（Joinable）</strong>，必须显式调用 <code>pthread_join</code> 回收资源，否则会导致：<ul><li><strong>内存泄漏</strong>：线程栈和描述符未被释放</li><li><strong>僵尸线程</strong>：类似僵尸进程，占用系统资源</li></ul></li></ul><h4><span id="2分离线程的优势"><strong>（2）分离线程的优势</strong></span></h4><ul><li><strong>自动回收资源</strong>：线程退出时，系统立即回收其资源</li><li><strong>减少同步负担</strong>：无需手动调用 <code>pthread_join</code>，适合不关心返回值的场景</li></ul><hr><h3><span id="函数原型">函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>thread</code></strong></td><td>目标线程的 ID（由 <code>pthread_create</code> 返回或 <code>pthread_self()</code> 获取）</td></tr></tbody></table><p><strong>返回值</strong>：</p><ul><li><strong><code>0</code></strong>：成功</li><li><strong>非零</strong>：错误码（如 <code>ESRCH</code> 表示线程不存在，<code>EINVAL</code> 表示线程已分离）</li></ul><hr><h3><span id="使用方式">使用方式</span></h3><p>（1）其他线程分离目标线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">pthread_detach(tid);  <span class="comment">// 主线程分离子线程</span></span><br></pre></td></tr></table></figure><p>（2）线程自我分离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_detach(pthread_self());  <span class="comment">// 分离自己</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="关键特性">关键特性</span></h3><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>资源回收</strong></td><td>线程退出时自动释放栈和描述符</td></tr><tr><td><strong>返回值</strong></td><td>分离线程的返回值无法通过 <code>pthread_join</code> 获取</td></tr><tr><td><strong>不可逆性</strong></td><td>一旦分离，不能再调用 <code>pthread_join</code>（否则返回 <code>EINVAL</code>）</td></tr><tr><td><strong>线程安全</strong></td><td>可被任意线程（包括自己）调用</td></tr></tbody></table><hr><h3><span id="使用示例">使用示例</span></h3><p>（1）基础用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread working...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread exiting\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_detach(tid);  <span class="comment">// 分离线程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread continues\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);  <span class="comment">// 等待子线程退出（实际生产代码应避免sleep）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main thread continues</span><br><span class="line">Thread working...</span><br><span class="line">Thread exiting  # 线程退出后资源自动回收</span><br></pre></td></tr></table></figure><p>（2）错误处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pthread_detach(tid) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pthread_detach failed&quot;</span>);</span><br><span class="line">    <span class="comment">// 补救措施：尝试 pthread_join</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="注意事项">注意事项</span></h3><ol><li><p><strong>禁止重复分离</strong>：</p><ul><li>对已分离的线程再次调用 <code>pthread_detach</code> 会返回 <code>EINVAL</code></li></ul></li><li><p><strong>与 <code>pthread_join</code> 互斥</strong>：</p><ul><li>分离和连接是互斥操作，一个线程只能选择一种方式</li></ul></li><li><p><strong>主线程退出问题</strong>：</p><ul><li>即使线程已分离，主线程若直接退出（如调用 <code>exit</code>），仍可能导致子线程被强制终止</li></ul></li><li><p><strong>返回值限制</strong>：</p><ul><li>分离线程不应返回需要手动释放的堆内存（因为无法通过 <code>pthread_join</code> 获取指针并 <code>free</code>）</li></ul></li></ol><hr><h3><span id="常见问题">常见问题</span></h3><h4><span id="q1-分离线程和守护线程的区别"><strong>Q1: 分离线程和守护线程的区别？</strong></span></h4><ul><li><strong>分离线程</strong>：仅控制资源回收方式，仍是普通线程</li><li><strong>守护线程</strong>（如 Linux 的 <code>pthread_create</code> + <code>pthread_detach</code>）：常驻后台执行任务，主线程退出时不会影响它（需额外设置）</li></ul><h4><span id="q2-如何判断线程是否已分离"><strong>Q2: 如何判断线程是否已分离？</strong></span></h4><ul><li>POSIX 未提供直接接口，需通过返回值推断：<ul><li>调用 <code>pthread_detach</code> 返回 <code>EINVAL</code> 表示已分离</li><li>调用 <code>pthread_join</code> 返回 <code>EINVAL</code> 也表示已分离</li></ul></li></ul><h4><span id="q3-分离线程能否取消"><strong>Q3: 分离线程能否取消？</strong></span></h4><ul><li>可以，<code>pthread_cancel</code> 对分离线程同样有效</li></ul><hr><h3><span id="应用场景">应用场景</span></h3><table><thead><tr><th>场景</th><th>理由</th></tr></thead><tbody><tr><td><strong>后台任务</strong></td><td>不依赖主线程，不关心结果（如日志写入）</td></tr><tr><td><strong>一次性任务</strong></td><td>执行完即销毁，无需跟踪状态</td></tr><tr><td><strong>资源受限环境</strong></td><td>避免忘记 <code>pthread_join</code> 导致泄漏</td></tr></tbody></table><hr><h3><span id="总结">总结</span></h3><table><thead><tr><th>关键点</th><th>说明</th></tr></thead><tbody><tr><td><strong>核心作用</strong></td><td>让线程退出时自动回收资源</td></tr><tr><td><strong>资源管理</strong></td><td>替代 <code>pthread_join</code>，避免手动回收</td></tr><tr><td><strong>使用限制</strong></td><td>无法获取返回值，不可逆</td></tr><tr><td><strong>最佳实践</strong></td><td>适用于不关心返回值的异步任务</td></tr></tbody></table><p><strong>线程分离是多线程编程中”即用即弃”场景的高效解决方案</strong></p><hr><h2><span id="线程局部存储tls技术__thread-关键字详解">线程局部存储（TLS）技术：<code>__thread</code> 关键字详解</span></h2><p>线程局部存储（Thread-Local Storage, TLS）是一种<strong>让每个线程拥有变量独立副本</strong>的机制，POSIX 线程库通过 <code>__thread</code> 关键字实现这一功能</p><hr><h3><span id="为什么需要线程局部存储">为什么需要线程局部存储？</span></h3><p>在多线程环境中，全局变量和静态变量被所有线程共享，可能导致：</p><ul><li><strong>数据竞争</strong>：多个线程同时修改同一变量</li><li><strong>逻辑错误</strong>：某线程修改全局变量影响其他线程</li><li><strong>减少函数传参</strong>：对于每一个线程，都有一个属于自己的变量副本，函数内调用别的函数可以直接访问</li></ul><p><code>__thread</code> 为变量提供<strong>线程级别的存储周期</strong>，每个线程访问的都是自己的独立副本</p><hr><h3><span id="__thread-的基本用法"><code>__thread</code> 的基本用法</span></h3><h4><span id="1语法规则"><strong>（1）语法规则</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread 类型 变量名;</span><br></pre></td></tr></table></figure><ul><li>只能修饰 <strong>全局变量</strong>、<strong>静态变量</strong>（局部或全局作用域均可），且必须为内置类型</li><li>不能修饰函数内的普通局部变量（非静态）</li></ul><h4><span id="2示例代码"><strong>（2）示例代码</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__thread <span class="type">int</span> tls_var = <span class="number">0</span>;  <span class="comment">// 线程局部存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    tls_var = (<span class="type">int</span>)(<span class="type">long</span>)arg;  <span class="comment">// 每个线程修改自己的副本</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld: tls_var = %d\n&quot;</span>, (<span class="type">long</span>)pthread_self(), tls_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread: tls_var = %d\n&quot;</span>, tls_var);  <span class="comment">// 主线程的副本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: tls_var = 1</span><br><span class="line">Thread 2: tls_var = 2</span><br><span class="line">Main thread: tls_var = 0  # 主线程的副本未被修改</span><br></pre></td></tr></table></figure><hr><h3><span id="关键特性">关键特性</span></h3><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>独立性</strong></td><td>每个线程持有变量的独立副本</td></tr><tr><td><strong>初始化</strong></td><td>只能使用常量表达式初始化（如 <code>__thread int x = 42;</code>）</td></tr><tr><td><strong>作用域</strong></td><td>可修饰全局变量或 <code>static</code> 局部变量</td></tr><tr><td><strong>效率</strong></td><td>访问速度与普通全局变量相当（由编译器优化）</td></tr></tbody></table><hr><h3><span id="与相关技术的对比">与相关技术的对比</span></h3><table><thead><tr><th>技术</th><th>作用</th><th>区别</th></tr></thead><tbody><tr><td><strong><code>__thread</code></strong></td><td>线程局部存储</td><td>编译器直接支持，效率最高</td></tr><tr><td><strong><code>pthread_key_create</code></strong></td><td>动态TLS</td><td>更灵活但性能较低（需函数调用）</td></tr><tr><td><strong>全局变量</strong></td><td>共享数据</td><td>所有线程共用同一变量</td></tr></tbody></table><hr><h3><span id="使用注意事项">使用注意事项</span></h3><ol><li><p><strong>不可修饰类对象</strong>（C++）：</p><ul><li><code>__thread</code> 在 C++ 中只能修饰 POD 类型（简单数据类型），不能修饰带构造函数的类</li></ul></li><li><p><strong>动态初始化限制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误！不能用非常量初始化</span></span><br><span class="line"><span class="type">int</span> global_init = <span class="number">10</span>;</span><br><span class="line">__thread <span class="type">int</span> bad_var = global_init;  </span><br></pre></td></tr></table></figure></li><li><p><strong>兼容性问题</strong>：</p><ul><li><code>__thread</code> 是 GCC&#x2F;Clang 扩展，Windows 需用 <code>__declspec(thread)</code></li><li>可移植代码建议使用 <code>pthread_key_create</code></li></ul></li></ol><hr><h3><span id="典型应用场景">典型应用场景</span></h3><table><thead><tr><th>场景</th><th>用途</th></tr></thead><tbody><tr><td><strong>错误码存储</strong></td><td>每个线程维护独立的 <code>errno</code></td></tr><tr><td><strong>随机数种子</strong></td><td>避免多线程共用随机数生成器</td></tr><tr><td><strong>线程上下文</strong></td><td>存储线程专属数据（如用户ID）</td></tr></tbody></table><hr><h3><span id="底层实现原理">底层实现原理</span></h3><p>编译器会为 <code>__thread</code> 变量生成：</p><ol><li><strong>线程局部存储段</strong>（TLS Section）：每个线程启动时分配独立空间</li><li><strong>隐式线程ID关联</strong>：通过线程控制块（TCB）定位变量地址</li></ol><p>访问 <code>__thread</code> 变量时，实际执行以下伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：获取__thread变量地址</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_tls_addr</span><span class="params">(__thread_var)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TCB-&gt;tls_section + offset_of(__thread_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="总结">总结</span></h3><table><thead><tr><th>关键点</th><th>说明</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>为每个线程提供变量的独立副本</td></tr><tr><td><strong>性能</strong></td><td>比 <code>pthread_key_create</code> 更高效</td></tr><tr><td><strong>限制</strong></td><td>仅支持简单数据类型，初始化受限</td></tr><tr><td><strong>适用场景</strong></td><td>需要线程隔离数据的场景（如 <code>errno</code>）</td></tr></tbody></table><p><strong><code>__thread</code> 是高性能线程局部存储的首选方案</strong>，但需注意其平台兼容性限制</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程概念</title>
      <link href="/2025/07/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_concept/"/>
      <url>/2025/07/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/thread_concept/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">线程的基本概念</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB">线程与进程的关系</a><ul><li><a href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E6%89%A7%E8%A1%8C">资源分配与执行</a></li></ul></li><li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6">线程的实现机制</a><ul><li><a href="#%E5%88%86%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">分页式存储管理</a></li><li><a href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84">多级页表结构</a></li></ul></li><li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF">线程的优势</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9">线程的缺点</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E5%AF%B9%E6%AF%94">线程与进程的资源对比</a><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90">线程共享的资源</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E7%8B%AC%E6%9C%89%E7%9A%84%E8%B5%84%E6%BA%90">线程独有的资源</a></li></ul></li></ul><!-- tocstop --><h2><span id="线程的基本概念">线程的基本概念</span></h2><p>线程是<strong>在一个程序里的一个执行路线</strong>，更准确的定义是：线程是”一个进程内部的控制序列”。一切进程至少都有一个执行线程，线程在进程内部运行，本质是在进程地址空间内运行。</p><p>在Linux系统中，从CPU的角度来看，线程对应的PCB（进程控制块）比传统的进程更加轻量化。通过进程的虚拟地址空间，我们可以看到进程的大部分资源，将这些资源合理分配给每个执行流，就形成了线程执行流。</p><p><img src="/img/Linux/thread/thread_concept.png" alt="thread_concept"></p><h2><span id="线程与进程的关系">线程与进程的关系</span></h2><p>我们可以用一个家庭成员来形象地理解线程、执行流和进程之间的关系：</p><ul><li><strong>进程</strong>就像一个家庭，拥有共同的资源（房子、存款、家具等）</li><li><strong>线程</strong>就像家庭中的各个成员（父母、孩子），共享家庭资源但各自有自己的任务</li><li><strong>执行流</strong>就像家庭成员各自的活动轨迹（爸爸上班、妈妈做饭、孩子学习）</li></ul><h3><span id="资源分配与执行">资源分配与执行</span></h3><ul><li><strong>进程</strong>是承担分配系统资源的基本实体，它拥有独立的地址空间、文件描述符、信号处理等资源</li><li><strong>线程</strong>是进程内部的执行流单元，多个线程共享进程的资源，但每个线程有自己的执行上下文</li></ul><h2><span id="线程的实现机制">线程的实现机制</span></h2><h3><span id="分页式存储管理">分页式存储管理</span></h3><p>现代操作系统使用虚拟内存和分页机制来管理内存：</p><ol><li>将物理内存按照固定长度的页框（通常4KB）进行分割</li><li>为每个进程提供独立的虚拟地址空间（32位系统为0~4GB）</li><li>通过页表建立虚拟地址和物理地址的映射关系</li></ol><p>这种机制允许：</p><ul><li>连续的虚拟内存映射到不连续的物理内存页</li><li>解决物理内存碎片问题</li><li>实现内存保护和共享</li></ul><h3><span id="多级页表结构">多级页表结构</span></h3><p>为了高效管理页表，现代CPU使用多级页表结构：</p><ol><li><strong>页目录表</strong>：由CR3寄存器指向，包含1024个页表项</li><li><strong>页表</strong>：每个页表包含1024个页表项，指向物理页</li><li><strong>TLB快表</strong>：缓存最近使用的页表项，加速地址转换</li></ol><p>当CPU访问内存时，MMU（内存管理单元）会：</p><ol><li>首先查询TLB快表</li><li>如果未命中，则查询多级页表</li><li>如果页表项不存在，则触发缺页异常</li></ol><h2><span id="线程的优势">线程的优势</span></h2><ol><li><strong>创建代价低</strong>：创建线程比创建进程开销小得多</li><li><strong>切换速度快</strong>：<ul><li>线程切换不改变虚拟内存空间，TLB不需要刷新</li><li>只需要保存&#x2F;恢复少量寄存器内容</li></ul></li><li><strong>资源占用少</strong>：线程共享进程资源，额外开销小</li><li><strong>并行性好</strong>：能充分利用多处理器核心</li><li><strong>I&#x2F;O重叠</strong>：可以在等待I&#x2F;O时执行其他计算任务</li></ol><h2><span id="线程的缺点">线程的缺点</span></h2><ol><li><strong>性能损失</strong>：计算密集型线程过多可能导致额外调度开销</li><li><strong>健壮性降低</strong>：一个线程崩溃可能导致整个进程终止</li><li><strong>编程复杂</strong>：需要考虑线程同步和数据竞争问题</li><li><strong>缺乏隔离</strong>：线程间缺乏保护机制，容易相互干扰</li></ol><h2><span id="线程与进程的资源对比">线程与进程的资源对比</span></h2><h3><span id="线程共享的资源">线程共享的资源</span></h3><ul><li>代码段(Text Segment)</li><li>数据段(Data Segment)</li><li>堆空间</li><li>文件描述符表</li><li>信号处理方式</li><li>用户ID和组ID</li><li>当前工作目录</li></ul><h3><span id="线程独有的资源">线程独有的资源</span></h3><ul><li>线程ID</li><li><strong>寄存器组（线程上下文）</strong></li><li><strong>栈空间</strong></li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><p>线程虽然是进程内的执行分支，共享进程的代码、数据、堆等资源，但每个线程仍然需要维护自己的独立执行环境。其中，<strong>寄存器组（线程上下文）<strong>和</strong>栈空间</strong>是线程独有资源的关键部分，它们确保了线程可以独立执行，不受其他线程干扰。</p><h4><span id="1-寄存器组线程上下文"><strong>1. 寄存器组（线程上下文）</strong></span></h4><p><strong>（1）为什么线程需要独立的寄存器组？</strong><br>CPU 执行指令时，依赖寄存器存储当前的计算状态，例如：</p><ul><li><strong>程序计数器（PC &#x2F; EIP &#x2F; RIP）</strong>：记录当前执行指令的地址  </li><li><strong>栈指针（SP &#x2F; ESP &#x2F; RSP）</strong>：指向当前线程的栈顶  </li><li><strong>通用寄存器（EAX, EBX, ECX, EDX…）</strong>：存储临时计算结果  </li><li><strong>状态寄存器（EFLAGS）</strong>：记录运算状态（如进位、溢出等）</li></ul><p>由于 <strong>线程是 CPU 调度的基本单位</strong>，操作系统在切换线程时，必须保存当前线程的寄存器状态（上下文），并恢复下一个线程的寄存器状态，否则计算会出错。</p><p><strong>（2）线程切换时寄存器的保存与恢复</strong><br>线程切换（上下文切换）的过程：</p><ol><li><strong>保存当前线程的寄存器状态</strong>（存入线程的 <code>task_struct</code> 或 <code>TCB</code> 结构体）。</li><li><strong>加载目标线程的寄存器状态</strong>（从它的 <code>task_struct</code> 恢复）。</li><li><strong>CPU 继续执行目标线程</strong>。</li></ol><p>如果多个线程共享同一套寄存器，切换时数据会混乱，因此 <strong>每个线程必须有自己的寄存器副本</strong>。</p><hr><h4><span id="2-栈空间"><strong>2. 栈空间</strong></span></h4><p><strong>（1）为什么线程需要独立的栈？</strong><br>栈（Stack）用于存储：</p><ul><li><strong>函数调用时的返回地址</strong>（调用 <code>call</code> 指令时压栈）</li><li><strong>局部变量</strong></li><li><strong>函数参数</strong></li><li><strong>临时数据</strong></li></ul><p>如果多个线程共享同一个栈：</p><ul><li><strong>函数调用链会混乱</strong>（A 线程调用 <code>func1()</code>，B 线程调用 <code>func2()</code>，栈帧会交错，导致程序崩溃）。</li><li><strong>局部变量可能被覆盖</strong>（线程 A 的变量可能被线程 B 修改）。</li></ul><p>因此，<strong>每个线程必须有自己的栈空间</strong>，确保函数调用和局部变量的独立性。</p><p><strong>（2）线程栈的分配方式</strong></p><ul><li><strong>主线程</strong>：通常使用进程的默认栈（由操作系统或编译器分配）。</li><li><strong>子线程</strong>：由 <code>pthread_create()</code> 动态分配栈（默认大小通常为 2~8MB，可调整）。</li></ul><blockquote><p>线程作为轻量级的执行单元，在现代操作系统中扮演着重要角色。理解线程的工作原理、资源分配方式以及与进程的关系，对于编写高效、可靠的并发程序至关重要。合理使用多线程可以显著提升程&gt;序性能，但也需要注意线程安全、同步和资源管理等问题。</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux SIGCHLD信号处理与僵尸进程清理实验</title>
      <link href="/2025/07/23/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7/signal_sigchld/"/>
      <url>/2025/07/23/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7/signal_sigchld/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%AE%9E%E9%AA%8C%E8%83%8C%E6%99%AF">实验背景</a></li><li><a href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%E9%80%9A%E8%BF%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%B8%85%E7%90%86%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E6%94%B9%E8%BF%9B%E7%89%88">实验一：通过信号处理函数清理僵尸进程（改进版）</a><ul><li><a href="#1-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">1. 程序结构设计</a></li><li><a href="#2-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90">2. 关键组件分析</a></li><li><a href="#3-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%BC%98%E5%8C%96%E7%82%B9">3. 执行流程优化点</a></li><li><a href="#4-%E5%8F%AF%E8%83%BD%E7%9A%84%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE">4. 可能的改进建议</a></li></ul></li><li><a href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E9%80%9A%E8%BF%87sig_ign%E8%87%AA%E5%8A%A8%E6%B8%85%E7%90%86%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8C%81%E5%8E%9F%E6%96%B9%E6%A1%88">实验二：通过SIG_IGN自动清理僵尸进程（保持原方案）</a><ul><li><a href="#%E5%85%B3%E9%94%AE%E9%AA%8C%E8%AF%81%E7%82%B9">关键验证点</a></li></ul></li><li><a href="#%E5%AE%9E%E9%AA%8C%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90">实验对比分析</a></li><li><a href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E8%AE%BA">实验结论</a></li><li><a href="#%E5%BB%B6%E4%BC%B8%E6%80%9D%E8%80%83">延伸思考</a></li></ul><!-- tocstop --><hr><h2><span id="实验背景">实验背景</span></h2><p>在Unix&#x2F;Linux系统中，当子进程终止时，如果父进程没有及时调用<code>wait</code>或<code>waitpid</code>回收，子进程会变成僵尸进程（Zombie）。本实验通过两种方式验证如何有效清理僵尸进程：</p><ol><li><strong>自定义SIGCHLD信号处理函数</strong>（可移植方案）</li><li><strong>直接忽略SIGCHLD信号</strong>（Linux特有方案）</li></ol><hr><h2><span id="实验一通过信号处理函数清理僵尸进程改进版">实验一：通过信号处理函数清理僵尸进程（改进版）</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHILD_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DURATION 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> child_cnt = CHILD_NUM;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非阻塞回收所有终止的子进程</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        --child_cnt;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[Parent] Child %d exited with status %d\n\n&quot;</span>, </span><br><span class="line">                   pid, WEXITSTATUS(status));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[Parent] Child %d terminated abnormally\n\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.sa_handler = sigchld_handler;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Parent] PID=%d will create %d children in %d seconds\n\n&quot;</span>, </span><br><span class="line">           getpid(), CHILD_NUM, DURATION);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在20秒内随机创建20个子进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHILD_NUM; i++) &#123;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);  <span class="comment">// 随机延迟0-2秒</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程代码</span></span><br><span class="line">            <span class="type">int</span> sleep_time = <span class="number">1</span> + rand() % <span class="number">5</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[Child] PID=%d started (will exit after %ds)\n\n&quot;</span>, </span><br><span class="line">                   getpid(), sleep_time);</span><br><span class="line">            sleep(sleep_time);</span><br><span class="line">            <span class="built_in">exit</span>(rand() % <span class="number">100</span>);  <span class="comment">// 随机退出状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程持续工作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(child_cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Parent] I am working...\n\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="1-程序结构设计">1. 程序结构设计</span></h3><ul><li><strong>父进程</strong>：创建20个子进程，每个子进程随机延时启动，随机生存时间</li><li><strong>子进程</strong>：执行简单任务后以随机状态退出</li><li><strong>信号处理</strong>：通过SIGCHLD信号异步回收子进程</li></ul><h3><span id="2-关键组件分析">2. 关键组件分析</span></h3><h4><span id="信号处理函数核心机制">信号处理函数（核心机制）</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        --child_cnt;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[Parent] Child %d exited with status %d\n\n&quot;</span>, </span><br><span class="line">                   pid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>技术亮点</strong>：</p><ul><li>使用<code>waitpid(-1, &amp;status, WNOHANG)</code>非阻塞回收任意子进程</li><li><code>WIFEXITED</code>和<code>WEXITSTATUS</code>宏规范处理退出状态</li><li>全局计数器<code>child_cnt</code>实现优雅终止</li></ul><h4><span id="进程创建逻辑">进程创建逻辑</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHILD_NUM; i++) &#123;</span><br><span class="line">    sleep(rand() % <span class="number">3</span>);  <span class="comment">// 随机延迟0-2秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> sleep_time = <span class="number">1</span> + rand() % <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Child] PID=%d started (will exit after %ds)\n\n&quot;</span>, </span><br><span class="line">               getpid(), sleep_time);</span><br><span class="line">        sleep(sleep_time);</span><br><span class="line">        <span class="built_in">exit</span>(rand() % <span class="number">100</span>);  <span class="comment">// 随机退出状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计特点</strong>：</p><ul><li>随机延迟创建（0-2秒）模拟真实场景</li><li>子进程随机生存时间（1-5秒）</li><li>随机退出状态（0-99）测试状态捕获</li></ul><h3><span id="3-执行流程优化点">3. 执行流程优化点</span></h3><ol><li><p><strong>信号处理配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;</span><br></pre></td></tr></table></figure><ul><li><code>SA_RESTART</code>：自动重启被中断的系统调用</li><li><code>SA_NOCLDSTOP</code>：忽略子进程停止产生的信号</li></ul></li><li><p><strong>父进程工作循环</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(child_cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Parent] I am working...\n\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过全局计数器实现无忙等待的优雅退出</p></li></ol><h3><span id="4-可能的改进建议">4. 可能的改进建议</span></h3><ol><li><p><strong>错误处理增强</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">        delay = <span class="number">1</span>;</span><br><span class="line">        sleep(delay);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>日志记录优化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(fmt, ...) \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;[%s] PID=%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">           __func__, getpid(), ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>信号安全处理</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用原子操作修改全局变量</span></span><br><span class="line">    __sync_fetch_and_sub(&amp;child_cnt, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>实验结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign</span><br><span class="line">╰─➤  ./signal_child.o</span><br><span class="line">[Parent] PID=710610 will create 20 children in 20 seconds</span><br><span class="line"></span><br><span class="line">[Child] PID=710611 started (will exit after 2s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710623 started (will exit after 1s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710611 exited with status 45</span><br><span class="line"></span><br><span class="line">[Child] PID=710624 started (will exit after 1s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710623 exited with status 20</span><br><span class="line"></span><br><span class="line">[Parent] Child 710624 exited with status 84</span><br><span class="line"></span><br><span class="line">[Child] PID=710634 started (will exit after 5s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710635 started (will exit after 4s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710644 started (will exit after 2s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710645 started (will exit after 4s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710646 started (will exit after 1s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710648 started (will exit after 5s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710646 exited with status 39</span><br><span class="line"></span><br><span class="line">[Child] PID=710649 started (will exit after 1s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710635 exited with status 21</span><br><span class="line"></span><br><span class="line">[Parent] Child 710644 exited with status 3</span><br><span class="line"></span><br><span class="line">[Child] PID=710653 started (will exit after 2s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710649 exited with status 41</span><br><span class="line"></span><br><span class="line">[Child] PID=710654 started (will exit after 2s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710634 exited with status 93</span><br><span class="line"></span><br><span class="line">[Child] PID=710662 started (will exit after 3s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710663 started (will exit after 1s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710664 started (will exit after 1s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710645 exited with status 55</span><br><span class="line"></span><br><span class="line">[Parent] Child 710653 exited with status 21</span><br><span class="line"></span><br><span class="line">[Parent] Child 710663 exited with status 30</span><br><span class="line"></span><br><span class="line">[Parent] Child 710664 exited with status 13</span><br><span class="line"></span><br><span class="line">[Child] PID=710666 started (will exit after 4s)</span><br><span class="line"></span><br><span class="line">[Child] PID=710667 started (will exit after 2s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710654 exited with status 92</span><br><span class="line"></span><br><span class="line">[Child] PID=710668 started (will exit after 2s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710662 exited with status 55</span><br><span class="line"></span><br><span class="line">[Parent] Child 710648 exited with status 75</span><br><span class="line"></span><br><span class="line">[Child] PID=710671 started (will exit after 1s)</span><br><span class="line"></span><br><span class="line">[Parent] I am working...</span><br><span class="line"></span><br><span class="line">[Child] PID=710672 started (will exit after 5s)</span><br><span class="line"></span><br><span class="line">[Parent] Child 710667 exited with status 36</span><br><span class="line"></span><br><span class="line">[Parent] I am working...</span><br><span class="line"></span><br><span class="line">[Parent] Child 710668 exited with status 35</span><br><span class="line"></span><br><span class="line">[Parent] I am working...</span><br><span class="line"></span><br><span class="line">[Parent] Child 710671 exited with status 99</span><br><span class="line"></span><br><span class="line">[Parent] I am working...</span><br><span class="line"></span><br><span class="line">[Parent] Child 710666 exited with status 86</span><br><span class="line"></span><br><span class="line">[Parent] I am working...</span><br><span class="line"></span><br><span class="line">[Parent] I am working...</span><br><span class="line"></span><br><span class="line">[Parent] I am working...</span><br><span class="line"></span><br><span class="line">[Parent] Child 710672 exited with status 57</span><br></pre></td></tr></table></figure><hr><h2><span id="实验二通过sig_ign自动清理僵尸进程保持原方案">实验二：通过SIG_IGN自动清理僵尸进程（保持原方案）</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置SIGCHLD的处理动作为SIG_IGN</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.sa_handler = SIG_IGN;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process %d started\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">2</span>);  <span class="comment">// 模拟子进程工作</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process %d exiting\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);    <span class="comment">// 子进程以状态2退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父进程继续自己的工作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent process %d continues working\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent working...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查子进程状态</span></span><br><span class="line">        <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, WNOHANG) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process %d has been automatically reaped\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="关键验证点">关键验证点</span></h3><ol><li>使用<code>waitpid(pid, NULL, WNOHANG)</code>会立即返回-1（errno&#x3D;ECHILD）</li><li><code>ps aux | grep defunct</code> 确认无僵尸进程存在</li></ol><p>实验结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign</span><br><span class="line">╰─➤  ./signal_child.o</span><br><span class="line">Parent process 711693 continues working</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 started</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 exiting</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 has been automatically reaped</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 has been automatically reaped</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 has been automatically reaped</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 has been automatically reaped</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 has been automatically reaped</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 has been automatically reaped</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 has been automatically reaped</span><br><span class="line">Parent working...</span><br><span class="line">Child process 711694 has been automatically reaped</span><br></pre></td></tr></table></figure><hr><h2><span id="实验对比分析">实验对比分析</span></h2><table><thead><tr><th>特性</th><th>自定义信号处理函数</th><th>SIG_IGN方式</th></tr></thead><tbody><tr><td><strong>子进程控制</strong></td><td>可精确控制每个子进程的生命周期</td><td>完全由系统自动管理</td></tr><tr><td><strong>状态获取</strong></td><td>能获取每个子进程的退出状态</td><td>无法获取任何状态信息</td></tr><tr><td><strong>系统负载</strong></td><td>父进程需要处理信号</td><td>零开销</td></tr><tr><td><strong>适用场景</strong></td><td>需要监控子进程状态的场景</td><td>只关心任务是否完成的场景</td></tr><tr><td><strong>可移植性</strong></td><td>所有UNIX&#x2F;Linux系统通用</td><td>仅Linux可靠支持</td></tr></tbody></table><hr><h2><span id="实验结论">实验结论</span></h2><ol><li><strong>生产环境推荐</strong>使用自定义信号处理函数（方案一），兼具可移植性和可控性</li><li><strong>临时任务</strong>可考虑<code>SIG_IGN</code>方案（方案二），但需注意：<ul><li>无法获取子进程退出状态</li><li>可能干扰其他依赖SIGCHLD的库（如Apache）</li></ul></li><li>两种方案都能有效避免僵尸进程，但设计哲学不同：<ul><li>方案一体现”显式管理”思想</li><li>方案二体现”自动回收”思想</li></ul></li></ol><hr><h2><span id="延伸思考">延伸思考</span></h2><ol><li>如果子进程数量极大（如1000+），信号处理函数可能成为性能瓶颈</li><li>在多线程环境中，信号处理需要额外注意线程安全问题</li><li>某些场景下可结合<code>epoll</code>+<code>signalfd</code>实现更优雅的子进程监控</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 信号捕捉</title>
      <link href="/2025/07/23/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7/signal_capture/"/>
      <url>/2025/07/23/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7/signal_capture/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E6%B5%81%E7%A8%8B">信号捕捉流程</a></li><li><a href="#sigaction-%E5%87%BD%E6%95%B0"><code>sigaction</code> 函数</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><strong>函数原型</strong></a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><strong>参数说明</strong></a></li><li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><strong>返回值</strong></a></li><li><a href="#struct-sigaction-%E7%BB%93%E6%9E%84%E4%BD%93"><strong><code>struct sigaction</code> 结构体</strong></a></li><li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E"><strong>关键字段说明</strong></a></li></ul></li><li><a href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82">信号捕捉底层细节</a><ul><li><a href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E5%89%8D%E6%B8%85%E9%9B%B6-pending"><strong>3. 为什么要在调用处理函数前清零 pending？</strong></a></li></ul></li></ul><!-- tocstop --><h2><span id="信号捕捉流程">信号捕捉流程</span></h2><p>信号的捕捉流程图如下：</p><p><img src="/img/Linux/signal/signal_capture.png" alt="signal_capture"></p><p>信号捕捉是指当进程收到信号时，内核将控制流转交给用户自定义的信号处理函数，并在处理完成后恢复原始执行流程的过程。整个过程涉及<strong>多次用户态↔内核态切换</strong>，并确保信号不会丢失。以下是详细流程：  </p><hr><p><strong>1. 主程序在用户态执行（如 <code>main</code> 函数）</strong>  </p><ul><li>进程正常执行用户代码（如 <code>main</code> 函数的指令）。  </li><li><strong>可能被中断</strong>：由于<strong>硬件中断（如时钟中断）、异常（如缺页异常）或系统调用</strong>，CPU 从用户态切换到内核态。</li></ul><hr><p><strong>2. 进入内核态处理中断&#x2F;异常</strong>  </p><ul><li>内核完成中断或异常的处理（如系统调用执行完毕）。  </li><li><strong>在返回用户态前，检查待处理信号（<code>do_signal</code>）</strong>：  <ul><li>如果没有待处理信号，直接返回用户态，恢复 <code>main</code> 的执行。  </li><li><strong>如果发现待处理信号（如 <code>SIGQUIT</code>），且该信号的处理方式是用户自定义函数</strong>，进入信号递送流程。</li></ul></li></ul><hr><p><strong>3. 内核准备执行信号处理函数</strong>  </p><ul><li><strong>修改用户态返回地址</strong>：  <ul><li>内核不会直接返回到 <code>main</code>，而是修改栈和寄存器，使得 CPU 返回用户态时<strong>跳转到信号处理函数（如 <code>sighandler</code>）</strong>。  </li><li>信号处理函数运行在<strong>独立的栈帧</strong>（避免破坏 <code>main</code> 的栈）。</li></ul></li><li><strong>记录原始上下文</strong>：  <ul><li>内核保存 <code>main</code> 的完整执行现场（寄存器、栈指针等），以便后续恢复。</li></ul></li></ul><hr><p><strong>4. 信号处理函数在用户态执行</strong>  </p><ul><li>信号处理函数（如 <code>sighandler</code>）开始执行，完成用户定义的逻辑（如打印日志、清理资源等）。  </li><li><strong>信号处理函数执行完毕后，不会直接返回 <code>main</code>，而是自动调用 <code>sigreturn</code> 系统调用，再次进入内核态</strong>。</li></ul><hr><p><strong>5. <code>sigreturn</code>：内核恢复主程序上下文</strong>  </p><ul><li><strong><code>sigreturn</code> 的作用</strong>：  <ul><li>告诉内核“信号处理已完成”，并<strong>恢复之前保存的 <code>main</code> 的上下文</strong>。  </li><li><strong>但在此之前，内核会再次检查是否有新的待处理信号</strong>（防止信号丢失）。  <ul><li><strong>如果没有新信号</strong>：直接恢复 <code>main</code> 的执行现场，返回用户态继续执行。  </li><li><strong>如果有新信号</strong>：重复信号递送流程（可能再次进入另一个信号处理函数）。</li></ul></li></ul></li></ul><hr><p><strong>6. 最终返回主程序继续执行</strong>  </p><ul><li>如果没有更多信号需要处理，内核恢复 <code>main</code> 的寄存器、栈指针等，并返回到用户态。  </li><li><strong>主程序从被中断的位置继续执行</strong>，就像信号从未发生过一样（除非信号处理函数修改了全局状态）。</li></ul><hr><blockquote><p><strong>总结</strong>  </p><ol><li><strong>信号是异步的</strong>，内核在每次<strong>返回用户态前</strong>（无论是从中断、异常还是 <code>sigreturn</code>）都会检查信号。  </li><li><strong>信号处理函数和主程序是独立的控制流</strong>，它们使用不同的栈，没有直接的调用关系。</li><li><strong><code>sigreturn</code> 是信号处理的关键</strong>：</li></ol><ul><li>它不仅是恢复现场，还会<strong>再次检查信号</strong>，确保不会遗漏新到达的信号。</li></ul><ol start="4"><li><strong>递归信号处理</strong>：</li></ol><ul><li>如果信号处理函数执行期间又收到同一信号，可能会导致递归调用（除非使用 <code>sigaction</code> 阻塞该信号）。</li></ul></blockquote><h2><span id="sigaction-函数"><code>sigaction</code> 函数</span></h2><p><code>sigaction</code> 是比 <code>signal</code> 更强大、更灵活的信号处理函数，它允许<strong>精确控制信号的处理行为</strong>，包括：</p><ul><li>设置信号处理函数（<code>sa_handler</code> 或 <code>sa_sigaction</code>）</li><li>指定在执行信号处理函数时<strong>自动阻塞哪些信号</strong>（<code>sa_mask</code>）</li><li>配置额外的信号处理选项（<code>sa_flags</code>）</li></ul><hr><h3><span id="函数原型"><strong>函数原型</strong></span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><h3><span id="参数说明"><strong>参数说明</strong></span></h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>signum</code></strong></td><td>要操作的信号编号（如 <code>SIGINT</code>、<code>SIGTERM</code>）</td></tr><tr><td><strong><code>act</code></strong></td><td>指向 <code>struct sigaction</code>，用于<strong>设置新的信号处理方式</strong>（若为 <code>NULL</code>，则仅读取旧设置）</td></tr><tr><td><strong><code>oldact</code></strong></td><td>用于<strong>保存旧的信号处理方式</strong>（若为 <code>NULL</code>，则不保存）</td></tr></tbody></table><h3><span id="返回值"><strong>返回值</strong></span></h3><ul><li><strong>成功</strong>：返回 <code>0</code></li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code></li></ul><hr><h3><span id="struct-sigaction-结构体"><strong><code>struct sigaction</code> 结构体</strong></span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);                  <span class="comment">// 普通信号处理函数</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);  <span class="comment">// 实时信号处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;                         <span class="comment">// 额外阻塞的信号集</span></span><br><span class="line">    <span class="type">int</span> sa_flags;                             <span class="comment">// 控制信号行为的标志位</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);                <span class="comment">// 已废弃，通常置 NULL</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="关键字段说明"><strong>关键字段说明</strong></span></h3><ol><li><p><strong><code>sa_handler</code></strong>  </p><ul><li>指定信号处理函数，可以是：<ul><li><code>SIG_IGN</code>（忽略信号）</li><li><code>SIG_DFL</code>（恢复默认行为）</li><li><strong>自定义函数</strong>（格式：<code>void handler(int signo)</code>）</li></ul></li><li>例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler = handler;  <span class="comment">// 设置自定义处理函数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>sa_sigaction</code></strong>  </p><ul><li>用于<strong>实时信号</strong>（如 <code>SIGRTMIN</code> 以后的信号），提供更多信息（<code>siginfo_t</code>）。</li><li>需配合 <code>sa_flags = SA_SIGINFO</code> 使用。</li></ul></li><li><p><strong><code>sa_mask</code></strong>  </p><ul><li><p>在执行信号处理函数时，<strong>自动阻塞的信号集</strong>（防止信号嵌套）。</p></li><li><p><strong>默认阻塞当前信号</strong>（无需手动添加）。</p></li><li><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigemptyset(&amp;act.sa_mask);  <span class="comment">// 清空信号集</span></span><br><span class="line">sigaddset(&amp;act.sa_mask, SIGQUIT);  <span class="comment">// 阻塞 SIGQUIT</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>sa_flags</code></strong>  </p><ul><li><p>控制信号行为的标志位，常见选项：</p><ul><li><code>SA_RESTART</code>：被信号中断的系统调用自动重启。</li><li><code>SA_NOCLDSTOP</code>：仅对 <code>SIGCHLD</code> 有效，子进程停止时不通知父进程。</li><li><code>SA_SIGINFO</code>：使用 <code>sa_sigaction</code> 而非 <code>sa_handler</code>。</li></ul></li><li><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">act.sa_flags = SA_RESTART;  <span class="comment">// 系统调用被中断后自动恢复</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><blockquote><p><strong>与 <code>signal</code> 函数的对比</strong></p><table><thead><tr><th>特性</th><th><code>signal</code></th><th><code>sigaction</code></th></tr></thead><tbody><tr><td><strong>可移植性</strong></td><td>不同系统行为可能不同</td><td>行为一致</td></tr><tr><td><strong>信号屏蔽</strong></td><td>无法指定额外阻塞的信号</td><td>支持 <code>sa_mask</code></td></tr><tr><td><strong>实时信号</strong></td><td>不支持</td><td>支持（<code>sa_sigaction</code>）</td></tr><tr><td><strong>系统调用重启</strong></td><td>依赖实现</td><td>可通过 <code>SA_RESTART</code> 控制</td></tr></tbody></table></blockquote><h2><span id="信号捕捉底层细节">信号捕捉底层细节</span></h2><p>在信号捕捉的底层实现中，内核会在<strong>调用信号处理函数之前</strong>（而非之后）将 <code>pending</code> 表中对应信号的位置清零（即 <code>pending &amp;= ~(1 &lt;&lt; signo)</code>）。这一设计是为了正确处理信号的<strong>重复触发</strong>，同时结合**信号屏蔽字（blocking mask）**的自动管理机制。以下是详细解释：</p><hr><p><strong>步骤 1：信号到达，pending 位置 1</strong>  </p><ul><li>当信号（如 <code>SIGINT</code>）到达时，内核会：<ol><li>检查该信号是否被阻塞（通过 <code>blocking mask</code>）：<ul><li>如果未被阻塞，准备递送。</li><li>如果被阻塞，仅将 <code>pending</code> 对应位置 <code>1</code>，暂不处理。</li></ul></li><li>若信号未被阻塞，内核将其加入待处理队列。</li></ol></li></ul><p><strong>步骤 2：准备调用信号处理函数</strong>  </p><ul><li>在<strong>从内核态返回用户态执行信号处理函数前</strong>，内核会：<ol><li><strong>清零 <code>pending</code> 表中的对应位</strong>（表示该信号正在被处理）。</li><li><strong>自动阻塞该信号</strong>（将 <code>blocking mask</code> 中对应位置 <code>1</code>），防止嵌套调用。</li></ol></li></ul><p><strong>步骤 3：执行信号处理函数</strong>  </p><ul><li>信号处理函数（如 <code>handler</code>）在用户态执行：<ul><li>如果在此期间<strong>同一信号再次到达</strong>：<ul><li>由于该信号已被阻塞（<code>blocking mask</code> 置 <code>1</code>），内核不会立即递送。</li><li>但会将 <code>pending</code> 表中对应位<strong>重新置 <code>1</code></strong>（记录信号到达）。</li></ul></li></ul></li></ul><p><strong>步骤 4：信号处理函数返回</strong>  </p><ul><li>函数返回时，内核通过 <code>sigreturn</code> 系统调用恢复现场：<ol><li><strong>恢复原来的 <code>blocking mask</code></strong>（取消对该信号的阻塞）。</li><li><strong>再次检查 <code>pending</code> 表</strong>：<ul><li>如果发现该信号位为 <code>1</code>（表示在处理期间信号又到达了），则<strong>重新递送</strong>。</li><li>否则，正常恢复主程序执行。</li></ul></li></ol></li></ul><hr><h3><span id="3-为什么要在调用处理函数前清零-pending"><strong>3. 为什么要在调用处理函数前清零 pending？</strong></span></h3><h4><span id="原因-1避免信号丢失"><strong>原因 1：避免信号丢失</strong></span></h4><ul><li>如果在处理函数<strong>执行后</strong>才清零 <code>pending</code>，可能会出现：<ul><li>信号 A 正在处理时，同一信号 A 再次到达。</li><li>如果第一次的 <code>pending</code> 未被清零，第二次到达的信号可能被忽略（内核认为“已在处理”）。</li></ul></li><li><strong>提前清零</strong>确保后续到达的信号能正确记录在 <code>pending</code> 中。</li></ul><h4><span id="原因-2与阻塞机制配合"><strong>原因 2：与阻塞机制配合</strong></span></h4><ul><li>内核通过<strong>自动阻塞当前信号</strong> + <strong>提前清零 <code>pending</code></strong>，实现以下行为：<ul><li>信号处理期间，同一信号不会被嵌套调用（避免递归）。</li><li>但后续到达的信号会被记录，并在处理完成后重新递送。</li></ul></li></ul><h4><span id="示例场景"><strong>示例场景</strong></span></h4><p>假设进程收到两次 <code>SIGINT</code>：</p><ol><li>第一次 <code>SIGINT</code>：<ul><li><code>pending</code> 置 <code>1</code> → 内核调用处理函数前清零 <code>pending</code> 并阻塞 <code>SIGINT</code>。</li></ul></li><li>处理函数执行期间，第二次 <code>SIGINT</code> 到达：<ul><li>由于 <code>SIGINT</code> 被阻塞，内核仅将 <code>pending</code> 置 <code>1</code>，不立即处理。</li></ul></li><li>处理函数返回后：<ul><li>内核发现 <code>pending</code> 为 <code>1</code>，重新递送 <code>SIGINT</code>，再次触发处理函数。</li></ul></li></ol><p>下面是验证示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印当前进程的未决信号集(pending signals)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_pending_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> sigset;</span><br><span class="line">    <span class="built_in">sigpending</span>(&amp;sigset);  <span class="comment">// 获取当前未决信号集</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从31到1遍历所有可能的信号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sigismember</span>(&amp;sigset, i)) </span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 该信号处于未决状态</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">// 该信号未产生</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打印收到的信号信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;signal &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(sign) &lt;&lt; <span class="string">&quot; begin&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无限循环打印信号状态</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print_pending_map</span>();  <span class="comment">// 打印当前未决信号集</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Processing signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(sign) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 每秒打印一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置SIGINT的信号处理</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act, oact;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);  <span class="comment">// 初始化信号屏蔽字</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;oact.sa_mask);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键设置：在执行SIGINT处理函数时阻塞SIGQUIT</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;act.sa_mask, SIGQUIT);  <span class="comment">// 将SIGQUIT加入阻塞集</span></span><br><span class="line">    </span><br><span class="line">    act.sa_handler = myhandler;  <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT, &amp;act, &amp;oact);  <span class="comment">// 注册SIGINT的处理方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为SIGQUIT设置相同的处理函数(用于演示)</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGQUIT, myhandler);  <span class="comment">// 注意：这里使用signal而不是sigaction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)  <span class="comment">// 子进程代码</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程无限循环打印自己的PID</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Child process &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; running...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程代码</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 等待2秒让子进程启动</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次向子进程发送SIGINT</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Parent sending SIGINT to child process&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">kill</span>(ret, SIGINT);  <span class="comment">// 发送SIGINT信号</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 等待2秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二次向子进程发送SIGINT</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Parent sending SIGINT to child process again&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">kill</span>(ret, SIGINT);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 等待2秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向子进程发送SIGQUIT</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Parent sending SIGQUIT to child process&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">kill</span>(ret, SIGQUIT);  <span class="comment">// 发送SIGQUIT信号</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 等待2秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向子进程发送SIGKILL(无法被捕获或忽略)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Parent sending SIGKILL to child process&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">kill</span>(ret, SIGKILL);  <span class="comment">// 发送SIGKILL信号强制终止子进程</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">wait</span>(<span class="literal">nullptr</span>);  <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="代码设计目标">代码设计目标</span></h5><p>本实验通过父子进程模型，演示以下Linux信号处理核心机制：</p><ul><li>信号处理函数的注册方式差异（<code>signal</code> vs <code>sigaction</code>）</li><li>信号阻塞掩码（sa_mask）的实际效果</li><li>未决信号集（pending signals）的动态变化</li><li>不可阻塞信号（SIGKILL）的特殊性</li></ul><h5><span id="核心组件说明">核心组件说明</span></h5><p>信号监控函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_pending_map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> sigset;</span><br><span class="line">    <span class="built_in">sigpending</span>(&amp;sigset);  <span class="comment">// 获取当前未决信号集</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        cout &lt;&lt; (<span class="built_in">sigismember</span>(&amp;sigset, i) ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能</strong>：实时打印信号未决状态，每个bit代表对应信号是否处于未决状态。</p><p>信号处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> sign)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Handler executing for: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(sign) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  <span class="comment">// 用于保持处理状态便于观察</span></span><br><span class="line">        <span class="built_in">print_pending_map</span>();</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计意图</strong>：通过无限循环模拟长时间信号处理，便于观察信号阻塞效果。</p><h5><span id="关键配置">关键配置</span></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置SIGINT处理</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;act.sa_mask, SIGQUIT);  <span class="comment">// 关键设置！</span></span><br><span class="line">act.sa_handler = myhandler;</span><br><span class="line"><span class="built_in">sigaction</span>(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置SIGQUIT处理（对比组）</span></span><br><span class="line"><span class="built_in">signal</span>(SIGQUIT, myhandler);</span><br></pre></td></tr></table></figure><p><strong>核心设置</strong>：当处理SIGINT时，自动阻塞SIGQUIT信号。</p><h5><span id="实验流程">实验流程</span></h5><pre class="mermaid">sequenceDiagram    participant Parent    participant Child    Parent->>Child: fork()    loop 子进程运行        Child->>Child: 打印运行状态    end    Parent->>Child: kill(SIGINT)    Child->>Child: 执行myhandler    Parent->>Child: kill(SIGINT)     Parent->>Child: kill(SIGQUIT)    Note right of Child: SIGQUIT被阻塞<br>保持pending状态    Parent->>Child: kill(SIGKILL)</pre><p>结果输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign</span><br><span class="line">╰─➤  ./signal_cap.o</span><br><span class="line">Child process 703969 running...</span><br><span class="line">Parent sending SIGINT to child process</span><br><span class="line">signal Interrupt begin</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">Processing signal: Interrupt</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">Processing signal: Interrupt</span><br><span class="line">Parent sending SIGINT to child process again</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span><br><span class="line"></span><br><span class="line">Processing signal: Interrupt</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span><br><span class="line"></span><br><span class="line">Processing signal: Interrupt</span><br><span class="line">Parent sending SIGQUIT to child process</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0</span><br><span class="line"></span><br><span class="line">Processing signal: Interrupt</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0</span><br><span class="line"></span><br><span class="line">Processing signal: Interrupt</span><br><span class="line">Parent sending SIGKILL to child process</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 信号管理</title>
      <link href="/2025/07/22/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7/signal_manage/"/>
      <url>/2025/07/22/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7/signal_manage/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81">信号的状态</a><ul><li><a href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81">信号的三种状态</a></li><li><a href="#2-%E9%98%BB%E5%A1%9E-vs-%E5%BF%BD%E7%95%A5">2. 阻塞 vs 忽略</a></li><li><a href="#3-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0">3. 内核中的实现</a></li></ul></li><li><a href="#%E4%BF%A1%E5%8F%B7%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BF%A1%E5%8F%B7%E9%9B%86-sigset_t">信号管理核心数据结构：信号集 sigset_t</a><ul><li><a href="#%E4%BF%A1%E5%8F%B7%E6%A0%87%E5%BF%97%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">信号标志的存储方式</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9A%84%E8%AF%AD%E4%B9%89">信号集的语义</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%89%B9%E7%82%B9">信号集特点</a></li><li><a href="#%E5%9B%BE%E7%A4%BA%E8%A1%A8%E7%A4%BA">图示表示</a></li></ul></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">信号集操作函数</a><ul><li><a href="#1-sigemptyset">1. sigemptyset</a></li><li><a href="#2-sigfillset">2. sigfillset</a></li><li><a href="#3-sigaddset">3. sigaddset</a></li><li><a href="#4-sigdelset">4. sigdelset</a></li><li><a href="#5-sigismember">5. sigismember</a></li></ul></li><li><a href="#%E4%BF%A1%E5%8F%B7%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3">信号状态相关函数详解</a><ul><li><a href="#1-sigpending-%E8%8E%B7%E5%8F%96%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86">1. sigpending - 获取未决信号集</a></li><li><a href="#2-sigprocmask-%E8%AE%BE%E7%BD%AE%E8%8E%B7%E5%8F%96%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86">2. sigprocmask - 设置&#x2F;获取阻塞信号集</a></li><li><a href="#3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">3. 注意事项</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2">使用示例</a></li></ul></li></ul><!-- tocstop --><h2><span id="信号的状态">信号的状态</span></h2><h3><span id="信号的三种状态">信号的三种状态</span></h3><table><thead><tr><th>状态</th><th>说明</th><th>类比手机消息</th></tr></thead><tbody><tr><td><strong>递达</strong></td><td>信号已到达进程并完成处理（执行默认动作、自定义处理函数或忽略）。</td><td>消息被打开并阅读（已读）。</td></tr><tr><td><strong>未决</strong></td><td>信号已产生但尚未递达（可能因阻塞而暂时无法处理）。</td><td>消息收到但未读（通知栏显示未读红点）。</td></tr><tr><td><strong>阻塞</strong></td><td>进程主动屏蔽某个信号，即使信号产生也不会递达，直到解除阻塞。</td><td>消息被设为“免打扰”（不提醒但未读）。</td></tr></tbody></table><hr><h3><span id="2-阻塞-vs-忽略">2. 阻塞 vs 忽略</span></h3><table><thead><tr><th>行为</th><th>说明</th><th>结果</th></tr></thead><tbody><tr><td><strong>阻塞</strong></td><td>信号被加入未决集合，但暂时不递达（即使收到多次也只记录一次）。</td><td>信号状态保持为未决，直到解除阻塞。</td></tr><tr><td><strong>忽略</strong></td><td>信号已递达，但处理动作为显式忽略（通过 <code>SIG_IGN</code> 或捕获函数中不处理）。</td><td>信号直接丢弃，不会未决。</td></tr></tbody></table><p><strong>关键区别</strong>：</p><ul><li><strong>阻塞</strong>影响的是信号从产生到递达的过程（未决阶段）。  </li><li><strong>忽略</strong>是信号递达后的处理方式之一。</li></ul><hr><h3><span id="3-内核中的实现">3. 内核中的实现</span></h3><p>信号的阻塞和未决状态通过位图（ <code>sigset_t</code>）管理：</p><ul><li><strong>未决集合（Pending）</strong>：记录哪些信号已产生但未递达。  </li><li><strong>阻塞掩码（Block）</strong>：记录哪些信号被阻塞（屏蔽）。</li></ul><p>信号在内核中的表示示意图</p><p><img src="/img/Linux/signal/signal.png" alt="signal"></p><p>每个信号在内核中由以下三部分表示：</p><ul><li><strong>阻塞标志 (block)</strong>：布尔值，表示信号是否被屏蔽</li><li><strong>未决标志 (pending)</strong>：布尔值，表示信号是否已产生但未递达</li><li><strong>处理函数指针</strong>：指向信号处理函数（可以是默认动作&#x2F;SIG_IGN&#x2F;用户自定义函数）</li></ul><blockquote><p>信号产生时，内核在进程PCB中设置该信号的<strong>未决标志</strong><br>信号递达时（执行处理动作后），内核才会清除未决标志</p></blockquote><p>示例如下：</p><table><thead><tr><th>信号</th><th>阻塞状态</th><th>未决状态</th><th>处理动作</th><th>说明</th></tr></thead><tbody><tr><td>SIGHUP</td><td>未阻塞</td><td>未产生</td><td>默认处理动作</td><td>正常递达</td></tr><tr><td>SIGINT</td><td>阻塞</td><td>已产生</td><td>忽略(SIG_IGN)</td><td><strong>即使动作为忽略</strong>，仍需先解除阻塞才会处理</td></tr><tr><td>SIGQUIT</td><td>将阻塞</td><td>未产生</td><td>用户自定义函数(sighandler)</td><td>一旦产生会被阻塞，直到解除阻塞后执行sighandler</td></tr></tbody></table><p>多次信号产生处理规则:</p><p>当信号在解除阻塞前多次产生时：</p><ul><li><p><strong>常规信号</strong>（1-31）：</p><ul><li>只记录一次（后到的信号会被丢弃）</li><li>示例：连续发送3次SIGINT，解除阻塞后只处理1次</li></ul></li><li><p><strong>实时信号</strong>（34-64）：</p><ul><li>会排队保存多次信号</li><li>示例：发送3次SIGRTMIN，解除阻塞后会处理3次</li></ul></li></ul><blockquote><p>POSIX.1标准允许系统自行选择实现方式，Linux采用上述策略</p></blockquote><p><strong>流程</strong>：</p><ol><li>信号产生 → 检查是否被阻塞：  <ul><li>若阻塞：加入未决集合，保持未决状态。  </li><li>未阻塞：立即递达（执行处理动作）。</li></ul></li><li>解除阻塞后 → 检查未决集合中是否有该信号，若有则递达。</li></ol><h2><span id="信号管理核心数据结构信号集-sigset_t">信号管理核心数据结构：信号集 sigset_t</span></h2><h3><span id="信号标志的存储方式">信号标志的存储方式</span></h3><ul><li>每个信号使用 <strong>1个bit</strong> 表示状态<ul><li><strong>未决标志 (pending)</strong>：<code>0</code>&#x3D;未产生，<code>1</code>&#x3D;已产生（不记录次数）</li><li><strong>阻塞标志 (block)</strong>：<code>0</code>&#x3D;未阻塞，<code>1</code>&#x3D;已阻塞</li></ul></li><li>两种标志均使用 <strong>相同数据类型 <code>sigset_t</code></strong> 存储</li></ul><h3><span id="信号集的语义">信号集的语义</span></h3><table><thead><tr><th>信号集类型</th><th>“有效” (1) 的含义</th><th>“无效” (0) 的含义</th></tr></thead><tbody><tr><td><strong>未决信号集</strong></td><td>信号处于未决状态</td><td>信号未产生或已递达</td></tr><tr><td><strong>阻塞信号集</strong></td><td>信号被阻塞</td><td>信号未被阻塞</td></tr></tbody></table><blockquote><p><strong>关键说明</strong>：  </p><ul><li>阻塞信号集又称 <strong>信号屏蔽字 (Signal Mask)</strong>  </li><li>“屏蔽”在此语境中特指 <strong>阻塞</strong>（拦截信号递达），与忽略（递达后的处理方式）有本质区别</li></ul></blockquote><h3><span id="信号集特点">信号集特点</span></h3><ol><li><p><strong>二进制记录</strong>  </p><ul><li>不统计信号产生次数（常规信号多次触发仅记1次）</li><li>实时信号需通过其他机制实现队列化</li></ul></li><li><p><strong>高效存储</strong>  </p><ul><li>使用位图结构（一般为 <code>unsigned long[]</code>）紧凑存储所有信号状态</li></ul></li><li><p><strong>内核操作</strong>  </p><ul><li>通过 <code>sigprocmask()</code> 修改阻塞信号集  </li><li>通过 <code>sigpending()</code> 读取未决信号集</li></ul></li></ol><h3><span id="图示表示">图示表示</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sigset_t 结构示例（假设系统有8种信号）：</span><br><span class="line">位序号: [7][6][5][4][3][2][1][0]</span><br><span class="line">未决集: 0  1  0  0  1  0  0  1  → 信号1/4/7未决</span><br><span class="line">阻塞集: 1  0  1  0  0  0  0  0  → 信号0/2被阻塞</span><br></pre></td></tr></table></figure><h2><span id="信号集操作函数">信号集操作函数</span></h2><h3><span id="1-sigemptyset">1. sigemptyset</span></h3><p>该函数用于清空信号集，即将所有信号标志设置为无效（0）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><h3><span id="2-sigfillset">2. sigfillset</span></h3><p>该函数用于填充信号集，即将所有信号标志设置为有效（1）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><h3><span id="3-sigaddset">3. sigaddset</span></h3><p>该函数用于在信号集 <code>set</code> 中添加指定信号 <code>signo</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;</span><br></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGINT);  <span class="comment">// 添加 SIGINT 信号</span></span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGTERM); <span class="comment">// 添加 SIGTERM 信号</span></span><br></pre></td></tr></table></figure><h3><span id="4-sigdelset">4. sigdelset</span></h3><p>该函数用于在信号集 <code>set</code> 中删除指定信号 <code>signo</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;</span><br></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">sigfillset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigdelset(&amp;<span class="built_in">set</span>, SIGINT);  <span class="comment">// 删除 SIGINT 信号</span></span><br><span class="line">sigdelset(&amp;<span class="built_in">set</span>, SIGTERM); <span class="comment">// 删除 SIGTERM 信号</span></span><br></pre></td></tr></table></figure><h3><span id="5-sigismember">5. sigismember</span></h3><p>该函数用于检查信号集 <code>set</code> 中是否包含指定信号 <code>signo</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;</span><br></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line"><span class="keyword">if</span> (sigismember(&amp;<span class="built_in">set</span>, SIGINT)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is in the set\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is not in the set\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="信号状态相关函数详解">信号状态相关函数详解</span></h2><h3><span id="1-sigpending-获取未决信号集">1. sigpending - 获取未决信号集</span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><h4><span id="功能说明">功能说明</span></h4><ul><li>获取当前进程的<strong>未决信号集</strong>（Pending Signal Set）</li><li>未决信号指已产生但尚未递达的信号（可能因阻塞而滞留）</li></ul><h4><span id="参数">参数</span></h4><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>sigset_t*</td><td>输出参数，用于存储未决信号集</td></tr></tbody></table><h4><span id="返回值">返回值</span></h4><ul><li>成功：返回 0</li><li>失败：返回 -1 并设置 errno</li></ul><h4><span id="使用示例">使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> pending_set;</span><br><span class="line"><span class="keyword">if</span> (sigpending(&amp;pending_set) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigpending failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="2-sigprocmask-设置x2f获取阻塞信号集">2. sigprocmask - 设置&#x2F;获取阻塞信号集</span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><h4><span id="功能说明">功能说明</span></h4><ul><li>修改或获取当前进程的<strong>信号屏蔽字</strong>（Blocked Signal Set）</li><li>信号屏蔽字决定哪些信号会被阻塞（阻止递达）</li></ul><h4><span id="参数详解">参数详解</span></h4><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>how</td><td>int</td><td>指定操作方式（见下表）</td></tr><tr><td>set</td><td>const sigset_t*</td><td>新信号集（NULL表示不修改）</td></tr><tr><td>oldset</td><td>sigset_t*</td><td>输出旧信号集（NULL表示不需要获取）</td></tr></tbody></table><h5><span id="how-取值说明">how 取值说明</span></h5><table><thead><tr><th>宏定义</th><th>值</th><th>行为</th></tr></thead><tbody><tr><td>SIG_BLOCK</td><td>0</td><td>将 <code>set</code> 中的信号<strong>加入</strong>当前屏蔽字（阻塞新增信号）</td></tr><tr><td>SIG_UNBLOCK</td><td>1</td><td>从当前屏蔽字中<strong>移除</strong> <code>set</code> 中的信号（解除阻塞）</td></tr><tr><td>SIG_SETMASK</td><td>2</td><td>直接将当前屏蔽字<strong>替换</strong>为 <code>set</code>（完全覆盖旧值）</td></tr></tbody></table><h4><span id="返回值">返回值</span></h4><ul><li>成功：返回 0</li><li>失败：返回 -1 并设置 errno</li></ul><h4><span id="使用示例">使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> new_set, old_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号集</span></span><br><span class="line">sigemptyset(&amp;new_set);</span><br><span class="line">sigaddset(&amp;new_set, SIGINT);  <span class="comment">// 阻塞SIGINT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加阻塞信号</span></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;new_set, &amp;old_set) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigprocmask failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复旧屏蔽字</span></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;old_set, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigprocmask restore failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="3-注意事项">3. 注意事项</span></h3><ol><li><p><strong>信号屏蔽字继承</strong>  </p><ul><li>子进程会继承父进程的信号屏蔽字</li><li>但未决信号集不会被继承</li></ul></li><li><p><strong>原子操作建议</strong></p></li></ol><blockquote><p>修改信号屏蔽字时应确保操作的原子性，避免竞态条件</p></blockquote>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐先获取旧值再修改</span></span><br><span class="line"><span class="type">sigset_t</span> old_mask;</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;new_mask, &amp;old_mask);</span><br><span class="line"><span class="comment">/* 临界区代码 */</span></span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;old_mask, <span class="literal">NULL</span>);  <span class="comment">// 恢复</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>不可阻塞信号</strong>  </p><ul><li>SIGKILL 和 SIGSTOP <strong>无法被阻塞</strong>（即使尝试设置也会被系统忽略）</li></ul></li><li><p><strong>多线程环境</strong>  </p><ul><li>在多线程中应使用 <code>pthread_sigmask()</code> 而非 <code>sigprocmask()</code></li><li><code>sigprocmask()</code> 的行为在多线程中是未定义的</li></ul></li></ol><h3><span id="使用示例">使用示例</span></h3><p>下面我们利用信号状态相关函数来模拟一下阻塞二号信号以及解除阻塞的条件下给进程通过键盘发送二号信号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 模拟处理耗时</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;  <span class="comment">// 打印信号信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闹钟信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">raise</span>(SIGINT);  <span class="comment">// 给自己发送SIGINT信号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I have sent myself signal SIGINT&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印当前未决信号集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_pending_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> sigset;</span><br><span class="line">    <span class="built_in">sigpending</span>(&amp;sigset);  <span class="comment">// 获取未决信号集</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从31到1遍历所有可能的信号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sigismember</span>(&amp;sigset, i)) </span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 信号未决</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">// 信号未产生</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置SIGINT信号处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, myhandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> sigset, old_sigset;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;sigset);      <span class="comment">// 清空信号集</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;old_sigset);  <span class="comment">// 清空旧信号集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将SIGINT添加到信号集</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;sigset, SIGINT);</span><br><span class="line">    <span class="comment">// 阻塞SIGINT信号，并保存旧的信号屏蔽字</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;sigset, &amp;old_sigset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置1秒后触发SIGALRM信号</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置SIGALRM信号处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, alarm_handler);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;  <span class="comment">// 循环计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="comment">// 第5次循环时解除对SIGINT的阻塞</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;signal SIGINT unblocked&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_UNBLOCK, &amp;sigset, &amp;old_sigset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">10</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// 第10次循环时终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print_pending_map</span>();  <span class="comment">// 打印当前未决信号状态</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);            <span class="comment">// 休眠1秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>信号处理部分：</p><ul><li><code>myhandler</code>处理SIGINT信号，打印接收到的信号信息</li><li><code>alarm_handler</code>处理SIGALRM信号，会主动发送SIGINT信号</li></ul></li><li><p>信号阻塞控制：</p><ul><li>程序开始时阻塞SIGINT信号</li><li>第5次循环时解除阻塞</li><li>第10次循环时终止程序</li></ul></li><li><p>未决信号监控：</p><ul><li><code>print_pending_map</code>函数会打印所有信号的未决状态</li><li>1表示信号未决，0表示信号未产生</li></ul></li><li><p>主要流程：</p><ul><li>程序启动后立即阻塞SIGINT</li><li>1秒后闹钟触发，发送SIGINT（但由于阻塞会进入未决状态）</li><li>第5秒解除阻塞，未决的SIGINT会被递达</li><li>第10秒程序终止</li></ul></li></ol><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign</span><br><span class="line">╰─➤  ./signal.o</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">I have sent myself signal SIGINT</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span><br><span class="line"></span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span><br><span class="line"></span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span><br><span class="line"></span><br><span class="line">signal SIGINT unblocked</span><br><span class="line">I get a signal: Interrupt</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">Bye!</span><br><span class="line">[1]    424187 IOT instruction  ./signal.o</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 信号产生</title>
      <link href="/2025/07/22/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7/signal/"/>
      <url>/2025/07/22/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7/signal/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#linux-%E4%BF%A1%E5%8F%B7signal%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9A%E4%B9%89">Linux 信号（Signal）的简单定义</a></li><li><a href="#linux-%E4%BF%A1%E5%8F%B7%E5%88%86%E7%B1%BB%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7-vs-%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7">Linux 信号分类：普通信号 vs 实时信号</a><ul><li><a href="#1-%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7standard-signals1~31">1. 普通信号（Standard Signals，1~31）</a></li><li><a href="#2-%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7real-time-signals34~64">2. 实时信号（Real-Time Signals，34~64）</a></li><li><a href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93">区别总结</a></li></ul></li><li><a href="#linux-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><strong>Linux 信号处理方式</strong></a><ul><li><a href="#1-%E6%89%A7%E8%A1%8C%E9%BB%98%E8%AE%A4%E5%8A%A8%E4%BD%9Cdefault-action">1. 执行默认动作（Default Action）</a></li><li><a href="#2-%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7ignore-signal">2. 忽略信号（Ignore Signal）</a></li><li><a href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7">3. 自定义处理（捕获信号）</a></li><li><a href="#%E6%80%BB%E7%BB%93"><strong>总结</strong></a></li></ul></li><li><a href="#%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F">信号产生方式</a><ul><li><a href="#%E9%94%AE%E7%9B%98%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7">键盘发送信号</a></li><li><a href="#%E5%91%BD%E4%BB%A4%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7">命令发送信号</a></li><li><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7">函数调用发送信号</a></li><li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li></ul></li></ul><!-- tocstop --><h2><span id="linux-信号signal的简单定义">Linux 信号（Signal）的简单定义</span></h2><p><strong>信号（Signal）是 Linux 系统用于通知进程发生某种事件的机制</strong>，它是一种<strong>异步通信方式</strong>，用于进程间通信（IPC）或由内核向进程发送通知。  </p><ul><li>信号就像是一个<strong>通知</strong>，告诉进程：“有事情发生了，你要处理一下！”  </li><li>例如：  <ul><li>用户按下 <code>Ctrl+C</code>（发送 <code>SIGINT</code> 信号）终止进程。  </li><li>系统强制杀死进程（<code>SIGKILL</code>）。  </li><li>进程出错（如段错误 <code>SIGSEGV</code>）。</li></ul></li></ul><p>信号是 Linux 管理进程的重要机制，用于<strong>控制进程行为</strong>（终止、暂停、恢复等）。</p><h2><span id="linux-信号分类普通信号-vs-实时信号">Linux 信号分类：普通信号 vs 实时信号</span></h2><h3><span id="1-普通信号standard-signals1~31">1. 普通信号（Standard Signals，1~31）</span></h3><ul><li><strong>范围</strong>：<code>1</code> ~ <code>31</code>（如 <code>SIGINT(2)</code>、<code>SIGKILL(9)</code>、<code>SIGTERM(15)</code>）。  </li><li><strong>特点</strong>：  <ul><li><strong>不排队</strong>：如果同一个信号连续发送多次，进程可能只收到一次。  </li><li><strong>无优先级</strong>：多个信号到达时，处理顺序不确定。  </li><li><strong>部分可被阻塞或捕获</strong>（如 <code>SIGINT</code> 可捕获，<code>SIGKILL</code> 不可捕获）。</li></ul></li><li><strong>典型用途</strong>：进程控制（终止、暂停、错误处理等）。</li></ul><h3><span id="2-实时信号real-time-signals34~64">2. 实时信号（Real-Time Signals，34~64）</span></h3><ul><li><strong>范围</strong>：<code>34</code> (<code>SIGRTMIN</code>) ~ <code>64</code> (<code>SIGRTMAX</code>)。  </li><li><strong>特点</strong>：  <ul><li><strong>支持排队</strong>：连续发送多次，进程会按顺序处理所有信号。  </li><li><strong>有优先级</strong>：数值小的信号优先处理（如 <code>34</code> 比 <code>35</code> 优先）。  </li><li><strong>可携带额外数据</strong>（通过 <code>sigqueue()</code> 发送）。</li></ul></li><li><strong>典型用途</strong>：高可靠性通信（如多线程同步、自定义事件通知）。</li></ul><h3><span id="区别总结">区别总结</span></h3><table><thead><tr><th>特性</th><th>普通信号</th><th>实时信号</th></tr></thead><tbody><tr><td><strong>编号范围</strong></td><td>1~31</td><td>34~64</td></tr><tr><td><strong>排队机制</strong></td><td>不排队</td><td>排队（保证不丢失）</td></tr><tr><td><strong>优先级</strong></td><td>无</td><td>数值小的优先</td></tr><tr><td><strong>数据传递</strong></td><td>不支持</td><td>支持（<code>sigqueue</code>）</td></tr><tr><td><strong>典型用途</strong></td><td>进程控制</td><td>实时应用、线程通信</td></tr></tbody></table><ul><li><strong>普通信号</strong>：适用于简单进程控制，但可能丢失。  </li><li><strong>实时信号</strong>：适用于高可靠性场景，支持排队和数据传递。</li></ul><p>因为这里主要讲解的是进程控制，所以后面我们主要介绍的是普通信号。</p><h2><span id="linux-信号处理方式"><strong>Linux 信号处理方式</strong></span></h2><p>在 Linux 中，进程收到信号后，可以采取以下 <strong>3 种处理方式</strong>：  </p><h3><span id="1-执行默认动作default-action">1. 执行默认动作（Default Action）</span></h3><p>每个信号都有系统预定义的默认行为，常见的有：  </p><ul><li><strong>终止进程</strong>（Terminate）：<code>SIGTERM(15)</code>、<code>SIGKILL(9)</code>（不可捕获）。  </li><li><strong>终止并生成核心转储</strong>（Core Dump）：<code>SIGSEGV(11)</code>（段错误）。  </li><li><strong>暂停进程</strong>（Stop）：<code>SIGSTOP(19)</code>（不可捕获）。  </li><li><strong>忽略</strong>（Ignore）：<code>SIGCHLD(17)</code>（子进程退出时默认忽略）。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My pid is: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o</span><br><span class="line">My pid is: 274247</span><br><span class="line">My pid is: 274247</span><br><span class="line">^C                  # Ctrl + C 发送 SIGINT 信号，进程终止</span><br></pre></td></tr></table></figure><h3><span id="2-忽略信号ignore-signal">2. 忽略信号（Ignore Signal）</span></h3><p>进程可以主动忽略某些信号（但部分信号如 <code>SIGKILL</code> 和 <code>SIGSTOP</code> <strong>无法被忽略</strong>）。  </p><p>为什么 <code>SIGKILL</code> 和 <code>SIGSTOP</code> 无法被忽略？  </p><p>因为 <code>SIGKILL</code> 和 <code>SIGSTOP</code> 是用于强制终止和暂停进程的信号，如果允许进程忽略它们，就无法保证进程能够被正常终止或暂停，这可能会导致系统不稳定。</p><p>我们可以在 C 程序中使用 <code>signal(SIGXXX, SIG_IGN)</code> 忽略信号。  </p><p><strong>不可忽略的信号</strong>：</p><ul><li><code>SIGKILL(9)</code>：强制终止。  </li><li><code>SIGSTOP(19)</code>：强制暂停。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略 SIGINT 信号</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My pid is: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用 <code>Ctrl + C</code> 无法终止进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o </span><br><span class="line">My pid is: 273355</span><br><span class="line">^CMy pid is: 273355                  # Ctrl + C 无法终止进程</span><br><span class="line">[1]    273355 killed     ./signal.o  # 通过 kill 命令发送 SIGKILL 信号</span><br></pre></td></tr></table></figure><hr><h3><span id="3-自定义处理捕获信号">3. 自定义处理（捕获信号）</span></h3><p>进程可以注册一个<strong>信号处理函数</strong>，在信号到达时执行自定义逻辑。  </p><p>我们可以利用 C 语言<code>signal()</code> 或更安全的 <code>sigaction()</code> 来自定义信号处理函数。  </p><p><strong>不可自定义的信号</strong>：</p><ul><li><code>SIGKILL(9)</code> 和 <code>SIGSTOP(19)</code> <strong>无法被捕获或忽略</strong>，只能执行默认行为。</li></ul><p>在示例讲解之前，我们先学习一个用于自定义信号处理方式的函数：</p><h4><span id="signal-函数"><code>signal()</code> 函数</span></h4><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>signum</code>：要处理的信号编号。  </li><li><code>handler</code>：自定义的信号处理函数，类型为 <code>void (*)(int)</code>。  </li><li>返回值：上一个信号处理函数的指针，用于链式调用。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 执行完自定义逻辑后，退出进程</span></span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, myhandler);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My pid is: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="总结"><strong>总结</strong></span></h3><table><thead><tr><th>处理方式</th><th>适用场景</th><th>限制</th></tr></thead><tbody><tr><td><strong>默认动作</strong></td><td>简单控制（如强制终止、错误处理）</td><td>无</td></tr><tr><td><strong>忽略信号</strong></td><td>避免无关信号干扰（如 <code>SIGCHLD</code>）</td><td><code>SIGKILL</code>&#x2F;<code>SIGSTOP</code> 不可忽略</td></tr><tr><td><strong>自定义处理</strong></td><td>执行清理、日志记录等自定义逻辑</td><td><code>SIGKILL</code>&#x2F;<code>SIGSTOP</code> 不可捕获</td></tr></tbody></table><h2><span id="信号产生方式">信号产生方式</span></h2><h3><span id="键盘发送信号">键盘发送信号</span></h3><p>在 Linux 终端中，<strong>键盘快捷键</strong> 可以主动向当前前台进程发送特定信号，用于 <strong>进程控制</strong>（如终止、暂停、恢复等）。以下是常见的键盘信号及其扩展说明：</p><hr><h4><span id="1-常用键盘信号">1. 常用键盘信号</span></h4><table><thead><tr><th>快捷键</th><th>信号名</th><th>信号编号</th><th>默认行为</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>Ctrl + C</strong></td><td><code>SIGINT</code></td><td>2</td><td><strong>终止进程</strong></td><td>优雅终止当前运行的程序</td></tr><tr><td><strong>Ctrl + \</strong></td><td><code>SIGQUIT</code></td><td>3</td><td><strong>终止 + 核心转储</strong></td><td>强制终止并生成调试文件（core dump）</td></tr><tr><td><strong>Ctrl + Z</strong></td><td><code>SIGTSTP</code></td><td>20</td><td><strong>暂停进程（放入后台）</strong></td><td>暂停当前任务，可用 <code>fg</code>&#x2F;<code>bg</code> 恢复</td></tr><tr><td><strong>Ctrl + D</strong></td><td><code>EOF</code></td><td>-</td><td><strong>输入结束（非信号）</strong></td><td>结束终端输入或退出 Shell</td></tr><tr><td><strong>Ctrl + S</strong></td><td>-</td><td>-</td><td><strong>暂停屏幕输出</strong></td><td>冻结终端显示（与信号无关）</td></tr><tr><td><strong>Ctrl + Q</strong></td><td>-</td><td>-</td><td><strong>恢复屏幕输出</strong></td><td>解冻终端显示（与信号无关）</td></tr></tbody></table><blockquote><p><strong>注意</strong>：  </p><ul><li><code>Ctrl + D</code> <strong>不是信号</strong>，而是发送 <strong>EOF（End-of-File）</strong>，通常用于结束输入或退出 Shell。  </li><li><code>Ctrl + S</code> 和 <code>Ctrl + Q</code> 是 <strong>终端控制流</strong>，与信号无关。</li></ul></blockquote><hr><h4><span id="2-信号行为详解">2. 信号行为详解</span></h4><p>(1) <code>Ctrl + C</code>（SIGINT）</p><ul><li><strong>默认行为</strong>：终止前台进程。</li><li><strong>可被捕获</strong>：程序可以自定义处理（如清理资源后退出）。</li><li><strong>示例</strong>（捕获 <code>SIGINT</code>）：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 程序捕获 SIGINT</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;收到 SIGINT，不退出\n&quot;</span>); &#125;</span><br><span class="line">signal(SIGINT, handler);</span><br></pre></td></tr></table></figure><p>(2) <code>Ctrl + \</code>（SIGQUIT）</p><ul><li><strong>默认行为</strong>：终止进程并生成 <code>core dump</code>（需启用 <code>ulimit -c unlimited</code>，我将在后面讲解 <code>core dump</code>）。</li><li><strong>用途</strong>：调试程序崩溃时的现场保存。</li><li><strong>不可被忽略</strong>：即使捕获，仍会终止进程。</li></ul><p>(3) <code>Ctrl + Z</code>（SIGTSTP）</p><ul><li><strong>默认行为</strong>：暂停进程并放入后台（状态变为 <code>T</code>）。</li><li><strong>恢复方法</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span>      <span class="comment"># 恢复到前台</span></span><br><span class="line"><span class="built_in">bg</span>      <span class="comment"># 在后台继续运行</span></span><br><span class="line"><span class="built_in">jobs</span>    <span class="comment"># 查看被暂停的任务</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>Ctrl + Z</code> 发送的 <code>SIGTSTP</code> 可被捕获，而 <code>SIGSTOP</code> 是强制暂停（不可捕获）。</p><p>(4) <code>Ctrl + D</code>（EOF）</p><ul><li><strong>非信号</strong>，而是终端输入的结束符。</li><li><strong>常见场景</strong>：<ul><li>退出 Shell（输入 <code>exit</code> 或直接按 <code>Ctrl + D</code>）。</li><li>结束 <code>cat</code>、<code>grep</code> 等命令的输入。</li></ul></li></ul><hr><h3><span id="命令发送信号">命令发送信号</span></h3><h4><span id="1-kill-命令">1. <code>kill</code> 命令</span></h4><p>该命令用于向进程发送信号，该命令只能向单个进程发送信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -信号编号 进程号</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 12345  <span class="comment"># 发送 SIGKILL(9) 终止进程 12345</span></span><br></pre></td></tr></table></figure><h4><span id="2-killall-命令">2. <code>killall</code> 命令</span></h4><p>该命令用于向所有指定名称的进程发送信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -信号编号 进程名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -15 firefox  <span class="comment"># 发送 SIGTERM(15) 终止所有 firefox 进程</span></span><br></pre></td></tr></table></figure><h3><span id="函数调用发送信号">函数调用发送信号</span></h3><h4><span id="1-kill-函数">1. <code>kill()</code> 函数</span></h4><p>该函数用于向单个进程发送信号。</p><p>语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, myhandler);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My pid is: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送 SIGINT 信号给当前进程</span></span><br><span class="line">    <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGINT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o</span><br><span class="line">My pid is: 281270</span><br><span class="line">My pid is: 281270</span><br><span class="line">My pid is: 281270</span><br><span class="line">I get a signal: Interrupt    # kill 发送 SIGINT 信号</span><br></pre></td></tr></table></figure><h4><span id="2-raise-函数">2. <code>raise()</code> 函数</span></h4><p>该函数用于向当前进程发送信号，效果和 <code>kill(getpid(), signal)</code> 相同。</p><p>语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, myhandler);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My pid is: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送 SIGINT 信号给当前进程</span></span><br><span class="line">    <span class="built_in">raise</span>(SIGINT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果和 <code>kill</code> 函数的示例完全相同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o</span><br><span class="line">My pid is: 282049</span><br><span class="line">My pid is: 282049</span><br><span class="line">My pid is: 282049</span><br><span class="line">I get a signal: Interrupt</span><br></pre></td></tr></table></figure><h4><span id="3-abort-函数">3. <code>abort()</code> 函数</span></h4><p>该函数用于向当前进程发送 <code>SIGABRT</code> 信号，用于异常终止程序，效果和 <code>raise(SIGABRT)</code> 或 <code>kill(getpid(), SIGABRT)</code> 相同。</p><p>语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGABRT, myhandler);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My pid is: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送 SIGABRT 信号给当前进程</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o               </span><br><span class="line">My pid is: 282738</span><br><span class="line">My pid is: 282738</span><br><span class="line">My pid is: 282738</span><br><span class="line">I get a signal: Aborted</span><br></pre></td></tr></table></figure><h4><span id="4-alarm-函数">4. <code>alarm()</code> 函数</span></h4><p>该函数用于设置定时器，当定时器到期时，向当前进程发送 <code>SIGALRM</code> 信号，而这种信号发送方式和前面几种硬件方式不同，<code>alarm</code> 是软件方式发送的信号。</p><p>语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, myhandler);</span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My pid is: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置定时器，3 秒后发送 SIGALRM 信号给当前进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o</span><br><span class="line">My pid is: 284189</span><br><span class="line">My pid is: 284189</span><br><span class="line">My pid is: 284189</span><br><span class="line">I get a signal: Alarm clock</span><br></pre></td></tr></table></figure><hr><p>利用闹钟，我们可以做出一些很好玩的机制，下面我们用闹钟做一个循环计数器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, myhandler);</span><br><span class="line">    <span class="comment">// 设置定时器，3 秒后发送 SIGALRM 信号给当前进程</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My pid is: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，我们只将自定义函数当中的 <code>_exit(1)</code> 去掉，然后在自定义函数中重新设置定时器，这样就可以实现循环计数器了。</p><p>现象如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o</span><br><span class="line">My pid is: 284711</span><br><span class="line">My pid is: 284711</span><br><span class="line">My pid is: 284711</span><br><span class="line">I get a signal: Alarm clock</span><br><span class="line">My pid is: 284711</span><br><span class="line">My pid is: 284711</span><br><span class="line">My pid is: 284711</span><br><span class="line">I get a signal: Alarm clock</span><br><span class="line">My pid is: 284711</span><br><span class="line">My pid is: 284711</span><br><span class="line">My pid is: 284711</span><br><span class="line">I get a signal: Alarm clock</span><br></pre></td></tr></table></figure><h3><span id="异常">异常</span></h3><p>我们来实现一个除零异常的场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义除零异常执行函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGFPE, myhandler);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o</span><br><span class="line">I get a signal: Floating point exception</span><br><span class="line">I get a signal: Floating point exception</span><br><span class="line">I get a signal: Floating point exception</span><br><span class="line">I get a signal: Floating point exception</span><br><span class="line">...                                       # 该自定义函数会被反复执行</span><br></pre></td></tr></table></figure><p>我们再试一试段错误（修改空指针）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myhandler</span><span class="params">(<span class="type">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get a signal: &quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(signal) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义段错误执行函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGSEGV, myhandler);</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/sign  </span><br><span class="line">╰─➤  ./signal.o</span><br><span class="line">I get a signal: Segmentation fault</span><br><span class="line">I get a signal: Segmentation fault</span><br><span class="line">I get a signal: Segmentation fault</span><br><span class="line">...                                   # 该自定义函数会被反复执行</span><br></pre></td></tr></table></figure><p>为什么会出现这种现象呢？</p><h4><span id="深入解析异常信号如除零-段错误为何会持续触发"><strong>深入解析：异常信号（如除零、段错误）为何会持续触发</strong></span></h4><hr><p><strong>核心结论</strong><br>当进程因 <strong>硬件异常</strong>（如除零、段错误）收到信号（如 <code>SIGFPE</code>、<code>SIGSEGV</code>）时，若在自定义处理函数中 <strong>不终止进程</strong>，操作系统会 <strong>反复触发该信号</strong>，导致处理函数被无限调用。<br><strong>根本原因</strong>：异常的 <strong>硬件状态标志</strong>（如 CPU 状态寄存器、MMU 页表异常）未被清除，且随进程上下文保存，操作系统会持续检测并发送信号。</p><hr><ol><li>硬件异常与信号的关系</li></ol><p>(1) 除零错误（SIGFPE）</p><ul><li><strong>硬件机制</strong>：  <ul><li>CPU 的 <strong>ALU（算术逻辑单元）</strong> 在执行除法时，若除数为零，会置位状态寄存器的 <strong>溢出标志位</strong>（如 x86 的 <code>#DE</code> 异常）。  </li><li><strong>OS 的干预</strong>：  <ul><li>操作系统通过 <strong>中断处理程序</strong> 捕获该硬件异常，将其转换为 <code>SIGFPE</code> 信号（编号 8）发送给进程。  </li><li><strong>进程上下文</strong> 保存了异常的 CPU 状态（包括标志位），因此异常状态会持续存在。</li></ul></li></ul></li></ul><p>(2) 段错误（SIGSEGV）</p><ul><li><strong>硬件机制</strong>：  <ul><li><strong>MMU（内存管理单元）</strong> 在访问非法地址（如空指针）时，触发 <strong>缺页异常</strong> 或 <strong>保护错误</strong>（如 x86 的 <code>#PF</code> 异常）。  </li><li><strong>OS 的干预</strong>：  <ul><li>操作系统检查异常地址合法性，若确认非法，则发送 <code>SIGSEGV</code> 信号（编号 11）给进程。  </li><li>页表错误状态会保留在进程的 <strong>内存上下文</strong> 中。</li></ul></li></ul></li></ul><hr><ol start="2"><li>为何信号会持续触发？</li></ol><p><strong>关键点</strong>：异常标志未被清除  </p><ul><li>若信号处理函数 <strong>不终止进程</strong>，操作系统在 <strong>恢复进程执行</strong> 时，会重新检测到 <strong>未解决的硬件异常状态</strong>，再次发送相同信号。  </li><li><strong>类比</strong>：  <ul><li>像一个人不断踩到钉子，医生（OS）每次包扎（信号处理）后，他仍踩在同一颗钉子上，伤口永远不会愈合。</li></ul></li></ul><p><strong>代码示例（无限循环的陷阱）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕获到信号 %d，但拒绝退出！\n&quot;</span>, sig);</span><br><span class="line">    <span class="comment">// 未终止进程，信号会再次触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGFPE, handler);  <span class="comment">// 捕获除零错误</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span> / <span class="number">0</span>;           <span class="comment">// 触发 SIGFPE</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">捕获到信号 8，但拒绝退出！  </span><br><span class="line">捕获到信号 8，但拒绝退出！  </span><br><span class="line">...（无限循环）</span><br></pre></td></tr></table></figure><hr><ol start="3"><li>操作系统的设计哲学</li></ol><p>(1) 异常信号的目的</p><ul><li><strong>“死得明白”</strong>：通知进程发生了不可恢复的错误（如内存损坏、算法错误）。  </li><li><strong>“而非垂死挣扎”</strong>：<strong>不建议</strong> 在信号处理中尝试修复硬件异常（如跳过除零指令），因程序状态已不可信。</li></ul><p>(2) 正确做法</p><ul><li><strong>立即终止进程</strong>：在信号处理中调用 <code>_exit()</code> 或 <code>abort()</code>，避免不可预测行为。  </li><li><strong>记录错误信息</strong>：如打印堆栈或写入日志，便于调试。</li></ul><p>这样一来，我们就应该理解为什么需要使用 <code>_exit()</code> 而不是 <code>exit()</code> 了。</p><p>原因如下：</p><p>(1) 避免递归触发信号</p><p>若在 <code>SIGSEGV</code> 处理函数中调用 <code>exit</code>，可能会因 <strong>缓冲区刷新</strong> 或 <strong><code>atexit</code> 钩子</strong> 再次访问非法内存，导致 <strong>信号递归触发</strong>（无限循环）。</p><p>(2) 跳过不可靠的清理</p><ul><li>异常发生时，程序状态可能已 <strong>损坏</strong>（如堆栈溢出、内存泄漏），此时 <code>exit</code> 的清理操作（如关闭文件、调用 <code>atexit</code>）可能 <strong>失败或引发新问题</strong>。</li><li><code>_exit</code> 直接通知内核终止进程，<strong>跳过所有用户态清理</strong>，确保快速退出。</li></ul><p>(3) 保持数据一致性<br>若程序因 <strong>段错误</strong> 崩溃，部分数据可能处于 <strong>不一致状态</strong>（如半写入的文件）。<code>_exit</code> 避免进一步写入，减少损坏风险。</p><p>(4) 避免僵尸进程<br><code>_exit</code> 不会执行 <code>exit</code> 的父进程等待逻辑，确保子进程立即变为僵尸，便于父进程清理。</p><hr><p>修正后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;错误：发生不可恢复异常（信号 %d）！\n&quot;</span>, sig);</span><br><span class="line">    _exit(<span class="number">1</span>);  <span class="comment">// 立即终止，避免循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为何部分信号可安全处理？</p><p>并非所有信号都关联硬件异常。例如：  </p><ul><li><strong><code>SIGINT</code>（Ctrl+C）</strong>：来自终端的请求，无硬件状态残留，可安全捕获后继续运行。  </li><li><strong><code>SIGCHLD</code></strong>：子进程状态变化，无持久化硬件状态。</li></ul></blockquote><ul><li><strong>硬件异常信号是“死刑判决”</strong>，处理函数应仅用于记录遗言，而非自救。  </li><li>持续触发是因 <strong>异常状态未被清除</strong>，而非操作系统“刁难”。</li></ul><hr><h4><span id="term-和-core核心转储-的区别">term 和 core(核心转储) 的区别</span></h4><p>我们来看一下下面这个表格：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Signal      Standard   Action   Comment</span><br><span class="line">      ────────────────────────────────────────────────────────────────────────</span><br><span class="line">      SIGABRT      P1990      Core    Abort signal from abort(3)</span><br><span class="line">      SIGALRM      P1990      Term    Timer signal from alarm(2)</span><br><span class="line">      SIGBUS       P2001      Core    Bus error (bad memory access)</span><br><span class="line">      SIGCHLD      P1990      Ign     Child stopped or terminated</span><br><span class="line">      SIGCLD         -        Ign     A synonym for SIGCHLD</span><br><span class="line">      SIGCONT      P1990      Cont    Continue if stopped</span><br><span class="line">      SIGEMT         -        Term    Emulator trap</span><br><span class="line">      SIGFPE       P1990      Core    Floating-point exception</span><br><span class="line">      SIGHUP       P1990      Term    Hangup detected on controlling terminal</span><br><span class="line">                                      or death of controlling process</span><br><span class="line">      SIGILL       P1990      Core    Illegal Instruction</span><br><span class="line">      SIGINFO        -                A synonym for SIGPWR</span><br><span class="line">      SIGINT       P1990      Term    Interrupt from keyboard</span><br><span class="line">      SIGIO          -        Term    I/O now possible (4.2BSD)</span><br><span class="line">      SIGIOT         -        Core    IOT trap. A synonym for SIGABRT</span><br><span class="line">      SIGKILL      P1990      Term    Kill signal</span><br><span class="line">      SIGLOST        -        Term    File lock lost (unused)</span><br><span class="line">      SIGPIPE      P1990      Term    Broken pipe: write to pipe with no</span><br><span class="line">                                      readers; see pipe(7)</span><br><span class="line">      SIGPOLL      P2001      Term    Pollable event (Sys V);</span><br><span class="line">                                      synonym for SIGIO</span><br><span class="line">      SIGPROF      P2001      Term    Profiling timer expired</span><br><span class="line">      SIGPWR         -        Term    Power failure (System V)</span><br><span class="line"></span><br><span class="line">      SIGQUIT      P1990      Core    Quit from keyboard</span><br><span class="line">      SIGSEGV      P1990      Core    Invalid memory reference</span><br><span class="line">      SIGSTKFLT      -        Term    Stack fault on coprocessor (unused)</span><br><span class="line">      SIGSTOP      P1990      Stop    Stop process</span><br><span class="line">      SIGTSTP      P1990      Stop    Stop typed at terminal</span><br><span class="line">      SIGSYS       P2001      Core    Bad system call (SVr4);</span><br><span class="line">                                      see also seccomp(2)</span><br><span class="line">      SIGTERM      P1990      Term    Termination signal</span><br><span class="line">      SIGTRAP      P2001      Core    Trace/breakpoint trap</span><br><span class="line">      SIGTTIN      P1990      Stop    Terminal input for background process</span><br><span class="line">      SIGTTOU      P1990      Stop    Terminal output for background process</span><br><span class="line">      SIGUNUSED      -        Core    Synonymous with SIGSYS</span><br><span class="line">      SIGURG       P2001      Ign     Urgent condition on socket (4.2BSD)</span><br><span class="line">      SIGUSR1      P1990      Term    User-defined signal 1</span><br><span class="line">      SIGUSR2      P1990      Term    User-defined signal 2</span><br><span class="line">      SIGVTALRM    P2001      Term    Virtual alarm clock (4.2BSD)</span><br><span class="line">      SIGXCPU      P2001      Core    CPU time limit exceeded (4.2BSD);</span><br><span class="line">                                      see setrlimit(2)</span><br><span class="line">      SIGXFSZ      P2001      Core    File size limit exceeded (4.2BSD);</span><br><span class="line">                                      see setrlimit(2)</span><br><span class="line">      SIGWINCH       -        Ign     Window resize signal (4.3BSD, Sun)</span><br></pre></td></tr></table></figure>    </div></div><p>这个表格显示了不同的信号对应的默认处理动作，我们只对比看一下 <code>term</code> 和 <code>core</code> 的区别：</p><ol><li><strong><code>term</code>（Terminate）</strong>：普通终止，不生成核心转储文件。  </li><li><strong><code>core</code>（Core Dump）</strong>：终止并生成核心转储文件（用于调试）。</li></ol><p>以下是详细对比：</p><hr><p>核心区别</p><table><thead><tr><th><strong>特性</strong></th><th><strong><code>term</code>（普通终止）</strong></th><th><strong><code>core</code>（核心转储终止）</strong></th></tr></thead><tbody><tr><td><strong>行为</strong></td><td>进程直接退出，无额外操作</td><td>进程退出，并生成 <code>core</code> 文件</td></tr><tr><td><strong>信号示例</strong></td><td><code>SIGTERM</code>（15）、<code>SIGINT</code>（2）</td><td><code>SIGSEGV</code>（11）、<code>SIGABRT</code>（6）</td></tr><tr><td><strong>是否可捕获</strong></td><td>是（可自定义处理）</td><td>是（但通常不推荐继续运行）</td></tr><tr><td><strong>用途</strong></td><td>正常终止进程（如 <code>kill</code> 默认行为）</td><td>调试程序崩溃（如段错误、断言失败）</td></tr><tr><td><strong>生成核心转储</strong></td><td>❌ 否</td><td>✅ 是（需 <code>ulimit -c unlimited</code>）</td></tr></tbody></table><hr><p>常见信号的终止类型</p><table><thead><tr><th><strong>信号</strong></th><th><strong>编号</strong></th><th><strong>默认行为</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>SIGTERM</code></td><td>15</td><td><code>term</code></td><td>优雅终止（<code>kill</code> 默认发送）</td></tr><tr><td><code>SIGINT</code></td><td>2</td><td><code>term</code></td><td><code>Ctrl+C</code> 触发</td></tr><tr><td><code>SIGKILL</code></td><td>9</td><td><code>term</code></td><td>强制终止（不可捕获）</td></tr><tr><td><code>SIGQUIT</code></td><td>3</td><td><code>core</code></td><td><code>Ctrl+\</code> 触发，生成核心转储</td></tr><tr><td><code>SIGSEGV</code></td><td>11</td><td><code>core</code></td><td>段错误（非法内存访问）</td></tr><tr><td><code>SIGABRT</code></td><td>6</td><td><code>core</code></td><td><code>abort()</code> 触发，断言失败时常用</td></tr></tbody></table><hr><p><strong>核心转储（Core Dump）详解</strong><br>（1）什么是核心转储？</p><ul><li>核心转储是 <strong>进程崩溃时的内存快照</strong>，保存了崩溃时的 <strong>寄存器状态、堆栈、变量值</strong> 等信息。</li><li>文件通常命名为 <code>core</code> 或 <code>core.&lt;PID&gt;</code>，需用 <code>gdb</code> 分析</li></ul><p>（2）如何启用核心转储？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited  <span class="comment"># 解除核心转储文件大小限制</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/tmp/core.%e.%p&quot;</span> &gt; /proc/sys/kernel/core_pattern  <span class="comment"># 指定保存路径</span></span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，某些系统可能禁用核心转储（通过 <code>ulimit -c 0</code>）。</p></blockquote><p>（3）什么情况下生成核心转储？</p><ul><li>信号默认行为为 <code>core</code>（如 <code>SIGSEGV</code>、<code>SIGABRT</code>）。  </li><li>程序未捕获该信号（或捕获后仍调用 <code>abort()</code>）。  </li><li>文件系统有足够空间，且权限允许。</li></ul><hr><blockquote><p>总结如下：</p><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方式</strong></th></tr></thead><tbody><tr><td>正常终止进程（如 <code>kill</code>）</td><td><code>SIGTERM</code>（<code>term</code>）</td></tr><tr><td>调试程序崩溃（如段错误）</td><td><code>SIGSEGV</code>（<code>core</code>）</td></tr><tr><td>防止生成核心转储（安全敏感场景）</td><td>捕获信号并调用 <code>_exit</code></td></tr><tr><td>主动生成核心转储（调试）</td><td><code>abort()</code> 或 <code>SIGABRT</code></td></tr></tbody></table><ul><li><code>term</code> 是 <strong>静默退出</strong>，<code>core</code> 是 <strong>崩溃快照</strong>。  </li><li>生产环境可禁用 <code>core</code>（避免磁盘占满），开发环境建议启用。  </li><li>在信号处理函数中，优先用 <code>_exit</code> 而非 <code>exit</code>（避免递归问题）。</li></ul></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程间通信--system V 共享内存</title>
      <link href="/2025/07/20/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E9%80%9A%E4%BF%A1/shared_memory/"/>
      <url>/2025/07/20/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E9%80%9A%E4%BF%A1/shared_memory/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%87%BD%E6%95%B0%E8%AE%B2%E8%A7%A3">函数讲解</a><ul><li><a href="#shmget-%E5%87%BD%E6%95%B0">shmget 函数</a></li><li><a href="#shmat-%E5%87%BD%E6%95%B0">shmat 函数</a></li><li><a href="#shmctl-%E5%87%BD%E6%95%B0">shmctl 函数</a></li></ul></li><li><a href="#%E6%8C%87%E4%BB%A4%E8%AE%B2%E8%A7%A3">指令讲解</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">查看当前所有共享内存</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">删除共享内存</a></li></ul></li><li><a href="#%E7%BB%BC%E5%90%88%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">综合使用示例</a></li></ul><!-- tocstop --><p>共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据</p><p><img src="/img/Linux/shared_mem/shared_mem.png" alt="shared_momery"></p><p>下面来介绍一下共享内存函数</p><h2><span id="函数讲解">函数讲解</span></h2><h3><span id="shmget-函数">shmget 函数</span></h3><h4><span id="功能描述">功能描述</span></h4><p><code>shmget</code>函数用于创建或获取一个共享内存段。共享内存是进程间通信(IPC)的一种方式，允许多个进程访问同一块内存区域，从而实现高效的数据共享。</p><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><ul><li><p><strong>key</strong>: 共享内存段的标识键值</p><ul><li>可以是由<code>ftok()</code>生成的键值，也可以是常量<code>IPC_PRIVATE</code>(表示创建私有共享内存)</li><li>不同进程通过相同的key值访问同一个共享内存</li></ul></li><li><p><strong>size</strong>: 请求的共享内存段大小(以字节为单位)</p><ul><li>如果是创建新共享内存，必须指定size</li><li>如果是获取已存在的共享内存，size可以设为0</li></ul></li><li><p><strong>shmflg</strong>: 权限标志和创建选项的组合</p><ul><li>权限标志：与文件权限类似，如0644(八进制)</li><li>创建选项：<ul><li><code>IPC_CREAT</code>: 如果共享内存不存在则创建，否则获取已存在的</li><li><code>IPC_EXCL</code>: 与<code>IPC_CREAT</code>一起使用时，如果共享内存已存在则返回错误</li><li><code>IPC_NOWAIT</code>: 如果内存段需要等待(如交换空间不足)，不等待直接返回错误</li></ul></li></ul></li></ul><h4><span id="返回值">返回值</span></h4><ul><li><strong>成功</strong>: 返回共享内存段的标识符(非负整数)</li><li><strong>失败</strong>: 返回-1，并设置errno指示错误原因</li></ul><h4><span id="使用示例">使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 1024  <span class="comment">// 1KB共享内存</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;shmfile&quot;</span>, <span class="number">65</span>);  <span class="comment">// 生成key</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建共享内存(如果已存在则失败)</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, SHM_SIZE, <span class="number">0666</span>|IPC_CREAT|IPC_EXCL);</span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory created with ID: %d\n&quot;</span>, shmid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li>使用<code>IPC_PRIVATE</code>作为key时，总是创建新的共享内存段</li><li>共享内存创建后不会自动初始化，内容是不确定的</li><li>需要配合<code>shmat()</code>和<code>shmdt()</code>函数来连接和分离共享内存</li><li>使用完毕后应使用<code>shmctl()</code>删除共享内存段</li><li>在多进程环境中需要考虑同步问题(如使用信号量)</li></ol><h3><span id="shmat-函数">shmat 函数</span></h3><h4><span id="功能描述">功能描述</span></h4><p><code>shmat</code>函数（Shared Memory Attach）用于将共享内存段连接到调用进程的地址空间中，使进程能够访问该共享内存区域。</p><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><ul><li><strong>shmid</strong>: 共享内存标识符，由<code>shmget</code>函数返回的值</li><li><strong>shmaddr</strong>: 指定共享内存连接到进程地址空间的地址<ul><li>为NULL时，系统自动选择合适的地址（最常用方式）</li><li>非NULL时，尝试在指定地址连接（需要特殊权限）</li></ul></li><li><strong>shmflg</strong>: 连接选项标志<ul><li><code>SHM_RDONLY</code>: 以只读方式连接共享内存</li><li><code>SHM_RND</code>: 当shmaddr非NULL时，将连接地址向下舍入到SHMLBA（低边界地址）的倍数</li><li>0: 默认读写权限</li></ul></li></ul><h4><span id="返回值">返回值</span></h4><ul><li><strong>成功</strong>: 返回指向共享内存段的指针（连接地址）</li><li><strong>失败</strong>: 返回(void *)-1，并设置errno指示错误原因</li></ul><h4><span id="详细说明">详细说明</span></h4><ol><li><p><strong>自动地址选择</strong><br>当<code>shmaddr</code>参数为NULL时，系统会自动选择一个合适的、未使用的地址来映射共享内存段。这是最常用、最安全的方式。</p></li><li><p><strong>指定地址连接</strong><br>当<code>shmaddr</code>非NULL且未设置<code>SHM_RND</code>标志时，系统会尝试在指定的确切地址连接共享内存段。这需要该地址可用且满足对齐要求，通常需要特殊权限。</p></li><li><p><strong>地址舍入</strong><br>当<code>shmaddr</code>非NULL且设置了<code>SHM_RND</code>标志时，实际连接地址会按照公式调整：<br><code>实际地址 = shmaddr - (shmaddr % SHMLBA)</code><br>其中SHMLBA是”段低边界地址”（Segment Low Boundary Address），通常是内存页大小的倍数。</p></li><li><p><strong>只读模式</strong><br>设置<code>SHM_RDONLY</code>标志时，进程只能读取共享内存内容，不能修改。其他进程可能仍具有读写权限（取决于创建时的权限设置）。</p></li></ol><h4><span id="使用示例">使用示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;shmfile&quot;</span>, <span class="number">65</span>);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, SHM_SIZE, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接共享内存（让系统自动选择地址）</span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*) shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (str == (<span class="type">char</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory attached at address: %p\n&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用共享内存...</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;Hello Shared Memory&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分离共享内存</span></span><br><span class="line">    shmdt(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li>连接后的共享内存就像普通内存一样使用，但要注意进程间的同步问题</li><li>使用完毕后应调用<code>shmdt</code>函数分离共享内存</li><li>多次连接同一共享内存段会返回不同的地址</li><li>共享内存的删除（<code>shmctl</code>）在所有进程都分离后才会实际生效</li><li>在多线程&#x2F;多进程环境中访问共享内存时，必须实现适当的同步机制（如信号量）</li></ol><h3><span id="shmctl-函数">shmctl 函数</span></h3><h4><span id="功能描述">功能描述</span></h4><p><code>shmctl</code>（Shared Memory Control）用于控制共享内存段，包括查询状态、修改权限或删除共享内存。  </p><hr><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure><hr><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>shmid</code></strong></td><td>共享内存标识符，由 <code>shmget</code> 返回</td></tr><tr><td><strong><code>cmd</code></strong></td><td>控制命令，决定操作类型（见下表）</td></tr><tr><td><strong><code>buf</code></strong></td><td>指向 <code>struct shmid_ds</code> 的指针，用于存储或设置共享内存信息</td></tr></tbody></table><h4><span id="cmd-命令取值及作用"><code>cmd</code> 命令取值及作用</span></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>IPC_STAT</code></strong></td><td>获取共享内存的当前状态，并存入 <code>buf</code> 指向的结构体</td></tr><tr><td><strong><code>IPC_SET</code></strong></td><td>修改共享内存的权限、属主等属性（需权限）</td></tr><tr><td><strong><code>IPC_RMID</code></strong></td><td><strong>标记删除</strong> 共享内存段（在所有进程 <code>shmdt</code> 后真正释放）</td></tr></tbody></table><hr><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li><strong>成功</strong>：返回 <code>0</code>  </li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code>（如 <code>EPERM</code> 权限不足、<code>EINVAL</code> 无效参数等）</li></ul><hr><h4><span id="struct-shmid_ds-结构体部分关键字段"><strong><code>struct shmid_ds</code> 结构体（部分关键字段）</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>  <span class="comment">// 权限信息</span></span><br><span class="line">    <span class="type">size_t</span>          shm_segsz; <span class="comment">// 共享内存大小</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_cpid;  <span class="comment">// 创建者PID</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_lpid;  <span class="comment">// 最后操作进程PID</span></span><br><span class="line">    <span class="type">time_t</span>          shm_atime; <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="type">time_t</span>          shm_dtime; <span class="comment">// 最后分离时间</span></span><br><span class="line">    <span class="type">time_t</span>          shm_ctime; <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4><span id="使用示例">使用示例</span></h4><h5><span id="1-查询共享内存状态ipc_stat">1. 查询共享内存状态（<code>IPC_STAT</code>）</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">shm_info</span>;</span></span><br><span class="line"><span class="keyword">if</span> (shmctl(shmid, IPC_STAT, &amp;shm_info) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;shmctl IPC_STAT failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Shared Memory Size: %zu\n&quot;</span>, shm_info.shm_segsz);</span><br></pre></td></tr></table></figure><h5><span id="2-修改共享内存权限ipc_set">2. 修改共享内存权限（<code>IPC_SET</code>）</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">shm_info</span>;</span></span><br><span class="line">shmctl(shmid, IPC_STAT, &amp;shm_info);  <span class="comment">// 先获取当前状态</span></span><br><span class="line">shm_info.shm_perm.mode = <span class="number">0640</span>;       <span class="comment">// 修改权限</span></span><br><span class="line"><span class="keyword">if</span> (shmctl(shmid, IPC_SET, &amp;shm_info) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;shmctl IPC_SET failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="3-删除共享内存ipc_rmid">3. 删除共享内存（<code>IPC_RMID</code>）</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;shmctl IPC_RMID failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Shared memory marked for deletion.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>⚠ <strong>注意</strong>：<code>IPC_RMID</code> 只是标记删除，<strong>实际释放需所有进程 <code>shmdt</code> 后</strong>。</p><hr><h4><span id="注意事项">注意事项</span></h4><ol><li><strong><code>IPC_RMID</code> 不会立即删除共享内存</strong>，而是等所有进程 <code>shmdt</code> 后才真正释放。  </li><li><strong><code>IPC_SET</code> 需要权限</strong>（如 root 或共享内存创建者）。  </li><li><strong><code>shmctl</code> + <code>IPC_STAT</code> 可用于监控共享内存使用情况</strong>（如检查最后访问时间）。  </li><li><strong>多进程共享内存时，需额外同步机制（如信号量）避免竞争</strong>。</li></ol><hr><h4><span id="总结">总结</span></h4><table><thead><tr><th>操作</th><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><strong>查询状态</strong></td><td><code>IPC_STAT</code></td><td>获取共享内存信息</td></tr><tr><td><strong>修改权限</strong></td><td><code>IPC_SET</code></td><td>调整属主、权限等</td></tr><tr><td><strong>删除内存</strong></td><td><code>IPC_RMID</code></td><td>标记删除（需进程分离后生效）</td></tr></tbody></table><p><code>shmctl</code> 是共享内存管理的核心函数，通常与 <code>shmget</code>、<code>shmat</code>、<code>shmdt</code> 配合使用。</p><h2><span id="指令讲解">指令讲解</span></h2><h3><span id="查看当前所有共享内存">查看当前所有共享内存</span></h3><h4><span id="1-ipcs-命令">1. <code>ipcs</code> 命令</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -m</span><br></pre></td></tr></table></figure><p><strong>选项说明</strong>:</p><ul><li><code>-m</code>: 只显示共享内存段</li><li><code>-a</code>: 显示所有IPC信息(共享内存、消息队列、信号量)</li><li><code>-l</code>: 显示系统限制</li><li><code>-p</code>: 显示创建者和最后操作者的PID</li><li><code>-t</code>: 显示时间信息</li></ul><p><strong>示例输出</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/fifo</span><br><span class="line">╰─➤  ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line">0x00000000 0          root       600        80         2</span><br><span class="line">0x00000000 1          root       600        16384      2</span><br><span class="line">0x00000000 2          root       600        280        2</span><br><span class="line">0xffffffff 3          ljx        666        4096       0</span><br></pre></td></tr></table></figure><h4><span id="2-查看更详细的信息">2. 查看更详细的信息</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/fifo</span><br><span class="line">╰─➤  ipcs -m -i 3</span><br><span class="line"></span><br><span class="line">Shared memory Segment shmid=3</span><br><span class="line">uid=1003        gid=1003        cuid=1003       cgid=1003</span><br><span class="line">mode=0666       access_perms=0666</span><br><span class="line">bytes=4096      lpid=3988199    cpid=3988199    nattch=0</span><br><span class="line">att_time=Sun Jul 20 21:49:15 2025</span><br><span class="line">det_time=Sun Jul 20 21:49:26 2025</span><br><span class="line">change_time=Sun Jul 20 21:49:15 2025</span><br></pre></td></tr></table></figure><p>其中<code>&lt;shmid&gt;</code>是共享内存ID</p><h3><span id="删除共享内存">删除共享内存</span></h3><h4><span id="1-ipcrm-命令">1. <code>ipcrm</code> 命令</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -m &lt;shmid&gt;</span><br></pre></td></tr></table></figure><p><strong>选项说明</strong>:</p><ul><li><code>-m &lt;shmid&gt;</code>: 删除指定的共享内存段</li><li><code>-M &lt;shmkey&gt;</code>: 删除指定key值的共享内存段</li><li><code>-a</code>: 删除当前用户拥有的所有IPC资源(慎用!)</li></ul><p><strong>示例</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/fifo</span><br><span class="line">╰─➤  ipcrm -m 3</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/fifo</span><br><span class="line">╰─➤  ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line">0x00000000 0          root       600        80         2</span><br><span class="line">0x00000000 1          root       600        16384      2</span><br><span class="line">0x00000000 2          root       600        280        2</span><br></pre></td></tr></table></figure><h4><span id="2-通过程序删除">2. 通过程序删除</span></h4><p>在C程序中可以使用<code>shmctl</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li>删除共享内存需要相应权限(通常是创建者或root用户)</li><li>如果共享内存仍被进程附加(nattch&gt;0)，删除会被标记但不会立即生效</li><li>使用<code>ipcs -m</code>可以查看共享内存是否已被成功删除</li><li>对于残留的共享内存，可能需要root权限才能删除</li></ol><h2><span id="综合使用示例">综合使用示例</span></h2><p>利用共享内存实现进程间通信</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMMON_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMMON_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;/home/ljx/linux_review/shared_memory&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> proj_id = <span class="number">669988</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">global_error</span>&#123;</span><br><span class="line">    shmid_error = <span class="number">1</span>,</span><br><span class="line">    ftok_error,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shared_mem</span><span class="params">(<span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(pathname, proj_id);</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;common.hpp: ftok failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(global_error::ftok_error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(key, SHM_SIZE, mod);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;common.hpp: shmget failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(global_error::shmid_error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_shared_mem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_mem</span>(<span class="number">0666</span> | IPC_CREAT | IPC_EXCL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_shared_mem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_mem</span>(IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>服务端实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">create_shared_mem</span>();</span><br><span class="line">    <span class="comment">// 将共享内存段连接到进程地址空间</span></span><br><span class="line">    <span class="type">char</span> * addr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(addr, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Client say: &quot;</span> &lt;&lt; addr &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shmdt</span>(addr);</span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">get_shared_mem</span>();</span><br><span class="line">    <span class="type">char</span> *addr = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Please Enter: &quot;</span>;</span><br><span class="line">        <span class="built_in">fgets</span>(addr, SHM_SIZE, stdin);</span><br><span class="line">        addr[<span class="built_in">strcspn</span>(addr, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(addr, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shmdt</span>(addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是直接实现存在进程读取不同步问题，因此我们需要利用同步机制，我们可以简单使用命名管道的同步机制来简单实现一下同步：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMMON_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMMON_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;/home/ljx/linux_review/shared_memory&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> proj_id = <span class="number">669988</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *file_name = <span class="string">&quot;myfifo&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mode = <span class="number">0664</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">global_error</span>&#123;</span><br><span class="line">    shmid_error = <span class="number">1</span>,</span><br><span class="line">    ftok_error,</span><br><span class="line">    mkfifo_error,</span><br><span class="line">    unlink_error,</span><br><span class="line">    write_error,</span><br><span class="line">    read_error,</span><br><span class="line">    open_error,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shared_mem</span><span class="params">(<span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(pathname, proj_id);</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;common.hpp: ftok failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(global_error::ftok_error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(key, SHM_SIZE, mod);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;common.hpp: shmget failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(global_error::shmid_error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_shared_mem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_mem</span>(<span class="number">0666</span> | IPC_CREAT | IPC_EXCL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_shared_mem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_mem</span>(IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fifo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitPipe</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InitPipe</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mkfifo</span>(file_name, mode) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;InitPipe(): mkfifo error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_error::mkfifo_error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">InitPipe</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">unlink</span>(file_name) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;~InitPipe(): unlink error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_error::unlink_error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">create_shared_mem</span>();</span><br><span class="line">    <span class="comment">// 将共享内存段连接到进程地址空间</span></span><br><span class="line">    <span class="type">char</span> * addr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 命名管道实现同步</span></span><br><span class="line">    InitPipe init;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(file_name, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;server.o: open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(global_error::open_error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(fd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(addr, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Client say: &quot;</span> &lt;&lt; addr &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shmdt</span>(addr);</span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">get_shared_mem</span>();</span><br><span class="line">    <span class="type">char</span> *addr = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 命名管道实现同步</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(file_name, O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Please Enter: &quot;</span>;</span><br><span class="line">        <span class="built_in">fgets</span>(addr, SHM_SIZE, stdin);</span><br><span class="line">        addr[<span class="built_in">strcspn</span>(addr, <span class="string">&quot;\n&quot;</span>)] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(addr, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shmdt</span>(addr);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/shared_memory</span><br><span class="line">╰─➤  ./client.o                                                                                                                      130 ↵</span><br><span class="line">Please Enter: 123</span><br><span class="line">Please Enter: 456</span><br><span class="line">Please Enter: quit</span><br><span class="line">Bye!</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/shared_memory  </span><br><span class="line">╰─➤  ./server.o</span><br><span class="line">Client say: 123</span><br><span class="line">Client say: 456</span><br></pre></td></tr></table></figure><p>可以看到，我们利用命名管道间接实现了进程同步</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 通信 </tag>
            
            <tag> 共享内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程间通信--命名管道</title>
      <link href="/2025/07/20/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E9%80%9A%E4%BF%A1/fifo_communication/"/>
      <url>/2025/07/20/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E9%80%9A%E4%BF%A1/fifo_communication/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#mkfifo-%E5%91%BD%E4%BB%A4">mkfifo 命令</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></li><li><a href="#%E4%B8%BB%E8%A6%81%E9%80%89%E9%A1%B9">主要选项</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a></li><li><a href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">实际应用场景</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li></ul></li><li><a href="#mkfifo-%E5%87%BD%E6%95%B0">mkfifo 函数</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B">函数原型</a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC">返回值</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%A0%81errno">常见错误码(errno)</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B">基本用法示例</a></li><li><a href="#fifo%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C">FIFO的读写操作</a></li><li><a href="#%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7">重要特性</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1">注意事项</a></li><li><a href="#%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">应用示例</a></li></ul></li></ul><!-- tocstop --><h2><span id="mkfifo-命令">mkfifo 命令</span></h2><p><code>mkfifo</code> 是 Linux&#x2F;Unix 系统中用于创建命名管道（named pipe，也称为 FIFO）的命令。命名管道是一种特殊的文件类型，允许不相关的进程通过文件系统进行通信。</p><h3><span id="基本语法">基本语法</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> [选项] 管道名</span><br></pre></td></tr></table></figure><h3><span id="主要选项">主要选项</span></h3><ul><li><code>-m MODE</code> 或 <code>--mode=MODE</code>：设置管道的权限模式（类似 chmod）</li><li><code>-Z</code>：设置 SELinux 安全上下文（在 SELinux 启用的系统上）</li></ul><h3><span id="使用示例">使用示例</span></h3><h4><span id="1-创建基本命名管道">1. 创建基本命名管道</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> mypipe</span><br></pre></td></tr></table></figure><p>这会在当前目录创建一个名为 “mypipe” 的命名管道。</p><h4><span id="2-创建带有特定权限的管道">2. 创建带有特定权限的管道</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> -m 644 mypipe</span><br></pre></td></tr></table></figure><p>这会创建一个权限为 644（所有者可读写，其他人只读）的命名管道。</p><h4><span id="3-使用命名管道进行进程通信">3. 使用命名管道进行进程通信</span></h4><p>在终端1中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; mypipe</span><br></pre></td></tr></table></figure><p>在终端2中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt; mypipe</span><br></pre></td></tr></table></figure><p>此时在终端1中输入的内容会出现在终端2中。</p><h4><span id="4-结合其他命令使用">4. 结合其他命令使用</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> mypipe</span><br><span class="line">tar -czf mypipe directory/ &amp;</span><br><span class="line">tar -xzf mypipe -C destination/</span><br></pre></td></tr></table></figure><p>这通过命名管道将一个目录压缩并直接解压到另一个位置，而不生成中间文件。</p><h3><span id="工作原理">工作原理</span></h3><p>命名管道与匿名管道（<code>|</code>）类似，但有几点关键区别：</p><ol><li>命名管道在文件系统中有一个名称，不相关的进程可以通过这个名称访问它</li><li>命名管道会一直存在，直到被显式删除（使用 <code>rm</code>）</li><li>读写操作是阻塞的 - 读操作会等待有数据写入，写操作会等待有进程开始读取</li></ol><h3><span id="实际应用场景">实际应用场景</span></h3><ol><li><strong>进程间通信</strong>：允许不相关的进程交换数据</li><li><strong>日志处理</strong>：多个进程可以向同一个管道写入日志，由一个中心进程处理</li><li><strong>流处理</strong>：在不创建临时文件的情况下传递大量数据</li><li><strong>网络编程</strong>：有时用于本地客户端和服务器之间的通信</li></ol><h3><span id="注意事项">注意事项</span></h3><ol><li>命名管道不存储数据 - 它只是连接读写进程的通道</li><li>如果所有写端关闭，读端会收到 EOF</li><li>如果没有读端，写操作会阻塞直到有读端打开管道</li><li>命名管道可以多次打开，允许多个读写者</li></ol><h2><span id="mkfifo-函数">mkfifo 函数</span></h2><p><code>mkfifo</code>是C语言中用于创建命名管道(FIFO)的系统函数，它是在POSIX标准中定义的，可以在<code>&lt;sys/stat.h&gt;</code>头文件中找到。</p><h3><span id="函数原型">函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h3><span id="参数说明">参数说明</span></h3><ol><li><strong>pathname</strong>：要创建的FIFO文件的路径名</li><li><strong>mode</strong>：指定FIFO的权限模式，通常使用八进制表示（如0666）</li></ol><h3><span id="返回值">返回值</span></h3><ul><li>成功时返回0</li><li>失败时返回-1，并设置errno来指示错误</li></ul><h3><span id="常见错误码errno">常见错误码(errno)</span></h3><ul><li><code>EACCES</code>：路径中的某个目录不允许搜索(执行)权限</li><li><code>EEXIST</code>：指定的pathname已经存在</li><li><code>ENAMETOOLONG</code>：路径名过长</li><li><code>ENOENT</code>：路径中的某个目录不存在</li><li><code>ENOSPC</code>：包含该文件的设备没有空间了</li><li><code>ENOTDIR</code>：路径中的某个部分不是目录</li><li><code>EROFS</code>：指定的文件位于只读文件系统上</li></ul><h3><span id="基本用法示例">基本用法示例</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifo_path = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建命名管道，权限设置为可读可写</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(fifo_path, <span class="number">0666</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FIFO created at %s\n&quot;</span>, fifo_path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里可以添加对FIFO的读写操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用完后删除FIFO</span></span><br><span class="line">    unlink(fifo_path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="fifo的读写操作">FIFO的读写操作</span></h3><p>创建FIFO后，可以使用标准文件I&#x2F;O函数进行读写：</p><h4><span id="写入示例">写入示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(fifo_path, O_WRONLY);</span><br><span class="line">write(fd, <span class="string">&quot;Hello, FIFO!&quot;</span>, <span class="number">12</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h4><span id="读取示例">读取示例</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(fifo_path, O_RDONLY);</span><br><span class="line"><span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h3><span id="重要特性">重要特性</span></h3><ol><li><p><strong>阻塞行为</strong>：</p><ul><li>打开一个FIFO进行读取(<code>O_RDONLY</code>)会阻塞，直到有进程打开同一个FIFO进行写入</li><li>打开一个FIFO进行写入(<code>O_WRONLY</code>)会阻塞，直到有进程打开同一个FIFO进行读取</li></ul></li><li><p><strong>非阻塞模式</strong>：</p><ul><li>可以通过<code>O_NONBLOCK</code>标志改变阻塞行为</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(fifo_path, O_RDONLY | O_NONBLOCK);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>数据传递</strong>：<ul><li>FIFO中的数据是字节流，没有消息边界</li><li>多个进程可以同时写入同一个FIFO，但这样可能会导致数据交错</li></ul></li></ol><h3><span id="注意事项">注意事项</span></h3><ol><li>FIFO在文件系统中有一个名称，但不会实际存储数据</li><li>当所有写端关闭后，读端会读到EOF</li><li>如果没有读端，写操作会阻塞（除非使用非阻塞模式）</li><li>FIFO的数据是先进先出的，读取顺序与写入顺序一致</li><li>使用完毕后应该删除FIFO文件</li></ol><h3><span id="应用示例">应用示例</span></h3><p>下面通过 mkfifo 函数创建一个命名管道用来实现两个无亲属关系的进程之间的通信</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMMON_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMMON_HPP_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *file_name = <span class="string">&quot;myfifo&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mode = <span class="number">0664</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">global_error</span>&#123;</span><br><span class="line">    mkfifo_error = <span class="number">1</span>,</span><br><span class="line">    unlink_error,</span><br><span class="line">    write_error,</span><br><span class="line">    read_error,</span><br><span class="line">    open_error,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数用于初始化命名管道以及 RAII 清理命名管道</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitPipe</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InitPipe</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mkfifo</span>(file_name, mode) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;InitPipe(): mkfifo error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_error::mkfifo_error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">InitPipe</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">unlink</span>(file_name) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;~InitPipe(): unlink error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_error::unlink_error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>服务端代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitPipe init;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(file_name, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;server.o: open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(global_error::open_error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> inbuffer[MAX_SIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(fd, inbuffer, MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;server.o: read error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_error::read_error);</span><br><span class="line">        &#125;</span><br><span class="line">        inbuffer[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(inbuffer, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;server get information: &quot;</span> &lt;&lt; inbuffer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(file_name, O_WRONLY);</span><br><span class="line">    string outbuffer;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; outbuffer;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">write</span>(fd, outbuffer.<span class="built_in">c_str</span>(), outbuffer.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;client.o: write error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_error::write_error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(outbuffer == <span class="string">&quot;quit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;bye&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以观察到，数据被正常接受处理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/fifo</span><br><span class="line">╰─➤  ./client.o</span><br><span class="line">Please Enter: 123</span><br><span class="line">Please Enter: 321</span><br><span class="line">Please Enter: 135</span><br><span class="line">Please Enter: quit</span><br><span class="line">bye</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/fifo  </span><br><span class="line">╰─➤  ./server.o</span><br><span class="line">server get information: 123</span><br><span class="line">server get information: 321</span><br><span class="line">server get information: 135</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 通信 </tag>
            
            <tag> 管道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程间通信--匿名管道</title>
      <link href="/2025/07/20/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E9%80%9A%E4%BF%A1/pipe_communication/"/>
      <url>/2025/07/20/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E9%80%9A%E4%BF%A1/pipe_communication/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E5%AE%9A%E4%B9%89">管道通信定义</a></li><li><a href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E4%BD%BF%E7%94%A8">管道通信使用</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B">函数原型</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">基本使用流程</a></li><li><a href="#%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7">关键特性</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%94%A8%E4%BE%8B">使用用例</a></li></ul></li><li><a href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5">异常情况</a><ul><li><a href="#1%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%96%AF%E7%8B%82%E5%86%99%E5%85%A5%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%BB%B6%E8%BF%9F%E8%AF%BB%E5%8F%96"><strong>（1）子进程疯狂写入，父进程延迟读取</strong></a></li><li><a href="#2%E7%88%B6%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%8F%96%E7%A9%BA%E7%AE%A1%E9%81%93"><strong>（2）父进程读取空管道</strong></a></li><li><a href="#3%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%88%B6%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%8F%96"><strong>（3）子进程退出，父进程读取</strong></a></li><li><a href="#4%E7%88%B6%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%86%99%E5%85%A5"><strong>（4）父进程退出，子进程写入</strong></a></li><li><a href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><strong>总结对比</strong></a></li></ul></li></ul><!-- tocstop --><h2><span id="管道通信定义">管道通信定义</span></h2><p>管道是Unix中最古老的进程间通信的形式，我们把从一个进程连接到另一个进程的一个数据流称为一个管道</p><p>在Linux中，父进程通过 <code>fork()</code> 创建子进程时，子进程会继承父进程的文件描述符表（<code>files_struct</code>），这是一种<strong>浅拷贝</strong>——父子进程的文件描述符（如 <code>fd[0]</code>）指向同一个内核文件对象（<code>struct file</code>），包括共享文件偏移量、访问模式等状态。因此，父子进程可以通过相同的文件描述符<strong>并发读写同一个文件</strong>。</p><p>若需要进程间共享数据，除了普通磁盘文件，还可以使用<strong>基于内存的通信媒介</strong>，主要包括以下两类机制：</p><ol><li><p><strong>内存文件系统（如 <code>tmpfs</code>&#x2F;<code>ramfs</code>）</strong>  </p><ul><li>数据完全驻留内存，拥有完整的文件系统抽象（<code>inode</code>、<code>file_operations</code>），但<strong>永不触盘</strong>。  </li><li>适合作为临时文件的存储媒介，但并非最优的进程通信（IPC）方式，因文件操作需经过VFS层，存在额外开销。</li></ul></li><li><p><strong>专用IPC机制</strong>  </p><ul><li><strong>匿名管道</strong>：通过 <code>pipe()</code> 创建，仅在内核缓冲区中流转数据，无文件系统关联（无 <code>inode</code>），适用于父子进程通信。  </li><li><strong>共享内存</strong>：直接映射同一物理内存区域，完全绕过文件系统，性能最高。  </li><li>其他：消息队列、信号量等。</li></ul></li></ol><p>那么，管道通信为什么需要通过内存级文件实现资源共享呢？</p><ul><li>性能：内存的访问速度远高于磁盘。使用内核缓冲区（如匿名管道或命名管道）可以避免磁盘I&#x2F;O，极大地提升数据传输的速度，减少延迟。</li><li>临时性：管道通常用于进程间的短暂通信，数据是临时的，不需要持久化存储。使用内存级文件可以在进程完成通信后自动释放资源，而使用磁盘文件则需要显式清理。</li><li>同步和并发性（最重要）：管道是一种同步通信机制，进程可以通过管道实现数据流的同步传递。使用内存级文件可以更好地管理并发和同步，而磁盘文件的使用可能导致额外的锁机制，增加复杂性和延迟。</li><li>资源效率：管道的设计是为了实现轻量级的进程间通信，仅需维护一个固定大小的内核缓冲区，而磁盘文件通常需要更多的系统资源（如磁盘空间和I&#x2F;O操作）</li></ul><p>父进程在创建管道时，为了避免读写冲突，会创建**两个文件描述符（fd）**指向同一个管道对象（内核缓冲区），分别用于读和写。这两个fd会对应两个独立的<code>struct file</code>对象（一个设置读模式，一个设置写模式）。若不分离读写，共用一个<code>struct file</code>会导致文件偏移量（<code>f_pos</code>）竞争，引发读写混乱。</p><p>当父进程<code>fork()</code>出子进程时，子进程会<strong>继承这两个fd及对应的<code>struct file</code>对象</strong>（引用计数+1），因此父子进程最初均持有读写两端。为实现单向通信：</p><ol><li>若子进程负责写，则关闭读端的fd（减少读端<code>struct file</code>的引用计数）；</li><li>若父进程负责读，则关闭写端的fd（减少写端<code>struct file</code>的引用计数）。<br>最终，读端和写端的<code>struct file</code>引用计数均降为1，确保<strong>读写完全隔离</strong>，互不干扰。</li></ol><p><img src="/img/Linux/pipe_com/fork.png" alt="fork"></p><p><img src="/img/Linux/pipe_com/pipe.png" alt="fork"></p><p>因其<strong>单向数据流</strong>特性，这一机制（两个<code>struct file</code>对象+内核缓冲区）被命名为<strong>管道</strong>。由于它仅用于进程间通信，无需磁盘存储和文件路径，故称为<strong>匿名管道</strong>（无<code>inode</code>，不关联文件系统）。</p><p>管道通信不仅仅只局限于父子进程，只要是有血缘关系的进程都可以进行管道通信，例如，父进程创建两个子进程，随后父进程将读写端都关闭了，这时两个兄弟进程的读写段都和父进程一样，故他们直接也可以构成管道通信，父进程创建的子进程，子进程再创建一个子进程，那么由于父进程和它的孙子进程共享同一个<code>file_struct</code>，故也可以构成管道通信。</p><h2><span id="管道通信使用">管道通信使用</span></h2><p><code>pipe</code> 是 Linux&#x2F;Unix 系统中用于创建<strong>匿名管道（Anonymous Pipe）<strong>的系统调用，主要用于</strong>父子进程或兄弟进程之间的单向通信</strong>。它创建一个内核缓冲区，并返回两个文件描述符（<code>fd</code>），一个用于<strong>读</strong>，一个用于<strong>写</strong>。</p><hr><h3><span id="函数原型">函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>pipefd[2]</code>：一个长度为 2 的整型数组，用于存储返回的文件描述符。<ul><li><code>pipefd[0]</code>：<strong>读端</strong>（从管道读取数据）。</li><li><code>pipefd[1]</code>：<strong>写端</strong>（向管道写入数据）。</li></ul></li></ul></li><li><strong>返回值</strong>：<ul><li>成功时返回 <code>0</code>，失败返回 <code>-1</code> 并设置 <code>errno</code>。</li></ul></li></ul><hr><h3><span id="基本使用流程">基本使用流程</span></h3><h4><span id="1创建管道"><strong>（1）创建管道</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此时：<ul><li><code>pipefd[0]</code> 可用于 <code>read()</code>（读数据）。</li><li><code>pipefd[1]</code> 可用于 <code>write()</code>（写数据）。</li></ul></li></ul><h4><span id="2fork-创建子进程"><strong>（2）<code>fork()</code> 创建子进程</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>父进程和子进程都会继承 <code>pipefd</code></strong>，因此两者都可以读写管道。</li></ul><h4><span id="3关闭不需要的文件描述符"><strong>（3）关闭不需要的文件描述符</strong></span></h4><p>为了实现<strong>单向通信</strong>，通常：</p><ul><li><strong>父进程关闭写端，只读数据</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(pipefd[<span class="number">1</span>]);  <span class="comment">// 父进程关闭写端</span></span><br></pre></td></tr></table></figure><ul><li><strong>子进程关闭读端，只写数据</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(pipefd[<span class="number">0</span>]);  <span class="comment">// 子进程关闭读端</span></span><br></pre></td></tr></table></figure><p>这样：</p><ul><li><strong>父进程只能 <code>read()</code></strong>（等待子进程写入）。</li><li><strong>子进程只能 <code>write()</code></strong>（发送数据给父进程）。</li></ul><hr><h3><span id="关键特性">关键特性</span></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>单向通信</strong></td><td>通常一个进程读，另一个进程写。</td></tr><tr><td><strong>阻塞机制</strong></td><td>- 读空管道会阻塞，直到有数据写入。<br>- 写满管道会阻塞，直到有空间。</td></tr><tr><td><strong>内核缓冲区</strong></td><td>默认大小通常为 64KB（可通过 <code>fcntl</code> 修改）。</td></tr><tr><td><strong>文件描述符继承</strong></td><td><code>fork()</code> 后子进程继承 <code>pipefd</code>，需手动关闭不需要的端。</td></tr><tr><td><strong>匿名管道</strong></td><td>无文件名，仅用于相关进程（父子&#x2F;兄弟）通信。</td></tr></tbody></table><h3><span id="使用用例">使用用例</span></h3><p>下面是一个综合测试用例，我们让父进程持续读取子进程的数据，而子进程每隔一秒写入一段数据到管道中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">global_ret</span>&#123;</span><br><span class="line">    pipe_error = <span class="number">1</span>,</span><br><span class="line">    write_error,</span><br><span class="line">    read_error,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> inbuffer[SIZE];</span><br><span class="line">    <span class="keyword">while</span>(cnt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="comment">// 告知此处将 inbuffer 作为字符串缓冲区使用</span></span><br><span class="line">        inbuffer[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">snprintf</span>(inbuffer, SIZE - <span class="number">1</span>, <span class="string">&quot;%s-%d: %s %d&quot;</span>, <span class="string">&quot;pid&quot;</span>, pid, <span class="string">&quot;hello, linux&quot;</span>, cnt);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">write</span>(fd, inbuffer, <span class="built_in">strlen</span>(inbuffer));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_ret::write_error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> outbuffer[SIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(fd, outbuffer, <span class="built_in">sizeof</span>(outbuffer));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取到了文件末尾，不再读取</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_ret::read_error);</span><br><span class="line">        &#125;</span><br><span class="line">        outbuffer[n] = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;parent process get message: &quot;</span> &lt;&lt; outbuffer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> global_ret::pipe_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端口</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 执行写操作</span></span><br><span class="line">        <span class="built_in">Write</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 退出时关闭写端口（关闭所有端口）</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="comment">// 关闭写端口</span></span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 执行读操作</span></span><br><span class="line">    <span class="built_in">Read</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 退出时关闭读端口（关闭所有端口）</span></span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(id, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 正常退出</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child process &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; exited with code: &quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 异常退出</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child process &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; killed by signal: &quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/pipe  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">parent process get message: pid-3873378: hello, linux 4</span><br><span class="line">parent process get message: pid-3873378: hello, linux 3</span><br><span class="line">parent process get message: pid-3873378: hello, linux 2</span><br><span class="line">parent process get message: pid-3873378: hello, linux 1</span><br><span class="line">parent process get message: pid-3873378: hello, linux 0</span><br><span class="line">Child process 3873378 exited with code: 0</span><br></pre></td></tr></table></figure><p>父进程的“每隔一秒读取一次”是 <strong>管道阻塞特性</strong> 和 <strong>进程调度</strong> 的自然结果：</p><p>(1) 管道的阻塞行为</p><ul><li><strong>当管道为空时</strong>，父进程的 <code>read()</code> 会<strong>阻塞</strong>（暂停执行），直到子进程写入数据。</li><li><strong>当管道有数据时</strong>，父进程的 <code>read()</code> 会立即返回数据。</li><li><strong>当所有写端关闭时</strong>，<code>read()</code> 返回 <code>0</code>（EOF）。</li></ul><p>(2) 子进程的写入节奏</p><ul><li>子进程每次写入后 <code>sleep(1)</code>，导致数据以 <strong>每秒一条</strong> 的速率进入管道。</li><li>父进程的 <code>read()</code> 会<strong>被动等待</strong>子进程的数据，因此看起来像是“同步”读取。</li></ul><p>(3) 没有“乱码”风险</p><ul><li><strong>管道是内核管理的缓冲区</strong>，读写操作是原子的，不会出现“读一半”或“写一半”的乱码问题。<ul><li>如果父进程尝试读取时子进程正在写入，内核会保证 <code>read()</code> 要么读到完整数据，要么阻塞等待。</li></ul></li></ul><h2><span id="异常情况">异常情况</span></h2><h3><span id="1子进程疯狂写入父进程延迟读取"><strong>（1）子进程疯狂写入，父进程延迟读取</strong></span></h3><ul><li><strong>现象</strong>：<br>子进程持续写入数据，直到管道缓冲区满（默认大小通常为 <strong>64KB</strong>），此时子进程的 <code>write()</code> 会<strong>阻塞</strong>，直到父进程读取数据腾出空间。</li><li><strong>原因</strong>：<br>管道是<strong>固定大小的内核缓冲区</strong>，当缓冲区满时，<code>write()</code> 会阻塞（除非设置为非阻塞模式）。</li></ul><p>阻塞是内核的<strong>流量控制机制</strong>，防止生产者（子进程）过快导致数据丢失。</p><hr><h3><span id="2父进程读取空管道"><strong>（2）父进程读取空管道</strong></span></h3><ul><li><strong>现象</strong>：<br>父进程调用 <code>read()</code> 时，若管道无数据且<strong>写端未关闭</strong>，父进程会<strong>阻塞</strong>，直到子进程写入数据。</li><li><strong>原因</strong>：<br>管道设计为<strong>同步通信</strong>，读操作默认阻塞等待数据。</li></ul><p>若需要非阻塞读取，可通过 <code>fcntl(fd, F_SETFL, O_NONBLOCK)</code> 设置，此时 <code>read()</code> 会返回 <code>-1</code> 并设置 <code>errno=EAGAIN</code>。</p><hr><h3><span id="3子进程退出父进程读取"><strong>（3）子进程退出，父进程读取</strong></span></h3><ul><li><strong>现象</strong>：<br>子进程退出后关闭写端，父进程的 <code>read()</code> <strong>返回 0</strong>（EOF），表示无更多数据，<strong>不会阻塞</strong>。</li><li><strong>原因</strong>：<br>当管道所有写端关闭时，<code>read()</code> 会立即返回 0，通知读端通信结束。</li></ul><p>返回 0 是合法的“文件结束”标志，<strong>不是错误</strong>。</p><hr><h3><span id="4父进程退出子进程写入"><strong>（4）父进程退出，子进程写入</strong></span></h3><ul><li><strong>现象</strong>：<br>父进程关闭读端后退出，子进程继续写入会触发 <strong><code>SIGPIPE</code> 信号（默认终止进程）</strong>，错误码为 <code>EPIPE</code>。</li><li><strong>原因</strong>：<br>当管道读端关闭时，写操作无意义，内核通过 <code>SIGPIPE</code> 终止子进程。</li></ul><p>若我们忽略 <code>SIGPIPE</code>（<code>signal(SIGPIPE, SIG_IGN)</code>），此时 <code>write()</code> 返回 <code>-1</code>，<code>errno=EPIPE</code>。</p><hr><h3><span id="总结对比"><strong>总结对比</strong></span></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>子进程行为</strong></th><th><strong>父进程行为</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>写端疯狂写入，缓冲区满</td><td><code>write()</code> 阻塞</td><td>正常读取</td><td>子进程暂停，直到父进程读取</td></tr><tr><td>读端读取空管道</td><td>未写入数据</td><td><code>read()</code> 阻塞</td><td>父进程暂停，直到子进程写入</td></tr><tr><td>写端关闭，读端尝试读取</td><td>已退出</td><td><code>read()</code> 返回 0</td><td>父进程检测到 EOF</td></tr><tr><td>读端关闭，写端尝试写入</td><td><code>write()</code> 触发 <code>SIGPIPE</code></td><td>已退出</td><td>子进程被终止（信号 13）</td></tr></tbody></table><ol><li><strong>管道缓冲区大小</strong>：<br>可通过 <code>fcntl(fd, F_SETPIPE_SZ, size)</code> 修改（需权限）。</li><li><strong>非阻塞模式</strong>：<br>设置 <code>O_NONBLOCK</code> 后，<code>read()</code> 和 <code>write()</code> 在无法立即完成时会返回 <code>-1</code>（<code>errno=EAGAIN</code>）。</li><li><strong>原子性保证</strong>：<br>管道保证 <strong>≤PIPE_BUF</strong>（通常 4KB）的写入是原子的，避免多进程写入交织。</li></ol><p>下面我们来验证一下父进程退出，子进程写入的现象：</p><p>父进程读取2秒后就退出，而子进程会持续写入5秒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> outbuffer[SIZE];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(fd, outbuffer, <span class="built_in">sizeof</span>(outbuffer));</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取到了文件末尾，不再读取</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(global_ret::read_error);</span><br><span class="line">        &#125;</span><br><span class="line">        outbuffer[n] = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;parent process get message: &quot;</span> &lt;&lt; outbuffer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/pipe  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">parent process get message: pid-3876701: hello, linux 4</span><br><span class="line">parent process get message: pid-3876701: hello, linux 3</span><br><span class="line">Child process 3876701 killed by signal: 13</span><br></pre></td></tr></table></figure><p>可以看到子进程被 13 号信号杀掉了</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 通信 </tag>
            
            <tag> 管道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 动态库和静态库</title>
      <link href="/2025/07/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/a_so/"/>
      <url>/2025/07/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/a_so/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%88%9B%E5%BB%BA">静态库创建</a></li><li><a href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%9B%E5%BB%BA">动态库创建</a></li></ul><!-- tocstop --><h3><span id="静态库创建">静态库创建</span></h3><p>我们先设计一个简单的头文件及实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mymath.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MY_MATH_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MY_MATH_H_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> my_errno;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divi</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mymath.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mymath.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> my_errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divi</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)&#123;</span><br><span class="line">        my_errno = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 makefile 实现库的封装：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lib=libmymath.a</span><br><span class="line"></span><br><span class="line"><span class="variable">$(lib)</span>:mymath.o</span><br><span class="line">    ar -rc <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">mymath.o:mymath.cc</span></span><br><span class="line">    g++ -c <span class="variable">$^</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o *.a</span><br><span class="line"></span><br><span class="line"><span class="section">output:</span></span><br><span class="line">    mkdir -p ./lib/<span class="keyword">include</span></span><br><span class="line">    mkdir -p ./lib/mymathlib</span><br><span class="line">    cp *.h ./lib/<span class="keyword">include</span></span><br><span class="line">    cp *.a ./lib/mymathlib</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  make                                                                                                                                2 ↵</span><br><span class="line">g++ -c mymath.cc</span><br><span class="line">ar -rc libmymath.a mymath.o</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  make output</span><br><span class="line">mkdir -p ./lib/include</span><br><span class="line">mkdir -p ./lib/mymathlib</span><br><span class="line">cp *.h ./lib/include</span><br><span class="line">cp *.a ./lib/mymathlib</span><br></pre></td></tr></table></figure><p>这样一来，静态库就被存放到了 .&#x2F;lib&#x2F;mymathlib 下面，接下来我们写一段代码试一试能不能将该库使用起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mymath.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">divi</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, errno: &quot;</span> &lt;&lt; my_errno &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  g++ -o main.o main.cc</span><br><span class="line">/usr/bin/ld: /tmp/ccD6e3Zl.o: warning: relocation against `my_errno&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/ccD6e3Zl.o: in function `main&#x27;:</span><br><span class="line">main.cc:(.text+0x13): undefined reference to `divi(int, int)&#x27;</span><br><span class="line">/usr/bin/ld: main.cc:(.text+0x48): undefined reference to `my_errno&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>编译器无法找到我们定义的函数，这是因为我们并没有指定我们的文件所在路径，于是我们加上 -I选项 从而指定我们的头文件所在路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  g++ -o main.o main.cc -I ./lib/include/</span><br><span class="line">/usr/bin/ld: /tmp/cc3M4mQd.o: warning: relocation against `my_errno&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/cc3M4mQd.o: in function `main&#x27;:</span><br><span class="line">main.cc:(.text+0x13): undefined reference to `divi(int, int)&#x27;</span><br><span class="line">/usr/bin/ld: main.cc:(.text+0x48): undefined reference to `my_errno&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>但是我们并没有告诉编译器我们的动态库在哪里，于是我们通过 -L 指定库路径，通过 -l 指定库名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  g++ -o main.o main.cc -I ./lib/include/ -L ./lib/mymathlib/ -lmymath</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">-1, errno: 1</span><br></pre></td></tr></table></figure><p>可以看到，这么一来，静态库就被我们调用起来了，需要注意的是，库名指定是需要去掉前缀（lib）和后缀（.a）的，且建议将 -l 和库名写在一起</p><p>而若我们直接将对应的头文件和库文件链接到系统当中，就可以直接使用该头文件了，但需要注意的是，我们仍然需要指定库名，毕竟你这也不是原生库，编译器是不知道你这个库在哪里的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  sudo ln -s /home/ljx/linux_review/dy_st_lib/lib/mymathlib/libmymath.a /lib64/libmymath.a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否链接成功</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  ll /lib64/libmymath.a</span><br><span class="line">lrwxrwxrwx 1 root root 58 Jul 19 17:45 /lib64/libmymath.a -&gt; /home/ljx/linux_review/dy_st_lib/lib/mymathlib/libmymath.a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否链接成功</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  sudo ln -s /home/ljx/linux_review/dy_st_lib/lib/include/mymath.h /usr/include/mymath.h</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  ll /usr/include/mymath.h</span><br><span class="line">lrwxrwxrwx 1 root root 53 Jul 19 17:46 /usr/include/mymath.h -&gt; /home/ljx/linux_review/dy_st_lib/lib/include/mymath.h</span><br></pre></td></tr></table></figure><p>然后我们就可以直接编译该代码了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  g++ -o main.o main.cc -lmymath</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib</span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">-1, errno: 1</span><br></pre></td></tr></table></figure><h3><span id="动态库创建">动态库创建</span></h3><p>同样，先设计一个简单的头文件和实现方法</p><p>mylog 方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylog.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYLOG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MYLOG_H_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mylog.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mylog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 转换为time_t类型</span></span><br><span class="line">    std::<span class="type">time_t</span> now_time = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    <span class="comment">// 转换为本地时间</span></span><br><span class="line">    std::tm* local_time = std::<span class="built_in">localtime</span>(&amp;now_time);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">asctime</span>(local_time) &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myprint 方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myprint.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYPRINT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MYPRINT_H_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// myprint.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myprint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样通过 makefile 实现对动态库的封装</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static_lib=libmymath.a</span><br><span class="line">dynamic_lib=libmymethod.so</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:<span class="variable">$(static_lib)</span> <span class="variable">$(dynamic_lib)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(static_lib)</span>:mymath.o</span><br><span class="line">    ar -rc <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">mymath.o:mymath.cc</span></span><br><span class="line">    g++ -c <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(dynamic_lib)</span>:mylog.o myprint.o</span><br><span class="line">    g++ -fPIC -shared -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">mylog.o:mylog.cc</span></span><br><span class="line">    g++ -fPIC -c <span class="variable">$^</span></span><br><span class="line"><span class="section">myprint.o:myprint.cc</span></span><br><span class="line">    g++ -fPIC -c <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o *.a *.so mylib</span><br><span class="line"></span><br><span class="line"><span class="section">output:</span></span><br><span class="line">    mkdir -p ./mylib/<span class="keyword">include</span></span><br><span class="line">    mkdir -p ./mylib/lib</span><br><span class="line">    cp *.h ./mylib/<span class="keyword">include</span></span><br><span class="line">    cp *.a ./mylib/lib</span><br><span class="line">    cp *.so ./mylib/lib</span><br></pre></td></tr></table></figure><p>需要注意的是，编译动态库是需要与位置无关码的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  make      </span><br><span class="line">g++ -c mymath.cc</span><br><span class="line">ar -rc libmymath.a mymath.o</span><br><span class="line">g++ -fPIC -c mylog.cc</span><br><span class="line">g++ -fPIC -c myprint.cc</span><br><span class="line">g++ -fPIC -shared -o libmymethod.so mylog.o myprint.o</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  make output</span><br><span class="line">mkdir -p ./mylib/include</span><br><span class="line">mkdir -p ./mylib/lib</span><br><span class="line">cp *.h ./mylib/include</span><br><span class="line">cp *.a ./mylib/lib</span><br><span class="line">cp *.so ./mylib/lib</span><br></pre></td></tr></table></figure><p>下面是测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mymath.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myprint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">divi</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, errno: &quot;</span> &lt;&lt; my_errno &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">mylog</span>(<span class="string">&quot;hello, linux!&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, dynamic library!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们尝试编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  g++ -o main.o main.cc -I ./mylib/lib/include/ -L ./mylib/lib/ -lmymath -lmymethod</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">./main.o: error while loading shared libraries: libmymethod.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>我们会发现，程序加载是需要静态库的，而我们并没有指定静态库所在路径，以下是指定静态库路径的四种方法</p><p>1、将动态库拷贝到 &#x2F;lib64 路径下</p><p>该方法和软链接相似，因此不做示例演示</p><p>2、将动态库软链接到 &#x2F;lib64 路径下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  sudo ln -s /home/ljx/linux_review/dy_st_lib/mylib/lib/libmymethod.so /usr/lib/libmymethod.so      </span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  ll /usr/lib/libmymethod.so</span><br><span class="line">lrwxrwxrwx 1 root root 57 Jul 19 22:56 /usr/lib/libmymethod.so -&gt; /home/ljx/linux_review/dy_st_lib/mylib/lib/libmymethod.so</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">-1, errno: 1</span><br><span class="line">Sat Jul 19 22:56:40 2025</span><br><span class="line">: hello, linux!</span><br><span class="line">hello, dynamic library!</span><br></pre></td></tr></table></figure><p>3、将环境变量导入 LD_LIBRARY_PATH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  export LD_LIBRARY_PATH=/home/ljx/linux_review/dy_st_lib/mylib/lib:$LD_LIBRARY_PATH</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/dy_st_lib  </span><br><span class="line">╰─➤  ./main.o</span><br><span class="line">-1, errno: 1</span><br><span class="line">Sat Jul 19 22:58:28 2025</span><br><span class="line">: hello, linux!</span><br><span class="line">hello, dynamic library!</span><br></pre></td></tr></table></figure><p>4、将路径写入 &#x2F;etc&#x2F;ld.so.conf.d&#x2F; 目录下的任意一个文件当中，然后 ldconfig</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文件软链接与硬链接</title>
      <link href="/2025/07/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6/soft_hard_link/"/>
      <url>/2025/07/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6/soft_hard_link/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-inode">什么是 inode</a><ul><li><a href="#inode-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8">Inode 的核心作用</a></li><li><a href="#inode-%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84">Inode 的底层结构</a></li><li><a href="#inode-%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%88%B0%E6%96%87%E4%BB%B6">Inode 如何关联到文件</a></li><li><a href="#inode-%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86">Inode 的分配与管理</a></li></ul></li><li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%AE%9E%E7%8E%B0">硬链接的实现</a></li><li><a href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E7%9A%84%E5%AE%9E%E7%8E%B0">软链接（符号链接）的实现</a></li><li><a href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E7%9A%84%E5%BA%95%E5%B1%82%E8%A1%A8%E7%8E%B0">关键区别的底层表现</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a><ul><li><a href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">软链接应用场景</a></li><li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">硬链接应用场景</a></li></ul></li><li><a href="#%E9%93%BE%E6%8E%A5%E7%9B%AE%E5%BD%95">链接目录</a></li></ul><!-- tocstop --><h2><span id="什么是-inode">什么是 inode</span></h2><p><strong>Inode</strong>（Index Node，索引节点）是类 Unix 文件系统（如 ext4、XFS、Btrfs 等）中用于<strong>管理文件元数据和数据块指针的核心数据结构</strong>。它是操作系统在磁盘上定位和操作文件的真实凭据（而非文件名）。</p><h3><span id="inode-的核心作用">Inode 的核心作用</span></h3><ol><li>存储文件元数据**<ul><li>不包含文件名，但包含所有其他文件属性：</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件类型（普通文件/目录/符号链接/设备文件等）</span><br><span class="line">权限（rwx）</span><br><span class="line">所有者（UID/GID）</span><br><span class="line">大小（字节数）</span><br><span class="line">时间戳（创建/修改/访问时间）</span><br><span class="line">链接计数（硬链接数）</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li>指向文件数据块<ul><li>记录文件内容在磁盘上的物理存储位置（数据块指针）。</li></ul></li><li>唯一标识文件<ul><li>每个 inode 有一个唯一的编号（inode number），操作系统通过 inode 号而非文件名访问文件。</li></ul></li></ol><hr><h3><span id="inode-的底层结构">Inode 的底层结构</span></h3><p>在 ext4 文件系统中，inode 是一个固定大小的结构（通常为 256 字节），其关键字段如下：</p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>i_mode</code></td><td>文件类型 + 权限（如 <code>0o100644</code> 表示普通文件，权限 <code>rw-r--r--</code>）</td></tr><tr><td><code>i_uid</code> &#x2F; <code>i_gid</code></td><td>所有者用户 ID 和组 ID</td></tr><tr><td><code>i_size</code></td><td>文件大小（字节）</td></tr><tr><td><code>i_atime</code></td><td>最后访问时间</td></tr><tr><td><code>i_mtime</code></td><td>最后修改时间</td></tr><tr><td><code>i_ctime</code></td><td>inode 状态变更时间</td></tr><tr><td><code>i_links_count</code></td><td>硬链接计数（删除文件时仅当此值为 0 才释放数据块）</td></tr><tr><td><code>i_block[15]</code></td><td>数据块指针（直接&#x2F;间接指向磁盘块，符号链接时直接存储目标路径）</td></tr><tr><td><code>i_flags</code></td><td>标志位（如加密&#x2F;压缩&#x2F;内联数据等特性）</td></tr></tbody></table><hr><h3><span id="inode-如何关联到文件">Inode 如何关联到文件</span></h3><ol><li><p>目录的作用</p><ul><li>目录本质是一个<strong>映射表</strong>，存储 <code>文件名 -&gt; inode 编号</code> 的对应关系。  </li><li>例如目录 <code>/home</code> 的内容可能如下：</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.    -&gt; inode 1234  (当前目录)</span><br><span class="line">..   -&gt; inode 2     (父目录)</span><br><span class="line">alice -&gt; inode 5678 (用户目录)</span><br><span class="line">bob   -&gt; inode 9012</span><br></pre></td></tr></table></figure></li><li><p>文件访问流程<br>当访问 <code>/home/alice/file.txt</code> 时：</p><ul><li>从根目录 <code>/</code>（inode 通常为 2）找到 <code>home</code> 的 inode 编号  </li><li>读取 <code>home</code> 的 inode，定位其数据块，找到 <code>alice</code> 的 inode 编号  </li><li>最终找到 <code>file.txt</code> 的 inode，进而访问文件内容。</li></ul></li></ol><hr><h3><span id="inode-的分配与管理">Inode 的分配与管理</span></h3><ol><li><p>inode Bitmap </p><ul><li>文件系统用位图（Bitmap）标记 inode 的使用状态（1&#x3D;已分配，0&#x3D;空闲）。  </li><li>创建文件时扫描 Bitmap 分配空闲 inode。</li></ul></li><li><p>inode 表（inode Table）</p><ul><li>磁盘上的固定区域，存储所有 inode 结构的数组。  </li><li>通过 inode 编号可直接计算其物理位置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inode 物理位置 = inode_table_start + (inode_number * inode_size)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>链接计数（<code>i_links_count</code>）</p><ul><li>硬链接会增加该计数，删除文件时计数减 1。  </li><li>当计数归零时，inode 和数据块被释放。</li></ul></li></ol><p>总结如下：</p><ul><li><strong>Inode 是文件的唯一身份证</strong>，文件名只是人类可读的别名。  </li><li>通过 inode 可以高效管理文件元数据和数据存储位置。  </li><li>理解 inode 是掌握文件系统工作原理（如软硬链接、文件删除恢复等）的基础。</li></ul><h2><span id="硬链接的实现">硬链接的实现</span></h2><ul><li><strong>创建过程</strong>：当创建硬链接时，系统会在目标目录中添加一个新的文件名条目，这个条目指向与被链接文件相同的 inode。</li><li><strong>inode 变化</strong>：inode 中的”链接计数”（link count）会加1。这个计数器记录有多少个目录项指向该 inode。</li><li><strong>特点</strong>：<ul><li>硬链接与原文件完全平等，无法区分谁是原始文件</li><li>只有当链接计数降为0时，文件数据才会被真正删除</li><li>不能跨文件系统（因为不同文件系统有独立的 inode 空间）</li><li>不能链接目录（防止循环链接）</li></ul></li></ul><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  ln test.cc test1.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 2 ljx ljx 0 Jul 19 12:34 test1.cc</span><br><span class="line">-rw-r--r-- 2 ljx ljx 0 Jul 19 12:34 test.cc</span><br></pre></td></tr></table></figure><p>可以看到，硬链接会使得硬链接引用计数加一，而我们若删掉原来的硬链接原副本，会发现被硬链接的副本引用技术变为1，因此，一个文件真正被删除实际是引用计数从1变成0的时候：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  rm test.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 ljx ljx 0 Jul 19 12:28 test1.cc</span><br></pre></td></tr></table></figure><h2><span id="软链接符号链接的实现">软链接（符号链接）的实现</span></h2><ul><li><strong>创建过程</strong>：创建软链接时，系统会：<ol><li>分配一个新的 inode 和新的文件（这个文件的内容是目标路径字符串）</li><li>在目录中添加一个特殊标记的条目，表示这是一个符号链接</li></ol></li><li><strong>inode 变化</strong>：<ul><li>原始文件的 inode 不受影响</li><li>新创建的符号链接有自己的 inode，其中存储了目标路径信息</li></ul></li><li><strong>特点</strong>：<ul><li>是一个独立的文件（有自己的 inode），只是内容存储了目标路径</li><li>可以跨文件系统</li><li>可以链接目录</li><li>如果目标文件被删除，链接会”悬空”（dangling）</li></ul></li></ul><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  ln -s test1.cc test2.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 ljx ljx 0 Jul 19 12:34 test1.cc</span><br><span class="line">lrwxrwxrwx 1 ljx ljx 8 Jul 19 12:35 test2.cc -&gt; test1.cc</span><br></pre></td></tr></table></figure><p>此时我们若删除原副本，将会导致链接失效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  rm test1.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 ljx ljx 8 Jul 19 12:35 test2.cc -&gt; test1.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson5</span><br><span class="line">╰─➤  cat test2.cc</span><br><span class="line">cat: test2.cc: No such file or directory</span><br></pre></td></tr></table></figure><h2><span id="关键区别的底层表现">关键区别的底层表现</span></h2><table><thead><tr><th>特性</th><th>硬链接</th><th>软链接</th></tr></thead><tbody><tr><td>inode</td><td>与原文件相同</td><td>分配新的 inode</td></tr><tr><td>存储内容</td><td>直接指向文件数据</td><td>存储目标文件的路径字符串</td></tr><tr><td>跨文件系统</td><td>不可能</td><td>可能</td></tr><tr><td>链接目录</td><td>通常不允许</td><td>允许</td></tr><tr><td>目标删除后</td><td>仍可访问（直到链接计数为0）</td><td>链接失效（”悬空”）</td></tr><tr><td>文件大小</td><td>与原文件相同</td><td>等于路径字符串的长度</td></tr><tr><td>权限</td><td>与原文件相同</td><td>通常是全开放（777）</td></tr></tbody></table><p>##应用场景：</p><h2><span id="应用场景">应用场景</span></h2><h3><span id="软链接应用场景">软链接应用场景</span></h3><p>在 Window 当中，软链接广泛应用于快捷方式，我们桌面上的图标之所以可以直接被打开，是因为这些图标本质上是将可执行程序的路径软链接到了桌面</p><p><img src="/img/Linux/soft_hard_link/soft.png" alt="soft"></p><h3><span id="硬链接应用场景">硬链接应用场景</span></h3><p>Linux 当中的文件管理就使用到了硬链接，每个目录下有两个隐藏文件：“.”，“..”分别代表当前路径和上一个目录的路径，因此，一个文件夹下每多一个目录，该文件夹就会多一个硬链接引用计数</p><h2><span id="链接目录">链接目录</span></h2><p>硬链接是不允许链接目录的</p><p>硬链接的本质是 <strong>多个文件名指向同一个 inode</strong>，而目录在文件系统中具有特殊结构，允许硬链接目录会导致以下问题：</p><p>（1）目录树循环问题</p><ul><li>目录结构在文件系统中是一棵 <strong>有向无环图（DAG）</strong>，通过硬链接目录可能形成循环引用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 假设允许硬链接目录：</span><br><span class="line">ln /home/user/dir /home/user/dir/link_to_self</span><br></pre></td></tr></table></figure><p>  此时：</p><ul><li><code>/home/user/dir</code> 包含 <code>link_to_self</code>，而 <code>link_to_self</code> 又指向 <code>/home/user/dir</code>。</li><li>遍历目录时会进入无限循环（如 <code>find</code>、<code>ls -R</code> 等命令会崩溃）。</li></ul><p>（2）父目录引用计数混乱</p><ul><li><p>每个目录的 inode 中都有一个 <code>..</code> 条目指向父目录。</p></li><li><p>如果允许硬链接目录，<code>..</code> 应该指向哪个父目录？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dir1/subdir (硬链接到 /dir2/subdir)</span><br></pre></td></tr></table></figure><ul><li><code>subdir</code> 的 <code>..</code> 应该是 <code>/dir1</code> 还是 <code>/dir2</code>？无法确定。</li></ul></li></ul><p>（3）文件系统一致性难以维护</p><ul><li>文件系统工具（如 <code>fsck</code>）依赖目录树的严格父子关系检测错误。</li><li>硬链接目录会破坏这种关系，导致恢复困难。</li></ul><p>当然，<code>.</code> 和 <code>..</code> 是硬链接</p><ul><li>每个目录的 <code>.</code>（当前目录）和 <code>..</code>（父目录）是文件系统内部维护的硬链接：</li><li>这是唯一合法的目录硬链接，由文件系统自身管理。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件缓冲区</title>
      <link href="/2025/07/18/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6/file_buffer/"/>
      <url>/2025/07/18/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6/file_buffer/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA">理解文件缓冲区</a></li><li><a href="#%E6%A0%87%E5%87%86io%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E7%B1%BB%E5%9E%8B">标准I&#x2F;O的缓冲区类型</a></li><li><a href="#%E5%86%8D%E7%9C%8B%E5%BC%80%E5%A4%B4%E4%BB%A3%E7%A0%81">再看开头代码</a><ul><li><a href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E8%A1%8C%E7%BC%93%E5%86%B2">标准输出行缓冲</a></li><li><a href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%E5%85%A8%E7%BC%93%E5%86%B2">文件输出全缓冲</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8">文件缓冲区的作用</a></li></ul><!-- tocstop --><p>首先来看一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str1 = <span class="string">&quot;fwrite: hello, linux!\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str2 = <span class="string">&quot;write: hello, linux!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// C/C++提供的文件接口</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf: hello, linux!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;fprintf: hello, linux!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(str1, <span class="built_in">strlen</span>(str1), <span class="number">1</span>, stdout);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cout: hello, linux!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linux 系统接口</span></span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, str2, <span class="built_in">strlen</span>(str2));</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们直接输出的时候结果是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./file_buf.o</span><br><span class="line">printf: hello, linux!</span><br><span class="line">fprintf: hello, linux!</span><br><span class="line">fwrite: hello, linux!</span><br><span class="line">cout: hello, linux!</span><br><span class="line">write: hello, linux!</span><br></pre></td></tr></table></figure><p>但当我们将输出重定向到文件中去是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./file_buf.o &gt; log.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  cat log.txt</span><br><span class="line">write: hello, linux!</span><br><span class="line">printf: hello, linux!</span><br><span class="line">fprintf: hello, linux!</span><br><span class="line">fwrite: hello, linux!</span><br><span class="line">cout: hello, linux!</span><br><span class="line">printf: hello, linux!</span><br><span class="line">fprintf: hello, linux!</span><br><span class="line">fwrite: hello, linux!</span><br><span class="line">cout: hello, linux!</span><br></pre></td></tr></table></figure><p>我们会发现，有些数据不仅输出了两遍，而且 write 函数明明是后面才打印的，现在却变成了最先开始被打印出来</p><p>如果你不是很清楚原因的话，这篇文章将会对你有帮助</p><h2><span id="理解文件缓冲区">理解文件缓冲区</span></h2><p>什么是缓冲区？</p><p>缓冲区是内存空间的⼀部分。也就是说，在内存空间中预留了⼀定的存储空间，这些存储空间用来缓冲输入或输出的数据，<br>这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区</p><p>那么，我们为什么要引入缓冲区机制呢？</p><p>读写文件时，如果不会开辟对文件操作的缓冲区，直接通过系统调用对磁盘进⾏操作(读、写等)，那么每次对文件进行⼀次读写操作时，都需要使用读写系统调用来处理此操作，即需要执行⼀次系统调用，执行⼀次系统调用将涉及到CPU状态的切换，即从用户空间切换到内核空间，实现进程上下文的切换，这将损耗⼀定的CPU时间，频繁的磁盘访问对程序的执行效率造成很大的影响。</p><p>为了减少使用系统调用的次数，提高效率，我们就可以采用缓冲机制。比如我们从磁盘里取信息，可以在磁盘文件进行操作时，可以⼀次从文件中读出大量的数据到缓冲区中，以后对这部分的访问就不需要再使用系统调用了，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提⾼计算机的运行速度。</p><p>又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。可以看出，缓冲区就是⼀块内存区，它用在输⼊输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调⼯作，避免低速的输⼊输出设备占用CPU，解放出CPU，使其能够高效率工作。</p><p>不论是在语言层还是系统层都存在缓冲区，系统层的缓冲区是为了优化硬件交互和调度，因此即使应用层直接调用write()，数据也可能先被放入内核的页缓存，由内核决定何时写入磁盘。</p><h2><span id="标准ix2fo的缓冲区类型">标准I&#x2F;O的缓冲区类型</span></h2><p>标准I&#x2F;O提供了3种类型的缓冲区：</p><ol><li><p><strong>全缓冲区</strong>  </p><ul><li>这种缓冲方式要求填满整个缓冲区后才进行I&#x2F;O系统调用操作。  </li><li>对于磁盘文件的操作通常使用全缓冲的方式访问。</li></ul></li><li><p><strong>行缓冲区</strong>  </p><ul><li>在行缓冲情况下，当在输入和输出中遇到换行符时，标准I&#x2F;O库函数将会执行系统调用操作。  </li><li>当所操作的流涉及一个终端时（例如标准输入和标准输出），使用行缓冲方式。  </li><li>因为标准I&#x2F;O库每行的缓冲区长度是固定的，所以只要填满了缓冲区，即使还没有遇到换行符，也会执行I&#x2F;O系统调用操作。  </li><li>默认行缓冲区的大小为1024。</li></ul></li><li><p><strong>无缓冲区</strong>  </p><ul><li>无缓冲区是指标准I&#x2F;O库不对字符进行缓存，直接调用系统调用。  </li><li>标准出错流<code>stderr</code>通常是不带缓冲区的，这使得出错信息能够尽快地显示出来。</li></ul></li></ol><p>除此之外，当缓冲区满了，或执行 flush 语句，或进程结束的时候，C语言都会将缓冲区的内容利用 write 接口写入内存</p><p>因此，如果我们不加换行符将数据输出到标准输出，而我们在进程退出前将标准输出文件关闭，就会导致数据无法被打印到显示屏上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf: hello, linux!&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果我们让数据打印时换行，但是将标准输出重定向到普通磁盘文件，就会发现结果无法被打印到文件当中，因为当我们选择输出到文件的时候，缓冲区刷新策略就是全缓冲区策略，<br>这意味着只有在缓冲区被写满或进程结束的时候数据才会被写入，而我们在保证数据足够短的条件下让重定向被关闭，就会发现数据无法被打印到文件当中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仅仅多了个换行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf: hello, linux!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接打印会因为行刷新策略使得数据被打印到显示屏上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./file_buf.o</span><br><span class="line">printf: hello, linux!</span><br></pre></td></tr></table></figure><p>将输出重定向到普通文件后，因为刷新策略为全缓冲，导致文件里没有被写入任何数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./file_buf.o &gt; test.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  cat test.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤</span><br></pre></td></tr></table></figure><h2><span id="再看开头代码">再看开头代码</span></h2><p>开头的代码为什么会出现这种现象呢？</p><p>情景再现：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str1 = <span class="string">&quot;fwrite: hello, linux!\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str2 = <span class="string">&quot;write: hello, linux!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// C/C++提供的文件接口</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf: hello, linux!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;fprintf: hello, linux!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(str1, <span class="built_in">strlen</span>(str1), <span class="number">1</span>, stdout);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cout: hello, linux!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linux 系统接口</span></span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, str2, <span class="built_in">strlen</span>(str2));</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们直接输出的时候结果是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./file_buf.o</span><br><span class="line">printf: hello, linux!</span><br><span class="line">fprintf: hello, linux!</span><br><span class="line">fwrite: hello, linux!</span><br><span class="line">cout: hello, linux!</span><br><span class="line">write: hello, linux!</span><br></pre></td></tr></table></figure><p>但当我们将输出重定向到文件中去是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./file_buf.o &gt; log.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  cat log.txt</span><br><span class="line">write: hello, linux!</span><br><span class="line">printf: hello, linux!</span><br><span class="line">fprintf: hello, linux!</span><br><span class="line">fwrite: hello, linux!</span><br><span class="line">cout: hello, linux!</span><br><span class="line">printf: hello, linux!</span><br><span class="line">fprintf: hello, linux!</span><br><span class="line">fwrite: hello, linux!</span><br><span class="line">cout: hello, linux!</span><br></pre></td></tr></table></figure>    </div></div><h3><span id="标准输出行缓冲">标准输出行缓冲</span></h3><p>首先，当我们让直接让数据打印到标准输出的时候，C&#x2F;C++采用的是行刷新策略，因为数据打印都有空行，导致每次打印的数据会直接被语言刷新出去，因此现象符合你的预期</p><h3><span id="文件输出全缓冲">文件输出全缓冲</span></h3><p>当我们将标准输出重定向到普通磁盘文件的时候，数据的缓冲方式由行缓冲变成了全缓冲，而我们放在缓冲区的数据就不会被立即刷新，即便是在 fork 之后，这些数据<br>会在进程退出之后统一被刷新写到文件当中</p><p>但是 fork 的时候，父子数据会发生写时拷贝，所以当父进程或子进程任意一方刷新缓冲区（进程退出）的时候触发写时拷贝，另一方在退出进程的时候同样会刷新缓冲区（另一方<br>不会发生写时拷贝，因为这段缓冲区数据在页表当中引用计数为1），而 write 不会等进程退出时才刷新缓冲区，这样我们就会发现 write 先被写入，而用户层的接口在进程退出时<br>才依次被写入文件</p><h4><span id="缓冲模式差异">缓冲模式差异</span></h4><table><thead><tr><th>输出方式</th><th>缓冲类型（终端）</th><th>缓冲类型（重定向到文件）</th><th>刷新时机</th></tr></thead><tbody><tr><td><code>printf</code>&#x2F;<code>fprintf</code></td><td>行缓冲</td><td>全缓冲</td><td>行缓冲：遇到 <code>\n</code> 或缓冲区满；全缓冲：缓冲区满或程序退出</td></tr><tr><td><code>fwrite</code></td><td>行缓冲</td><td>全缓冲</td><td>同上</td></tr><tr><td><code>cout</code></td><td>行缓冲</td><td>全缓冲</td><td>同上（C++ 的 <code>ostream</code> 默认与 <code>stdout</code> 同步）</td></tr><tr><td><code>write</code></td><td>无缓冲</td><td>无缓冲</td><td>立即写入内核缓冲区</td></tr></tbody></table><ul><li><strong>终端设备</strong>：默认行缓冲（用户友好，逐行显示）。  </li><li><strong>磁盘文件</strong>：默认全缓冲（减少频繁 I&#x2F;O，提升性能）。</li></ul><hr><h4><span id="fork-对缓冲区的关键影响"><code>fork()</code> 对缓冲区的关键影响</span></h4><p>当程序调用 <code>fork()</code> 时：</p><ol><li><p>用户层缓冲区（C&#x2F;C++库维护）</p><ul><li>全缓冲模式下，数据仍在用户空间缓冲区中，未写入内核。  </li><li><code>fork()</code> 会复制父进程的整个地址空间（包括缓冲区），触发 <strong>写时拷贝（Copy-On-Write）</strong>。  </li><li><strong>父&#x2F;子进程退出时</strong>：各自刷新缓冲区，导致数据被写入文件两次。</li></ul></li><li><p>系统调用 <code>write</code></p><ul><li>无缓冲，直接进入内核缓冲区，<code>fork()</code> 前已完成写入。  </li><li>不受 <code>fork()</code> 影响，仅输出一次。</li></ul></li><li><p><code>fork()</code> 后的初始状态  </p><ul><li>父进程和子进程共享相同的物理内存页（包括用户层缓冲区），内核将这些页标记为 <strong>写时拷贝</strong>（引用计数 &gt; 1）。  </li><li>此时缓冲区数据（如 <code>printf</code> 的内容）尚未被修改，父子进程的页表指向同一物理内存。</li></ul></li><li><p>某一方刷新缓冲区（如父进程退出）</p><ul><li>刷新操作（如 <code>exit()</code> 调用 <code>fflush()</code>）会 <strong>修改缓冲区</strong>（清空内容并写入文件）。  </li><li>内核检测到该内存页是 COW 的，触发 <strong>写时拷贝</strong>：  <ul><li>为父进程分配新的物理页，复制原数据。  </li><li>父进程修改新页（清空缓冲区），子进程仍引用旧页（原数据）。  </li><li><strong>旧页的引用计数降为 1</strong>（仅子进程持有）。</li></ul></li></ul></li><li><p>另一方退出时（如子进程退出）**</p><ul><li>子进程刷新缓冲区时，内核检查其引用的内存页：  <ul><li>发现该页 <strong>引用计数 &#x3D; 1</strong>（无共享），无需 COW，直接修改并写入文件。</li></ul></li><li>因此子进程的刷新操作不会重复触发写时拷贝。</li></ul></li></ol><h2><span id="文件缓冲区的作用">文件缓冲区的作用</span></h2><p>1.提高效率<br>就好比送快递，快递员不可能只送你一个人的快递，而是等库存足够多的时候再将快递送出去，语言层次的用户级缓冲区使得数据不会频繁交给内核区，避免了两态之间的频繁交换</p><p>2.配合格式化<br>除了效率问题，因为 C&#x2F;C++ 需要对你的数据做格式化（如 %d，%s），因此可以利用缓冲区先将未格式化字符串存入缓冲区，再根据可变参数模板中的参数进行数据格式化</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件重定向</title>
      <link href="/2025/07/18/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6/file_dup/"/>
      <url>/2025/07/18/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6/file_dup/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#dup2">dup2</a><ul><li><a href="#1-dup2-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B">1. <code>dup2</code> 函数原型</a></li><li><a href="#2-dup2-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD">2. <code>dup2</code> 的核心功能</a></li><li><a href="#3-%E5%85%B3%E9%94%AE%E8%A1%8C%E4%B8%BA">3. 关键行为</a></li><li><a href="#4-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">4. 典型应用场景</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">实现原理</a></li></ul></li><li><a href="#%E5%86%8D%E7%9C%8Bshell%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6%E5%8F%B7%E4%BD%BF%E7%94%A8">再看shell重定向符号使用</a></li></ul><!-- tocstop --><p>先来看一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello, linux!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将“标准输出文件”关闭了，我们再通过 cout 打印数据的时候，会发现数据被打印到了 test.txt 文件当中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  cat test.txt</span><br><span class="line">hello, linux!</span><br></pre></td></tr></table></figure><p>这是因为标准输出文件被关闭后，文件描述符 1 变成空闲的，那么 test.txt 文件就会使用 1 号文件描述符，最终就导致 cout 函数打印的数据被 test.txt 文件接收到，而<br>这正是文件重定向的原理</p><p>我们通过这种方式确实实现了重定向，但若每次通过这种方式来进行文件的重定向，未免太过麻烦，而且可读性极差，此时，我们就可以用到系统提供的一个重定向接口：</p><h2><span id="dup2">dup2</span></h2><h3><span id="1-dup2-函数原型">1. <code>dup2</code> 函数原型</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>oldfd</code></strong></td><td>源文件描述符（必须是一个已打开的有效 fd）</td></tr><tr><td><strong><code>newfd</code></strong></td><td>目标文件描述符（由用户指定，范围通常是 <code>0</code> ~ <code>RLIMIT_NOFILE-1</code>）</td></tr></tbody></table><h4><span id="返回值">返回值</span></h4><ul><li>成功：返回 <strong><code>newfd</code></strong>（即复制后的新文件描述符）。</li><li>失败：返回 <code>-1</code>，并设置 <code>errno</code>（常见错误如 <code>EBADF</code> 无效 fd，<code>EINTR</code> 被信号中断）。</li></ul><hr><h3><span id="2-dup2-的核心功能">2. <code>dup2</code> 的核心功能</span></h3><ol><li><p><strong>复制文件描述符</strong>：</p><ul><li>将 <code>oldfd</code> 指向的文件表项复制到 <code>newfd</code>。</li><li>如果 <code>newfd</code> 已经打开，<code>dup2</code> 会 <strong>先关闭 <code>newfd</code></strong>，再复制。</li></ul></li><li><p>文件描述符重定向：</p><ul><li>常用于将标准输入（<code>0</code>）、标准输出（<code>1</code>）、标准错误（<code>2</code>）重定向到文件或管道。</li></ul></li></ol><hr><h3><span id="3-关键行为">3. 关键行为</span></h3><ul><li><strong><code>newfd == oldfd</code></strong>：直接返回 <code>newfd</code>（无操作）。</li><li><strong><code>newfd</code> 已打开</strong>：自动关闭 <code>newfd</code>，再复制 <code>oldfd</code>。</li><li><strong><code>oldfd</code> 无效</strong>：返回 <code>-1</code>（<code>errno = EBADF</code>）。</li></ul><hr><h3><span id="4-典型应用场景">4. 典型应用场景</span></h3><h4><span id="1-重定向标准输出到文件">(1) 重定向标准输出到文件</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将标准输出（fd=1）重定向到文件</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(fd, STDOUT_FILENO) == <span class="number">-1</span>) &#123;  <span class="comment">// STDOUT_FILENO = 1</span></span><br><span class="line">        perror(<span class="string">&quot;dup2 failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);  <span class="comment">// 关闭原始 fd（因为 1 已经指向文件）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to output.txt\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行后</strong>：<code>printf</code> 的内容会写入 <code>output.txt</code>，而非屏幕。</p><hr><h4><span id="2-实现管道pipe通信">(2) 实现管道（Pipe）通信</span></h4><p>该示例设计后面内容，感兴趣可以展开看看：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipefd);  <span class="comment">// 创建管道</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);  <span class="comment">// 关闭读端</span></span><br><span class="line">        dup2(pipefd[<span class="number">1</span>], STDOUT_FILENO);  <span class="comment">// 将标准输出重定向到管道写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// 执行 ls -l</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);  <span class="comment">// 关闭写端</span></span><br><span class="line">        dup2(pipefd[<span class="number">0</span>], STDIN_FILENO);   <span class="comment">// 将标准输入重定向到管道读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        execlp(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;grep&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// 执行 grep test</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能：将 <code>ls -l</code> 的输出通过管道传递给 <code>grep test</code>。</p>    </div></div><h3><span id="实现原理">实现原理</span></h3><p>dup2 函数的实现原理很简单，我们先来看看这张图：</p><p><img src="/img/Linux/file_dup/dup2.png" alt="dup2"></p><p>该函数会将旧文件描述符内部存储的 file 指针覆盖拷贝到新文件描述符处，因此，一般我们在重定向后会把旧的文件描述符给关闭</p><p>下面是一个综合使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello, linux!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;error information!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个将标准输出重定向的例子，而标准错误我们并没有重定向，因此我们会看到标准错误打印的信息出现在显示屏上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./file_dump.o</span><br><span class="line">error information!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// test.txt</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们将标准错误也重定向：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello, linux!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;error information!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们会发现标准错误也被重定向到文件中去了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">hello, linux!</span><br><span class="line">error information!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="再看shell重定向符号使用">再看shell重定向符号使用</span></h2><p>shell 中的 “&gt;” 和“&gt;&gt;”符号可以进行输出重定向，本质上其实就是使用系统底层的 dup2 函数来实现的，当我们使用 2&gt; 时，会将标准错误重定向到指定文件当中去</p><p>我们写一个示例测试一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is a current information!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;This is a error information!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只重定向标准输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./test.o 1&gt; test.txt</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  cat test.txt</span><br><span class="line">This is a current information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a current information!</span><br></pre></td></tr></table></figure><p>我们会发现标准错误被打印到屏幕上，而标准输出被重定向到了 test.txt 当中</p><p>只重定向标准错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./test.o 2&gt; test.txt</span><br><span class="line">This is a current information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a current information!</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  cat test.txt</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br></pre></td></tr></table></figure><p>那我如果想要让标准输出和标准错误都重定向到 test.txt 中该怎么办，有些小天才可能就要动他的小脑筋了（没错正是本人），这样不就行了吗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./test.o 1&gt; test.txt 2&gt; test.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  cat test.txt</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a error information!</span><br><span class="line">ormation!</span><br></pre></td></tr></table></figure><p>你看这结果对劲吗？</p><p>当我们运行命令 <code>./test.o 1&gt; test.txt 2&gt; test.txt</code> 时，<strong>标准输出（stdout）和标准错误（stderr）都会被重定向到同一个文件 <code>test.txt</code></strong>，但这里存在一个潜在问题：<strong>竞争条件</strong>。</p><hr><p>分析过程如下：</p><ol><li><p><strong>两个文件描述符（fd 1 和 fd 2）同时指向 <code>test.txt</code></strong>  </p><ul><li><code>1&gt;</code> 将 stdout（fd 1）重定向到 <code>test.txt</code>  </li><li><code>2&gt;</code> 将 stderr（fd 2）也重定向到 <code>test.txt</code></li></ul></li><li><p><strong>写入时的竞争条件</strong>  </p><ul><li>stdout 和 stderr 会<strong>同时尝试写入同一个文件</strong>，但由于操作系统的文件描述符是独立的，两者的写入顺序<strong>不确定</strong>，可能导致内容交错或覆盖。  </li><li>例如，如果程序交替输出 stdout 和 stderr，最终 <code>test.txt</code> 的内容可能是乱序的。</li></ul></li><li><p><strong>文件被多次打开</strong>  </p><ul><li><code>1&gt;</code> 和 <code>2&gt;</code> 会分别以<strong>覆盖模式</strong>（<code>O_TRUNC</code>）打开 <code>test.txt</code>，后打开的会清空前一个的内容（取决于 shell 的实现）。  </li><li>在某些 shell（如 <code>bash</code>）中，最终可能只有 stderr 的内容被保留（因为 <code>2&gt;</code> 是最后执行的）。</li></ul></li></ol><hr><p>如果我们想将 <strong>stdout 和 stderr 合并写入同一个文件</strong>，应该使用以下方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.o &gt; test.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这样会把标准错误重定向搭配标准输出，从而避免了乱流问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  ./test.o 1&gt; test.txt 2&gt;&amp;1</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson4</span><br><span class="line">╰─➤  cat test.txt</span><br><span class="line">This is a current information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a error information!</span><br><span class="line">This is a current information!</span><br><span class="line">This is a error information!</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件读写及文件描述符</title>
      <link href="/2025/07/17/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6/file_desc/"/>
      <url>/2025/07/17/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%96%87%E4%BB%B6/file_desc/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#c%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%9B%9E%E9%A1%BE">C语言文件操作回顾</a><ul><li><a href="#1fopen-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><strong>1.<code>fopen</code> - 打开文件</strong></a></li><li><a href="#2-fclose-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><strong>2. <code>fclose</code> - 关闭文件</strong></a></li><li><a href="#3-fwrite-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><strong>3. <code>fwrite</code> - 写入数据</strong></a></li><li><a href="#4-fread-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><strong>4. <code>fread</code> - 读取数据</strong></a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">文件描述符</a><ul><li><a href="#%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">标准文件描述符</a></li><li><a href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99">文件描述符分配规则</a></li><li><a href="#1-open-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><strong>1. <code>open</code> - 打开文件</strong></a></li><li><a href="#2-close-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><strong>2. <code>close</code> - 关闭文件</strong></a></li><li><a href="#3-write-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><strong>3. <code>write</code> - 写入数据</strong></a></li><li><a href="#4-read-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><strong>4. <code>read</code> - 读取数据</strong></a></li></ul></li></ul><!-- tocstop --><p>文件存储在磁盘中，而磁盘是永久性的存储介质，因此文件在磁盘上的存储是永久性的，本质上对文件的所有操作，都是对外设的输入和输出，简称 IO</p><p>而在 Linux 下一切皆文件，所谓的键盘、显示器、网卡、磁盘等等都是抽象化的过程，在后面博客的讲解中将会慢慢理解这一点</p><p>即便是 0KB 的空文件也是会占用磁盘空间的，因为文件 &#x3D; 属性 + 内容，所有的文件操作本质上是对文件内容的操作和文件属性的操作，而这种操作本质上又是进程对文件的操作，<br>磁盘的管理者是操作系统，C语言 等高级语言的库函数中的文件读写本质上是对操作系统给出的文件读写的系统调用接口的包装，方便用户使用</p><h2><span id="c语言文件操作回顾">C语言文件操作回顾</span></h2><p>在 C 语言中，<code>fopen</code>、<code>fclose</code>、<code>fwrite</code> 和 <code>fread</code> 是标准 I&#x2F;O 库（<code>&lt;stdio.h&gt;</code>）提供的文件操作函数，用于文件的打开、关闭、写入和读取操作。以下是它们的详细参数介绍：</p><hr><h3><span id="1fopen-打开文件"><strong>1.<code>fopen</code> - 打开文件</strong></span></h3><h4><span id="函数原型"><strong>函数原型</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明"><strong>参数说明</strong></span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>filename</code></td><td>要打开的文件名（路径可以是相对路径或绝对路径）</td></tr><tr><td><code>mode</code></td><td>文件打开模式，决定文件如何被访问（读、写、追加等）</td></tr></tbody></table><h4><span id="mode-的常见取值"><strong><code>mode</code> 的常见取值</strong></span></h4><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td><code>&quot;r&quot;</code></td><td><strong>只读</strong>（文件必须存在）</td></tr><tr><td><code>&quot;w&quot;</code></td><td><strong>只写</strong>（如果文件存在则清空，否则创建）</td></tr><tr><td><code>&quot;a&quot;</code></td><td><strong>追加</strong>（如果文件存在则在末尾追加，否则创建）</td></tr><tr><td><code>&quot;r+&quot;</code></td><td><strong>读写</strong>（文件必须存在）</td></tr><tr><td><code>&quot;w+&quot;</code></td><td><strong>读写</strong>（如果文件存在则清空，否则创建）</td></tr><tr><td><code>&quot;a+&quot;</code></td><td><strong>读写</strong>（如果文件存在则在末尾追加，否则创建）</td></tr><tr><td><code>&quot;b&quot;</code></td><td><strong>二进制模式</strong>（可与上述模式组合，如 <code>&quot;rb&quot;</code>、<code>&quot;wb+&quot;</code>）</td></tr></tbody></table><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li>成功：返回 <code>FILE*</code> 文件指针（用于后续操作）</li><li>失败：返回 <code>NULL</code>（如文件不存在或权限不足）</li></ul><h4><span id="示例"><strong>示例</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="2-fclose-关闭文件"><strong>2. <code>fclose</code> - 关闭文件</strong></span></h3><h4><span id="函数原型"><strong>函数原型</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明"><strong>参数说明</strong></span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>stream</code></td><td>要关闭的文件指针（由 <code>fopen</code> 返回）</td></tr></tbody></table><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li>成功：返回 <code>0</code></li><li>失败：返回 <code>EOF</code>（通常意味着缓冲区写入失败）</li></ul><h4><span id="示例"><strong>示例</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to close file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="3-fwrite-写入数据"><strong>3. <code>fwrite</code> - 写入数据</strong></span></h3><h4><span id="函数原型"><strong>函数原型</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明"><strong>参数说明</strong></span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>ptr</code></td><td>指向要写入数据的缓冲区（如数组、结构体等）</td></tr><tr><td><code>size</code></td><td>每个数据项的字节大小（如 <code>sizeof(int)</code>）</td></tr><tr><td><code>count</code></td><td>要写入的数据项数量</td></tr><tr><td><code>stream</code></td><td>目标文件指针</td></tr></tbody></table><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li>返回 <strong>实际写入的数据项数量</strong>（通常等于 <code>count</code>，否则可能出错）</li><li>如果返回值 <code>&lt; count</code>，可能是磁盘满或写入错误</li></ul><h4><span id="示例"><strong>示例</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> written = fwrite(data, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="number">4</span>, fp);</span><br><span class="line"><span class="keyword">if</span> (written &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to write all data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="4-fread-读取数据"><strong>4. <code>fread</code> - 读取数据</strong></span></h3><h4><span id="函数原型"><strong>函数原型</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明"><strong>参数说明</strong></span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>ptr</code></td><td>存储读取数据的缓冲区</td></tr><tr><td><code>size</code></td><td>每个数据项的字节大小</td></tr><tr><td><code>count</code></td><td>要读取的数据项数量</td></tr><tr><td><code>stream</code></td><td>源文件指针</td></tr></tbody></table><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li>返回 <strong>实际读取的数据项数量</strong>（可能 <code>&lt; count</code>，如遇到文件末尾）</li><li>可用 <code>feof()</code> 检查是否到达文件末尾，<code>ferror()</code> 检查是否出错</li></ul><h4><span id="示例"><strong>示例</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">4</span>];</span><br><span class="line"><span class="type">size_t</span> read = fread(data, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="number">4</span>, fp);</span><br><span class="line"><span class="keyword">if</span> (read &lt; <span class="number">4</span> &amp;&amp; !feof(fp)) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to read data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>函数</th><th>作用</th><th>关键参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>fopen</code></td><td>打开文件</td><td><code>filename</code>, <code>mode</code></td><td><code>FILE*</code>（失败返回 <code>NULL</code>）</td></tr><tr><td><code>fclose</code></td><td>关闭文件</td><td><code>FILE*</code></td><td><code>0</code>（成功）或 <code>EOF</code>（失败）</td></tr><tr><td><code>fwrite</code></td><td>写入数据</td><td><code>ptr</code>, <code>size</code>, <code>count</code>, <code>FILE*</code></td><td>实际写入的数据项数量</td></tr><tr><td><code>fread</code></td><td>读取数据</td><td><code>ptr</code>, <code>size</code>, <code>count</code>, <code>FILE*</code></td><td>实际读取的数据项数量</td></tr></tbody></table><p>下面是 C语言 文件操作的一个综合代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;myfile&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fopen error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;hello, linux!&quot;</span>;</span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    fwrite(str, <span class="built_in">strlen</span>(str), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="type">char</span> output[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 指针重置</span></span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="type">int</span> n = fread(output, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1024</span>, fp);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        output[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fread error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson3</span><br><span class="line">╰─➤  ./basic_io.o</span><br><span class="line">hello, linux!</span><br></pre></td></tr></table></figure><h2><span id="文件描述符">文件描述符</span></h2><p>在 Linux 操作系统中，文件操作通过 open 函数等来实现，在 Linux 当中，操作系统对文件的管理同样遵循先描述再组织的方法，操作系统会维护一个文件结构体的双向链表，<br>而在进程结构体中同样有一个维护该进程的文件的结构体，这个结构体当中通过数组的方式维护一个个文件，而系统会将这些文件所对应的数组下标给用户使用，通过这些数组下标<br>就可以管理每一个文件，而这个数组下标就被称为文件描述符</p><p><img src="/img/Linux/file_desc/fd.png" alt="fd"></p><p>这个图详细的表述了进程 PCB 中对文件的管理方式，每个进程的 PCB 中都会有一个 files_struct 结构体</p><p>文件描述符中 0 表示标准输入文件，1 表示标准输出文件，2 表示标准错误文件，这是因为这三个外设在进程启动的时候就直接是打开的，因此每个文件在运行过程中默认<br>是有权利和这几个文件打交道的，因此，当我们在不关闭文件描述符的情况下通过 open 函数打开文件的时候默认获得的文件描述符是 3</p><p>下面是对这三个默认文件描述符的介绍：</p><h3><span id="标准文件描述符">标准文件描述符</span></h3><ul><li><strong><code>0</code>（STDIN_FILENO）</strong>：标准输入（键盘输入，默认来源）。</li><li><strong><code>1</code>（STDOUT_FILENO）</strong>：标准输出（屏幕输出，默认目标）。</li><li><strong><code>2</code>（STDERR_FILENO）</strong>：标准错误（屏幕输出，用于错误消息）。</li></ul><h3><span id="文件描述符分配规则">文件描述符分配规则</span></h3><ul><li><strong>文件描述符是进程级的</strong>，由内核动态分配，遵循 <strong>最小可用原则</strong>（从 0 开始查找第一个未被占用的 fd）。</li><li>如果 <code>0</code>、<code>1</code>、<code>2</code> 未被关闭，新打开的文件会分配到 <code>3</code>。</li><li>如果 <code>0</code>、<code>1</code>、<code>2</code> 中有被关闭的，新打开的文件的 fd 会优先填补空缺。</li></ul><p>下面来介绍一下 Linux 系统的文件相关函数：</p><h3><span id="1-open-打开文件"><strong>1. <code>open</code> - 打开文件</strong></span></h3><h4><span id="函数原型"><strong>函数原型</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明"><strong>参数说明</strong></span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>pathname</code></strong></td><td>文件路径（可以是相对路径或绝对路径）</td></tr><tr><td><strong><code>flags</code></strong></td><td>文件打开方式（必选 <code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code> 之一，并可组合其他标志）</td></tr><tr><td><strong><code>mode</code></strong></td><td>文件权限（仅在 <code>O_CREAT</code> 时有效，如 <code>0644</code>）</td></tr></tbody></table><h4><span id="flags-常用选项"><strong><code>flags</code> 常用选项</strong></span></h4><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>只读</td></tr><tr><td><code>O_WRONLY</code></td><td>只写</td></tr><tr><td><code>O_RDWR</code></td><td>读写</td></tr><tr><td><code>O_CREAT</code></td><td>如果文件不存在，则创建</td></tr><tr><td><code>O_TRUNC</code></td><td>如果文件存在，清空内容</td></tr><tr><td><code>O_APPEND</code></td><td>追加模式（写入时自动到文件末尾）</td></tr><tr><td><code>O_NONBLOCK</code></td><td>非阻塞模式（适用于设备文件或管道）</td></tr></tbody></table><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li>成功：返回 <strong>文件描述符（fd）</strong>（最小可用的整数，通常从 <code>3</code> 开始）。</li><li>失败：返回 <code>-1</code>，并设置 <code>errno</code>（如 <code>ENOENT</code> 文件不存在，<code>EACCES</code> 权限不足）。</li></ul><h4><span id="示例"><strong>示例</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，open 函数给的权限会受到权限掩码的影响，但我们可以给进程自定义 umask</p><hr><h3><span id="2-close-关闭文件"><strong>2. <code>close</code> - 关闭文件</strong></span></h3><h4><span id="函数原型"><strong>函数原型</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明"><strong>参数说明</strong></span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>fd</code></strong></td><td>要关闭的文件描述符（由 <code>open</code> 返回）</td></tr></tbody></table><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li>成功：返回 <code>0</code>。</li><li>失败：返回 <code>-1</code>（如 <code>EBADF</code> 表示无效的 fd）。</li></ul><h4><span id="示例"><strong>示例</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (close(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;close failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="3-write-写入数据"><strong>3. <code>write</code> - 写入数据</strong></span></h3><h4><span id="函数原型"><strong>函数原型</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明"><strong>参数说明</strong></span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>fd</code></strong></td><td>目标文件描述符</td></tr><tr><td><strong><code>buf</code></strong></td><td>要写入的数据缓冲区</td></tr><tr><td><strong><code>count</code></strong></td><td>要写入的字节数</td></tr></tbody></table><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li>成功：返回 <strong>实际写入的字节数</strong>（可能 <code>&lt; count</code>，如磁盘满）。</li><li>失败：返回 <code>-1</code>（如 <code>EBADF</code> 无效 fd，<code>ENOSPC</code> 磁盘空间不足）。</li></ul><h4><span id="示例"><strong>示例</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello, Linux!&quot;</span>;</span><br><span class="line"><span class="type">ssize_t</span> bytes_written = write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="4-read-读取数据"><strong>4. <code>read</code> - 读取数据</strong></span></h3><h4><span id="函数原型"><strong>函数原型</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明"><strong>参数说明</strong></span></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>fd</code></strong></td><td>源文件描述符</td></tr><tr><td><strong><code>buf</code></strong></td><td>存储读取数据的缓冲区</td></tr><tr><td><strong><code>count</code></strong></td><td>要读取的最大字节数</td></tr></tbody></table><h4><span id="返回值"><strong>返回值</strong></span></h4><ul><li>成功：返回 <strong>实际读取的字节数</strong>（<code>0</code> 表示文件末尾）。</li><li>失败：返回 <code>-1</code>（如 <code>EBADF</code> 无效 fd，<code>EINTR</code> 被信号中断）。</li></ul><h4><span id="示例"><strong>示例</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">ssize_t</span> bytes_read = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End of file\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buf[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加字符串终止符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read: %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>总结如下：</p><table><thead><tr><th>函数</th><th>作用</th><th>关键参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>open</code></td><td>打开文件</td><td><code>pathname</code>, <code>flags</code>, <code>mode</code></td><td>文件描述符（<code>fd</code>）或 <code>-1</code></td></tr><tr><td><code>close</code></td><td>关闭文件</td><td><code>fd</code></td><td><code>0</code> 或 <code>-1</code></td></tr><tr><td><code>write</code></td><td>写入数据</td><td><code>fd</code>, <code>buf</code>, <code>count</code></td><td>实际写入的字节数或 <code>-1</code></td></tr><tr><td><code>read</code></td><td>读取数据</td><td><code>fd</code>, <code>buf</code>, <code>count</code></td><td>实际读取的字节数或 <code>-1</code></td></tr></tbody></table><p>注意事项</p><ol><li><p><strong>文件描述符（fd）</strong>：</p><ul><li><code>0</code>（<code>STDIN_FILENO</code>）、<code>1</code>（<code>STDOUT_FILENO</code>）、<code>2</code>（<code>STDERR_FILENO</code>）默认打开。</li><li>新打开的 fd 从 <code>3</code> 开始（除非标准 fd 被关闭）。</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>所有函数失败时返回 <code>-1</code>，并通过 <code>errno</code> 表示具体错误（用 <code>perror</code> 打印）。</li></ul></li><li><p><strong>阻塞与非阻塞</strong>：</p><ul><li>默认是阻塞 I&#x2F;O（可使用 <code>O_NONBLOCK</code> 改为非阻塞模式）。</li></ul></li><li><p><strong>二进制 vs 文本</strong>：</p><ul><li>这些函数直接操作字节流，适合二进制文件（如 <code>write(&amp;data, sizeof(data), 1, fd)</code>）。</li></ul></li><li><p><strong>缓冲区管理</strong>：</p><ul><li><code>read</code>&#x2F;<code>write</code> 不保证一次性读完&#x2F;写完所有数据，需循环处理（尤其是网络编程）。</li></ul></li></ol><hr><p>下面是一个对文件操作的综合示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 权限掩码设置为 000</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 1. 打开文件（读写模式，不存在则创建）</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 写入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;hello, Linux!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> written = write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span> (written == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 重置文件指针到开头（否则 read 会从末尾读取）</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 读取数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;File content: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 关闭文件</span></span><br><span class="line">    <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;close failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson3</span><br><span class="line">╰─➤  ./basic_io.o</span><br><span class="line">File content: hello, Linux!</span><br></pre></td></tr></table></figure><p>查看文件权限验证权限是否受到了进程代码中 umask 函数的影响：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson3</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 32</span><br><span class="line">-rw-r--r-- 1 ljx ljx  1017 Jul 17 22:41 basic_io.c</span><br><span class="line">-rwxr-xr-x 1 ljx ljx 16408 Jul 17 22:40 basic_io.o</span><br><span class="line">-rw-r--r-- 1 ljx ljx    13 Jul 17 22:12 myfile</span><br><span class="line">-rw-rw-rw- 1 ljx ljx    13 Jul 17 22:40 test.txt</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程程序替换</title>
      <link href="/2025/07/17/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%8E%A7%E5%88%B6/process_replacement/"/>
      <url>/2025/07/17/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%8E%A7%E5%88%B6/process_replacement/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%90%86">替换原理</a></li><li><a href="#%E6%9B%BF%E6%8D%A2%E5%87%BD%E6%95%B0">替换函数</a><ul><li><a href="#execl-%E5%87%BD%E6%95%B0">execl 函数</a></li><li><a href="#execv-%E5%87%BD%E6%95%B0">execv 函数</a></li><li><a href="#execlp-%E5%92%8C-execvp">execlp 和 execvp</a></li><li><a href="#execle-%E5%92%8C-execve">execle 和 execve</a></li></ul></li></ul><!-- tocstop --><p>若父进程希望创建的子进程执行和父进程完全不一样的全新的程序，就可以利用进程的程序替换来实现这个功能</p><p>程序替换是通过特定的接口，加载磁盘上的一个全新的程序（代码和数据），加载到调用进程的地址空间中</p><h2><span id="替换原理">替换原理</span></h2><ol><li><strong>fork() 系统调用</strong></li></ol><ul><li>创建子进程时，会复制父进程的进程地址空间（代码段、数据段、堆栈等）</li><li>子进程获得父进程文件描述符表的副本</li><li>父子进程执行相同的程序，通过返回值区分：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>exec 函数族</strong></li></ol><ul><li>包含多个变体：execl, execv, execle, execve 等</li><li>核心功能是替换当前进程的地址空间：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execvp(<span class="string">&quot;ls&quot;</span>, argv);</span><br></pre></td></tr></table></figure><ul><li>特点：<ul><li>不创建新进程（PID不变）</li><li>新程序从 main() 开始执行</li><li>文件描述符默认保持打开（除非设置 FD_CLOEXEC）</li></ul></li></ul><ol start="3"><li><strong>环境变量处理</strong></li></ol><ul><li>exec 调用默认继承原环境变量</li><li>使用 execle&#x2F;execve 可以指定新环境：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *envp[] = &#123;<span class="string">&quot;PATH=/usr/bin&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>, envp);</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>程序计数器(PC)处理</strong></li></ol><ul><li>进程控制块(PCB)中保存了执行位置信息</li><li>exec 调用后，PC 会被设置为新程序的入口点（通常是 _start 或 main）</li></ul><p>下面这个图示完美的展示了程序替换所作出的改动：</p><p><img src="/img/Linux/process_rep/rep.png" alt="replace"></p><h2><span id="替换函数">替换函数</span></h2><p>有六种以 exec 开头的函数，统称为 exec 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...,<span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><h3><span id="execl-函数">execl 函数</span></h3><p>首先，我们先来了解一下 execl 函数的用法：</p><p><code>execl()</code> 是 <code>exec</code> 函数族中的一个成员，用于 <strong>替换当前进程的镜像</strong>（加载并执行新程序）。它的特点是 <strong>参数以可变参数列表（<code>...</code>）的形式传递</strong>，适合参数数量已知且固定的场景。</p><hr><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><ol><li><p><strong><code>path</code></strong>  </p><ul><li>新程序的 <strong>完整路径</strong>（如 <code>&quot;/bin/ls&quot;</code>）。</li><li>必须是可执行文件的绝对路径或相对路径（依赖 <code>PATH</code> 环境变量的 <code>execlp</code> 是另一个函数）。</li></ul></li><li><p><strong><code>arg</code></strong>  </p><ul><li>第一个参数是 <strong>新程序的名称</strong>（通常与 <code>path</code> 的最后一部分一致，但可以任意命名）。</li><li>例如：<code>&quot;ls&quot;</code> 是程序名，<code>&quot;-l&quot;</code> 是它的参数。</li></ul></li><li><p><strong><code>...</code></strong>  </p><ul><li>可变参数列表，表示传递给新程序的 <strong>命令行参数</strong>。</li><li>必须以 <code>(char *) NULL</code> 结尾（表示参数结束）。</li></ul></li></ol><h4><span id="返回值">返回值</span></h4><ul><li><strong>成功</strong>：不返回（原程序已被替换，后续代码不会执行）。</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code>（例如文件不存在、权限不足等）。</li></ul><h4><span id="使用示例">使用示例</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程pid：&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 让子进程执行 ls -a -l 命令</span></span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/usr/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 若执行到了这里，说明程序替换失败</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;父进程已回收子进程 &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson2</span><br><span class="line">╰─➤  ./pro_rep.o</span><br><span class="line">子进程pid：2880883</span><br><span class="line">total 64</span><br><span class="line"> 4 -rw-r--r-- 1 ljx ljx   594 Jul 17 13:40 pro_rep.cc</span><br><span class="line">20 -rwxr-xr-x 1 ljx ljx 16880 Jul 17 13:40 pro_rep.o</span><br><span class="line"> 4 -rw-r--r-- 1 ljx ljx  2009 Jul 16 23:14 pro_wait.cc</span><br><span class="line">36 -rwxr-xr-x 1 ljx ljx 33808 Jul 16 23:14 pro_wait.o</span><br><span class="line">父进程已回收子进程 2880883</span><br></pre></td></tr></table></figure><p>同样，我们可以利用这个函数执行自己的可执行程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pro_rep.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程pid：&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 让子进程执行 ls -a -l 命令</span></span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;./test.o&quot;</span>, <span class="string">&quot;test.o&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 若执行到了这里，说明程序替换失败</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;父进程已回收子进程 &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; argv[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，替换的进程会将 execl 传递的命令行参数接受，我们可以将其打印出来</p><h3><span id="execv-函数">execv 函数</span></h3><p>该函数和 execl 函数唯一的区别就在于该函数不是通过可变参数模板传递命令行参数的，而是通过数组的方式传递参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程pid：&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 让子进程执行 ls -a -l 命令（通过数组传递参数）</span></span><br><span class="line">        vector&lt;<span class="type">char</span>*&gt; argv = &#123;<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;test.o&quot;</span>), <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;aaa&quot;</span>), <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;bbb&quot;</span>), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="built_in">execv</span>(<span class="string">&quot;./test.o&quot;</span>, argv.<span class="built_in">data</span>());</span><br><span class="line">        <span class="comment">// 若执行到了这里，说明程序替换失败</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;运行完毕，状态码：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;异常退出，信号：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(<span class="built_in">WTERMSIG</span>(status)) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson2</span><br><span class="line">╰─➤  ./pro_rep.o</span><br><span class="line">子进程pid：2891886</span><br><span class="line">1:aaa</span><br><span class="line">2:bbb</span><br><span class="line">子进程 2891886运行完毕，状态码：0</span><br></pre></td></tr></table></figure><p>可以看到，我们通过父进程获取了子进程的退出状态，这里我们让子进程触发除零错误，此时即便子进程被进程程序替换了，父进程依然可以知晓子进程的状态，<br>因为子进程的程序替换并没有替换进程 pid，因此父进程依然和子进程保持着父子关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改替换程序，故意引发除零错误</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; argv[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson2</span><br><span class="line">╰─➤  ./pro_rep.o</span><br><span class="line">子进程pid：2893724</span><br><span class="line">子进程 2893724异常退出，信号：8(Floating point exception)</span><br></pre></td></tr></table></figure><p>可以看到，子进程的异常状况被父进程捕捉到了</p><h3><span id="execlp-和-execvp">execlp 和 execvp</span></h3><p>execlp 和 execvp 命令在执行环境变量路径下的命令时不需要带路径，可以自动根据环境变量搜索命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程pid：&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 让子进程执行 ls -a -l 命令（通过数组传递参数）</span></span><br><span class="line">        <span class="comment">// vector&lt;char*&gt; argv = &#123;const_cast&lt;char*&gt;(&quot;test.o&quot;), const_cast&lt;char*&gt;(&quot;aaa&quot;), const_cast&lt;char*&gt;(&quot;bbb&quot;), nullptr&#125;;</span></span><br><span class="line">        <span class="built_in">execlp</span>(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 若执行到了这里，说明程序替换失败</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;运行完毕，状态码：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;异常退出，信号：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(<span class="built_in">WTERMSIG</span>(status)) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，即便不指定路径，依然可以获取到可执行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson2</span><br><span class="line">╰─➤  ./pro_rep.o</span><br><span class="line">子进程pid：2895026</span><br><span class="line">total 88</span><br><span class="line">-rw-r--r-- 1 ljx ljx  1002 Jul 17 14:26 pro_rep.cc</span><br><span class="line">-rwxr-xr-x 1 ljx ljx 16936 Jul 17 14:26 pro_rep.o</span><br><span class="line">-rw-r--r-- 1 ljx ljx  2009 Jul 16 23:14 pro_wait.cc</span><br><span class="line">-rwxr-xr-x 1 ljx ljx 33808 Jul 16 23:14 pro_wait.o</span><br><span class="line">-rw-r--r-- 1 ljx ljx   202 Jul 17 14:23 test.cc</span><br><span class="line">-rwxr-xr-x 1 ljx ljx 16592 Jul 17 14:26 test.o</span><br><span class="line">子进程 2895026运行完毕，状态码：0</span><br></pre></td></tr></table></figure><p>但是，若不是系统命令，自己的可执行程序的路径不在环境变量当中，当然就需要指定路径了，若不指定路径则会导致程序替换失败，下面用 execvp 举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程pid：&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 让子进程执行 ls -a -l 命令（通过数组传递参数）</span></span><br><span class="line">        vector&lt;<span class="type">char</span>*&gt; argv = &#123;<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;test.o&quot;</span>), <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;aaa&quot;</span>), <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;bbb&quot;</span>), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="built_in">execvp</span>(<span class="string">&quot;test.o&quot;</span>, argv.<span class="built_in">data</span>());</span><br><span class="line">        <span class="comment">// 若执行到了这里，说明程序替换失败</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;运行完毕，状态码：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;异常退出，信号：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(<span class="built_in">WTERMSIG</span>(status)) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson2</span><br><span class="line">╰─➤  ./pro_rep.o</span><br><span class="line">子进程pid：2895822</span><br><span class="line">子进程 2895822运行完毕，状态码：1</span><br></pre></td></tr></table></figure><h3><span id="execle-和-execve">execle 和 execve</span></h3><p>这两个命令可以传递新的环境变量到替换的程序当中去，这里的传递是覆盖式传递，而不是追加环境变量，因此若想追加环境变量一定要在原始的环境变量参数上追加新的环境变量再传递参数：</p><p>假若父进程只希望给子进程追加一个环境变量而父进程不需要追加，实现方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程pid：&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 让子进程执行 ls -a -l 命令（通过数组传递参数）</span></span><br><span class="line">        vector&lt;<span class="type">char</span>*&gt; argv = &#123;<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;test.o&quot;</span>), <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;aaa&quot;</span>), <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;bbb&quot;</span>), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (environ[len] != <span class="literal">nullptr</span>) len++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用指针范围构造 vector</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">char</span>*&gt; <span class="title">new_env</span><span class="params">(environ, environ + len)</span></span>;</span><br><span class="line">        new_env.<span class="built_in">push_back</span>(<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="string">&quot;new_env_op=111&quot;</span>));</span><br><span class="line">        new_env.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">execve</span>(<span class="string">&quot;./test.o&quot;</span>, argv.<span class="built_in">data</span>(), new_env.<span class="built_in">data</span>());</span><br><span class="line">        <span class="comment">// 若执行到了这里，说明程序替换失败</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;运行完毕，状态码：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;异常退出，信号：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(<span class="built_in">WTERMSIG</span>(status)) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们让子进程的替换程序打印环境变量，可以看到子进程最终成功打印了新追加的环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">26:new_env_op=111</span><br><span class="line">子进程 2899087运行完毕，状态码：0</span><br></pre></td></tr></table></figure><p>下面是对这6个函数的总结：</p><table><thead><tr><th>函数名</th><th>参数格式</th><th>是否带路径</th><th>是否使用当前环境变量</th></tr></thead><tbody><tr><td>execl</td><td>列表</td><td>否</td><td>是</td></tr><tr><td>execlp</td><td>列表</td><td>是</td><td>是</td></tr><tr><td>execle</td><td>列表</td><td>否</td><td>否，须自己组装环境变量</td></tr><tr><td>execv</td><td>数组</td><td>否</td><td>是</td></tr><tr><td>execvp</td><td>数组</td><td>是</td><td>是</td></tr><tr><td>execve</td><td>数组</td><td>否</td><td>否，须自己组装环境变量</td></tr></tbody></table><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程等待</title>
      <link href="/2025/07/16/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%8E%A7%E5%88%B6/process_wait/"/>
      <url>/2025/07/16/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%8E%A7%E5%88%B6/process_wait/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%BF%85%E8%A6%81%E6%80%A7">进程等待必要性</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E6%96%B9%E6%B3%95">进程等待方法</a><ul><li><a href="#wait">wait</a></li><li><a href="#waitpid">waitpid</a></li></ul></li><li><a href="#%E7%AD%89%E5%BE%85%E8%8E%B7%E5%8F%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-status">等待获取子进程状态 status</a><ul><li><a href="#wait-%E5%92%8C-waitpid-%E7%9A%84-status-%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">wait 和 waitpid 的 status 参数说明</a></li></ul></li><li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E6%96%B9%E5%BC%8F">进程的非阻塞等待方式</a></li></ul><!-- tocstop --><h2><span id="进程等待必要性">进程等待必要性</span></h2><ul><li>子进程退出后，父进程如果不管不顾，就可能造成“僵尸进程”的问题，进而造成内存泄漏。</li><li>另外，进程一旦变成僵尸状态，那就刀枪不入，“杀人不眨眼”的 <code>kill -9</code> 也无能为力，因为谁也没有办法杀死一个已经死去的进程（当然，你可以将父进程给杀掉，这样子进程就<br>会被 init 进程托管然后定时通过 waitpid 函数回收了，不过一般不会这样用）</li><li>最后，父进程派给子进程的任务完成的如何，我们需要知道。如，子进程运行完成，结果对还是不对，或者是否正常退出。</li><li>父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息。</li></ul><h2><span id="进程等待方法">进程等待方法</span></h2><h3><span id="wait">wait</span></h3><p>函数格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> * status)</span>;</span><br></pre></td></tr></table></figure><p>返回值：成功返回被等待进程的 pid，失败返回 -1</p><p>参数：输出型参数，用户与获取子进程的退出状态，若不关心则将其设置为 nullptr</p><p>下面重点介绍一下 waitpid 方法，因为 waitpid 方法是完全包括了 wait 的功能的</p><h3><span id="waitpid">waitpid</span></h3><h4><span id="函数原型">函数原型</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><h4><span id="返回值">返回值</span></h4><ul><li><strong>成功时</strong>：返回收集到的子进程的进程 ID。</li><li><strong>设置了 <code>WNOHANG</code> 选项时</strong>：<br>若调用中 <code>waitpid</code> 发现没有已退出的子进程可收集，则返回 <code>0</code>。</li><li><strong>出错时</strong>：返回 <code>-1</code>，并通过 <code>errno</code> 指示具体错误。</li></ul><h4><span id="参数说明">参数说明</span></h4><h5><span id="pid"><code>pid</code></span></h5><ul><li><code>pid = -1</code>：等待任意一个子进程（与 <code>wait</code> 等效）。</li><li><code>pid &gt; 0</code>：等待进程 ID 与 <code>pid</code> 相等的子进程。</li></ul><h5><span id="status输出型参数"><code>status</code>（输出型参数）</span></h5><ul><li><code>WIFEXITED(status)</code>：<br>若为正常终止的子进程状态，返回真（用于检查进程是否正常退出）。</li><li><code>WEXITSTATUS(status)</code>：<br>若 <code>WIFEXITED</code> 非零，提取子进程的退出码。</li></ul><h5><span id="options"><code>options</code></span></h5><ul><li><strong>默认值 <code>0</code></strong>：表示阻塞等待。</li><li><strong><code>WNOHANG</code></strong>：<br>若指定的子进程未结束，则 <code>waitpid()</code> 立即返回 <code>0</code>（非阻塞）；若子进程正常结束，则返回其进程 ID。</li></ul><h4><span id="使用方法">使用方法</span></h4><p>接下来我们来试用一下 waitpid 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 模拟子进程处理任务</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; 执行任务中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; 退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父进程已回收子进程, pid: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson2</span><br><span class="line">╰─➤  ./pro_wait.o</span><br><span class="line">子进程 2684497 执行任务中</span><br><span class="line">子进程 2684497 退出</span><br><span class="line">父进程已回收子进程, pid: 2684497</span><br></pre></td></tr></table></figure><h2><span id="等待获取子进程状态-status">等待获取子进程状态 status</span></h2><p>通过 wait 函数和 waitpid 函数的 status 这个输出型参数即可获得子进程退出时的状态码</p><h3><span id="wait-和-waitpid-的-status-参数说明">wait 和 waitpid 的 status 参数说明</span></h3><p><code>wait</code> 和 <code>waitpid</code> 函数都有一个 <code>status</code> 参数，该参数是<strong>输出型参数</strong>，由操作系统填充：</p><ol><li><p><strong>参数传递</strong>  </p><ul><li>如果传递 <code>NULL</code>，表示父进程<strong>不关心</strong>子进程的退出状态信息。  </li><li>否则，操作系统会通过该参数将子进程的退出信息反馈给父进程。</li></ul></li><li><p><strong><code>status</code> 的底层结构</strong><br><code>status</code> 不能简单当作整型处理，而应视为<strong>位图</strong>（具体细节仅研究低 16 位比特）：</p></li></ol><p>下面这张图体现了 status 的底层结构：</p><p><img src="/img/Linux/process_wait/status.png" alt="status"></p><p>因此，我们在使用 wait 或 waitpid 函数获取进程的状态码的时候，需要对其进行位运算并通过判断终止信号是否为0来判断进程是正常终止还是被信号所杀</p><p>根据 status 的底层结构，我们可以非常方便的获取一个子进程的退出状态码</p><p>下面这个示例代码分别对正常终止结果正确、正常终止结果错误和异常终止的进程进行了状态码获取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常退出且结果正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">success</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; 将正常退出且结果正确&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常退出结果不正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uncurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; 将正常退出但结果不正确&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">killed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; 将被除零错误信号杀掉&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; exec&#123;success, uncurrent, killed&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> id = fork();</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            exec[i]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status_code = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status_code, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (signal_flag == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 程序未被异常终止</span></span><br><span class="line">                <span class="type">int</span> exit_status = (status_code &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;父进程已回收子进程, pid: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;，退出码为：&quot;</span> &lt;&lt; exit_status &lt;&lt;std::endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 程序被异常终止</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;父进程已回收子进程, pid: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;，程序异常终止，终止信号为：&quot;</span> &lt;&lt; signal_flag &lt;&lt;std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson2</span><br><span class="line">╰─➤  ./pro_wait.o</span><br><span class="line">子进程 2692025 将正常退出且结果正确</span><br><span class="line">子进程 2692027 将被除零错误信号杀掉</span><br><span class="line">子进程 2692026 将正常退出但结果不正确</span><br><span class="line">父进程已回收子进程, pid: 2692025，退出码为：0</span><br><span class="line">父进程已回收子进程, pid: 2692027，程序异常终止，终止信号为：8</span><br><span class="line">父进程已回收子进程, pid: 2692026，退出码为：2</span><br></pre></td></tr></table></figure><p>其中 8 号信号正是除零错误，结果完全符合预期</p><p>当然，这种位运算获取退出状态和信号的方式其实可以通过系统自带的宏函数来获取,下面是对这几个宏函数的介绍：</p><ol><li><strong><code>WIFEXITED(status)</code></strong>：检查进程是否正常退出（通过 <code>exit</code> 或 <code>return</code>）。  </li><li><strong><code>WEXITSTATUS(status)</code></strong>：若进程正常退出，提取其退出码（<code>exit</code> 或 <code>return</code> 的值）。  </li><li><strong><code>WIFSIGNALED(status)</code></strong>：检查进程是否因信号（如 <code>SIGSEGV</code>）终止。  </li><li><strong><code>WTERMSIG(status)</code></strong>：若进程因信号终止，提取导致终止的信号编号。  </li><li><strong><code>WCOREDUMP(status)</code></strong>：检查进程是否生成了 core dump 文件（需配合 <code>WIFSIGNALED</code> 使用）。</li></ol><p>因此，父进程回收子进程判断状态码的地方可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status_code))</span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">// 程序未被异常终止</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父进程已回收子进程, pid: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;，退出码为：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status_code) &lt;&lt;std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 程序被异常终止</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父进程已回收子进程, pid: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;，程序异常终止，终止信号为：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status_code) &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用宏函数来获取所需要的数据，增强了代码的可读性</p><h2><span id="进程的非阻塞等待方式">进程的非阻塞等待方式</span></h2><p>通过 WNOHANG 可以让 waitpid 函数实现非阻塞等待，父进程就通过轮询的方式回收子进程，其他时间父进程可以做别的事情，使用示例如下：</p><p>测试用例中我将子进程创建数量增加到了6个，检测父进程是否可以在子进程排队等待被回收的情况下马上将子进程批量回收（当检测到有子进程被回收时，立即进入下一个循环检测<br>是否还有进程需要被回收，而不是让父进程做自己的事情）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程创建数目</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exec_num 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常退出且结果正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">success</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; 将正常退出且结果正确&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常退出结果不正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uncurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; 将正常退出但结果不正确&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">killed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子进程 &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; 将被除零错误信号杀掉&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; exec&#123;success, uncurrent, killed, success, success, success&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exec_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> id = fork();</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            exec[i]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="comment">// 计数器，计算还有多少个进程没有被回收</span></span><br><span class="line">    <span class="type">int</span> cnt = exec_num;</span><br><span class="line">    <span class="keyword">while</span>(cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status_code = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status_code, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status_code))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 程序未被异常终止</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;父进程已回收子进程, pid: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;，退出码为：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(status_code) &lt;&lt;std::endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 程序被异常终止</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;父进程已回收子进程, pid: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;，程序异常终止，终止信号为：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status_code) &lt;&lt;std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 马上进入下一次子进程回收检测</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模拟父进程做别的工作</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;父进程在做别的事情&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson2</span><br><span class="line">╰─➤  ./pro_wait.o</span><br><span class="line">子进程 2696573 将正常退出且结果正确</span><br><span class="line">子进程 2696574 将正常退出但结果不正确</span><br><span class="line">子进程 2696575 将被除零错误信号杀掉</span><br><span class="line">子进程 2696576 将正常退出且结果正确</span><br><span class="line">子进程 2696577 将正常退出且结果正确</span><br><span class="line">子进程 2696578 将正常退出且结果正确</span><br><span class="line">父进程在做别的事情</span><br><span class="line">父进程在做别的事情</span><br><span class="line">父进程已回收子进程, pid: 2696573，退出码为：0</span><br><span class="line">父进程在做别的事情</span><br><span class="line">父进程已回收子进程, pid: 2696576，退出码为：0</span><br><span class="line">父进程已回收子进程, pid: 2696577，退出码为：0</span><br><span class="line">父进程已回收子进程, pid: 2696578，退出码为：0</span><br><span class="line">父进程在做别的事情</span><br><span class="line">父进程已回收子进程, pid: 2696574，退出码为：2</span><br><span class="line">父进程在做别的事情</span><br><span class="line">父进程在做别的事情</span><br><span class="line">父进程已回收子进程, pid: 2696575，程序异常终止，终止信号为：8</span><br></pre></td></tr></table></figure><p>结果表明，父进程可以在子进程排队等待被回收的情况下快速回收子进程</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程终止</title>
      <link href="/2025/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%8E%A7%E5%88%B6/process_termination/"/>
      <url>/2025/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E6%8E%A7%E5%88%B6/process_termination/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%AE%8C%E6%AF%95%E7%BB%93%E6%9E%9C%E4%B8%8D%E6%AD%A3%E7%A1%AE">代码运行完毕结果不正确</a><ul><li><a href="#_exit-%E5%87%BD%E6%95%B0">_exit 函数</a></li><li><a href="#exit-%E5%87%BD%E6%95%B0">exit 函数</a></li><li><a href="#strerr-%E5%87%BD%E6%95%B0">strerr 函数</a></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2">代码异常终止</a></li></ul><!-- tocstop --><p>一个进程退出一般分为以下这三种情况：</p><ul><li>代码运行完毕，结果正确</li><li>代码运行完毕，结果不正确</li><li>代码异常终止</li></ul><p>一个进程退出后会有一个退出码，该退出码是给父进程看的，子进程由父进程创建的，父进程自然是需要关心子进程的情况的，也正是因此，bash 或其他 shell 作为处理命令<br>的进程，我们在命令行中运行的所有可执行程序都是可以被 shell 给拿到的，也正因此，shell 提供了 “echo $?” 指令用于获取最近一次进程的退出码</p><p>我们直接写一个程序测试一下 echo 命令是否可以获取进程退出码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该指令发现父进程 shell 成功获得了退出码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1  </span><br><span class="line">╰─➤  ./term.o   </span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1  </span><br><span class="line">╰─➤  echo $?</span><br><span class="line">10    # 获取退出码成功</span><br></pre></td></tr></table></figure><h2><span id="代码运行完毕结果不正确">代码运行完毕结果不正确</span></h2><p>接下来我们学习两个函数：</p><h3><span id="_exit-函数">_exit 函数</span></h3><p>_exit 函数是一个系统函数，调用该函数后会直接将进程给终止掉，不做任何事情，因此我们调用该函数后缓冲区中的数据是无法被清理的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 未换行的数据会被存储在缓冲区当中</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello, Linux!&quot;</span>;</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发现什么结果都看不到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./term.o</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤</span><br></pre></td></tr></table></figure><h3><span id="exit-函数">exit 函数</span></h3><p>exit 函数是 C 标准库中的函数，该函数不是系统函数，他会在被调用时先执行用户定义的清理函数以及缓冲区数据，<strong>最后再调用 _exit() 函数</strong></p><p>我们将 _exit 函数换成 exit 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 未换行的数据会被存储在缓冲区当中</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello, Linux!&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现缓冲区中的数据被刷新出来了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./term.o</span><br><span class="line">hello, Linux!%         </span><br></pre></td></tr></table></figure><p>下面这张图很好的比较出来两个函数的区别：</p><p><img src="/img/Linux/process_term/exit_cmp.png" alt="addr"></p><p>除此之外，有些函数在执行失败后会给出一个错误码，但我们并不知道这个错误码对应的是什么含义，此时，我们可以通过一个函数来将退出码转化为我们可以看懂的字符串：</p><h3><span id="strerr-函数">strerr 函数</span></h3><p>通过这个函数，我们可以把错误码转化为我们可以看懂的字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strerror</span>(i) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./term.o</span><br><span class="line">Operation not permitted</span><br><span class="line">No such file or directory</span><br><span class="line">No such process</span><br><span class="line">Interrupted system call</span><br><span class="line">Input/output error</span><br></pre></td></tr></table></figure><p>在 C 语言中，errno 是一个全局变量（通常是线程局部的），用于存储最近一次系统调用或库函数调用失败的错误代码，结合 strerror 函数，我们就可以将 errno 对应的错误信息<br>打印出来了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配一块超大内存使得 malloc 函数调用出错</span></span><br><span class="line">    <span class="type">size_t</span> huge_size = <span class="number">1UL</span> &lt;&lt; <span class="number">40</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(huge_size);</span><br><span class="line">    std::cout &lt;&lt; errno &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，有了 errno 和 strerror 两个函数的加持，我们就能够很轻松的获取到函数&#x3D;&#x3D;系统调用或库函数调用失败的错误信息了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./term.o</span><br><span class="line">12:Cannot allocate memory</span><br></pre></td></tr></table></figure><h2><span id="代码异常终止">代码异常终止</span></h2><p>代码异常终止通常是因为进程执行了某些非法操作，触发了操作系统发送的 <strong>信号（Signal）</strong>，导致进程被强制终止。</p><hr><p><strong>1. 信号（Signal）是异常终止的直接原因</strong></p><p>当进程执行了不被允许的操作（如访问非法内存、除零、执行非法指令等），操作系统会向该进程发送一个信号，默认行为可能是终止进程（甚至产生核心转储 <code>core dump</code>）。常见信号包括：</p><table><thead><tr><th>信号名</th><th>信号值</th><th>触发原因</th><th>默认行为</th></tr></thead><tbody><tr><td><strong>SIGSEGV</strong></td><td>11</td><td>非法内存访问（如解引用空指针、越界访问数组）</td><td>终止 + core dump</td></tr><tr><td><strong>SIGFPE</strong></td><td>8</td><td>算术错误（如除零、整数溢出）</td><td>终止 + core dump</td></tr><tr><td><strong>SIGILL</strong></td><td>4</td><td>执行非法指令（如损坏的二进制文件、CPU 不支持的指令）</td><td>终止 + core dump</td></tr><tr><td><strong>SIGBUS</strong></td><td>7</td><td>总线错误（如对齐访问失败，硬件错误）</td><td>终止 + core dump</td></tr><tr><td><strong>SIGABRT</strong></td><td>6</td><td>程序主动调用 <code>abort()</code>（通常因断言失败或检测到不可恢复错误）</td><td>终止 + core dump</td></tr><tr><td><strong>SIGKILL</strong></td><td>9</td><td>强制终止（如 <code>kill -9</code>，不可捕获或忽略）</td><td>立即终止</td></tr><tr><td><strong>SIGTERM</strong></td><td>15</td><td>优雅终止请求（如 <code>kill</code> 默认发送的信号，允许程序清理资源）</td><td>终止</td></tr></tbody></table><hr><p><strong>2. 代码异常终止的常见场景</strong><br><strong>(1) 段错误（Segmentation Fault, SIGSEGV）</strong><br><strong>原因</strong>：访问了不属于进程的内存（如空指针解引用、数组越界）。<br><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">*p = <span class="number">42</span>;  <span class="comment">// 解引用空指针，触发 SIGSEGV</span></span><br></pre></td></tr></table></figure><p><strong>(2) 浮点&#x2F;算术异常（SIGFPE）</strong><br><strong>原因</strong>：除零、整数溢出等。<br><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;  <span class="comment">// 除零，触发 SIGFPE</span></span><br></pre></td></tr></table></figure><p><strong>(3) 主动调用 <code>abort()</code>（SIGABRT）</strong><br><strong>原因</strong>：程序检测到致命错误（如断言失败）。<br><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(<span class="number">1</span> == <span class="number">2</span>);  <span class="comment">// 断言失败，触发 SIGABRT</span></span><br></pre></td></tr></table></figure><p><strong>(4) 非法指令（SIGILL）</strong><br><strong>原因</strong>：执行了 CPU 不支持的指令（如损坏的二进制文件）。<br><strong>示例</strong>（人为构造）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*func)() = (<span class="type">void</span> (*)())<span class="number">0xDEADBEEF</span>;</span><br><span class="line">func();  <span class="comment">// 跳转到非法地址，可能触发 SIGILL</span></span><br></pre></td></tr></table></figure><p><strong>(5) 外部终止（SIGKILL&#x2F;SIGTERM）</strong><br><strong>原因</strong>：用户或系统管理员通过 <code>kill</code> 命令终止进程。<br><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 &lt;PID&gt;  <span class="comment"># 发送 SIGKILL，强制终止进程</span></span><br></pre></td></tr></table></figure><p>信号部分将会在后面讲解，这里做一个简单的理解即可</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程地址空间第一讲</title>
      <link href="/2025/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/process_add1/"/>
      <url>/2025/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/process_add1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86%E5%A4%8D%E4%B9%A0">高级语言地址划分复习</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">进程地址空间</a></li></ul><!-- tocstop --><h2><span id="高级语言地址划分复习">高级语言地址划分复习</span></h2><p>下面是一张进程地址空间的分布图，相信学过 C 语言的各位肯定不会陌生：</p><p><img src="/img/Linux/process_add/vm_addr.png" alt="addr"></p><p>我们先验证一下进程地址空间是不是这样排布的，先写一个程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量（模拟原始C代码）</span></span><br><span class="line"><span class="type">int</span> g_val_1;        <span class="comment">// 未初始化的全局变量</span></span><br><span class="line"><span class="type">int</span> g_val_2 = <span class="number">42</span>;   <span class="comment">// 已初始化的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* env[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印代码段地址（函数存储位置）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;代码段地址: &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(main) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 打印只读字符串常量地址（存储在.rodata段）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello linux&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;只读字符串地址: &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(str) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 打印已初始化全局变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;已初始化全局变量地址: &quot;</span> &lt;&lt; &amp;g_val_2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 打印未初始化全局变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;未初始化全局变量地址: &quot;</span> &lt;&lt; &amp;g_val_1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 在堆上分配内存并打印其地址</span></span><br><span class="line">    <span class="type">char</span>* mem = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">100</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;堆内存地址: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(mem) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 打印栈地址（局部变量str的地址）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;栈地址: &quot;</span> &lt;&lt; &amp;str &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 打印程序名称地址(argv[0])</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;argv[0]地址: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(argv[<span class="number">0</span>]) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 打印第一个环境变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;env[0]地址: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(env[<span class="number">0</span>]) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1  </span><br><span class="line">╰─➤  ./pro_add.o</span><br><span class="line">代码段地址: 0x56398dc17199</span><br><span class="line">只读字符串地址: 0x56398dc1801a</span><br><span class="line">已初始化全局变量地址: 0x56398dc1a048</span><br><span class="line">未初始化全局变量地址: 0x56398dc1a194</span><br><span class="line">堆内存地址: 0x56398eacf2c0</span><br><span class="line">栈地址: 0x7fffe4125f60</span><br><span class="line">argv[0]地址: 0x7fffe4128245</span><br><span class="line">env[0]地址: 0x7fffe4128251</span><br></pre></td></tr></table></figure><p>你会发现，这些地址的排列和上面那张图预期是一样的</p><p>当然，还有一个我们没有验证，那就是堆向上增长，栈向下增长：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> g_val_1;</span><br><span class="line"><span class="type">int</span> g_val_2 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印代码段地址（使用reinterpret_cast进行类型转换）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;code addr: &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(main) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串常量（使用string_view避免不必要的拷贝）</span></span><br><span class="line">    <span class="keyword">constexpr</span> std::string_view str = <span class="string">&quot;hello bit&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;read only string addr: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(str.<span class="built_in">data</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印全局变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;init global value addr: &quot;</span> &lt;&lt; &amp;g_val_2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uninit global value addr: &quot;</span> &lt;&lt; &amp;g_val_1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 堆区分配（使用智能指针自动管理内存）</span></span><br><span class="line">    <span class="keyword">auto</span> mem = std::<span class="built_in">make_unique</span>&lt;<span class="type">char</span>[]&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">auto</span> mem1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">char</span>[]&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">auto</span> mem2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">char</span>[]&gt;(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;heap addr: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(mem.<span class="built_in">get</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;heap addr: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(mem<span class="number">1.</span><span class="built_in">get</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;heap addr: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(mem<span class="number">2.</span><span class="built_in">get</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 栈区变量（使用结构化绑定处理多个变量）</span></span><br><span class="line">    <span class="keyword">auto</span> [a, b, c, d, f] = std::<span class="built_in">make_tuple</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stack addr: &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stack addr: &quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stack addr: &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stack addr: &quot;</span> &lt;&lt; &amp;d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stack addr: &quot;</span> &lt;&lt; &amp;f &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行发现结果符合预期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1  </span><br><span class="line">╰─➤  ./pro_add.o                </span><br><span class="line">code addr: 0x55de7a3341a9</span><br><span class="line">read only string addr: 0x55de7a335018</span><br><span class="line">init global value addr: 0x55de7a337050</span><br><span class="line">uninit global value addr: 0x55de7a337194</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">堆向上增长</span></span><br><span class="line">heap addr: 0x55de7b9402c0</span><br><span class="line">heap addr: 0x55de7b940330</span><br><span class="line">heap addr: 0x55de7b9403a0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">栈向下增长</span></span><br><span class="line">stack addr: 0x7ffef6ed95a0</span><br><span class="line">stack addr: 0x7ffef6ed959c</span><br><span class="line">stack addr: 0x7ffef6ed9598</span><br><span class="line">stack addr: 0x7ffef6ed9594</span><br><span class="line">stack addr: 0x7ffef6ed9590</span><br></pre></td></tr></table></figure><p>我们再做一个实验，我们在代码的最后加上一个静态变量，打印一下它的地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 附加代码</span><br><span class="line"><span class="type">static</span> <span class="keyword">auto</span> e = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;static int addr: &quot;</span> &lt;&lt; &amp;e &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>编译后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1  </span><br><span class="line">╰─➤  ./pro_add.o                </span><br><span class="line">code addr: 0x5577c42971b9</span><br><span class="line">read only string addr: 0x5577c4298018</span><br><span class="line">init global value addr: 0x5577c429a058</span><br><span class="line">uninit global value addr: 0x5577c429a194</span><br><span class="line">heap addr: 0x5577c5e962c0</span><br><span class="line">heap addr: 0x5577c5e96330</span><br><span class="line">heap addr: 0x5577c5e963a0</span><br><span class="line">stack addr: 0x7fffaf91fa60</span><br><span class="line">stack addr: 0x7fffaf91fa5c</span><br><span class="line">stack addr: 0x7fffaf91fa58</span><br><span class="line">stack addr: 0x7fffaf91fa54</span><br><span class="line">stack addr: 0x7fffaf91fa50</span><br><span class="line">static int addr: 0x5577c429a19c</span><br></pre></td></tr></table></figure><p>你会发现，a的地址变得很小，可以看到其地址在全局变量地址的范围内，这说明操作系统将 static 变量地址放到全局变量区，从而使得 static 生命周期变为全局有效</p><h2><span id="进程地址空间">进程地址空间</span></h2><p>我们知道，通过fork()函数可以创建子进程，子进程和父进程会共同享用这一份代码方案，但数据段是不共享的，接下来我将用一个函数创建子进程，但子进程会更改全局变量的值，看看修改前后父子进程对这个全局变量的读取有何变化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child, pid: %d, ppid: %d, g_val: %d, &amp;g_val: %p\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>(), g_val, &amp;g_val);</span><br><span class="line">            <span class="comment">// 两秒后修改cnt的值</span></span><br><span class="line">            <span class="keyword">if</span> (cnt)</span><br><span class="line">                --cnt;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                g_val = <span class="number">200</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;g_val changed\n&quot;</span>);</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am parent, pid: %d, ppid: %d, g_val: %d, &amp;g_val: %p\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>(), g_val, &amp;g_val);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1  </span><br><span class="line">╰─➤  ./pro_add.o                </span><br><span class="line">I am parent, pid: 2302657, ppid: 2225383, g_val: 100, &amp;g_val: 0x5611f94d3050</span><br><span class="line">I am child, pid: 2302658, ppid: 2302657, g_val: 100, &amp;g_val: 0x5611f94d3050</span><br><span class="line">I am parent, pid: 2302657, ppid: 2225383, g_val: 100, &amp;g_val: 0x5611f94d3050</span><br><span class="line">I am child, pid: 2302658, ppid: 2302657, g_val: 100, &amp;g_val: 0x5611f94d3050</span><br><span class="line">I am parent, pid: 2302657, ppid: 2225383, g_val: 100, &amp;g_val: 0x5611f94d3050</span><br><span class="line">I am child, pid: 2302658, ppid: 2302657, g_val: 100, &amp;g_val: 0x5611f94d3050</span><br><span class="line">g_val changed</span><br><span class="line">I am parent, pid: 2302657, ppid: 2225383, g_val: 100, &amp;g_val: 0x5611f94d3050</span><br><span class="line">I am child, pid: 2302658, ppid: 2302657, g_val: 200, &amp;g_val: 0x5611f94d3050</span><br></pre></td></tr></table></figure><p>这里我们会发现，子进程和父进程所指向的地址是“相同”的，但是子进程把全局变量修改后，父进程的值不变，这是为什么呢？</p><p>首先根据这种现象我们可以推出，这个地址一定不是物理地址，同一个物理地址是不可能有两个不同的值的，这个地址是线性地址or虚拟地址，而我们平时在C&#x2F;C++等语言里面的地址也不是物理地址。</p><p>在进程中，每一个进程都有一份页表，页表是一种key-value模型，页表中key存储的是虚拟地址，而value则是物理地址，也就是说进程读取数据是通过虚拟地址在页表中查找映射的物理地址，而在父进程中创建子进程的时候，最初子进程和父进程会享用同一份内存数据结构以及方案，它们共享的函数方法是不会改变的，因为函数是无法改变的，只有数据是可以改变的，但这并不意味着父子进程需要在子进程创建的时候就单独为子进程再深拷贝一份数据，而是采用写时拷贝的方法，也就是说刚开始父子进程的页表是一样的，但在子进程需要改变g_val时，就需要单独为子进程拷贝一份g_val，也就是单独为子进程开辟一份物理空间，我们只需要在页表中将虚拟地址所映射的物理地址修改成写时拷贝的物理空间的地址就可以了，正是因此，子进程在修改数据后父子进程地址一样数据却不一样，因为它们的虚拟地址是一样的，修改的是虚拟地址所映射的物理地址。下面这张图就是我对这个现象的解释：</p><p><img src="/img/Linux/process_add/cp_pro_addr.png" alt="addr"></p><p>那么，什么是进程地址空间呢？所谓的进程地址空间，实际上就是一个描述进程可视范围的大小，地址空间内存在各种区域划分，一部分属于代码区，一部分属于只读数据区等等，这些数据的空间划分通过规定它们地址的start和end就可以了,这样做有三个好处：</p><p>1.让进程以统一的视角看待内存。</p><p>每个进程都会认为整个内存空间都是进程自己的，从而方便操作系统管理每一个进程，让所有的进程以统一的视角去看待内存。</p><p>2.增加进程虚拟地址空间可以让我们访问内存的时候，增加一个转化的过程，在这个转化的过程中，可以对我们的寻址请求进行审查，所以一旦异常访问，直接拦截，该请求不会到达物理内存，保护物理内存。</p><p>3.因为有地址空间和页表的存在，将进程管理模块和内存管理模块进行解耦合。</p><p>因为一个页表存储的信息有虚拟地址，所映射的物理地址，访问权限，以及是否在内存中存储，这样的话我们就可以通过判断进程是否在内存中从而对是否需要运行该进程和如何运行该进程做出判断，因此进程管理模块和内存管理模块就可以分开进行管理，不会因为内存管理出现问题而导致进程管理受到限制，这种现象就叫做解耦合。</p><p>下面我们来具体看一下进程地址空间：</p><p>描述linux下进程的地址空间的所有的信息的结构体是 mm_struct （内存描述符）。每个进程只有⼀个mm_struct结构，在每个进程的 task_struct 结构中，有⼀个<br>指向该进程的mm_struct结构体指针，核心结构大概如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">//对于普通的用户进程来说该字段指向他</span></span><br><span class="line">的虚拟地址空间的用户空间部分，对于内核线程来说这部分为<span class="literal">NULL</span>。</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span> <span class="comment">// 该字段是内核线程使⽤的。当</span></span><br><span class="line">该进程是内核线程时，它的mm字段为<span class="literal">NULL</span>，表⽰没有内存地址空间，可也并不是真正的没有，这是因</span><br><span class="line">为所有进程关于内核的映射都是⼀样的，内核线程可以使⽤任意进程的地址空间。</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说， mm_struct 结构是对整个⽤⼾空间的描述。每⼀个进程都会有⾃⼰独⽴的 mm_struct ，<br>这样每⼀个进程都会有⾃⼰独⽴的地址空间才能互不⼲扰。先来看看由 task_struct 到<br>mm_struct ，进程的地址空间的分布情况</p><p><img src="/img/Linux/process_add/task_mm_struct.png" alt="addr"></p><p>mm_struct 针对每一个独立的内存区域都会划分一个界限，确定其上界和下界：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span> <span class="comment">/* 指向虚拟区间(VMA)链表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span> <span class="comment">/* red_black树 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> task_size; <span class="comment">/*具有该结构体的进程的虚拟地址空间的⼤⼩*/</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="comment">// 代码段、数据段、堆栈段、参数段及环境段的起始和结束地址。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然每⼀个进程都会有⾃⼰独⽴的 mm_struct ，操作系统肯定是要将这么多进程的 mm_struct<br>组织起来的，虚拟空间的组织⽅式有两种：</p><ol><li>当虚拟区较少时采取单链表，由mmap指针指向这个链表；</li><li>当虚拟区间多时采取红⿊树进⾏管理，由mm_rb指向这棵树。</li></ol><p>linux内核使⽤ vm_area_struct 结构来表⽰⼀个独⽴的虚拟内存区域(VMA)，由于每个不同质的虚<br>拟内存区域功能和内部机制都不同，因此⼀个进程使⽤多个vm_area_struct结构来分别表⽰不同类型<br>的虚拟内存区域。上⾯提到的两种组织⽅式使⽤的就是vm_area_struct结构来连接各个VMA，⽅便进<br>程快速访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_start; <span class="comment">//虚存区起始</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_end; <span class="comment">//虚存区结束</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span> <span class="comment">//前后指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span> <span class="comment">//红⿊树中的位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">//所属的 mm_struct</span></span><br><span class="line"><span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_flags; <span class="comment">//标志位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rb_subtree_last;</span><br><span class="line">&#125; shared;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span> <span class="comment">//vma对应的实际操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_pgoff; <span class="comment">//⽂件映射偏移量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span> <span class="comment">//映射的⽂件</span></span><br><span class="line"><span class="type">void</span> * vm_private_data; <span class="comment">//私有数据</span></span><br><span class="line"><span class="type">atomic_long_t</span> swap_readahead_info;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span> <span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span> <span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>因此，我们可以通过下面这两张图来更好的理解进程地址空间的结构分布：</p><p><img src="/img/Linux/process_add/vm_addr2.png" alt="addr"></p><p><img src="/img/Linux/process_add/vm_addr3.png" alt="addr"></p><p>所以说为什么需要进程地址空间这个东西呢？</p><p><strong>1. 直接操作物理内存的问题</strong><br><strong>(1) 安全风险</strong></p><ul><li><strong>问题</strong>：所有程序直接访问物理内存，恶意程序（如病毒）可以随意读写其他进程或内核的内存数据，导致系统崩溃或数据泄露。</li><li><strong>虚拟地址空间的解决方案</strong>：<ul><li><strong>隔离性</strong>：每个进程拥有独立的虚拟地址空间，进程只能访问自己地址空间内的内存。操作系统通过页表（Page Table）控制虚拟地址到物理地址的映射，确保非法访问被拦截（触发缺页异常或段错误）。</li><li><strong>权限控制</strong>：页表项（PTE）中标记内存区域的读写执行权限（如代码段只读），防止代码被篡改。</li></ul></li></ul><p><strong>(2) 地址不确定</strong></p><ul><li><strong>问题</strong>：程序编译时假设从固定物理地址加载，但实际运行时物理内存可能被其他进程占用，导致加载地址冲突。</li><li><strong>虚拟地址空间的解决方案</strong>：<ul><li><strong>固定虚拟地址</strong>：程序编译时使用虚拟地址（如从 <code>0x400000</code> 开始），操作系统通过页表动态映射到任意可用的物理地址。</li><li><strong>动态加载</strong>：程序每次运行时，物理内存的分配位置可以不同，但虚拟地址对进程透明，保证一致性。</li></ul></li></ul><p><strong>(3) 效率低下</strong></p><ul><li><strong>问题</strong>：直接操作物理内存时，进程必须作为连续的整体加载到内存或交换到磁盘，导致内存碎片化和交换效率低。</li><li><strong>虚拟地址空间的解决方案</strong>：<ul><li><strong>分页机制</strong>：物理内存和虚拟内存被划分为固定大小的页（如4KB），进程的页可以离散分布在物理内存中，无需连续。</li><li><strong>按需调页</strong>：只有实际访问的页才会被加载到物理内存（延迟分配），减少内存浪费。</li><li><strong>交换优化</strong>：仅将不活跃的页交换到磁盘，而非整个进程。</li></ul></li></ul><hr><p><strong>2. 虚拟地址空间的核心优势</strong><br><strong>(1) 解耦进程管理与内存管理</strong></p><ul><li><strong>物理内存的灵活性</strong>：物理内存的分配与进程的虚拟地址空间无关，操作系统可以动态调整物理页的分配（如页面置换算法）。</li><li><strong>进程视角统一</strong>：进程看到的虚拟地址空间是连续的，实际物理内存的碎片化对进程透明。</li></ul><p><strong>(2) 延迟分配与内存超售</strong></p><ul><li><strong>示例</strong>：<code>malloc</code> 或 <code>new</code> 申请内存时，仅分配虚拟地址空间，物理内存实际占用为0。首次访问时触发缺页异常，操作系统再分配物理页并建立页表映射。</li><li><strong>好处</strong>：避免提前占用物理内存，提高资源利用率。</li></ul><p><strong>(3) 共享内存与高效通信</strong></p><ul><li><strong>机制</strong>：不同进程的虚拟地址可以映射到同一物理页（如共享库、进程间通信的共享内存）。</li><li><strong>实现</strong>：页表项中标记共享属性，避免数据冗余拷贝。</li></ul><hr><p><strong>3. 虚拟地址空间的实现关键</strong><br><strong>(1) 页表（Page Table）</strong></p><ul><li><strong>作用</strong>：记录虚拟地址到物理地址的映射关系，由操作系统维护。</li><li><strong>多级结构</strong>：现代CPU使用多级页表（如x86_64的4级页表：PGD→PUD→PMD→PTE），节省存储空间。</li></ul><p><strong>(2) 硬件支持</strong></p><ul><li><strong>MMU（内存管理单元）</strong>：CPU内置组件，负责虚拟地址到物理地址的转换（查页表）。</li><li><strong>TLB（快表）</strong>：缓存常用页表项，加速地址转换。</li></ul><p><strong>(3) 操作系统协作</strong></p><ul><li><strong>缺页异常处理</strong>：访问未映射的虚拟地址时，CPU触发缺页异常，内核分配物理页并更新页表。</li><li><strong>页面置换</strong>：物理内存不足时，将不活跃的页换出到磁盘（如Linux的Swap机制）。</li></ul><hr><p><strong>4. 实际案例</strong><br><strong>(1) 程序启动过程</strong></p><ol><li>加载器读取可执行文件，为其分配虚拟地址空间（如代码段 <code>.text</code> 映射到 <code>0x400000</code>）。</li><li>操作系统动态分配物理页，建立页表映射。</li><li>程序从虚拟地址 <code>0x400000</code> 开始执行，无需关心实际物理地址。</li></ol><p><strong>(2) <code>malloc</code> 的工作原理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>GB); <span class="comment">// 仅分配1GB的虚拟地址空间</span></span><br><span class="line">*p = <span class="string">&#x27;a&#x27;</span>;              <span class="comment">// 首次访问时触发缺页异常，分配物理页</span></span><br></pre></td></tr></table></figure><p><strong>(3) 共享库（如<code>libc.so</code>）</strong></p><ul><li>多个进程的虚拟地址映射到同一物理内存中的库代码，节省内存。</li></ul><hr><p><strong>5. 总结：虚拟地址空间的意义</strong></p><table><thead><tr><th><strong>问题</strong></th><th><strong>虚拟地址空间的解决方案</strong></th></tr></thead><tbody><tr><td>安全风险</td><td>进程隔离 + 页表权限控制</td></tr><tr><td>地址不确定</td><td>固定虚拟地址 + 动态物理映射</td></tr><tr><td>内存效率低下</td><td>分页机制 + 按需调页 + 离散分配</td></tr><tr><td>进程与内存强耦合</td><td>解耦虚拟地址与物理地址，支持灵活管理</td></tr><tr><td>内存浪费</td><td>延迟分配（如<code>malloc</code>） + 共享内存</td></tr></tbody></table><p>虚拟地址空间不仅是技术实现的进步，更是操作系统设计哲学的体现：<strong>通过抽象层隐藏复杂性，为用户和程序提供统一、安全、高效的运行环境</strong>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令行参数和环境变量</title>
      <link href="/2025/07/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/environment_argc_argv/"/>
      <url>/2025/07/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/environment_argc_argv/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-environment-variables-%E6%A6%82%E5%BF%B5">环境变量 (Environment Variables) 概念</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%A4%BA%E4%BE%8B">常见环境变量示例</a></li><li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">命令行参数</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8F%82%E6%95%B0">环境变量参数</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84">进程是如何获取环境变量的？</a></li><li><a href="#getenv">getenv</a></li></ul><!-- tocstop --><h2><span id="环境变量-environment-variables-概念">环境变量 (Environment Variables) 概念</span></h2><ul><li><p><strong>定义</strong>: 环境变量是指在操作系统中用来指定操作系统运行环境的一些参数</p></li><li><p><strong>示例</strong>:<br>在编写C&#x2F;C++代码时，链接过程中通常不需要明确知道动态或静态库的位置，但仍能成功链接并生成可执行程序。这是因为相关环境变量帮助编译器进行查找</p></li><li><p><strong>特性</strong>:  </p><ul><li>通常具有特殊用途</li><li>在系统中具有全局特性</li></ul></li></ul><h2><span id="常见环境变量示例">常见环境变量示例</span></h2><ul><li><p><strong>PATH</strong><br>指定命令的搜索路径。</p></li><li><p><strong>HOME</strong><br>指定用户的主工作目录（即用户登录到Linux系统时的默认目录）。</p></li><li><p><strong>SHELL</strong><br>当前使用的Shell，其值通常是<code>/bin/bash</code>。</p></li></ul><p>我们可以通过 echo 指令查看环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $NAME //NAME:你的环境变量名称</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/games</span><br></pre></td></tr></table></figure><p>系统的命令本质上也是可执行程序，而你自己编译出来的可执行程序执行是需要指定对应路径的，但系统的命令确不需要指定路径就可以调度，这是为什么呢？</p><p>这正是环境变量起到了作用，当你输入一个命令的时候，系统是会去 PATH 环境变量对应的路径下面查找是否有对应可执行程序的，而你自己编译出来的可执行程序的路径并不在<br> PATH 环境变量中，因此若你不提供自己的可执行程序对应的路径，系统在 PATH 所包含的所有路径中查找后没有发现该可执行程序，就会报错</p><p>这里我们可以举例验证一下，下面这个可执行程序默认情况下是需要指定路径才可以运行的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./test.o                                                                                                     130 ↵</span><br><span class="line">I am parent process, my pid is 2027036</span><br><span class="line">I am child process, my pid is 2027037 my ppid is 2027036</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  test.o</span><br><span class="line">zsh: command not found: test.o</span><br></pre></td></tr></table></figure><p>但我们可以用个 export 命令导入一个新的路径环境变量到 PATH 中去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  export PATH=$PATH:/home/ljx/linux_review/lesson1/dir1</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  test.o</span><br><span class="line">I am parent process, my pid is 2027629</span><br><span class="line">I am child process, my pid is 2027630 my ppid is 2027629</span><br></pre></td></tr></table></figure><p>然后你就会惊奇的发现，不用指定路径也可以运行这条指令了，我们查看一下 PATH 变量，会发现多了一条<br>刚刚被我们导入的路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/games:/home/ljx/linux_review/lesson1/dir1</span><br></pre></td></tr></table></figure><p>Linux 中如果想要查看到所有的变量，可以通过 env 命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  env</span><br><span class="line">USER=ljx</span><br><span class="line">LOGNAME=ljx</span><br><span class="line">HOME=/home/ljx</span><br><span class="line">PATH=/usr/local/bin:/usr/bin:/bin:/usr/games</span><br><span class="line">SHELL=/usr/bin/zsh</span><br><span class="line">...... #后面内容太多就省略了</span><br></pre></td></tr></table></figure><p>除了这种方式获取环境变量，我们还可以通过代码获取环境变量，不过在此之前，我得先介绍一下 main 函数传参的前两个参数 argc 和 argv</p><h2><span id="命令行参数">命令行参数</span></h2><p>这两个参数分别代表的是命令行参数的个数以及命令行参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行这段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./arg.o 111 222 333</span><br><span class="line">./arg.o</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br></pre></td></tr></table></figure><p>你会发现，argv 的第一个参数是进程名称，后面分别就对应的是输入的命令行参数</p><p>命令行参数中存储的是一个个的 char* 指针，因此最后一个 argv 的下一个 char* 是空指针，因此可以改写成如下遍历形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; argv[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当遍历到 argv[i] 为0的时候，就会退出循环，最终运行结果和上面相同</p><h2><span id="环境变量参数">环境变量参数</span></h2><p>同样的，环境变量也可以通过这种方式获取，环境变量对应的是 main 函数的第三个参数 env（名字随便取的，你喜欢怎么叫都行）</p><p>当然，环境变量参数不像命令行参数一样有一个 argc 用于计数，但我们可以通过判断是否便利到了 nullptr 来判断是否遍历完了</p><p>环境变量参数存储图：</p><p><img src="/img/Linux/env_arg/environ.png" alt="env"></p><p>我们通过判断是否遍历到空指针来遍历整个环境变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; env[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; env[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，打印出来的数据和通过 env 指令获取的一模一样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./arg.o</span><br><span class="line">USER=ljx</span><br><span class="line">LOGNAME=ljx</span><br><span class="line">HOME=/home/ljx</span><br><span class="line">PATH=/usr/local/bin:/usr/bin:/bin:/usr/games</span><br><span class="line">SHELL=/usr/bin/zsh</span><br><span class="line">...... # 同理，省略了后面的数据</span><br></pre></td></tr></table></figure><p>除此之外，我们还可以利用第三方变量 environ 来获取环境变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; environ[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; environ[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>libc中定义的全局变量environ指向环境变量表,environ没有包含在任何头文件中,所以在使用时 要用<br>extern声明</p><h2><span id="进程是如何获取环境变量的">进程是如何获取环境变量的？</span></h2><p>子进程的环境变量都是会从父进程继承过来的，而我们创建的所有进程，都是通过 bash 或 zsh 等命令行工具创建出来的，因此<br>在我们运行一个进程的时候，这个进程就自然将 bash 进程的环境变量继承过来了</p><h2><span id="getenv">getenv</span></h2><p>该函数可以用于获取环境变量对应的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getenv</span>(<span class="string">&quot;PATH&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后即可直接查看到 PATH 环境变量存储的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./arg.o</span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/games</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 环境变量 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程状态及优先级</title>
      <link href="/2025/07/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/process_status/"/>
      <url>/2025/07/14/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/process_status/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">进程状态</a><ul><li><a href="#%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81-r">运行状态 R</a></li><li><a href="#%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%80%81-s">休眠状态 S</a></li><li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%80%81-d">深度休眠状态 D</a></li><li><a href="#%E6%9A%82%E5%81%9C%E7%8A%B6%E6%80%81-t">暂停状态 T</a></li><li><a href="#%E6%AD%BB%E4%BA%A1%E7%8A%B6%E6%80%81-x">死亡状态 X</a></li><li><a href="#%E5%83%B5%E5%B0%B8%E7%8A%B6%E6%80%81-z">僵尸状态 Z</a></li><li><a href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B">孤儿进程</a></li></ul></li><li><a href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7">进程优先级</a></li></ul><!-- tocstop --><h2><span id="进程状态">进程状态</span></h2><p>进程在操作系统中是以双链表的方式连接起来的，而操作系统管理进程本质上是对双链表的增删查改，因此，进程的状态也是由操作系统管理起来的，在操作系统中，<br>进程的状态转化图如下所示：</p><p><img src="/img/Linux/process_status/status.png" alt="status"></p><p>这个是在操作系统学科的教材里面对操作系统内进程状态的一般解释，下面我们再看看 Linux 中进程状态转化图：</p><p><img src="/img/Linux/process_status/linux_status.png" alt="status"></p><p>哇，这个图看着好复杂，但我想说的是，你完全没必要去理解这玩意，把下面这些搞懂，这张图自然就可以看懂了</p><p>为了更加深入的理解 Linux 中进程状态，我们先看看 Linux 内核中进程状态结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* states in TASK_REPORT: */</span></span><br><span class="line">    <span class="string">&quot;R (running)&quot;</span>,        <span class="comment">/* 0x00 */</span></span><br><span class="line">    <span class="string">&quot;S (sleeping)&quot;</span>,        <span class="comment">/* 0x01 */</span></span><br><span class="line">    <span class="string">&quot;D (disk sleep)&quot;</span>,    <span class="comment">/* 0x02 */</span></span><br><span class="line">    <span class="string">&quot;T (stopped)&quot;</span>,        <span class="comment">/* 0x04 */</span></span><br><span class="line">    <span class="string">&quot;t (tracing stop)&quot;</span>,    <span class="comment">/* 0x08 */</span></span><br><span class="line">    <span class="string">&quot;X (dead)&quot;</span>,        <span class="comment">/* 0x10 */</span></span><br><span class="line">    <span class="string">&quot;Z (zombie)&quot;</span>,        <span class="comment">/* 0x20 */</span></span><br><span class="line">    <span class="string">&quot;P (parked)&quot;</span>,        <span class="comment">/* 0x40 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* states beyond TASK_REPORT: */</span></span><br><span class="line">    <span class="string">&quot;I (idle)&quot;</span>,        <span class="comment">/* 0x80 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>状态标志</strong></th><th><strong>十六进制值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>&quot;R (running)&quot;</code></td><td><code>0x00</code></td><td><strong>运行中</strong> 或 <strong>可运行</strong>：进程正在 CPU 执行，或在运行队列中等待调度。</td></tr><tr><td><code>&quot;S (sleeping)&quot;</code></td><td><code>0x01</code></td><td><strong>可中断睡眠</strong>：进程在等待事件（如 I&#x2F;O 完成、信号），可被信号唤醒。</td></tr><tr><td><code>&quot;D (disk sleep)&quot;</code></td><td><code>0x02</code></td><td><strong>不可中断睡眠</strong>：进程在等待不可中断的事件（如磁盘 I&#x2F;O），<strong>不会被信号唤醒</strong>。此状态通常由内核关键路径（如文件系统操作）触发，长时间阻塞可能引发系统问题。</td></tr><tr><td><code>&quot;T (stopped)&quot;</code></td><td><code>0x04</code></td><td><strong>暂停状态</strong>：进程被信号（如 <code>SIGSTOP</code>、<code>SIGTSTP</code>）暂停，需 <code>SIGCONT</code> 恢复。</td></tr><tr><td><code>&quot;t (tracing stop)&quot;</code></td><td><code>0x08</code></td><td><strong>跟踪暂停</strong>：进程被调试器（如 <code>gdb</code>）暂停，类似于 <code>T</code> 但专用于调试场景。</td></tr><tr><td><code>&quot;X (dead)&quot;</code></td><td><code>0x10</code></td><td><strong>死亡状态</strong>：进程已终止，等待父进程回收。此状态用户态通常不可见。</td></tr><tr><td><code>&quot;Z (zombie)&quot;</code></td><td><code>0x20</code></td><td><strong>僵尸状态</strong>：进程已退出，但父进程尚未通过 <code>wait()</code> 回收其资源。残留的 <code>task_struct</code> 会占用内核资源，过多僵尸进程可能导致 PID 耗尽。</td></tr><tr><td><code>&quot;P (parked)&quot;</code></td><td><code>0x40</code></td><td><strong>停放状态</strong>：内核线程主动进入休眠，等待被唤醒（如 <code>kthreadd</code> 管理的线程）。</td></tr></tbody></table><p>前面说过，操作系统通过队列的方式来管理进程，而进程又有这么写状态存在，因此在单 CPU 架构当中，CPU 内部会针对各种状态实现一个队列用于管理这些进程</p><h3><span id="运行状态-r">运行状态 R</span></h3><p>好比说，当一个进程被唤醒后处于运行状态时，操作系统和就会把该进程放入运行队列当中，处在运行队列当中的进程的状态是 R 状态，但是这并不意味着这个<br>进程会一直处于运行状态直到运行完，因为一个进程运行的时间是不确定的，要是一直让他运行那你让运行队列中的其他进程怎么想，因此运行队列中的每一个 task_struct 都会<br>对应有一个东西叫做时间片，即每个进程只能运行固定的时间，而后会调用下一个进程，但因为 CPU 运行的速度非常快，所以你很难看出这些进程实际上是串行运行的，他们<br>被放到运行队列中以轮询的方式被均衡调度，所以你会有一种所有进程在并行运行的感觉</p><p>而在多 CPU 的结构里，每个 CPU 会有一个独立的运行队列，而不是使用全局队列，若实例一个全局运行队列就会导致出现 CPU 竞争访问运行队列资源的现象，这是很耗时的，且<br>安全性也会很差，因此不如个每个 CPU 一个运行队列，这样每个 CPU 各管各的进程，就不存在竞争和冲突了</p><p>运行状态如何查看呢？我们当然可以通过 ps 命令查看他：</p><p>我们先跑一个死循环的程序，然后通过 ps 查看他的状态：</p><p>cpp 程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看状态如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep run.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1961362 1962323 1962323 1961362 pts/4    1962323 R+    1003   0:21 ./run.o</span><br><span class="line">1962368 1962465 1962464 1962368 pts/5    1962464 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv run.o</span><br></pre></td></tr></table></figure><p>可以看到，run.o 进程处于运行状态（R+），这说明该进程一直都在运行队列上面</p><h3><span id="休眠状态-s">休眠状态 S</span></h3><p>我们对这个代码进行一个小小的改动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再查看该进程的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep sleep.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1961362 1963227 1963227 1961362 pts/4    1963227 S+    1003   0:00 ./sleep.o</span><br><span class="line">1962368 1963288 1963287 1962368 pts/5    1963287 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv sleep.o</span><br></pre></td></tr></table></figure><p>可以看到，该进程处于休眠状态，我们再改变一下代码形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，进程仍然处于休眠状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep sleep.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1961362 1963776 1963776 1961362 pts/4    1963776 S+    1003   0:00 ./sleep.o</span><br><span class="line">1962368 1963862 1963861 1962368 pts/5    1963861 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv sleep.o</span><br></pre></td></tr></table></figure><p>第一个示例本身调用的就是 sleep 函数，就是让系统将自己休眠，在第二个示例中，scanf 操作属于阻塞操作，进程会等待标准输入输入数据，操作系统会将该进程挂载到<br>阻塞队列当中，在没有被回应前会一直处于休眠状态，而当监测到标准输入时则会被操作系统唤醒，将进程挂载到运行队列当中去</p><h3><span id="深度休眠状态-d">深度休眠状态 D</span></h3><p>你肯定会有疑惑，休眠还不够吗，咋还需要深度休眠？</p><p>我来举个例子吧，假如说一个进程正在执行磁盘写入操作，而写入的过程中操作系统发现 CPU 快要满了，于是就需要杀掉一些睡眠状态的进程，于是就把这个进程给杀掉了，<br>等 CPU 空闲的时候操作系统再回头发现这个进程被杀掉了，这就意味着这一次的磁盘写入操作失效了，假如说这个写入操作是一次银行的交易，那就有可能造成3亿资金的泄露，<br>一切磁盘写入的操作都是不允许丢失的，因此，为了防止 CPU “乱杀无辜”，就有了深度睡眠的概念</p><p>对于一些因执行任务比较重要而不可被杀掉的进程在休眠的时候会给深度休眠的状态，<strong>深度休眠的进程是不可以被杀掉的</strong>，利用这一特性就可以解决这一问题</p><h3><span id="暂停状态-t">暂停状态 T</span></h3><p>该状态一般是通过信号控制的，关于信号的具体使用等等将会在后面讲解，这里我们需要简单了解一下这个状态的意义所在</p><p>举一个很简单的例子，gdb 是一个用来代码调试的工具，他的断点功能是怎么实现的呢？没错，就是通过给执行程序发送暂停信号来控制的，通过给进程发送暂停信号<br>来完成断点就是暂停状态的一个很好的使用案例</p><h3><span id="死亡状态-x">死亡状态 X</span></h3><p>死亡状态（EXIT_DEAD 或 TASK_DEAD） 是进程生命周期中的最终状态，表示进程已完全终止且所有资源（包括 task_struct 结构体）已被内核回收。由于其存在时间极短（通常仅几微秒），普通用户无法直接观察到该状态，这里只需要简单理解一下即可</p><h3><span id="僵尸状态-z">僵尸状态 Z</span></h3><p>僵尸状态指的是一个进程死亡后但还没有被父进程回收时所处的状态，若一个进程长期不被父进程回收就会导致进程长期处于僵尸状态，这种子进程死亡确一直占着内存<br>不放的现象我们称之为<strong>内存泄露</strong>，这种现象是不被允许发生的</p><p>接下来我们制作一个让子进程短时间处于僵尸状态从而让我们可以察觉到的现象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = fork();</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am child process.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 休眠5秒</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I will die.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I will sleep for 10s.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 回收子进程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I will recycle the child process.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">waitpid</span>(ret, <span class="literal">nullptr</span>, WNOHANG);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I will exit.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个用例，刚开始我们会查看到两个进程都处于休眠状态（sleep 函数占大头），5s 后子进程退出死亡，但父进程此时还没有回收子进程，因此子进程会等待被回收，进入僵尸状态，<br>再过5s，父进程回收掉子进程，就只会看到父进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二者都在休眠状态</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep zombie.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1961362 1972423 1972423 1961362 pts/4    1972423 S+    1003   0:00 ./zombie.o</span><br><span class="line">1972423 1972424 1972423 1961362 pts/4    1972423 S+    1003   0:00 ./zombie.o</span><br><span class="line">1962368 1972476 1972475 1962368 pts/5    1972475 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv zombie.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">子进程等待父进程回收自己</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep zombie.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1961362 1972423 1972423 1961362 pts/4    1972423 S+    1003   0:00 ./zombie.o</span><br><span class="line">1972423 1972424 1972423 1961362 pts/4    1972423 Z+    1003   0:00 [zombie.o] &lt;defunct&gt;</span><br><span class="line">1962368 1972502 1972501 1962368 pts/5    1972501 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv zombie.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">子进程被回收</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep zombie.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1961362 1972423 1972423 1961362 pts/4    1972423 S+    1003   0:00 ./zombie.o</span><br><span class="line">1962368 1972556 1972555 1962368 pts/5    1972555 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv zombie.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">父进程退出</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep zombie.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1962368 1972647 1972646 1962368 pts/5    1972646 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv zombie.o</span><br></pre></td></tr></table></figure><h3><span id="孤儿进程">孤儿进程</span></h3><p>进程如果提前退出，那么字进程后退出，进⼊Z之后，就会被1 号进程领养，没错，1 号进程就是操作系统本身，而操作系统会定期回收这些子进程，从而避免了<br>内存泄露等问题</p><p>我们将例子改一下，使得父进程先退出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = fork();</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am child process.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I will sleep for 10s.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I will die.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I will sleep for 5s.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I will exit.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep zombie.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1961362 1974897 1974897 1961362 pts/4    1974897 S+    1003   0:00 ./zombie.o</span><br><span class="line">1974897 1974898 1974897 1961362 pts/4    1974897 S+    1003   0:00 ./zombie.o</span><br><span class="line">1962368 1974955 1974954 1962368 pts/5    1974954 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv zombie.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">父进程退出，子进程 ppid 变成 1，表示被操作系统领养</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep zombie.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">      1 1974898 1974897 1961362 pts/4    1961362 S     1003   0:00 ./zombie.o</span><br><span class="line">1962368 1975026 1975025 1962368 pts/5    1975025 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv zombie.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">操作系统定期调用 <span class="built_in">wait</span> 函数回收子进程</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep zombie.o</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1962368 1975103 1975102 1962368 pts/5    1975102 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv zombie.o</span><br></pre></td></tr></table></figure><h2><span id="进程优先级">进程优先级</span></h2><ul><li><strong>CPU资源分配的先后顺序</strong>，就是指进程的优先权（priority）。  </li><li>优先权高的进程有优先执行权利。配置进程优先权对多任务环境的Linux很有用，可以改善系统性能。  </li><li>还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能。</li></ul><p>为了方便看进程的优先级，我们可以利用指令 ps -l 来查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1003 1962368 1962367  0  80   0 -  2884 sigsus pts/5    00:00:01 zsh</span><br><span class="line">0 R  1003 1976685 1962368  0  80   0 -  2772 -      pts/5    00:00:00 ps</span><br></pre></td></tr></table></figure><p>这里涉及到两个新的概念：</p><p>• PRI ：代表这个进程可被执⾏的优先级，其值越⼩越早被执⾏<br>• NI ：代表这个进程的nice值</p><p>优先级越高的进程被调度得就越频繁，高优先级进程就好比 vip 用户，享用的是 vip 专区服务，而低优先级的进程就是普通用户，必须严格遵循排队等待机制</p><p>进程的优先级等于 pri + nice，我们可以通过 top 命令来修改一个进程的 nice 值从而修改一个进程的优先级，需要注意的是<br>输入 nice 值后进程的优先级等于80 + nice 值，比如说，我们修改一个进程的nice值为10：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入 top 命令，而后输入 r 进入 <span class="built_in">nice</span> 值修改模式，输入当前进程号</span></span><br><span class="line">top - 15:22:09 up 65 days, 35 min,  2 users,  load average: 0.00, 0.03, 0.06</span><br><span class="line">Tasks: 121 total,   1 running, 120 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):100.0 us,  0.0 sy,  0.0 ni,  0.0 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span> </span><br><span class="line">MiB Mem :   1839.0 total,     72.2 free,   1405.4 used,    536.7 buff/cache     </span><br><span class="line">MiB Swap:   4096.0 total,   3342.4 free,    753.6 used.    433.6 avail Mem </span><br><span class="line">PID to renice [default pid = 1] 1980795</span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                                              </span><br><span class="line">      1 root      20   0  168960   9804   7308 S   0.0   0.5   0:58.86 systemd                                                                                                              </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:01.48 kthreadd                                                                                                             </span><br><span class="line">      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp                                                                                                               </span><br><span class="line">      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp          </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改优先级为 10</span></span><br><span class="line">top - 15:22:09 up 65 days, 35 min,  2 users,  load average: 0.00, 0.03, 0.06</span><br><span class="line">Tasks: 121 total,   1 running, 120 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):100.0 us,  0.0 sy,  0.0 ni,  0.0 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span> </span><br><span class="line">MiB Mem :   1839.0 total,     72.2 free,   1405.4 used,    536.7 buff/cache     </span><br><span class="line">MiB Swap:   4096.0 total,   3342.4 free,    753.6 used.    433.6 avail Mem </span><br><span class="line">Renice PID 1980795 to value 10</span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                                              </span><br><span class="line">      1 root      20   0  168960   9804   7308 S   0.0   0.5   0:58.86 systemd                                                                                                              </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:01.48 kthreadd                                                                                                             </span><br><span class="line">      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp                                                                                                               </span><br><span class="line">      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 </span><br></pre></td></tr></table></figure><p>再次查看，我们会发现该进程的优先级变成了90：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1  </span><br><span class="line">╰─➤  ps -al</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1003 1980795 1962368  0  90  10 -  1412 wait_w pts/5    00:00:00 sleep.o</span><br><span class="line">0 R  1003 1983196 1961362  0  80   0 -  2772 -      pts/4    00:00:00 ps</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程概念</title>
      <link href="/2025/07/13/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/process_concept/"/>
      <url>/2025/07/13/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/process_concept/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3">进程基本概念理解</a></li><li><a href="#linux-%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97task_struct">Linux 的进程控制块——task_struct</a><ul><li><a href="#task_struct-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84">task_struct 内部结构</a><ul><li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6-pid">标识符 PID</a></li><li><a href="#fork">fork</a></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="进程基本概念理解">进程基本概念理解</span></h1><p>进程（Process）是计算机中正在运行的程序实例，是操作系统进行资源分配和调度的基本单位。每个进程都有独立的内存空间、代码、数据和系统资源（如文件句柄、网络连接等）</p><p>不要把进程理解成一个非常高深的概念，进程还有另一个你可能听得更多的名称，叫做任务，在 Windows 中，你启动一个软件本质上就是创建了一个进程，这个进程是被操作系统管理起来的<br>而一个操作系统需要管理的进程数量肯定不止这一个。例如，在操作系统启动的时候，就会有许多系统级进程（守护进程等等）自动创建出来，因此，管理一个个进程的过程可以被理解成一个<br>学校管理学生的过程</p><p>一个进程通常包含：</p><ol><li><strong>代码段（Text Segment）</strong><ul><li>存储程序的<strong>可执行指令</strong>（机器码）。</li></ul></li><li><strong>数据段（Data Segment）</strong><ul><li>存储<strong>全局变量和静态变量</strong>。</li></ul></li><li><strong>堆（Heap）</strong><ul><li>动态分配的内存（如 <code>malloc()</code> 或 <code>new</code> 申请的空间）。</li></ul></li><li><strong>栈（Stack）</strong><ul><li>存储<strong>局部变量、函数调用信息</strong>（如返回地址、参数）。</li></ul></li><li><strong>进程控制块（PCB）</strong><ul><li>操作系统维护的<strong>元数据</strong>，包括：<ul><li>进程 ID（PID）</li><li>进程状态（运行、就绪、阻塞等）</li><li>寄存器值（程序计数器、堆栈指针等）</li><li>资源占用情况（打开的文件、内存分配等）</li></ul></li></ul></li></ol><p>乍一看感觉进程有好多好多的东西，但你再仔细观察一下，1到4都可以被统称为进程运行所需要的基本数据，在编写一个程序的时候，你需要编写一段代码并将它编译后<br>形成可执行程序，这个可执行程序是一段二进制代码，这段二进制代码会被计算机（如冯诺依曼架构）执行，通过指令寄存器一一读取，再被控制单元（CU）译码转化为实际的行为，<br>而数据段就是运行代码时需要通过寻址找到的数据，这些数据被存储在了内存当中，而他也是一个进程的一部分。堆和栈一个用于动态分配内存并使用，另一个用于存储局部变量以及函数<br>的调用，这些都是一个程序要运行起来所必须的部分。</p><p>回到学校管理学生的例子，程序的 代码段、数据段、堆、栈 就好比学生自己本身，他是进程运行所需要的自身因素，而进程控<br>制块内部存储的进程 ID 就好比学校管理学生给学生编的一个唯一标识–学号，进程状态就好比<br>学校判断学生是在读，还是在休假，而资源占用情况可以理解为学校判断一个学生的考核情况，违纪情况以及奖赏情况</p><p>没错，学校对大量的学生进行管理，操作系统对大量进程的管理同样也叫做管理，管理这个词不仅仅是用于实际生活中的，操作系统中对进程既然是做了管理，那么就得用同样的一套思路去管理他们</p><p>因此，我们将进程分为两部分，代码和数据是一部分，而进程控制块（PCB）是另一部分，进程本身运作起来依赖于代码和数据，而何时运作，运作方式如何，该不该运作等等就由进程控制块去控制，<br>这就好比你在学校里面该如何活动是有你自身来决定的，但你该干什么，何时去做某件事就是由学校来控制你了，学校控制你的方式可以是给你一个课程表，给你安排一场考试等等</p><p>进程的特点如下（不需要特别去理解，后面讲解过程中会逐一理解它们的）：</p><table><thead><tr><th><strong>特征</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>动态性</strong></td><td>进程是程序的<strong>一次执行过程</strong>，有创建、运行、暂停、终止的生命周期。</td></tr><tr><td><strong>独立性</strong></td><td>每个进程拥有<strong>独立的地址空间</strong>，一个进程崩溃不会直接影响其他进程。</td></tr><tr><td><strong>并发性</strong></td><td>多个进程可以<strong>同时运行</strong>（通过 CPU 时间片轮转或并行执行）。</td></tr><tr><td><strong>资源拥有者</strong></td><td>进程是操作系统分配资源（CPU、内存、I&#x2F;O 设备等）的基本单位。</td></tr><tr><td><strong>结构化信息</strong></td><td>每个进程由 <strong>PCB（Process Control Block）</strong> 描述，包含状态、优先级等元数据。</td></tr></tbody></table><p>上面所讲的进程的概念适用于所有的操作系统，而不仅仅是 Linux，不论是什么操作系统，进程运行一定需要代码和数据，以何种方式运行就依靠于进程控制块（PCB），<br>因此，操作系统管理每个进程实际上是对进程控制块内部数据的修改，而进程控制块在操作系统中本质上是一个结构体，操作系统管理的进程有很多很多，这就意味着操作系统<br>需要对很多很多个进程控制结构体进行管理，那就需要将这些结构体通过链表的方式关联起来，因此，再说的通俗一些，<strong>操作系统对进程的管理实质上是对一个个由PCB结构体串起来的双链表的增删查改</strong>！</p><p>而在 Linux 当中，进程控制块有一个属于自己的名字叫做<strong>task_struct</strong>!!!因此 Linux 对进程的管理实质上是对list<task_struct> 的管理（Linux 内部肯定不是这样命名的，只是为了方便理解），如下图所示（运行在系统里的进程都以 task_struct 双链表的形式存在内核里）：</task_struct></p><p><img src="/img/Linux/process_concept/task_struct_list.png" alt="task_struct_list"></p><p>接下来，我们就一起来讨论一下 Linux 的这个进程控制块</p><h1><span id="linux-的进程控制块task_struct">Linux 的进程控制块——task_struct</span></h1><p>task_struct 是可以用来管理一个进程的所有信息的，因此它内部的数据肯定是相当庞大的，下面是对task_struct内部数据的大致概括：</p><h2><span id="task_struct-内部结构">task_struct 内部结构</span></h2><ul><li><strong>标示符</strong>: 描述本进程的唯一标示符，用来区别其他进程。</li><li><strong>状态</strong>: 任务状态，退出代码，退出信号等。</li><li><strong>优先级</strong>: 相对于其他进程的优先级。</li><li><strong>程序计数器（PC）</strong>: 程序中即将被执行的下一条指令的地址。</li><li><strong>内存指针</strong>: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针。</li><li><strong>上下文数据</strong>: 进程执行时处理器的寄存器中的数据。</li><li><strong>I&#x2F;O状态信息</strong>: 包括显示的I&#x2F;O请求，分配给进程的I&#x2F;O设备和被进程使用的文件列表。</li><li><strong>记账信息</strong>: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li><li><strong>其他信息</strong></li></ul><p>下面我将针对 task_struct 结构体中的每个属性进行说明</p><h3><span id="标识符-pid">标识符 PID</span></h3><p>进程标识符是用来区分每一个进程的唯一标识，成为PID(Process ID)，首先，我们要学会查看进程的 PID，下面是查看进程 PID 的一个实用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axj</span><br></pre></td></tr></table></figure><p>其中，axj代表的是ps命令的三个选项，选项代表的意义如下：</p><p>在Linux中，<code>ps axj</code> 是一个组合了多个选项的命令，用于显示进程信息。各选项的含义如下：</p><ol><li><p><strong><code>a</code></strong>  </p><ul><li>显示<strong>所有用户的进程</strong>（包括其他用户的进程），而不仅是当前终端的进程。</li></ul></li><li><p><strong><code>x</code></strong>  </p><ul><li>显示<strong>无控制终端的进程</strong>（如后台服务、守护进程等）。通常与 <code>a</code> 一起使用，以查看所有进程。</li></ul></li><li><p><strong><code>j</code></strong>  </p><ul><li>以**作业格式（Job format）**显示信息，包括额外的列：<ul><li><code>PPID</code>：父进程ID。</li><li><code>PGID</code>：进程组ID。</li><li><code>SID</code>：会话ID。</li><li>其他与作业控制相关的字段（如 <code>TPGID</code> 等）。</li></ul></li></ul></li></ol><p>下面，我们在 &#x2F;linux_review&#x2F;lesson1&#x2F;dir 下面启动一个可执行程序，并让该可执行程序死循环，然后我们可以通过<br>该命令查看进程对应信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep test1</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1674011 1757149 1757149 1673035 pts/0    1757149 R+    1003   0:40 ./test1.o</span><br><span class="line">1755563 1757366 1757365 1755563 pts/1    1757365 R+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv test1</span><br></pre></td></tr></table></figure><ul><li><strong>关键列信息</strong>：<ul><li><code>PPID</code>：父进程ID。</li><li><code>PID</code>：进程ID。</li><li><code>PGID</code>：进程组ID。</li><li><code>SID</code>：会话ID。</li><li><code>TTY</code>：关联的终端（<code>?</code> 表示无终端）。</li><li><code>STAT</code>：进程状态（如 <code>S</code>&#x3D;休眠，<code>R</code>&#x3D;运行等）。</li><li><code>COMMAND</code>：进程名称或命令行。</li></ul></li></ul><p>其中下面那个 command 为 grep 的是因为我们使用了 grep 命令过滤对应的进程名，而 grep 命令在执行的时候后面带上了我们所要查找的进程名的名称，因此该指令也会被过滤出来</p><p>可以看到有一个叫做 PID 的列，表示的是进程的 PID，可以观察到该进程的 PID 为1757149，除了这种观察进程 PID 的方式除外，我们还可以通过查看 &#x2F;proc 目录下的信息来<br>查看进程对应数据信息，proc 目录是用来管理进程信息的,通过 “ll &#x2F;proc” 指令我们可以观察到有一个目录显示的详细信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dr-xr-xr-x  9 ljx        ljx                      0 Jul 13 22:03 1757149</span><br></pre></td></tr></table></figure><p>这个文件的所有者和用户组都是 ljx ，没错，这个就是我的那个正在运行的进程！我们再进去看一下，会发现里面也有很多的文件，其中有一个我们需要重点关注的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx  1 ljx ljx 0 Jul 13 22:03 cwd -&gt; /home/ljx/linux_review/lesson1/dir</span><br></pre></td></tr></table></figure><p>可以看到，cwd -&gt; &#x2F;home&#x2F;ljx&#x2F;linux_review&#x2F;lesson1&#x2F;dir，cwd 表示的是进程的当前工作目录(current working directory)，而其指向的目录名称为 &#x2F;home&#x2F;ljx&#x2F;linux_review&#x2F;lesson1&#x2F;<br>dir，这不正是我们当前进程所运行的环境吗，所以说为什么我们通过 mkdir 命令创建文件的时候就一定知道是在当前路径下面创建的文件？本质上是因为 mkdir 命令运行起来也是一个进程，<br>而该进程运行后对应的进程文件目录下有一个 cwd 用于存储当前工作目录信息，这样 mkdir 指令就知道该在哪里创建目录了</p><p>下面将讲到 Linux 中进程获取自身 pid 和父进程 pid 的接口函数：</p><ul><li>getpid()，返回值是该进程自己的 pid，</li><li>getppid()，返回值是该进程的父进程的 pid</li></ul><p>我们来测试一下这两个接口：</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my pid is &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my ppid is &quot;</span> &lt;&lt; <span class="built_in">getppid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  ./test1.o</span><br><span class="line">my pid is 1763828</span><br><span class="line">my ppid is 1674011</span><br></pre></td></tr></table></figure><p>让我们在测试一次：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  ./test1.o</span><br><span class="line">my pid is 1764433</span><br><span class="line">my ppid is 1674011</span><br></pre></td></tr></table></figure><p>然后你会惊奇地发现，两次运行的子进程号确实会变化，这就好比一个学生上了大学后对自己大学不满意，然后复读一年结果又考上了这个大学，<br>但第二年的学号和上一年肯定是不同了，这里虽然我还没有讲解 ppid 的存在意义，但你可以将父进程理解成管理学生的校长，虽然你小子入了<br>两次学，但我校长是不变的呀，下面我将讲解一下进程中父进程存在的意义以及为什么这里的父进程不会改变：</p><p>在操作系统中，<strong>父进程（Parent Process）</strong> 的概念是为了实现 <strong>进程的层次化管理</strong>，主要作用包括：</p><ol><li><strong>进程创建与继承</strong><ul><li>新进程（子进程）通常由现有进程（父进程）通过 <code>fork()</code> + <code>exec()</code> 创建（fork() 指令马上会讲到，exec() 指令会在后期讲到）。</li><li>子进程会继承父进程的部分属性（如环境变量、文件描述符等）。</li></ul></li><li><strong>资源管理</strong><ul><li>父进程负责回收子进程的资源（避免僵尸进程）。</li></ul></li><li><strong>进程间关系维护</strong><ul><li>操作系统通过父子关系形成<strong>进程树</strong>（如 <code>pstree</code> 命令显示的层级结构）。</li></ul></li></ol><hr><p>这里只需要你有一个父进程的概念，你就可以理解成校长管理学生，而最上层对学生的管理你可以理解成教育局，教育局不可能实时关系每一个学生，<br>因此教育局就让每个学校有一个校长来管理学生，而校长也不可能管理那么多学生，故校长又让许多的辅导员来管理学生，而 Linux 中的进程管理<br>使用的也是这样的分层管理</p><p>我们通过查看该进程的父进程 id 对应信息会发现，该进程号对应的进程名叫 zsh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  ps axj | head -1 &amp;&amp; ps axj | grep 1674011                                                                    130 ↵</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1674010 1674011 1674011 1673035 pts/0    1765978 S     1003   0:06 zsh</span><br><span class="line">1674011 1765978 1765978 1673035 pts/0    1765978 R+    1003   0:00 ps axj</span><br><span class="line">1674011 1765979 1765978 1673035 pts/0    1765978 S+    1003   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox --exclude-dir=.venv --exclude-dir=venv 1674011</span><br></pre></td></tr></table></figure><p>这里需要说明一下，Linux 默认的 shell 是 bash 而不是 zsh，bash 是 Linux 中默认的命令行解析工具，所有的命令都会通过该命令解析然后创建对应的子进程并调用它们，<br>没错，Linux 中的 shell 是可以自由修改的，我为了有一个更好看的 shell 样式所以使用了 zsh 来配置主题，这也就解释了为什么该进程的父进程从来都没有改变，<br>原因就是该进程的父进程 zsh 一直都处于运行状态，而我们在命令行中输入的数据正是 zsh（或bash等其他shell）从标准输入中读取数据，我们按回车后 zsh 就会解析这个命令<br>并创建出子进程运行</p><p>因此，下面我们将要介绍子进程创建的一个工具：</p><h3><span id="fork">fork</span></h3><p>该命令用于创建子进程，首先我们看一下这个指令在 manual 中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fork(2)                       System Calls Manual                       fork(2)   </span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       fork - create a child process</span><br><span class="line"></span><br><span class="line">LIBRARY</span><br><span class="line">       Standard C library (libc, -lc)</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">       pid_t fork(void);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       fork()  creates  a  new process by duplicating the calling process.  The   </span><br><span class="line">       new process is referred to as the child process.  The calling process is   </span><br><span class="line">       referred to as the parent process.</span><br><span class="line">       ......(话太多了这里只把目前需要的部分显示出来)</span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, the PID of the child process is returned in the parent,  and   </span><br><span class="line">       0  is  returned in the child.  On failure, -1 is returned in the parent,   </span><br><span class="line">       no child process is created, and errno is set to indicate the error.  </span><br></pre></td></tr></table></figure><p>可以看到，这个指令的返回值有两个，对于子进程，若进程创建成功则返回0，对于父进程，若进程创建成功则返回新创建的子进程的 pid，否则返回 -1</p><p>这里你肯定就会疑惑了，为什么一个函数可以返回两个返回值，还可以保证两个返回值不同</p><p>首先，创建的子进程是会继承父进程的代码的，他会和父进程一起并行执行代码，而 fork 函数返回返回值也是代码的一部分，因此父子进程在运行时就都可以通过 fork 函数<br>得到返回值，这样一来就很容易根据进程的不同得到不同的返回值了</p><p>那么，为什么父进程得到的返回值时子进程的 pid，而子进程得到的返回值时0或1呢？</p><p>这是为了在 fork 函数执行后更好的分流，进程执行后可以通过fork的返回值判断，若是0则说明时子进程，父进程则判断若是-1说明进程创建失败了，否则就成狗</p><p>至于是怎么实现返回两个不同的返回值的，这就涉及到了进程地址空间的讲解，我将在后面章节对他们进行一个讲解</p><p>下面时该指令使用的一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>  <span class="comment">// 添加 wait 相关头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am child process, my pid is &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() </span><br><span class="line">             &lt;&lt; <span class="string">&quot; my ppid is &quot;</span> &lt;&lt; <span class="built_in">getppid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am parent process, my pid is &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 这里是为了等待子进程退出从而回收子进程的，否则子进程会变成孤儿进程（这个目前只需要了解，后面在讲进程状态时会重点讨论）</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">nullptr</span>);  <span class="comment">// 等待任意子进程退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行后可以看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./test.o</span><br><span class="line">I am parent process, my pid is 1778506</span><br><span class="line">I am child process, my pid is 1778507 my ppid is 1778506</span><br></pre></td></tr></table></figure><p>子进程的 ppid 正好就是父进程的 pid，效果与预期相同</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 权限管理</title>
      <link href="/2025/07/13/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/authority/"/>
      <url>/2025/07/13/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/authority/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E6%9D%83%E9%99%90%E7%90%86%E8%A7%A3%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">权限理解前置知识</a><ul><li><a href="#su-%E6%8C%87%E4%BB%A4%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD">su 指令切换用户身份</a></li><li><a href="#linux-%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA">Linux 用户创建</a></li><li><a href="#sudo-%E5%91%BD%E4%BB%A4">sudo 命令</a></li></ul></li><li><a href="#linux-%E6%9D%83%E9%99%90%E7%90%86%E8%A7%A3">Linux 权限理解</a><ul><li><a href="#chmod">chmod</a></li><li><a href="#rwx-%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AB%E4%B9%89">rwx 对于普通文件的含义</a></li><li><a href="#rwx-%E5%AF%B9%E4%BA%8E%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%AB%E4%B9%89">rwx 对于目录文件的含义</a></li><li><a href="#%E7%B2%98%E6%BB%9E%E4%BD%8D">粘滞位</a></li><li><a href="#%E6%9D%83%E9%99%90%E6%8E%A9%E7%A0%81">权限掩码</a></li></ul></li></ul><!-- tocstop --><p>在 Linux 中，用户一般分为两大类，一类是超级管理员，即 root 用户（对标 windows 中的 管理员），另一类则是普通用户</p><ul><li>root 用户：除了一些系统级别的权限，谁都拦不住它，后面我将要讲到的权限，你会发现没有一个能管得住 root，正所谓规矩是 root 定的，那自然规矩是拦不住 root 的</li><li>普通用户：如果 root 是掌权者的话，那普通用户就是百姓了，一切的权限都是对普通用户的管理</li></ul><p>在讲解权限之前，先要讲几个小小的知识点：</p><h2><span id="权限理解前置知识">权限理解前置知识</span></h2><h3><span id="su-指令切换用户身份">su 指令切换用户身份</span></h3><p>su 指令是用于切换当前用户身份的，具体如下：</p><table><thead><tr><th>指令形式</th><th>指令说明</th></tr></thead><tbody><tr><td>su</td><td>切换到超级管理员（root）</td></tr><tr><td>su xxx</td><td>切换到 xxx 用户身份（也可以是root用户）</td></tr></tbody></table><hr><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要密码验证</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  su</span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不需要密码验证</span></span><br><span class="line">┌─[root@VM-16-15-debian] - [/home/ljx/linux_review/lesson1/dir1] - [630]</span><br><span class="line">└─[$] su ljx                                                                                                 [14:27:47]</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤</span><br></pre></td></tr></table></figure><p>切换用户是需要密码的，在 Linux 当中，所有的用户都需要有密码，通过这个示例我们可以看到，普通用户切换身份的时候是需要输入密码的，但是<br>正如我前面所说，root 想要切换用户谁也拦不住，因此不需要输入密码就直接切换了</p><h3><span id="linux-用户创建">Linux 用户创建</span></h3><p>创建用户非常简单，系统默认的用户创建命令用起来非常不爽，因此他需要你手动创建用户然后手动设置密码，且有一些必要的工作也得自己后期去处理，<br>下面以 debian&#x2F;ubuntu 系统为例，使用这俩系统自带的用户创建命令来创建一个新的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">adduser [用户名]</span></span><br><span class="line">┌─[root@VM-16-15-debian] - [~] - [660]</span><br><span class="line">└─[$] adduser liangfei                                                                                       [14:49:22]</span><br><span class="line">Adding user `liangfei&#x27; ...</span><br><span class="line">Adding new group `liangfei&#x27; (1006) ...</span><br><span class="line">Adding new user `liangfei&#x27; (1006) with group `liangfei (1006)&#x27; ...</span><br><span class="line">Creating home directory `/home/liangfei&#x27; ...</span><br><span class="line">Copying files from `/etc/skel&#x27; ...</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for liangfei</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">        Full Name []:</span><br><span class="line">        Room Number []:</span><br><span class="line">        Work Phone []:</span><br><span class="line">        Home Phone []:</span><br><span class="line">        Other []:</span><br><span class="line">Is the information correct? [Y/n] y</span><br><span class="line">Adding new user `liangfei&#x27; to supplemental / extra groups `users&#x27; ...</span><br><span class="line">Adding user `liangfei&#x27; to group `users&#x27; ...</span><br></pre></td></tr></table></figure><p>adduser 命令采用交互式的方式一步步创建用户信息，用起来非常的方便，把这条命令输入进去后根据他的提示一步步操作即可</p><p>对应的，删除用户可以使用 deluser 来完成，但需要注意的是，adduser 指令和 deluser 指令都需要 root 用户来操作，普通用户是操作不了的</p><h3><span id="sudo-命令">sudo 命令</span></h3><p>有人可能就会问了，真的只能有 root 用户有这么强大的实力吗，其他普通用户有时候也需要拥有像 root 这样强大的能力，怎么办呢</p><p>这里就需要讲到一个新的命令 sudo：</p><p>有些命令对于普通用户来说会受到权限的约束，但我们有的时候确实需要访问这个权限怎么办呢？那就在你想要操作的命令最前面加上 sudo，在进行用户身份验证后（输入密码）<br>就可以使用该命令了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我现在是一个普通用户，但我想删除刚刚我创建的这个用户，直接使用该指令删除会发现命令行提示只有 root 用户才具备此权限</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  deluser liangfei                                                                                               1 ↵</span><br><span class="line">deluser: Only root may remove a user or group from the system.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">那么我们在该命令前面添加上 <span class="built_in">sudo</span> 选项，然后验证本人是 ljx 就可以使用该命令了</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  sudo deluser liangfei                                                                                          1 ↵</span><br><span class="line">[sudo] password for ljx:</span><br><span class="line">Removing crontab ...</span><br><span class="line">Removing user `liangfei&#x27; ...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>当然，sudo 指令的使用是得经过 root 同意的，只有 root 用户才可以给予用户 sudo 的使用权限</p><p>下面我们利用创建好的 liangfei 来举例：</p><p>普通的 liangfei 是无法直接使用 sudo 指令的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">liangfei@VM-16-15-debian:/home/ljx/linux_review/lesson1/dir1$ sudo su root</span><br><span class="line">[sudo] password for liangfei:</span><br><span class="line">liangfei is not in the sudoers file.</span><br></pre></td></tr></table></figure><p>此时 root 通过修改文件的白名单将 liangfei 加入到 sudoer 组里面去 ，使得 liangfei 也具有使用 sudo 的权限：</p><p>我们在&#x2F;etc&#x2F;sudoers 文件中加入如下语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liangfei ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>保存并退出，会发现 liangfei 也可以使用 sudo 指令了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">liangfei@VM-16-15-debian:/etc$ sudo whoami</span><br><span class="line">root</span><br><span class="line">liangfei@VM-16-15-debian:/etc$ sudo su root</span><br><span class="line">┌─[root@VM-16-15-debian] - [/etc] - [735]</span><br><span class="line">└─[$]      </span><br></pre></td></tr></table></figure><h2><span id="linux-权限理解">Linux 权限理解</span></h2><p>下面正式开始讲解 Linux 的权限：</p><p>我们打开一个文件，通过 ll 指令查看文件的详细信息，会看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 12 23:27 dir</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 13 11:11 dir1</span><br><span class="line">-rw-r--r-- 1 ljx ljx    0 Jul 12 21:59 test.txt</span><br></pre></td></tr></table></figure><p>一共有三行信息，每一行都表示一个文件的各种属性，下面这张图是对每行属性的表述</p><p><img src="/img/Linux/authority/authority.png" alt="authority"></p><p>从右往左看，最右边的是文件名，其次是文件本创建或者修改的日期，再接着就是文件所消耗的内存大小，因此，我们需要讨论的是左边类似于 “drwxr-xr-x 2 ljx ljx” 这样<br>的信息</p><p>首先，最左边的符号表示的是文件类型，d 表示目录文件，- 表示普通文件，目前暂时只需要了解这两个，在 Linux 中，系统是不认文件后缀的，系统只认文件信息最前面的这个文件标识，<br>因此，不能以 windows 的视角来看待 Linxu 中的文件，windows 中确实是通过文件后缀来分辨文件类型的，但 Linux 并非如此</p><p>文件类型右边的东西就是我们要重点讨论的权限了，我们选取 dir 中的权限标志，截取出来后是这样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwxr-xr-x</span><br></pre></td></tr></table></figure><p>让我们对这个标志三个一看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwx r-x r-x</span><br></pre></td></tr></table></figure><p>可以看到，这个权限标识是对三类用户进行约束的，第一个是对文件所有者的约束，第二个是对文件所属用户组的约束，第三个是对其他用户的约束（既不属于<br>文件所有者也不属于文件所属用户组）</p><p>而右边的两个名字(ljx ljx)则表示的是文件所有者和文件所属用户组分别是谁,可以看到，默认每个文件的所有者和所属用户组均为文件创建者本身</p><p>rwx 中的三个标识分别表示 read、write、execute，表示是否可读、可写、可操作，字母显示则表示对应权限有效，若为-则表示对应权限无效</p><p>就拿上面这个权限标识（rwx r-x r-x）做比方，表示的是拥有者（rwx）可读可写可操作该文件，用户组和其他用户（r-x）可读，可操作，但是不能写，因为写位置对应的是-，而不是w</p><p>权限是可以通过 chmod 指令来修改的，下面我们将隆重介绍一下 chmod 指令：</p><h3><span id="chmod">chmod</span></h3><p>首先讲解一下文件权限的两种表示方法</p><h4><span id="文件权限值的表示方法">文件权限值的表示方法</span></h4><h5><span id="a-字符表示方法">a) 字符表示方法</span></h5><table><thead><tr><th>Linux表示</th><th>说明</th><th>Linux表示</th><th>说明</th></tr></thead><tbody><tr><td>r–</td><td>只读</td><td>-w-</td><td>仅可写</td></tr><tr><td>–x</td><td>仅可执行</td><td>rw-</td><td>可读可写</td></tr><tr><td>-wx</td><td>可写和可执行</td><td>r-x</td><td>可读可执行</td></tr><tr><td>rwx</td><td>可读可写可执行</td><td>—</td><td>无权限</td></tr></tbody></table><h5><span id="b-8进制数值表示方法">b) 8进制数值表示方法</span></h5><table><thead><tr><th>权限符号（读写执行）</th><th>八进制</th><th>二进制</th></tr></thead><tbody><tr><td>r</td><td>4</td><td>100</td></tr><tr><td>w</td><td>2</td><td>010</td></tr><tr><td>x</td><td>1</td><td>001</td></tr><tr><td>rw</td><td>6</td><td>110</td></tr><tr><td>rx</td><td>5</td><td>101</td></tr><tr><td>wx</td><td>3</td><td>011</td></tr><tr><td>rwx</td><td>7</td><td>111</td></tr><tr><td>—</td><td>0</td><td>000</td></tr></tbody></table><p>该指令用于修改用户权限，依照的就是这两种表示方法来修改的，一种是通过对 rwx 三个字母进行加减，另一种则是通过八进制的方式直接修改文件权限属性，<br>只有文件的拥有者和root才可以改变文件的权限</p><p><strong>指令格式</strong>：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`chmod [参数] 权限 文件名` </span><br></pre></td></tr></table></figure><p>下面是对 chmod 命令两种权限值修改方式的说明：</p><h4><span id="chmod命令权限值的格式">chmod命令权限值的格式</span></h4><h5><span id="1-用户表示符x2f-权限字符">① 用户表示符+&#x2F;-权限字符</span></h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>+</code></td><td>向权限范围增加权限代号所表示的权限</td></tr><tr><td><code>-</code></td><td>向权限范围取消权限代号所表示的权限</td></tr><tr><td><code>=</code></td><td>向权限范围赋予权限代号所表示的权限</td></tr></tbody></table><p><strong>用户符号</strong>：</p><ul><li><code>u</code>：拥有者  </li><li><code>g</code>：拥有者同组用户  </li><li><code>o</code>：其它用户  </li><li><code>a</code>：所有用户</li></ul><hr><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给文件拥有者添加写权限</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod u+w dir</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 12 23:27 dir</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 13 11:11 dir1</span><br><span class="line">-rw-r--r-- 1 ljx ljx    0 Jul 12 21:59 test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消其他用户的执行权限</span>  </span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod o-x dir</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-- 2 ljx ljx 4096 Jul 12 23:27 dir</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 13 11:11 dir1</span><br><span class="line">-rw-r--r-- 1 ljx ljx    0 Jul 12 21:59 test.txt</span><br></pre></td></tr></table></figure><h5><span id="2-三位8进制数字表示法">② 三位8进制数字表示法</span></h5><p>使用数字表示权限组合，每位数字分别对应：</p><ul><li><strong>第一位</strong>：所有者（u）权限  </li><li><strong>第二位</strong>：同组用户（g）权限  </li><li><strong>第三位</strong>：其他用户（o）权限</li></ul><p>权限数值对照：  </p><ul><li><code>4</code>：读（r）  </li><li><code>2</code>：写（w）  </li><li><code>1</code>：执行（x）  </li><li>组合权限为数值相加（如 <code>rw-</code> &#x3D; 4+2 &#x3D; <code>6</code>）</li></ul><hr><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置权限：所有者可读可写（6），同组用户可读可写（6），其他用户仅可读（4）</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod 664 dir</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 8</span><br><span class="line">drw-rw-r-- 2 ljx ljx 4096 Jul 12 23:27 dir</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 13 11:11 dir1</span><br><span class="line">-rw-r--r-- 1 ljx ljx    0 Jul 12 21:59 test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置权限：所有者可读可写（6），同组用户可读（4），其他用户无权限（0）</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod 640 dir</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 8</span><br><span class="line">drw-r----- 2 ljx ljx 4096 Jul 12 23:27 dir</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 13 11:11 dir1</span><br><span class="line">-rw-r--r-- 1 ljx ljx    0 Jul 12 21:59 test.txt</span><br></pre></td></tr></table></figure><p>下面我们要重点讨论一下这三个标识对于普通文件和目录文件分别表示什么含义:</p><h3><span id="rwx-对于普通文件的含义">rwx 对于普通文件的含义</span></h3><h4><span id="r读权限">r（读权限）</span></h4><p>当用户没有 r 权限时，就无法读取文件内的内容了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 <span class="built_in">chmod</span> 使得文件所有者失去读权限</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod u-r test.txt        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否失去读权限</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 8</span><br><span class="line">d---r----- 2 ljx ljx 4096 Jul 12 23:27 dir</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 13 11:11 dir1</span><br><span class="line">--w-r--r-- 1 ljx ljx    0 Jul 12 21:59 test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户无法读取文件数据了</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  cat test.txt</span><br><span class="line">cat: test.txt: Permission denied</span><br></pre></td></tr></table></figure><h4><span id="w写权限">w（写权限）</span></h4><p>当用户没有 w 权限时，就无法写入数据到文件中了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod u-w test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户无法写入数据了</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  echo 123 &gt;&gt; test.txt</span><br><span class="line">zsh: permission denied: test.txt</span><br></pre></td></tr></table></figure><h4><span id="x操作权限">x（操作权限）</span></h4><p>操作权限在普通文件上一般体现不出来，我们拿可执行程序来看：</p><p>可执行程序被编译出来后默认是由执行权限的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">test.o 文件为可执行程序</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 196</span><br><span class="line">-rw-r--r-- 1 ljx ljx     94 Jul 13 10:44 error.log</span><br><span class="line">-rw-r--r-- 1 ljx ljx    102 Jul 12 22:16 test.cc</span><br><span class="line">-rwxr-xr-x 1 ljx ljx  16544 Jul 13 17:02 test.o</span><br><span class="line">-rw-r--r-- 1 ljx ljx 168894 Jul 13 11:11 test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时可以正常运行该程序</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./test.o</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>接下来我们尝试关闭该可执行程序的操作权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  chmod u-x test.o</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ./test.o</span><br><span class="line">zsh: permission denied: ./test.o</span><br></pre></td></tr></table></figure><p>可以看到，没有执行权限后是无法执行该可执行程序的</p><h3><span id="rwx-对于目录文件的含义">rwx 对于目录文件的含义</span></h3><p>这里我们又要提到一个非常经典的语句：Linux 中一切皆文件，因此 rwx 对于目录文件真正作用的是目录文件的内部数据</p><h4><span id="r读权限">r（读权限）</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod u-r dir</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ll dir</span><br><span class="line">ls: cannot open directory &#x27;dir&#x27;: Permission denied</span><br></pre></td></tr></table></figure><p>没有读权限，我们就无法通过 ll 指令读取目录中的具体数据了</p><h4><span id="w写权限">w（写权限）</span></h4><p>没有写权限，我们就无法在文件中创建任何文件了，因为创建文件本质是往目录文件中写入数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  cd dir</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  mkdir dir1                                                                                                     2 ↵</span><br><span class="line">mkdir: cannot create directory ‘dir1’: Permission denied</span><br></pre></td></tr></table></figure><h4><span id="x操作权限">x（操作权限）</span></h4><p>没有操作权限，我们就无法进入该文件了，因为进入该文件的过程本质是访问目录文件，属于对目录文件的一种操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod u-x dir                                                                                                  1 ↵</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  cd dir</span><br><span class="line">cd:cd:1: permission denied: dir</span><br></pre></td></tr></table></figure><hr><p>现在就有了一个新的问题，我作为非文件拥有者，因为权限设置，虽然我无法修改文件的信息，但我可以删除该文件，<br>这样看来是不是就非常不科学呢？因此我们需要引入一个新的标识叫做粘滞位</p><h3><span id="粘滞位">粘滞位</span></h3><p>粘滞位是对目录文件属性的一种修改，当目录文件被加上粘滞位时，目录文件中的任何文件删除的权限就都属于该文件的创建者或者 root 了，<br>粘滞位添加方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  chmod +t dir1</span><br></pre></td></tr></table></figure><p>最后我们再就可以理解为什么 Linux 中的家目录下属于每个人的目录只有自己和 root 可以进去，而其他人是没有访问权限了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian /home</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 20</span><br><span class="line">drwx------ 12 coconut    coconut    4096 Apr 19 12:26 coconut</span><br><span class="line">drwx------  2       1006       1006 4096 Jul 13 15:31 liangfei</span><br><span class="line">drwxr-xr-x  2 lighthouse lighthouse 4096 Sep 14  2024 lighthouse</span><br><span class="line">drwx------ 29 ljx        ljx        4096 Jul 13 17:19 ljx</span><br><span class="line">drwx------  7 zhang      zhang      4096 Nov  5  2024 zhang</span><br></pre></td></tr></table></figure><p>可以看到，home 下的每个目录文件操作权限只属于文件拥有者，因此其他人是无法进入该文件的</p><h3><span id="权限掩码">权限掩码</span></h3><p>当我们创建普通文件的时候默认权限是666，而创建一个目录文件的时候默认权限是777，这是因为普通文件一般不需要操作权限（可执行程序除外），<br>而目录文件如果不给操作权限用户连进去都不可以，所以目录文件默认权限是666，但是我们会发现，我们创建普通文件和目录文件默认的权限并不是666和777：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 13 17:25 dir</span><br><span class="line">-rw-r--r-- 1 ljx ljx    0 Jul 13 17:25 test.cc</span><br></pre></td></tr></table></figure><p>为什么它们的文件用户组和其他用户都失去了读权限？这就涉及到了权限掩码：</p><p>我们可以查看到我们的权限掩码是多少：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  umask</span><br><span class="line">022</span><br></pre></td></tr></table></figure><p>可以看到我们的权限掩码是 022，即000 010 010，可以看到，被屏蔽的两个读权限在权限掩码上正好对应<br>的是1，因此权限掩码的作用是使得自己所对应二进制位上为1的地方所对应权限被ban掉，如果我们想给<br>文件的用户组默认拥有读权限，可以通过修改umask为002来实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改掩码为 002</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  umask 002</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  touch test.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  mkdir dir</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户组默认拥有了读权限</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x 2 ljx ljx 4096 Jul 13 17:30 dir</span><br><span class="line">-rw-rw-r-- 1 ljx ljx    0 Jul 13 17:30 test.cc</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 权限 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 其他基础命令</title>
      <link href="/2025/07/13/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%91%BD%E4%BB%A4/Common_commands_adv/"/>
      <url>/2025/07/13/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%91%BD%E4%BB%A4/Common_commands_adv/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#echo">echo</a><ul><li><a href="#-n">-n</a></li><li><a href="#-e">-e</a></li></ul></li><li><a href="#linux-%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%A6%E8%A7%A3%E7%BB%93%E5%90%88-echo-%E5%92%8C-cat-%E5%AE%9E%E8%B7%B5"><strong>Linux 重定向详解（结合 echo 和 cat 实践）</strong></a><ul><li><a href="#%E4%B8%80-%E9%87%8D%E5%AE%9A%E5%90%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">一、重定向基础概念</a></li><li><a href="#%E4%BA%8C-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91-%E5%92%8C">二、输出重定向（&gt; 和 &gt;&gt;）</a></li><li><a href="#%E4%B8%89-%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91-%E5%92%8C">三、输入重定向（&lt; 和 &lt;&lt;）</a></li><li><a href="#%E5%9B%9B-%E9%94%99%E8%AF%AF%E9%87%8D%E5%AE%9A%E5%90%912-%E5%92%8C-2">四、错误重定向（2&gt; 和 2&gt;&gt;）</a></li><li><a href="#%E4%BA%94-%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B">五、综合实践案例</a></li></ul></li><li><a href="#more">more</a><ul><li><a href="#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><strong>一、基本用法</strong></a></li><li><a href="#%E4%BA%8C-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E7%89%B9%E7%82%B9"><strong>二、核心功能特点</strong></a></li><li><a href="#%E4%B8%89-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><strong>三、常用操作指令</strong></a></li><li><a href="#%E5%9B%9B-%E4%B8%8E-less-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AF%B9%E6%AF%94"><strong>四、与 <code>less</code> 命令的对比</strong></a></li><li><a href="#%E4%BA%94-%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E7%A4%BA%E4%BE%8B"><strong>五、实用技巧示例</strong></a></li></ul></li><li><a href="#linux-less-%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3">Linux <code>less</code> 命令讲解</a><ul><li><a href="#%E4%B8%80-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><strong>一、核心优势</strong></a></li><li><a href="#%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><strong>二、基本用法</strong></a></li><li><a href="#%E4%B8%89-%E5%AF%BC%E8%88%AA%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8"><strong>三、导航命令大全</strong></a></li><li><a href="#%E5%9B%9B-%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3"><strong>四、搜索功能详解</strong></a></li><li><a href="#%E4%BA%94-%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD%E6%8A%80%E5%B7%A7"><strong>五、实用功能技巧</strong></a></li></ul></li><li><a href="#head-%E4%BB%A5%E5%8F%8A-tail-%E6%8C%87%E4%BB%A4">head 以及 tail 指令</a></li><li><a href="#find">find</a></li><li><a href="#grep">grep</a></li></ul><!-- tocstop --><p>上一节命令讲解跳转：<a href="https://liujiaxuan69.github.io/2025/07/12/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Common_commands_basic/" title="跳转到上一节">Linux 最基础的命令</a></p><p>接下来要讲解的命令都和上一节的 cat 命令息息相关</p><h2><span id="echo">echo</span></h2><p>该命令主要用于在终端输出文本或变量的值</p><p>下面是 echo 的基础用法示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  echo &quot;hello world&quot;</span><br><span class="line">hello world</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  echo $HOME</span><br><span class="line">/home/ljx</span><br></pre></td></tr></table></figure><p>下面是 echo 命令常用的两个选项：</p><h3><span id="-n">-n</span></h3><p>加上该选项后，echo 命令输出信息时会不换行输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  echo -n &quot;hello&quot;; echo &quot; World&quot;</span><br><span class="line">hello World</span><br></pre></td></tr></table></figure><h3><span id="-e">-e</span></h3><p>加上改选项后，echo 命令会检测转义字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  echo -e &quot;hello\nworld&quot;</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>这些是 echo 命令的基础用法，包括上一节讲到的 cat 命令都是一些基础用法，下面我要讲到的一个很重要的知识点是重定向，目前并不需要了解太深，<br>只需要学会将重定向和这两个指令结合着使用就可以了</p><h2><span id="linux-重定向详解结合-echo-和-cat-实践"><strong>Linux 重定向详解（结合 echo 和 cat 实践）</strong></span></h2><p>重点！重点！重点！重要的事情说三遍，下面我们将讨论和重定向相关的知识点</p><h3><span id="一-重定向基础概念">一、重定向基础概念</span></h3><p>Linux 中有三种标准数据流：</p><ol><li>标准输入（stdin，文件描述符 0）</li><li>标准输出（stdout，文件描述符 1）</li><li>标准错误（stderr，文件描述符 2）</li></ol><p>这里提到的文件描述符涉及进程概念，当前并不需要了解太深入，后面进程部分会有讲解，之所以提及这个东西是因为后面<br>在重定向的使用过程中你会发现有些重定向符号会在前面加上数字，这个数字就对应了上面这三种情况，举个简单的例子，&gt;&gt; 符号是追加重定向，<br>那么 2&gt;&gt; 就是错误追加重定向（现在你并不需要记住他，只是为了让你待会看到这个符号的时候有个印象）、</p><p>首先我们得有一个概念，在 Linux 中一切皆文件，比如说我们的显示屏，虽说它是用来给我们提供显示信息的，让我们的信息可视化，但它之所以可以显示各种信息，<br>本质上是通过一个叫做显示屏文件的东西将信息显示出来的</p><p>这样一来，我们就可以理解到 cat 命令 和 echo 命令的基本底层逻辑了，cat 命令默认是读取后面输入的文件名所对应的信息的，而 echo 默认是将用户<br>输入的信息显示到显示屏上去的（准确说是输出到标准输出文件 stdout 中去的）（当然，你可以试试输入 cat 命令直接回车，然后你可以尝试输入一段信息并回车，他就会显示什么信息到显示屏，这是因为在你没有指定 cat 的输入流的<br>时候他会默认从标准输入中读取数据）</p><p>因此，下面这些操作本质上就是让 cat 命令和 echo 命令将输入流和输出流控制到别的地方去</p><h3><span id="二-输出重定向gt-和-gtgt">二、输出重定向（&gt; 和 &gt;&gt;）</span></h3><h4><span id="1-覆盖写入gt">1. 覆盖写入（&gt;）</span></h4><p>使用该符号重定向写入的数据会覆盖掉文件中的原始数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ echo &quot;第一行内容&quot; &gt; test.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat test.txt</span><br><span class="line">第一行内容</span><br><span class="line"></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ echo &quot;新内容&quot; &gt; test.txt  # 覆盖原内容</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat test.txt</span><br><span class="line">新内容</span><br></pre></td></tr></table></figure><h4><span id="2-追加写入gtgt">2. 追加写入（&gt;&gt;）</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ echo &quot;第一行&quot; &gt;&gt; log.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ echo &quot;第二行&quot; &gt;&gt; log.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat log.txt</span><br><span class="line">第一行</span><br><span class="line">第二行</span><br></pre></td></tr></table></figure><h3><span id="三-输入重定向lt-和-ltlt">三、输入重定向（&lt; 和 &lt;&lt;）</span></h3><h4><span id="1-文件作为输入lt">1. 文件作为输入（&lt;）</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat &lt; log.txt  # 效果等同于 cat log.txt（效果虽然相同，但是他们的底层实现逻辑有本质区别，这个涉及到了文件描述符，因此暂时不深究）</span><br><span class="line">第一行</span><br><span class="line">第二行</span><br></pre></td></tr></table></figure><h4><span id="2-here-documentltlt">2. Here Document（&lt;&lt;）</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">这是即时输入的内容</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">直到遇到EOF结束标记</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">这是即时输入的内容</span><br><span class="line">直到遇到EOF结束标记</span><br></pre></td></tr></table></figure><h3><span id="四-错误重定向2gt-和-2gtgt">四、错误重定向（2&gt; 和 2&gt;&gt;）</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat not_exist.txt 2&gt; error.log</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat error.log</span><br><span class="line">cat: not_exist.txt: No such file or directory</span><br></pre></td></tr></table></figure><p>错误重定向用于将输出的错误信息重定向到指定文件中，当使用 2&gt; 作为错误输出重定向时和直接使用 &gt; 重定向没有本质区别，<br>但若想追加错误信息重定向就一定得使用 2&gt;&gt; 而不是 &gt;&gt;，当然相信你会有疑问， &gt;&gt; 符号不也是输出追加重定向吗，为什么他就不能<br>将错误信息追加到文件里面呢</p><p>这就涉及到了一个历史遗留的问题了：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <p>1、核心原因解析</p><p><strong><code>&gt;</code> 和 <code>&gt;&gt;</code> 的默认行为不同</strong>：</p><ul><li><code>&gt;</code> 默认同时重定向 <strong>stdout(1)</strong> 和 <strong>stderr(2)</strong></li><li><code>&gt;&gt;</code> 默认 <strong>只重定向 stdout(1)</strong>，这是历史遗留的设计行为</li></ul><p>2、技术背景说明</p><ul><li><p><strong>shell 的历史设计</strong>：</p><ul><li>早期版本中 <code>&gt;</code> 被设计为会合并输出流（POSIX 标准要求）</li><li>但 <code>&gt;&gt;</code> 被设计为保持流分离，需要显式指定</li></ul></li><li><p><strong>POSIX 标准规定</strong>：<br><code>&gt;</code> 重定向时，如果文件不存在会创建，存在则截断，且实现可以自由决定是否合并流<br><code>&gt;&gt;</code> 则严格要求只追加 stdout</p></li></ul><p>3、正确用法对比</p><table><thead><tr><th>场景</th><th>正确写法</th><th>错误写法</th><th>原因</th></tr></thead><tbody><tr><td>覆盖错误日志</td><td><code>cmd &gt; error.log 2&gt;&amp;1</code></td><td><code>cmd &gt; error.log</code></td><td>显式合并更可靠</td></tr><tr><td>追加错误日志</td><td><code>cmd &gt;&gt; error.log 2&gt;&amp;1</code></td><td><code>cmd &gt;&gt; error.log</code></td><td>必须显式合并</td></tr><tr><td>分离输出</td><td><code>cmd &gt; output.log 2&gt; error.log</code></td><td>-</td><td>标准做法</td></tr></tbody></table><p>因此，重定向中之所以 &gt;&gt; 只追加 stdout的数据，是为了让用户在使用这些重定向选项的时候能够更加明确，当我想追加错误信息的时候就应该在前面加上2，而当我想要标准输出<br>的时候就应该在重定向前面加上1，养成一个良好的习惯是一个程序员的基本素养</p>    </div></div><h3><span id="五-综合实践案例">五、综合实践案例</span></h3><h4><span id="案例1创建配置文件">案例1：创建配置文件</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ echo &quot;SERVER_IP=192.168.1.1&quot; &gt; config.env</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ echo &quot;PORT=8080&quot; &gt;&gt; config.env</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat config.env</span><br><span class="line">SERVER_IP=192.168.1.1</span><br><span class="line">PORT=8080</span><br></pre></td></tr></table></figure><h4><span id="案例2日志收集">案例2：日志收集</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ echo &quot;$(date): 系统启动&quot; &gt;&gt; system.log</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat system.log</span><br><span class="line">Wed Jun 15 10:00:00 CST 2023: 系统启动</span><br></pre></td></tr></table></figure><h4><span id="案例3错误处理">案例3：错误处理</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat maybe_exist.txt &gt; output.log 2&gt; error.log</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ echo &quot;命令退出状态: $?&quot; &gt;&gt; error.log</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤ cat error.log</span><br><span class="line">cat: maybe_exist.txt: No such file or directory</span><br><span class="line">命令退出状态: 1</span><br></pre></td></tr></table></figure><h2><span id="more">more</span></h2><p><code>more</code> 是 Linux&#x2F;Unix 系统中一个经典的分页查看工具，用于逐屏查看长文本文件内容。它是早期分页工具，后来被功能更强大的 <code>less</code> 命令部分取代，但在许多场景中仍然实用。</p><hr><h3><span id="一-基本用法"><strong>一、基本用法</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [选项] 文件名</span><br></pre></td></tr></table></figure><hr><h3><span id="二-核心功能特点"><strong>二、核心功能特点</strong></span></h3><ol><li><p><strong>分页显示</strong>：</p><ul><li>自动在终端高度处暂停</li><li>显示已阅读百分比（如 <code>--More--(15%)</code>）</li></ul></li><li><p><strong>基础导航</strong>：</p><ul><li><code>空格键</code>：向下翻一页</li><li><code>回车键</code>：向下翻一行</li><li><code>q</code>：立即退出</li></ul></li><li><p><strong>搜索功能</strong>：</p><ul><li><code>/关键词</code>：向前搜索（按 <code>n</code> 跳转到下一个匹配）</li></ul></li></ol><hr><h3><span id="三-常用操作指令"><strong>三、常用操作指令</strong></span></h3><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>空格</td><td>下一页</td></tr><tr><td>Enter</td><td>下一行</td></tr><tr><td><code>q</code></td><td>退出</td></tr><tr><td><code>=</code></td><td>显示当前行号</td></tr><tr><td><code>:f</code></td><td>显示文件名和当前行号</td></tr><tr><td><code>/pattern</code></td><td>搜索指定模式（正则表达式支持有限）</td></tr><tr><td><code>!cmd</code></td><td>执行shell命令（如 <code>!ls</code>）</td></tr></tbody></table><hr><h3><span id="四-与-less-命令的对比"><strong>四、与 <code>less</code> 命令的对比</strong></span></h3><table><thead><tr><th>特性</th><th><code>more</code></th><th><code>less</code></th></tr></thead><tbody><tr><td><strong>回滚</strong></td><td>只能向前</td><td>支持前后滚动</td></tr><tr><td><strong>搜索</strong></td><td>只能向前搜索</td><td>支持双向搜索</td></tr><tr><td><strong>大文件</strong></td><td>加载全部内容</td><td>按需加载（更高效）</td></tr><tr><td><strong>功能</strong></td><td>基础功能</td><td>支持标签、多文件等高级功能</td></tr><tr><td><strong>系统资源</strong></td><td>占用较多内存</td><td>更节省内存</td></tr></tbody></table><hr><h3><span id="五-实用技巧示例"><strong>五、实用技巧示例</strong></span></h3><h4><span id="1-从特定行开始查看">1. 从特定行开始查看</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +100 /var/log/nginx/access.log  # 从第100行开始显示</span><br></pre></td></tr></table></figure><h4><span id="2-配合管道使用">2. 配合管道使用</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;ERROR&quot; system.log | more      # 过滤错误日志后分页查看</span><br></pre></td></tr></table></figure><h4><span id="3-查看多个文件">3. 查看多个文件</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more file1.txt file2.txt           # 按 `:n` 切换到下一个文件</span><br></pre></td></tr></table></figure><h4><span id="4-快速跳转较新版本支持">4. 快速跳转（较新版本支持）</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +/error system.log           # 搜索&quot;error&quot;并跳转到第一个匹配处</span><br></pre></td></tr></table></figure><p>下面要重点介绍的是 less 命令：</p><h2><span id="linux-less-命令讲解">Linux <code>less</code> 命令讲解</span></h2><p><code>less</code> 是 Linux&#x2F;Unix 系统中功能最强大的分页查看工具，相比 <code>more</code> 具有更丰富的功能和更高的效率，是系统管理员和开发者的必备工具。</p><hr><h3><span id="一-核心优势"><strong>一、核心优势</strong></span></h3><ol><li><strong>双向浏览</strong>：支持向前&#x2F;向后滚动</li><li><strong>高效内存管理</strong>：不会加载整个文件到内存</li><li><strong>高级搜索</strong>：支持正则表达式和反向搜索</li><li><strong>多文件操作</strong>：可同时打开多个文件</li><li><strong>自定义界面</strong>：可调整显示方式和快捷键</li></ol><hr><h3><span id="二-基本用法"><strong>二、基本用法</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [选项] 文件名</span><br></pre></td></tr></table></figure><h4><span id="常用启动选项">常用启动选项：</span></h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-N</code></td><td>显示行号</td></tr><tr><td><code>-i</code></td><td>忽略搜索大小写</td></tr><tr><td><code>-S</code></td><td>截断长行（不换行）</td></tr><tr><td><code>-F</code></td><td>文件小于一屏时自动退出</td></tr><tr><td><code>+F</code></td><td>实时跟踪模式（类似 <code>tail -f</code>）</td></tr></tbody></table><hr><h3><span id="三-导航命令大全"><strong>三、导航命令大全</strong></span></h3><h4><span id="基础移动">基础移动：</span></h4><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td><code>空格</code>&#x2F;<code>f</code></td><td>前进一屏</td></tr><tr><td><code>b</code></td><td>后退一屏</td></tr><tr><td><code>↓</code>&#x2F;<code>j</code></td><td>下一行</td></tr><tr><td><code>↑</code>&#x2F;<code>k</code></td><td>上一行</td></tr><tr><td><code>G</code></td><td>跳转到文件末尾</td></tr><tr><td><code>1G</code>&#x2F;<code>gg</code></td><td>跳转到文件开头</td></tr><tr><td><code>50%</code></td><td>跳转到50%位置</td></tr></tbody></table><h4><span id="高级跳转">高级跳转：</span></h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>10j</code></td><td>向下10行</td></tr><tr><td><code>20↓</code></td><td>向下20行</td></tr><tr><td><code>:n</code></td><td>下一个文件（多文件时）</td></tr><tr><td><code>:p</code></td><td>上一个文件</td></tr></tbody></table><hr><h3><span id="四-搜索功能详解"><strong>四、搜索功能详解</strong></span></h3><h4><span id="1-文本搜索">1. 文本搜索：</span></h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>/pattern</code></td><td>向前搜索</td></tr><tr><td><code>?pattern</code></td><td>向后搜索</td></tr><tr><td><code>n</code></td><td>下一个匹配项</td></tr><tr><td><code>N</code></td><td>上一个匹配项</td></tr><tr><td><code>&amp;pattern</code></td><td>只显示匹配行</td></tr></tbody></table><h4><span id="2-正则搜索">2. 正则搜索：</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[0-9]&#123;3&#125;-[0-9]&#123;4&#125;  # 搜索电话号码模式</span><br></pre></td></tr></table></figure><h4><span id="3-搜索高亮">3. 搜索高亮：</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less -p &quot;error&quot; log.txt  # 启动时直接搜索并高亮&quot;error&quot;</span><br></pre></td></tr></table></figure><hr><h3><span id="五-实用功能技巧"><strong>五、实用功能技巧</strong></span></h3><p>下面这些并不需要你记住，包括上面的一些用法，在需要的时候学会查询文档就可以了，常用的选项其实就那么几个</p><h4><span id="1-多文件操作">1. 多文件操作：</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less file1.txt file2.txt</span><br></pre></td></tr></table></figure><ul><li><code>:n</code> 下一个文件</li><li><code>:p</code> 上一个文件</li><li><code>:e</code> 打开新文件</li></ul><h4><span id="2-实时监控替代-tail-f">2. 实时监控（替代 <code>tail -f</code>）：</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less +F /var/log/syslog</span><br></pre></td></tr></table></figure><ul><li><code>Ctrl+C</code> 退出跟踪模式</li><li><code>F</code> 重新进入跟踪模式</li></ul><h4><span id="3-编辑当前文件">3. 编辑当前文件：</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v  # 用默认编辑器打开当前文件</span><br></pre></td></tr></table></figure><h4><span id="4-标记位置">4. 标记位置：</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ma  # 标记当前位置为a</span><br><span class="line">&#x27;a  # 跳转到标记a</span><br></pre></td></tr></table></figure><h2><span id="head-以及-tail-指令">head 以及 tail 指令</span></h2><p>这两个指令一个是用来指定看文件的前多少行，另一个则用来查看问价你的最后多少行，我直接给你们一个示例你们自然就懂了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  head -10 test.txt                                                                                              1 ↵</span><br><span class="line">hello linux 1</span><br><span class="line">hello linux 2</span><br><span class="line">hello linux 3</span><br><span class="line">hello linux 4</span><br><span class="line">hello linux 5</span><br><span class="line">hello linux 6</span><br><span class="line">hello linux 7</span><br><span class="line">hello linux 8</span><br><span class="line">hello linux 9</span><br><span class="line">hello linux 10</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  tail -10 test.txt</span><br><span class="line">hello linux 9991</span><br><span class="line">hello linux 9992</span><br><span class="line">hello linux 9993</span><br><span class="line">hello linux 9994</span><br><span class="line">hello linux 9995</span><br><span class="line">hello linux 9996</span><br><span class="line">hello linux 9997</span><br><span class="line">hello linux 9998</span><br><span class="line">hello linux 9999</span><br><span class="line">hello linux 10000</span><br></pre></td></tr></table></figure><p>会用了吧，接下来咱进阶一下，假如说我想要读取某个文件从第1300行开始的10行数据怎么办？</p><p>你肯定会和我一样立刻产生一个想法，那我先通过 head 读取前1310行数据，再读取这1310行数据的最后10行不就可以了吗？</p><p>没错，为了达成这个目的，我们就要讲到一个叫做管道的东西了：</p><p>这里我们不需要理解太深刻，先把这个例子的实现搬出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  head -1310 test.txt | tail -10</span><br><span class="line">hello linux 1301</span><br><span class="line">hello linux 1302</span><br><span class="line">hello linux 1303</span><br><span class="line">hello linux 1304</span><br><span class="line">hello linux 1305</span><br><span class="line">hello linux 1306</span><br><span class="line">hello linux 1307</span><br><span class="line">hello linux 1308</span><br><span class="line">hello linux 1309</span><br><span class="line">hello linux 1310</span><br></pre></td></tr></table></figure><p>可以看到，我们先读取文件的钱1310行，然后有一个 | 符号，这个符号就是管道，它的作用是，将管道左边的输出流（文件的前1310行数据）作为右边数据访问的输入流，这样<br>tail 所操作的数据就是文件的钱1310行了。</p><h2><span id="find">find</span></h2><p>改命令用于查找文件名所在目录，这个命令的选项很多，但我们常用的就一个 -name 选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 /home/ljx 中查找所有叫 test.txt 文件的所在路径</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  find /home/ljx -name test.txt                                                                                130 ↵</span><br><span class="line">/home/ljx/linux_review/lesson1/dir1/test.txt</span><br><span class="line">/home/ljx/linux_review/lesson1/test.txt</span><br><span class="line">/home/ljx/linux_lesson/lesson11/test.txt</span><br><span class="line">/home/ljx/cpp_code/Logging-System/build/Draft/logfile/test.txt</span><br></pre></td></tr></table></figure><h2><span id="grep">grep</span></h2><p>这个命令是用来查询文件中包含指定内容的数据，示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 test.txt 中包含 999 的 行</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  grep 999 test.txt                                                                                              2 ↵</span><br><span class="line">hello linux 999</span><br><span class="line">hello linux 1999</span><br><span class="line">hello linux 2999</span><br><span class="line">hello linux 3999</span><br><span class="line">hello linux 4999</span><br><span class="line">hello linux 5999</span><br><span class="line">hello linux 6999</span><br><span class="line">hello linux 7999</span><br><span class="line">hello linux 8999</span><br><span class="line">hello linux 9990</span><br><span class="line">hello linux 9991</span><br><span class="line">hello linux 9992</span><br><span class="line">hello linux 9993</span><br><span class="line">hello linux 9994</span><br><span class="line">hello linux 9995</span><br><span class="line">hello linux 9996</span><br><span class="line">hello linux 9997</span><br><span class="line">hello linux 9998</span><br><span class="line">hello linux 9999</span><br></pre></td></tr></table></figure><p>grep 命令还有很多作用，这里先只介绍这一种，具体的后面用到时会详细介绍</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 最基础的命令</title>
      <link href="/2025/07/12/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%91%BD%E4%BB%A4/Common_commands_basic/"/>
      <url>/2025/07/12/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%91%BD%E4%BB%A4/Common_commands_basic/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#ls-%E6%8C%87%E4%BB%A4">ls 指令</a></li><li><a href="#pwd-%E6%8C%87%E4%BB%A4">pwd 指令</a></li><li><a href="#cd-%E6%8C%87%E4%BB%A4">cd 指令</a><ul><li><a href="#cd-">cd -</a></li><li><a href="#cd-~">cd ~</a></li></ul></li><li><a href="#touch">touch</a></li><li><a href="#mkdir">mkdir</a></li><li><a href="#rmdir-%E5%8F%8A-rm-%E6%8C%87%E4%BB%A4">rmdir 及 rm 指令</a><ul><li><a href="#rmdir">rmdir</a></li><li><a href="#rm">rm</a></li></ul></li><li><a href="#cp">cp</a></li><li><a href="#mv">mv</a></li><li><a href="#cat">cat</a></li></ul><!-- tocstop --><p>Linux 作为一个深受广大社区欢迎的操作系统，其功能的强大以及使用的便利使得它成为了我们学习操作系统的一个很好的板子，<br>首先我们要知道，操作系统的根本要义是使计算机更好用，因此我们学习它是为了方便我们使用计算机，让我们对计算机有更加深入的理解。</p><p>在讲解命令之前，先交给你们一个招数，叫做 ctrl + c，这个组合键可以帮助我们跳出某个正在执行的进程，比如说你执行某个命令，结果发现他无休止的执行下去了，此时你就得<br>通过这个组合键来停止该命令的执行</p><p>下面我们先学习一下 Linux 的一些最基础的指令，学会这些基本就可以上手 Linux 了：</p><h2><span id="ls-指令">ls 指令</span></h2><p>该指令用于列出当前目录下的所有子目录与文件，列出文件名以及其他信息</p><p>ls 指令的选项有很多，下面只介绍平时用的很多的命令选项：</p><p>1、-a</p><p>该选项用于列出目录下的所有文件，包括以.开头的隐含文件</p><p>比如说，当我们在什么信息都没有的目录下用 ls 指令查看当前目录下的文件信息，会发现没有任何相应，但若我们加上-a选项，会看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls -a</span><br><span class="line">.  ..</span><br></pre></td></tr></table></figure><p>你会看到，一个新的目录下面隐含了两个文件，一个叫’.’,另一个叫’..’，这两个文件分别表示当前目录以及上级目录，我会在cd指令中重点讲解这两个<br>文件，你现在只需要知道这两个文件是隐含文件，只有通过-a选项才可以查看到</p><p>当然，隐含文件还有很多类型，比如说.config配置文件，还有许多环境变量的文件，这些文件一般都是通过隐含文件的形式来存放的</p><p>2、-l</p><p>该选项用于显示文件的详细信息，下面我会创建两个文件以及一个文本文件，创建好后通过 ls 指令查看效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls</span><br><span class="line">dir1  dir2  test.txt</span><br></pre></td></tr></table></figure><p>可以看到，只显示了文件名，但我们若想要看到每个文件的具体信息，就可以通过-l选项查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls -l （等价于 ll 命令，ll 是对 ls -l 指令的缩写）</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 12 21:58 dir1</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 12 21:58 dir2</span><br><span class="line">-rw-r--r-- 1 ljx ljx    0 Jul 12 21:59 test.txt</span><br></pre></td></tr></table></figure><p>其中 dir1 和 dir2 是目录文件，而 test.txt 是普通文件（文本文件）</p><p>我们可以观察到两个目录文件最前面有一个d标志，这个表示该文件是一个目录文件（directory），但 test.txt 文件前面显示<br>的是一个-，表示该文件是普通文件，除了 d 和 - 其实还有别的标志，目前我们只需要知道这两个就够了</p><p>3、-d</p><p>该指令可以让目录按照文件的方式显示，ls 后面若跟的是一个目录文件，则会显示该目录下的文件信息，但有时候我们只是想看看这个目录文件<br>的详细信息，因此我们需要通过-d选项让目录按照文件的方式显示，与此同时再配合-l指令就可以显示该目录文件的详细信息了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接使用会显示dir1目录下面的文件信息</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls dir1</span><br><span class="line">test_dir1.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用-d选项就可以看到 dir1的信息</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls -d dir1</span><br><span class="line">dir1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过追加-l选项就可以看到 dir1 的详细信息了（-d -l 在显示 dir1 的信息(-d)的同时显示它的详细信息(-l)）</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls -d -l dir1</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 12 22:08 dir1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以将-d -l 选项综合写成 -dl，效果相同</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls -dl dir1</span><br><span class="line">drwxr-xr-x 2 ljx ljx 4096 Jul 12 22:08 dir1</span><br></pre></td></tr></table></figure><p>4、-F</p><p>该指令会在每个文件名后附上一个字符以说明该文件的类型，“<em>”表示可执行的普通文件；“&#x2F;”表示目录；“@”表<br>示符号链接；“|”表示FIFOs；“&#x3D;”表示套接字(sockets)。这里只需要知道“</em>”表示可执行的普通文件；“&#x2F;”表示目录,<br>其他的后面会讲到</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls -F</span><br><span class="line">dir1/  dir2/  hello.cc  hello.o*  test.txt</span><br></pre></td></tr></table></figure><p>其中 dir1 和 dir2 是目录文件，因此他们的后面会显示&#x2F;,而 hello.o 是可执行程序，因此后面会显示*</p><p>hello.o 文件是通过 g++ 编译出来的可执行程序，hello.cc的信息如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 g++ 编译后得到 hello.o 可执行程序，运行可得到输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  g++ -o hello.o hello.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ./hello.o</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>这里我们会发现运行 hello.o 文件需要在文件名前面加上”.&#x2F;“，上面我们讲到”.”是一个目录，表示的是当前目录，因此这里<br>我们可以发现这两个隐藏文件的作用：指定执行的文件的路径。若我们直接输入hello.o，那么系统是不知道这个可执行程序在哪里的，<br>但我们在该文件前面加上”.&#x2F;“，系统就知道了需要执行的是当前目录下的 hello.o ，所以我们当然可以进入到当前目录的下一级目录，然后<br>使用..&#x2F;hello.o 去执行这个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> dir1 表示跳转到当前目录下的 dir1 目录</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  cd dir1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时该可执行程序位于上一级目录，通过../标识路径</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  ../hello.o</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2><span id="pwd-指令">pwd 指令</span></h2><p>该指令很简单，用于显示用户当前所在的绝对路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  pwd</span><br><span class="line">/home/ljx/linux_review/lesson1/dir1</span><br></pre></td></tr></table></figure><h2><span id="cd-指令">cd 指令</span></h2><p>该指令用于路径跳转</p><p>Linux系统中，磁盘上的文件和目录被组成一棵目录树，每个节点都是目录或文件:</p><p><img src="/img/Linux/common_commands/linux_dir_tree.png" alt="tree"></p><p>其中最上面的是根目录，根目录是指向自己的，因此通过 cd 命令跳转到根目录的上层仍然是根目录，下面是 cd 命令的使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前所在路径</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  pwd</span><br><span class="line">/home/ljx/linux_review/lesson1/dir1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 .. 跳转到上一层目录</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  cd ..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检测是否跳转到了上一层（相对跳转）</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  pwd</span><br><span class="line">/home/ljx/linux_review/lesson1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接跳转到根目录（绝对跳转）</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  cd /</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检测是否跳转到了根目录</span></span><br><span class="line">╭─ljx@VM-16-15-debian /</span><br><span class="line">╰─➤  pwd</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h3><span id="cd-">cd -</span></h3><p>该指令用于跳转到上一次所在的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前所在路径</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review</span><br><span class="line">╰─➤  pwd</span><br><span class="line">/home/ljx/linux_review</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跳转到根目录</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review</span><br><span class="line">╰─➤  cd /</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再通过 <span class="built_in">cd</span> - 命令跳转到上一次所在路径</span></span><br><span class="line">╭─ljx@VM-16-15-debian /</span><br><span class="line">╰─➤  cd -</span><br><span class="line">~/linux_review</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否回到了上一次所在路径</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review</span><br><span class="line">╰─➤  pwd</span><br><span class="line">/home/ljx/linux_review</span><br></pre></td></tr></table></figure><h3><span id="cd-~">cd ~</span></h3><p>该指令用于跳转到自己所对应的家目录：</p><p>在 Linux 中，root 用户（超级管理员）的家目录在 &#x2F;root 下，而其他普通用户的家目录在 &#x2F;home&#x2F;xxx 下面，因此<br>我们通过 cd ~ 指令就可以直接跳转到我们当前用户身份所对应的家目录下面了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review</span><br><span class="line">╰─➤  cd ~</span><br><span class="line">╭─ljx@VM-16-15-debian ~</span><br><span class="line">╰─➤  pwd</span><br><span class="line">/home/ljx</span><br></pre></td></tr></table></figure><h2><span id="touch">touch</span></h2><p>该指令用于创建文件（非目录），比如说我想在当前目录下面穿件一个 test.txt 文本文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir2</span><br><span class="line">╰─➤  touch test.cc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到文件创建成功了</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir2</span><br><span class="line">╰─➤  ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 ljx ljx 0 Jul 12 22:58 test.cc</span><br></pre></td></tr></table></figure><h2><span id="mkdir">mkdir</span></h2><p>该指令专门用于创建目录，通过上面可知，touch 命令是无法创建目录的，而我们需要通过这个命令创建目录文件：</p><p>普通的文件目录创建就不过多赘述了，下面我们讲一下 -p 选项，该选项可以用于递归创建目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时创建 dir3 以及在下面递归创建 dir3_1 以及 dir3_1 下面递归创建 dir3_2</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  mkdir -p dir3/dir3_1/dir3_2  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tree 指令用于将目录按照树状图的形式显示出来                                                                                  1 ↵</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  tree dir3</span><br><span class="line">dir3</span><br><span class="line">└── dir3_1</span><br><span class="line">    └── dir3_2</span><br><span class="line"></span><br><span class="line">3 directories, 0 files</span><br></pre></td></tr></table></figure><h2><span id="rmdir-及-rm-指令">rmdir 及 rm 指令</span></h2><h3><span id="rmdir">rmdir</span></h3><p>该指令只能用来删除目录文件，而 rm 指令包含了 rmdir 的所有功能，因此日后使用指令一般都用不到rmdir，下面详细介绍 rm 指令：</p><h3><span id="rm">rm</span></h3><p>rm命令可以同时删除文件或目录<br><strong>语法</strong>：rm [-f-i-r-v][dirName&#x2F;dir]<br><strong>适用对象</strong>：所有使用者<br><strong>功能</strong>：删除文件或目录<br><strong>常用选项</strong>：</p><ul><li>-f 即使文件属性为只读(即写保护)，亦直接删除</li><li>-i 删除前逐一询问确认</li><li>-r 删除目录及其下所有文件</li></ul><p>下面介绍一下 -r 选项以及 -f 选项：</p><h4><span id="-r">-r</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  rm dir1                                                                                                        1 ↵</span><br><span class="line">rm: cannot remove &#x27;dir1&#x27;: Is a directory                                                                                                1 ↵</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  rm -r dir1</span><br></pre></td></tr></table></figure><p>有些目录文件下面并不是空的，因此需要通过 -r 指令递归删除目录以及目录下的所有文件</p><h4><span id="-f">-f</span></h4><p>在某些时候删除文件时会询问你是否确认删除该文件，加上这个选项后就可以跳过确认直接无脑删除了</p><p>这样一来就形成了一套递归删除文件夹的命令格式：</p><p>rm -rf [dir_name]</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  rm -rf dir3</span><br></pre></td></tr></table></figure><h2><span id="cp">cp</span></h2><p><strong>语法</strong>：cp [选项] 源文件或目录 目标文件或目录<br><strong>功能</strong>: 复制文件或目录<br><strong>说明</strong>: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，<br>则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存<br>在的目录，则会出现错误信息<br><strong>常用选项</strong>：</p><ul><li>-f 或 –force 强行复制文件或目录， 不论目的文件或目录是否已经存在</li><li>-i 或 –interactive 覆盖文件之前先询问用户</li><li>-r递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链<br>接，则一律视为普通文件处理</li><li>-R 或 –recursive递归处理，将指定目录下的文件及子目录一并处理</li></ul><p>同样的选项中 -r 和 -f 最常用，而这两个选项的用法和 rm 中的 -r 和 -f 相同，下面是使用示例：</p><p>复制单个文件到指定目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  tree dir</span><br><span class="line">dir</span><br><span class="line"></span><br><span class="line">0 directories, 0 files</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  cp hello.o dir</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  tree dir</span><br><span class="line">dir</span><br><span class="line">└── hello.o</span><br><span class="line"></span><br><span class="line">1 directory, 1 file</span><br></pre></td></tr></table></figure><p>复制目录文件到指定目录（加上 -r 选项）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不加上 -r 选项无法 <span class="built_in">cp</span></span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  cp dir tmp</span><br><span class="line">cp: -r not specified; omitting directory &#x27;dir&#x27;</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  cp -r dir tmp     </span><br></pre></td></tr></table></figure><h2><span id="mv">mv</span></h2><p>mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命<br>令，经常用来备份文件或者目录。<br><strong>语法</strong>: mv [选项] 源文件或目录 目标文件或目录<br><strong>功能</strong>: </p><ol><li>视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的<br>目录中。</li><li>当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它<br>将所给的源文件或目录重命名为给定的目标文件名。</li><li>当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至<br>目标目录中。<br><strong>常用选项</strong>：</li></ol><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖</li></ul><p>示例一：移动文件到指定目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  mv hello.o dir1</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls dir1</span><br><span class="line">hello.o</span><br></pre></td></tr></table></figure><p>示例二：改变文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  mv hello.cc world.cc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hello.cc 被改名为 world.cc</span></span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls</span><br><span class="line">dir  dir1  test.txt  world.cc</span><br></pre></td></tr></table></figure><p>示例三：移动文件的同时改变文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls</span><br><span class="line">dir  dir1  test.txt  world.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls dir1</span><br><span class="line">test.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  mv world.cc dir1/test.cc</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls</span><br><span class="line">dir  dir1  test.txt</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1</span><br><span class="line">╰─➤  ls dir1</span><br><span class="line">test.cc</span><br></pre></td></tr></table></figure><p>这是你肯定会有疑问，既然 mv 指令既可以用于移动文件，又可以用于修改文件名，那么它在不同的场合到底发挥着什么功能呢？</p><p>其实很简单，首先我们把 mv 的功能理解为移动文件的同时修改文件名，那么我们会发现，若目标是目录文件，就无法修改文件名，就只能将文件移动过去，<br>但目的若是非目录文件，那么就意味着我们会将该文件移动过去的同时将该文件的文件名也修改了，可以理解为覆盖cp，再抽象一点，你可以理解为 windows 中<br>将某个文件剪切下来，然后选择另一个文件通过 ctrl + v 覆盖另一个文件为之前剪切的文件</p><h2><span id="cat">cat</span></h2><p><strong>语法</strong>：cat [选项][文件]<br><strong>功能</strong>： 查看目标文件的内容<br><strong>常用选项</strong>：</p><ul><li>-b 对非空输出行编号</li><li>-n 对输出的所有行编号</li><li>-s 不输出多行空行</li></ul><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  cat -n test.cc</span><br><span class="line">     1  #include &lt;iostream&gt;</span><br><span class="line">     2  using namespace std;</span><br><span class="line">     3</span><br><span class="line">     4  int main()</span><br><span class="line">     5  &#123;</span><br><span class="line">     6    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">     7    return 0;</span><br><span class="line">     8  &#125;</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  cat -ns test.cc</span><br><span class="line">     1  #include &lt;iostream&gt;</span><br><span class="line">     2  using namespace std;</span><br><span class="line">     3</span><br><span class="line">     4  int main()</span><br><span class="line">     5  &#123;</span><br><span class="line">     6    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">     7    return 0;</span><br><span class="line">     8  &#125;</span><br><span class="line">╭─ljx@VM-16-15-debian ~/linux_review/lesson1/dir1</span><br><span class="line">╰─➤  cat -nb test.cc</span><br><span class="line">     1  #include &lt;iostream&gt;</span><br><span class="line">     2  using namespace std;</span><br><span class="line"></span><br><span class="line">     3  int main()</span><br><span class="line">     4  &#123;</span><br><span class="line">     5    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">     6    return 0;</span><br><span class="line">     7  &#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常见数据类型-Zset 类型</title>
      <link href="/2025/07/10/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Zset/"/>
      <url>/2025/07/10/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Zset/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B">类型简介</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">相关指令</a><ul><li><a href="#zadd-%E6%8C%87%E4%BB%A4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><strong>ZADD 指令深度解析</strong></a></li><li><a href="#zcard">zcard</a></li><li><a href="#zcount">zcount</a></li><li><a href="#zrange">zrange</a></li><li><a href="#zrevrange">ZREVRANGE</a></li><li><a href="#zpopmax">ZPOPMAX</a></li><li><a href="#zpopmin">ZPOPMIN</a></li><li><a href="#zrank-zrevrank">ZRANK、ZREVRANK</a></li><li><a href="#zscore-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">ZSCORE 指令详解</a></li><li><a href="#zrem-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">ZREM 指令详解</a></li><li><a href="#zremrangebyrank">ZREMRANGEBYRANK</a></li><li><a href="#zremrangebyscore">ZREMRANGEBYSCORE</a></li><li><a href="#zincrby-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">ZINCRBY 指令详解</a></li></ul></li><li><a href="#%E9%9B%86%E5%90%88%E9%97%B4%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">集合间操作指令</a><ul><li><a href="#zinterstore-%E6%8C%87%E4%BB%A4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><strong>ZINTERSTORE 指令深度解析</strong></a></li><li><a href="#zunionstore">ZUNIONSTORE</a></li></ul></li><li><a href="#zset-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB%E8%A1%A8">Zset 相关指令汇总表</a></li><li><a href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81">内部编码</a></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a><ul><li><a href="#1-%E5%AE%9E%E6%97%B6%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%B3%BB%E7%BB%9F">1. 实时排行榜系统</a></li><li><a href="#2-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F">2. 延迟队列系统</a></li><li><a href="#3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81">3. 滑动窗口限流</a></li><li><a href="#4-%E5%B8%A6%E6%9D%83%E9%87%8D%E7%9A%84%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F">4. 带权重的投票系统</a></li><li><a href="#5-%E6%97%B6%E9%97%B4%E7%BA%BF%E6%8E%92%E5%BA%8F">5. 时间线排序</a></li><li><a href="#6-%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%8E%92%E5%BA%8F">6. 多维度排序</a></li><li><a href="#7-%E5%AE%9E%E6%97%B6%E7%AB%9E%E8%B5%9B%E7%B3%BB%E7%BB%9F">7. 实时竞赛系统</a></li><li><a href="#8-%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98">8. 热点数据缓存</a></li></ul></li></ul><!-- tocstop --><h2><span id="类型简介">类型简介</span></h2><p>有序集合保留了集合不能有重复成员的特点，但与集合不同的是，有序集合中的每个元素都有⼀个唯⼀的浮点类型的分数（score）与之关联，这使得有序集合中的元素是可以维护有序性的，但这个有序不是用下标作为排序依据而是用这个分数。</p><p>下面是列表、集合、有序集合三者的异同点</p><table><thead><tr><th>数据结构</th><th>是否允许重复元素</th><th>是否有序</th><th>有序依据</th><th>应用场景</th></tr></thead><tbody><tr><td>列表</td><td>是</td><td>是</td><td>索引下标</td><td>时间轴、消息队列等</td></tr><tr><td>集合</td><td>否</td><td>否</td><td>-</td><td>标签、社交等</td></tr><tr><td>有序集合</td><td>否</td><td>是</td><td>分数</td><td>排行榜系统、社交等</td></tr></tbody></table><h2><span id="相关指令">相关指令</span></h2><h3><span id="zadd-指令深度解析"><strong>ZADD 指令深度解析</strong></span></h3><p>将一个或多个成员元素及其分数值加入到有序集（sorted set）中。如果成员已经存在于有序集合中，则会更新其分数值，并根据新的分数值重新排序。</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX|XX] [GT|LT] [CH] [INCR] score member [score member ...]</span><br></pre></td></tr></table></figure><h4><span id="选项说明">选项说明</span></h4><ul><li><strong>NX</strong>：仅添加新元素，不更新已存在的元素</li><li><strong>XX</strong>：仅更新已存在的元素，不添加新元素</li><li><strong>GT</strong>：只有当新分数大于当前分数时才更新（Redis 7.0+）</li><li><strong>LT</strong>：只有当新分数小于当前分数时才更新（Redis 7.0+）</li><li><strong>CH</strong>：返回被修改的元素总数（包括新增和更新的）</li><li><strong>INCR</strong>：将指定成员的分数增加给定值（相当于ZINCRBY）</li></ul><p>时间复杂度：</p><ul><li>O(log(N))：添加单个元素（N是有序集的基数）</li><li>O(M*log(N))：添加M个元素</li></ul><p>返回值：</p><ul><li>不使用CH选项时：新增的元素数量</li><li>使用CH选项时：被修改的元素总数（包括新增和更新的）</li><li>使用INCR选项时：成员的新分数值（字符串形式）</li></ul><h4><span id="使用示例">使用示例</span></h4><ol><li>基本用法：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加三个成员</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看有序集</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;3&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用NX选项（仅添加新元素）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试更新已存在的元素<span class="string">&quot;one&quot;</span>（失败）</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset NX 4 &quot;one&quot; 5 &quot;four&quot;</span><br><span class="line">(integer) 1  # 只新增了&quot;four&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看结果</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;four&quot;</span><br><span class="line">8) &quot;5&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用XX选项（仅更新已存在元素）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试更新已存在的<span class="string">&quot;one&quot;</span>和新增<span class="string">&quot;five&quot;</span></span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset XX 10 &quot;one&quot; 5 &quot;five&quot;</span><br><span class="line">(integer) 1  # 只更新了&quot;one&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看结果</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 withscores</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;four&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">7) &quot;one&quot;</span><br><span class="line">8) &quot;10&quot;  # &quot;one&quot;的分数被更新</span><br></pre></td></tr></table></figure><ol start="4"><li>使用CH选项（返回修改总数）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新一个已存在元素，添加一个新元素</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset CH 15 &quot;one&quot; 20 &quot;five&quot;</span><br><span class="line">(integer) 2  # 一个更新，一个新增</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看结果</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 withscores</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;four&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">7) &quot;one&quot;</span><br><span class="line">8) &quot;15&quot;</span><br><span class="line">9) &quot;five&quot;</span><br><span class="line">10) &quot;20&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用INCR选项（分数递增）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将<span class="string">&quot;one&quot;</span>的分数增加5</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset INCR 5 &quot;one&quot;</span><br><span class="line">&quot;20&quot;  # 返回新分数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看结果</span></span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 withscores</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;four&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">7) &quot;five&quot;</span><br><span class="line">8) &quot;20&quot;</span><br><span class="line">9) &quot;one&quot;</span><br><span class="line">10) &quot;20&quot;</span><br></pre></td></tr></table></figure><ol><li>使用GT&#x2F;LT选项：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只有当新分数大于当前分数时才更新</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset GT 25 &quot;one&quot;  # 当前分数20 &lt; 25，会更新</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试用更小的分数更新</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset GT 10 &quot;one&quot;  # 当前分数25 &gt; 10，不会更新</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用LT选项（只有当新分数小于当前分数时才更新）</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset LT 8 &quot;two&quot;  # 当前分数2 &lt; 8，不会更新</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset LT 1 &quot;two&quot;  # 当前分数2 &gt; 1，会更新</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li>分数值是64位双精度浮点数，可以表示的范围为-(2^53)到+(2^53)</li><li>相同分数的成员按字典序排序</li><li>从Redis 3.0.2开始，ZADD支持多参数语法</li><li>GT&#x2F;LT选项需要Redis 7.0及以上版本</li><li>INCR选项不能与其他选项（NX&#x2F;XX&#x2F;GT&#x2F;LT）一起使用</li></ol><h3><span id="zcard">zcard</span></h3><p>该指令获取—个 zset 的基数（cardinality），即 zset 中的元素个数</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><p>返回值：zset 内的元素个数</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd k1 10 a 20 b</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 k1 中的元素个数</span></span><br><span class="line">127.0.0.1:6379&gt; zcard k1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3><span id="zcount">zcount</span></h3><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><p>返回有序集合中分数值在<code>min</code>和<code>max</code>之间的成员数量（默认包含边界值）</p><p>时间复杂度：O(log(N))，其中N是有序集合的基数</p><p>返回值：指定分数范围内的成员数量</p><h4><span id="开区间功能">开区间功能</span></h4><ul><li>使用<code>(</code>前缀表示排除边界值（开区间）</li><li><code>(min</code>表示大于min（不包含min）</li><li><code>(max</code>表示小于max（不包含max）</li><li>可以组合使用，如<code>(min (max</code>表示大于min且小于max</li></ul><h4><span id="使用示例">使用示例</span></h4><ol><li>基本用法（闭区间）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建有序集合</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot; 400 &quot;David&quot;</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计200-400分（包含边界）的成员</span></span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT scores 200 400</span><br><span class="line">(integer) 3  # 包含Bob(200), Charlie(300), David(400)</span><br></pre></td></tr></table></figure><ol start="2"><li>开区间用法：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计大于200且小于400的成员（排除边界）</span></span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT scores (200 (400</span><br><span class="line">(integer) 1  # 仅Charlie(300)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅排除下限</span></span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT scores (200 400</span><br><span class="line">(integer) 2  # Charlie(300), David(400)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅排除上限</span></span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT scores 200 (400</span><br><span class="line">(integer) 2  # Bob(200), Charlie(300)</span><br></pre></td></tr></table></figure><ol start="3"><li>无限区间：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计所有小于300分的成员</span></span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT scores -inf 300</span><br><span class="line">(integer) 3  # Alice(100), Bob(200), Charlie(300)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计所有大于200分的成员（不包含200）</span></span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT scores (200 +inf</span><br><span class="line">(integer) 2  # Charlie(300), David(400)</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li>默认范围是闭区间（包含边界值）</li><li><code>-inf</code>和<code>+inf</code>表示无限小和无限大</li><li>键不存在时返回0</li><li>分数值使用双精度浮点数存储</li></ol><h3><span id="zrange">zrange</span></h3><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]</span><br></pre></td></tr></table></figure><p>返回有序集合中指定区间内的成员，支持按索引、分数或字典序查询</p><h4><span id="核心功能">核心功能</span></h4><ol><li><strong>索引范围查询</strong>（默认）：<ul><li><code>start</code>和<code>stop</code>为从0开始的索引（包含边界）</li><li>支持负数索引（-1表示最后一个元素）</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取前3个元素</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE scores 0 2</span><br><span class="line">1) &quot;Alice&quot;</span><br><span class="line">2) &quot;Bob&quot;</span><br><span class="line">3) &quot;Charlie&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>分数范围查询</strong>（BYSCORE）：<ul><li>使用<code>(</code>表示开区间</li><li>支持<code>-inf</code>和<code>+inf</code>表示无限</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取分数在(100,300]之间的元素</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE scores (100 300 BYSCORE</span><br><span class="line">1) &quot;Bob&quot;</span><br><span class="line">2) &quot;Charlie&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>字典序查询</strong>（BYLEX）：<ul><li>要求所有元素分数相同</li><li>使用<code>[</code>或<code>(</code>指定闭&#x2F;开区间</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD k1 1 a 1 b 1 c 1 d 1 e 1 f</span><br><span class="line">(integer) 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取字典序在[a,e)之间的元素</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 [a (e BYLEX</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br></pre></td></tr></table></figure><h4><span id="关键选项">关键选项：</span></h4><ul><li><code>REV</code>：反向排序（从高到低）</li><li><code>LIMIT</code>：分页查询（类似SQL的LIMIT）</li><li><code>WITHSCORES</code>：返回成员及其分数</li></ul><h4><span id="时间复杂度">时间复杂度：</span></h4><ul><li>O(log(N)+M)，N是有序集合基数，M是返回元素数</li></ul><h4><span id="使用示例">使用示例：</span></h4><ol><li>基本范围查询：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE scores 0 -1</span><br><span class="line">1) &quot;Alice&quot;</span><br><span class="line">2) &quot;Bob&quot;</span><br><span class="line">3) &quot;Charlie&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>带分数的反向查询：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE scores 0 -1 REV WITHSCORES</span><br><span class="line">1) &quot;Charlie&quot;</span><br><span class="line">2) &quot;300&quot;</span><br><span class="line">3) &quot;Bob&quot;</span><br><span class="line">4) &quot;200&quot;</span><br><span class="line">5) &quot;Alice&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>开区间查询：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE scores (100 (300 BYSCORE</span><br><span class="line">1) &quot;Bob&quot;</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li>Redis 6.2+版本开始替代了ZREVRANGE等命令</li><li>使用BYLEX时所有成员分数必须相同</li><li>大范围查询可能影响性能（时间复杂度O(log(N)+M)）</li></ol><h3><span id="zrevrange">ZREVRANGE</span></h3><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>返回有序集合中指定索引范围内的成员，按分数从高到低排序（与ZRANGE排序相反）</p><h4><span id="核心特性">核心特性</span></h4><ol><li><strong>反向排序</strong>：默认按分数降序排列（最高分在前）</li><li><strong>索引范围</strong>：<ul><li><code>start</code>和<code>stop</code>为基于0的索引</li><li>支持负数索引（-1表示最后一个元素）</li></ul></li><li><strong>分数相同</strong>时按字典序降序排列</li></ol><p>时间复杂度：O(log(N)+M)，N是有序集合基数，M是返回元素数</p><p>返回值：指定范围内的成员列表（可选包含分数）</p><h4><span id="使用示例">使用示例</span></h4><ol><li>基本用法：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE scores 0 -1  # 获取全部元素（降序）</span><br><span class="line">1) &quot;Charlie&quot;</span><br><span class="line">2) &quot;Bob&quot;</span><br><span class="line">3) &quot;Alice&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>带分数返回：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGE scores 0 1 WITHSCORES  # 获取前两名</span><br><span class="line">1) &quot;Charlie&quot;</span><br><span class="line">2) &quot;300&quot;</span><br><span class="line">3) &quot;Bob&quot;</span><br><span class="line">4) &quot;200&quot;</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li><strong>已弃用</strong>：Redis 6.2+建议改用<code>ZRANGE key start stop REV</code></li><li>索引越界时自动截断</li><li>键不存在时返回空列表</li></ol><h4><span id="典型应用场景">典型应用场景</span></h4><ol><li>排行榜（显示前N名）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGE leaderboard 0 9 WITHSCORES</span><br></pre></td></tr></table></figure><ol start="2"><li>优先级队列（处理高优先级任务）</li><li>时间线（最新内容优先）</li></ol><h3><span id="zpopmax">ZPOPMAX</span></h3><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZPOPMAX key [count]</span><br></pre></td></tr></table></figure><p>移除并返回有序集合中分数最高的成员（默认返回1个）</p><h4><span id="核心特性">核心特性</span></h4><ol><li><strong>原子性操作</strong>：同时完成查询和删除操作</li><li><strong>排序规则</strong>：按分数降序返回（最高分在前）</li><li><strong>默认行为</strong>：未指定count时只返回1个成员</li></ol><p>时间复杂度：O(log(N)*M)，N是有序集合基数，M是返回元素数</p><p>返回值：被移除的成员及其分数（数组形式）</p><h4><span id="使用示例">使用示例</span></h4><ol><li>基本用法：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZPOPMAX scores  # 移除并返回最高分成员</span><br><span class="line">1) &quot;Charlie&quot;</span><br><span class="line">2) &quot;300&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>批量移除：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZPOPMAX scores 2  # 移除前两名</span><br><span class="line">1) &quot;Bob&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;Alice&quot;</span><br><span class="line">4) &quot;100&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>异常情况：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键不存在时</span></span><br><span class="line">127.0.0.1:6379&gt; ZPOPMAX not_exists</span><br><span class="line">(empty array)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误数据类型时</span></span><br><span class="line">127.0.0.1:6379&gt; SET wrong_type &quot;value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ZPOPMAX wrong_type</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><h4><span id="注意事项">注意事项</span></h4><ol><li><strong>count限制</strong>：<ul><li>必须为非负整数</li><li>超过集合大小时返回全部元素</li></ul></li><li><strong>数据修改</strong>：操作后成员会从集合中永久移除</li><li><strong>替代命令</strong>：Redis 6.2+推荐使用<code>ZRANGE</code>+<code>ZREM</code>组合实现类似功能</li></ol><h4><span id="典型应用场景">典型应用场景</span></h4><ol><li>任务队列（处理高优先级任务）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZPOPMAX pending_tasks</span><br></pre></td></tr></table></figure><ol start="2"><li>实时排行榜（获取当日冠军）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZPOPMAX daily_ranking WITHSCORES</span><br></pre></td></tr></table></figure><ol start="3"><li>流量控制（处理最高权重请求）</li></ol><h3><span id="zpopmin">ZPOPMIN</span></h3><p>用法和 ZPOPMAX 类似，这里不再赘述</p><h3><span id="zrank-zrevrank">ZRANK、ZREVRANK</span></h3><h4><span id="1-基本功能">1. 基本功能</span></h4><ul><li><strong>ZRANK</strong>：返回成员在有序集合中的升序排名（分数从低到高），排名从0开始计算，最低分成员排名为0</li><li><strong>ZREVRANK</strong>：返回成员在有序集合中的降序排名（分数从高到低），排名从0开始计算，最高分成员排名为0</li></ul><h4><span id="2-命令格式">2. 命令格式</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member [WITHSCORE]</span><br><span class="line">ZREVRANK key member [WITHSCORE]</span><br></pre></td></tr></table></figure><h4><span id="3-共同特性">3. 共同特性</span></h4><ul><li>时间复杂度：O(log(N))</li><li>返回值类型：<ul><li>成员存在时返回整数排名</li><li>成员不存在或key不存在时返回nil</li><li>Redis 7.2+支持WITHSCORE选项可同时返回分数（返回数组格式[排名,分数]）</li></ul></li></ul><h4><span id="4-核心区别">4. 核心区别</span></h4><table><thead><tr><th>特性</th><th>ZRANK</th><th>ZREVRANK</th></tr></thead><tbody><tr><td>排序方向</td><td>分数升序（低→高）</td><td>分数降序（高→低）</td></tr><tr><td>最高分排名</td><td>最大排名值</td><td>0</td></tr><tr><td>最低分排名</td><td>0</td><td>最大排名值</td></tr></tbody></table><h4><span id="5-使用示例">5. 使用示例</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建测试数据</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD leaderboard 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZRANK示例（升序排名）</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANK leaderboard &quot;Alice&quot;  # 最低分→排名0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK leaderboard &quot;Charlie&quot;  # 最高分→排名2</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZREVRANK示例（降序排名）</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK leaderboard &quot;Alice&quot;  # 最低分→排名2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK leaderboard &quot;Charlie&quot;  # 最高分→排名0</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHSCORE选项（Redis 7.2+）</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK leaderboard &quot;Bob&quot; WITHSCORE</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) &quot;200&quot;</span><br></pre></td></tr></table></figure><h4><span id="6-应用场景">6. 应用场景</span></h4><ul><li><p><strong>ZRANK适用场景</strong>：</p><ul><li>需要知道成员在整体中的相对位置（如成绩百分位）</li><li>按成本&#x2F;价格从低到高排序的场景</li></ul></li><li><p><strong>ZREVRANK适用场景</strong>：</p><ul><li>排行榜系统（显示TOP N用户）</li><li>按热度&#x2F;评分从高到低排序的场景</li></ul></li></ul><h4><span id="7-注意事项">7. 注意事项</span></h4><ul><li>两个命令都采用0-based排名体系</li><li>分数相同的成员按字典序决定排名</li><li>大集合中使用时要注意O(log(N))的时间复杂度</li></ul><h3><span id="zscore-指令详解">ZSCORE 指令详解</span></h3><h4><span id="1-基本功能">1. 基本功能</span></h4><p>返回有序集合中指定成员的分数值。如果成员不存在或key不存在，返回nil</p><h4><span id="2-命令格式">2. 命令格式</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure><h4><span id="3-核心特性">3. 核心特性</span></h4><ul><li>时间复杂度：O(1)</li><li>返回值类型：<ul><li>字符串形式返回双精度浮点数分数值</li><li>成员不存在时返回nil</li><li>Redis 7.2+支持WITHSCORE选项可同时返回排名和分数</li></ul></li></ul><h4><span id="4-使用示例">4. 使用示例</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建测试数据</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询成员分数</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE scores &quot;Alice&quot;</span><br><span class="line">&quot;100&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不存在的成员</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE scores &quot;David&quot;</span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误数据类型</span></span><br><span class="line">127.0.0.1:6379&gt; SET wrong_type &quot;value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE wrong_type &quot;test&quot;</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><h4><span id="5-应用场景">5. 应用场景</span></h4><ul><li>排行榜系统（查看用户得分）</li><li>优先级任务检查（确认任务优先级）</li><li>游戏计分系统（查询玩家分数）</li></ul><hr><h3><span id="zrem-指令详解">ZREM 指令详解</span></h3><h4><span id="1-基本功能">1. 基本功能</span></h4><p>从有序集合中移除一个或多个成员，不存在的成员会被忽略</p><h4><span id="2-命令格式">2. 命令格式</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><h4><span id="3-核心特性">3. 核心特性</span></h4><ul><li>时间复杂度：O(M*log(N))，M为移除成员数，N为集合基数</li><li>返回值：实际移除的成员数量（不包含不存在的成员）</li><li>支持批量操作（Redis 2.4+）</li></ul><h4><span id="4-使用示例">4. 使用示例</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建测试数据</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除单个成员</span></span><br><span class="line">127.0.0.1:6379&gt; ZREM scores &quot;Alice&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量移除</span></span><br><span class="line">127.0.0.1:6379&gt; ZREM scores &quot;Bob&quot; &quot;David&quot;  # David不存在</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误数据类型</span></span><br><span class="line">127.0.0.1:6379&gt; SET wrong_type &quot;value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ZREM wrong_type &quot;test&quot;</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><h4><span id="5-应用场景">5. 应用场景</span></h4><ul><li>排行榜更新（移除过期用户）</li><li>任务队列管理（完成的任务移出队列）</li><li>实时数据清理（移除过期数据）</li></ul><h4><span id="6-注意事项">6. 注意事项</span></h4><ul><li>与ZREMRANGEBYRANK不同，ZREM是按成员值移除而非排名</li><li>大集合批量移除时建议使用管道(pipeline)提高效率</li></ul><h3><span id="zremrangebyrank">ZREMRANGEBYRANK</span></h3><h4><span id="1-基本功能"><strong>1. 基本功能</strong></span></h4><p>移除有序集合中指定<strong>排名范围</strong>内的所有成员，按<strong>升序排名</strong>（分数从低到高）计算范围。</p><h4><span id="2-命令格式"><strong>2. 命令格式</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><h4><span id="3-核心特性"><strong>3. 核心特性</strong></span></h4><ul><li><strong>时间复杂度</strong>：<code>O(log(N) + M)</code>，其中 <code>N</code> 是集合大小，<code>M</code> 是被移除的成员数量。</li><li><strong>排名规则</strong>：<ul><li>排名从 <code>0</code> 开始（最低分成员的排名为 <code>0</code>）。</li><li>支持<strong>负数索引</strong>（<code>-1</code> 表示最后一个成员，<code>-2</code> 表示倒数第二个，依此类推）。</li></ul></li><li><strong>返回值</strong>：被移除的成员数量（若 <code>key</code> 不存在或范围无效，返回 <code>0</code>）。</li></ul><h4><span id="4-使用示例"><strong>4. 使用示例</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建测试数据</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot; 400 &quot;David&quot; 500 &quot;Eve&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除排名 0-2（最低分的3个成员）</span></span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK scores 0 2</span><br><span class="line">(integer) 3  # 移除了 Alice(100), Bob(200), Charlie(300)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查剩余成员</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE scores 0 -1 WITHSCORES</span><br><span class="line">1) &quot;David&quot;</span><br><span class="line">2) &quot;400&quot;</span><br><span class="line">3) &quot;Eve&quot;</span><br><span class="line">4) &quot;500&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用负数索引（移除倒数2个成员）</span></span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK scores -2 -1</span><br><span class="line">(integer) 2  # 移除了 David(400), Eve(500)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否为空</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE scores 0 -1</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><h4><span id="5-应用场景"><strong>5. 应用场景</strong></span></h4><ul><li><strong>排行榜清理</strong>（定期移除排名最低的N个用户）</li><li><strong>数据分页删除</strong>（批量移除指定范围的记录）</li><li><strong>缓存淘汰策略</strong>（移除低优先级数据）</li></ul><h4><span id="6-注意事项"><strong>6. 注意事项</strong></span></h4><ul><li><strong>与 <code>ZREMRANGEBYSCORE</code> 的区别</strong>：<ul><li><code>ZREMRANGEBYRANK</code> 按<strong>排名</strong>移除（基于排序后的位置）。</li><li><code>ZREMRANGEBYSCORE</code> 按<strong>分数范围</strong>移除（如 <code>ZREMRANGEBYSCORE scores 100 300</code>）。</li></ul></li><li><strong>索引越界</strong>：<ul><li>若 <code>start</code> 超过最大排名，不会移除任何成员。</li><li>若 <code>stop</code> 超过最大排名，会截断到最后一个成员。</li></ul></li><li><strong>键不存在时</strong>：返回 <code>0</code>，不会报错。</li></ul><h4><span id="7-替代方案redis-62"><strong>7. 替代方案（Redis 6.2+）</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 ZRANGE + ZREM 组合（适用于复杂条件删除）</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE scores 0 2 BYSCORE | xargs redis-cli ZREM scores</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：<code>ZREMRANGEBYRANK</code> 适用于<strong>按排名批量删除</strong>，适合排行榜维护、数据清理等场景，使用时需注意排名方向和索引范围。</p><h3><span id="zremrangebyscore">ZREMRANGEBYSCORE</span></h3><h4><span id="1-基本功能"><strong>1. 基本功能</strong></span></h4><p>移除有序集合中<strong>分数在指定范围内</strong>的所有成员（包含 <code>min</code> 和 <code>max</code> 边界值）。</p><h4><span id="2-命令格式"><strong>2. 命令格式</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure><h4><span id="3-核心特性"><strong>3. 核心特性</strong></span></h4><ul><li><strong>时间复杂度</strong>：<code>O(log(N) + M)</code>，<code>N</code> 是集合大小，<code>M</code> 是被移除的成员数量。</li><li><strong>分数范围</strong>：<ul><li>默认包含边界值（如 <code>ZREMRANGEBYSCORE key 100 200</code> 移除分数 100 ≤ score ≤ 200 的成员）。</li><li>支持<strong>开区间</strong>（使用 <code>(</code> 符号，如 <code>(100</code> 表示 &gt;100，<code>200</code> 表示 ≤200）。</li><li>支持特殊值 <code>-inf</code>（负无穷）和 <code>+inf</code>（正无穷）。</li></ul></li><li><strong>返回值</strong>：被移除的成员数量（若 <code>key</code> 不存在或范围无效，返回 <code>0</code>）。</li></ul><h4><span id="4-使用示例"><strong>4. 使用示例</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建测试数据</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot; 300 &quot;Charlie&quot; 400 &quot;David&quot; 500 &quot;Eve&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除分数 200 ≤ score ≤ 400 的成员</span></span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE scores 200 400</span><br><span class="line">(integer) 3  # 移除了 Bob(200), Charlie(300), David(400)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查剩余成员</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE scores 0 -1 WITHSCORES</span><br><span class="line">1) &quot;Alice&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;Eve&quot;</span><br><span class="line">4) &quot;500&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用开区间（移除分数 &gt;100 且 ≤300 的成员）</span></span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE scores (100 300</span><br><span class="line">(integer) 1  # 仅移除了 Bob(200)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 -inf 和 +inf（移除所有成员）</span></span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE scores -inf +inf</span><br><span class="line">(integer) 2  # 移除了剩余 Alice(100), Eve(500)</span><br></pre></td></tr></table></figure><h4><span id="5-应用场景"><strong>5. 应用场景</strong></span></h4><ul><li><strong>数据清理</strong>（如删除过期低分数据）。</li><li><strong>动态排行榜维护</strong>（定期移除低活跃用户）。</li><li><strong>范围任务处理</strong>（批量移除特定优先级的任务）。</li></ul><h4><span id="6-注意事项"><strong>6. 注意事项</strong></span></h4><ul><li><strong>与 <code>ZREMRANGEBYRANK</code> 区别</strong>：<ul><li><code>ZREMRANGEBYSCORE</code> 按<strong>分数范围</strong>移除。</li><li><code>ZREMRANGEBYRANK</code> 按<strong>排名范围</strong>移除（如 <code>ZREMRANGEBYRANK scores 0 2</code>）。</li></ul></li><li><strong>键不存在时</strong>：返回 <code>0</code>，无错误。</li><li><strong>错误类型</strong>：若键存在但非有序集合，返回 <code>WRONGTYPE</code> 错误。</li></ul><h4><span id="7-替代方案复杂条件删除"><strong>7. 替代方案（复杂条件删除）</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 ZRANGEBYSCORE + ZREM 组合（适用于非连续范围）</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE scores 100 300 | xargs redis-cli ZREM scores</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：<code>ZREMRANGEBYSCORE</code> 适用于<strong>按分数批量删除</strong>，支持灵活的范围设定，适合数据过滤和动态集合维护场景。</p><h3><span id="zincrby-指令详解">ZINCRBY 指令详解</span></h3><h4><span id="1-基本功能"><strong>1. 基本功能</strong></span></h4><p>对有序集合中的指定成员进行<strong>分数增减操作</strong>。若成员不存在，则自动创建并设置初始分数为 <code>0.0</code> 后增减；若键不存在，则创建新有序集合并添加该成员。</p><h4><span id="2-命令格式"><strong>2. 命令格式</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><h4><span id="3-核心特性"><strong>3. 核心特性</strong></span></h4><ul><li><strong>时间复杂度</strong>：<code>O(log(N))</code>，<code>N</code> 为有序集合的成员数量。</li><li><strong>分数规则</strong>：<ul><li><code>increment</code> 可为正数（增加分数）或负数（减少分数）。</li><li>支持<strong>双精度浮点数</strong>（如 <code>3.14</code> 或 <code>-1.5</code>）。</li></ul></li><li><strong>键和成员处理</strong>：<ul><li>若 <code>key</code> 不存在，自动创建新有序集合。</li><li>若 <code>member</code> 不存在，视为初始分数 <code>0.0</code> 并增减。</li><li>若 <code>key</code> 存在但非有序集合，返回错误。</li></ul></li></ul><h4><span id="4-使用示例"><strong>4. 使用示例</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始数据</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD scores 100 &quot;Alice&quot; 200 &quot;Bob&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加 Alice 的分数 (+50)</span></span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY scores 50 &quot;Alice&quot;</span><br><span class="line">&quot;150&quot;  # 新分数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">减少 Bob 的分数 (-30)</span></span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY scores -30 &quot;Bob&quot;</span><br><span class="line">&quot;170&quot;  # 新分数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不存在的成员（自动创建，初始分数 0 + 10）</span></span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY scores 10 &quot;Charlie&quot;</span><br><span class="line">&quot;10&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误示例（键存在但非有序集合）</span></span><br><span class="line">127.0.0.1:6379&gt; SET wrong_type &quot;value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY wrong_type 5 &quot;test&quot;</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><h4><span id="5-应用场景"><strong>5. 应用场景</strong></span></h4><ul><li><strong>实时排行榜更新</strong>（如游戏积分变动）。</li><li><strong>优先级任务调整</strong>（动态修改任务优先级）。</li><li><strong>计数器系统</strong>（支持增减的浮点计数器）。</li></ul><h4><span id="6-注意事项"><strong>6. 注意事项</strong></span></h4><ul><li><strong>返回值</strong>：始终返回成员增减后的<strong>新分数</strong>（字符串形式的浮点数）。</li><li><strong>精度问题</strong>：浮点数运算可能存在微小误差，需业务层处理。</li><li><strong>性能</strong>：高频操作时建议使用管道（pipeline）优化。</li></ul><h4><span id="7-对比其他命令"><strong>7. 对比其他命令</strong></span></h4><ul><li>与 <code>ZADD</code> 区别：<code>ZINCRBY</code> 专用于<strong>增量修改</strong>，而 <code>ZADD</code> 直接覆盖分数。</li><li>与 <code>HINCRBY</code> 区别：<code>HINCRBY</code> 用于哈希结构且仅支持整数增减。</li></ul><p><strong>总结</strong>：<code>ZINCRBY</code> 是动态维护有序集合分数的核心命令，适用于需频繁增减分数的场景，如排行榜、优先级队列等。</p><p>等等，我知道你想问什么，ZADD 好像已经有了 ZINCRBY 的功能呀，那为什么还要保留这个命令呢？感兴趣可以展开看看：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <ol><li><strong>语义清晰性</strong></li></ol><ul><li><code>ZINCRBY</code> 明确表达了”增量”操作的意图，代码可读性更强</li><li><code>ZADD ... INCR</code> 的语法相对隐晦，不够直观</li></ul><ol start="2"><li><strong>使用便捷性</strong></li></ol><ul><li><code>ZINCRBY</code> 语法更简洁：<code>ZINCRBY key increment member</code></li><li><code>ZADD</code> 实现相同功能需要：<code>ZADD key INCR increment member</code></li></ul><ol start="3"><li><strong>历史原因</strong></li></ol><ul><li><code>ZINCRBY</code> 是早期版本就存在的命令(1.2.0引入)</li><li><code>ZADD</code> 的 <code>INCR</code> 选项是后来添加的(2.6.9版本)</li></ul><ol start="4"><li><strong>性能考虑</strong></li></ol><ul><li>虽然差异很小，但专用命令(<code>ZINCRBY</code>)可能比通用命令(<code>ZADD</code>带选项)有轻微的性能优势</li><li><code>ZINCRBY</code> 的实现路径更直接，不需要解析额外选项</li></ul><ol start="5"><li><strong>错误预防</strong></li></ol><ul><li><code>ZINCRBY</code> 明确限制为单成员操作，避免误用</li><li><code>ZADD</code> 支持多成员操作，配合 <code>INCR</code> 时容易误传多个成员导致错误</li></ul><p>实际建议：</p><ul><li><strong>当明确要做增量操作时</strong>，优先使用 <code>ZINCRBY</code>，代码更清晰</li><li><strong>需要批量操作或复杂条件时</strong>，使用 <code>ZADD</code> 的选项功能</li><li><strong>维护旧代码时</strong>，保持原有命令使用的一致性</li></ul><p>Redis 的设计哲学之一是保持命令的专一性和明确性，即使某些功能有重叠，也会保留更专门的命令来满足不同场景的需求。</p>    </div></div><h2><span id="集合间操作指令">集合间操作指令</span></h2><h3><span id="zinterstore-指令深度解析"><strong>ZINTERSTORE 指令深度解析</strong></span></h3><h4><span id="1-核心功能"><strong>1. 核心功能</strong></span></h4><p>计算多个有序集合的交集，并将结果存储到指定的目标键中。仅保留同时存在于所有输入集合的成员，其分数通过可配置的聚合规则计算。</p><hr><h4><span id="2-完整命令格式"><strong>2. 完整命令格式</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] </span><br><span class="line">    [WEIGHTS weight [weight ...]] </span><br><span class="line">    [AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></table></figure><hr><h4><span id="3-参数详解"><strong>3. 参数详解</strong></span></h4><h5><span id="31-必选参数"><strong>3.1 必选参数</strong></span></h5><ul><li><strong>destination</strong>：存储结果的键名。若已存在会被覆盖（无论原类型）。</li><li><strong>numkeys</strong>：指定参与计算的有序集合数量（必须与实际输入的key数量一致）。</li><li><strong>key [key …]</strong>：参与交集的集合键名（至少1个）。</li></ul><h5><span id="32-可选参数"><strong>3.2 可选参数</strong></span></h5><h6><span id="weights"><strong>WEIGHTS</strong></span></h6><ul><li><strong>作用</strong>：为每个输入集合的分数设置权重乘法因子。</li><li><strong>规则</strong>：<ul><li>权重数量必须与<code>numkeys</code>一致，未指定时默认为<code>1</code>。</li><li>支持浮点数（如<code>2.5</code>），可正可负。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集合1分数×10，集合2分数×0.5</span></span><br><span class="line">ZINTERSTORE result 2 set1 set2 WEIGHTS 10 0.5</span><br></pre></td></tr></table></figure><h6><span id="aggregate"><strong>AGGREGATE</strong></span></h6><ul><li><strong>作用</strong>：控制交集成员的分数计算方式。</li><li><strong>选项</strong>：<ul><li><strong>SUM</strong>（默认）：各集合分数×权重后<strong>相加</strong>。</li><li><strong>MIN</strong>：取各集合分数×权重后的<strong>最小值</strong>。</li><li><strong>MAX</strong>：取各集合分数×权重后的<strong>最大值</strong>。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取分数的最小值</span></span><br><span class="line">ZINTERSTORE result 2 set1 set2 AGGREGATE MIN</span><br></pre></td></tr></table></figure><hr><h4><span id="4-执行逻辑"><strong>4. 执行逻辑</strong></span></h4><ol><li><strong>交集判定</strong>：仅保留所有输入集合中均存在的成员。</li><li><strong>分数计算</strong>：<ul><li>对每个成员，按<code>WEIGHTS</code>对原始分数加权。</li><li>按<code>AGGREGATE</code>规则聚合加权后的分数。</li></ul></li><li><strong>存储结果</strong>：覆盖<code>destination</code>键，类型转为有序集合。</li></ol><hr><h4><span id="5-时间复杂度"><strong>5. 时间复杂度</strong></span></h4><ul><li><strong>O(N<em>K) + O(M</em>log(M))</strong>：<ul><li><code>N</code>：最小输入集合的成员数。</li><li><code>K</code>：输入集合数量。</li><li><code>M</code>：结果集的成员数。</li></ul></li></ul><p>下面是对于这个时间复杂度的说明，感兴趣可以展开看看：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <p><strong>1. 时间复杂度组成</strong><br><code>O(N*K) + O(M*log(M))</code> 由两部分构成：</p><ul><li><p><strong><code>O(N*K)</code></strong>：计算交集的核心成本</p><ul><li><code>N</code>：<strong>最小输入集合</strong>的成员数量（需遍历该集合的所有成员）</li><li><code>K</code>：参与交集的集合数量（每个成员需检查是否存在于其他 <code>K-1</code> 个集合）</li><li>例如：3个集合分别有100、200、300个成员，则 <code>N=100</code>，<code>K=3</code>。</li></ul></li><li><p><strong><code>O(M*log(M))</code></strong>：存储结果集的成本</p><ul><li><code>M</code>：结果集的成员数量（需对 <code>M</code> 个成员按分数排序后存储）</li><li>使用跳表（Skip List）结构存储，插入单个成员的时间为 <code>O(log(M))</code></li></ul></li></ul><hr><p><strong>2. 为什么是这种复杂度？</strong><br><strong>2.1 交集计算逻辑</strong></p><ol><li><strong>选择基准集合</strong>：取成员数最少的集合（<code>N</code>最小）作为遍历基准</li><li><strong>成员存在性检查</strong>：对基准集合的每个成员，检查是否在其他 <code>K-1</code> 个集合中存在：<ul><li>每个检查操作时间复杂度为 <code>O(log(S))</code>（<code>S</code>为被检查集合的大小），但因有序集合使用哈希表+跳表，实际平均为 <code>O(1)</code></li><li>总检查成本为 <code>O(N*K)</code>（简化模型）</li></ul></li></ol><p><strong>2.2 结果集存储</strong></p><ul><li>交集成员需按分数重新排序后存入目标键：<ul><li>插入 <code>M</code> 个成员到跳表的总成本为 <code>O(M*log(M))</code></li></ul></li></ul><hr><p><strong>3. 影响因素</strong></p><ul><li><strong>数据分布</strong>：<ul><li>若输入集合的成员高度重合（<code>M</code>接近 <code>N</code>），<code>O(M*log(M))</code> 会显著增加</li><li>若成员几乎无交集（<code>M≈0</code>），则主要成本为 <code>O(N*K)</code></li></ul></li><li><strong>权重与聚合操作</strong>：<ul><li><code>WEIGHTS</code> 和 <code>AGGREGATE</code> 的计算成本已包含在 <code>O(N*K)</code> 中（仅额外算术操作）</li></ul></li></ul><hr><p><strong>4. 实测验证</strong></p><ul><li><strong>测试场景</strong>（参考实际案例）：<ul><li>交集两个集合（在线用户与付费用户），规模从1k到1M成员。</li><li>结果：当 <code>N=1k</code> 时，单次操作约0.5ms；<code>N=1M</code> 时约200ms，符合 <code>O(N*K)</code> 趋势</li></ul></li><li><strong>关键结论</strong>：<ul><li>小数据集（<code>N&lt;10k</code>）实时计算可行；大数据集需权衡性能</li></ul></li></ul><hr><p><strong>5. 对比其他命令</strong></p><ul><li><strong>与 <code>ZUNIONSTORE</code> 区别</strong>：<ul><li>并集需遍历所有集合的成员，时间复杂度为 <code>O(N)</code>（<code>N</code>为所有集合成员总数）</li></ul></li><li><strong>与 <code>ZINTER</code> 区别</strong>：<ul><li><code>ZINTER</code> 仅返回结果，不存储，省去 <code>O(M*log(M))</code> 成本</li></ul></li></ul><hr><p><strong>总结</strong>：<code>ZINTERSTORE</code> 的时间复杂度由<strong>交集计算</strong>和<strong>结果存储</strong>两部分决定，实际性能取决于最小集合大小和结果集规模。业务中建议对大数据集预分片或离线计算[5]。</p>    </div></div><hr><h4><span id="6-使用示例"><strong>6. 使用示例</strong></span></h4><h5><span id="61-基础交集"><strong>6.1 基础交集</strong></span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建测试数据</span></span><br><span class="line">ZADD set1 1 &quot;A&quot; 2 &quot;B&quot;</span><br><span class="line">ZADD set2 2 &quot;B&quot; 3 &quot;C&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算交集（默认SUM聚合）</span></span><br><span class="line">ZINTERSTORE result 2 set1 set2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果: <span class="string">&quot;B&quot;</span>的分数=2(set1)+2(set2)=4</span></span><br></pre></td></tr></table></figure><h5><span id="62-加权与聚合"><strong>6.2 加权与聚合</strong></span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加权计算（set1分数×10，set2分数×0.1）</span></span><br><span class="line">ZINTERSTORE result 2 set1 set2 WEIGHTS 10 0.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;B&quot;</span>的分数=2×10 + 2×0.1=20.2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MIN聚合</span></span><br><span class="line">ZINTERSTORE result 2 set1 set2 AGGREGATE MIN</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;B&quot;</span>的分数=min(2, 2)=2</span></span><br></pre></td></tr></table></figure><h5><span id="63-错误处理"><strong>6.3 错误处理</strong></span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键类型错误（非有序集合）</span></span><br><span class="line">SET wrong_type &quot;value&quot;</span><br><span class="line">ZINTERSTORE result 1 wrong_type</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回: (error) WRONGTYPE</span></span><br></pre></td></tr></table></figure><hr><h4><span id="7-应用场景"><strong>7. 应用场景</strong></span></h4><ul><li><strong>共同好友统计</strong>：计算多个用户的共同关注列表。</li><li><strong>商品筛选</strong>：找出同时满足多个条件的商品（如价格区间+评分区间）。</li><li><strong>优先级任务合并</strong>：整合多来源的高优先级任务。</li></ul><hr><h4><span id="8-注意事项"><strong>8. 注意事项</strong></span></h4><ol><li><strong>覆盖风险</strong>：目标键会被强制覆盖，包括类型转换。</li><li><strong>权重顺序</strong>：<code>WEIGHTS</code>顺序需与输入集合顺序严格对应。</li><li><strong>空集合处理</strong>：若输入集合无交集，结果集为空（返回<code>0</code>）。</li><li><strong>性能影响</strong>：大集合交集的CPU和内存消耗较高，建议在低峰期执行。</li></ol><h3><span id="zunionstore">ZUNIONSTORE</span></h3><p>该指令用法和 ZINERSTORE 相同，故不再赘述，下面是使用示例：</p><h4><span id="1-基础并集计算"><strong>1. 基础并集计算</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建两个有序集合</span></span><br><span class="line">ZADD set1 1 &quot;A&quot; 2 &quot;B&quot;</span><br><span class="line">ZADD set2 2 &quot;B&quot; 3 &quot;C&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算并集（默认SUM聚合）</span></span><br><span class="line">ZUNIONSTORE result 2 set1 set2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果: <span class="string">&quot;A&quot;</span>(1), <span class="string">&quot;B&quot;</span>(4=2+2), <span class="string">&quot;C&quot;</span>(3)</span></span><br></pre></td></tr></table></figure><h4><span id="2-使用权重weights"><strong>2. 使用权重（WEIGHTS）</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集合1分数×10，集合2分数×0.5</span></span><br><span class="line">ZUNIONSTORE result 2 set1 set2 WEIGHTS 10 0.5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果: <span class="string">&quot;A&quot;</span>(10=1×10), <span class="string">&quot;B&quot;</span>(21=2×10 + 2×0.5), <span class="string">&quot;C&quot;</span>(1.5=3×0.5)</span></span><br></pre></td></tr></table></figure><h4><span id="3-聚合规则aggregate"><strong>3. 聚合规则（AGGREGATE）</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MIN聚合（取最小分数）</span></span><br><span class="line">ZUNIONSTORE result 2 set1 set2 AGGREGATE MIN</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果: <span class="string">&quot;A&quot;</span>(1), <span class="string">&quot;B&quot;</span>(2), <span class="string">&quot;C&quot;</span>(3)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MAX聚合（取最大分数）</span></span><br><span class="line">ZUNIONSTORE result 2 set1 set2 AGGREGATE MAX</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果: <span class="string">&quot;A&quot;</span>(1), <span class="string">&quot;B&quot;</span>(2), <span class="string">&quot;C&quot;</span>(3)</span></span><br></pre></td></tr></table></figure><h4><span id="4-多集合并集"><strong>4. 多集合并集</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">三个集合的并集</span></span><br><span class="line">ZADD set3 4 &quot;B&quot; 5 &quot;D&quot;</span><br><span class="line">ZUNIONSTORE result 3 set1 set2 set3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果: <span class="string">&quot;A&quot;</span>(1), <span class="string">&quot;B&quot;</span>(8=2+2+4), <span class="string">&quot;C&quot;</span>(3), <span class="string">&quot;D&quot;</span>(5)</span></span><br></pre></td></tr></table></figure><h4><span id="5-异常处理"><strong>5. 异常处理</strong></span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键不存在时</span></span><br><span class="line">ZUNIONSTORE result 1 non_existing_key</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果: (<span class="built_in">integer</span>) 0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键类型错误（非有序集合）</span></span><br><span class="line">SET wrong_type &quot;value&quot;</span><br><span class="line">ZUNIONSTORE result 1 wrong_type</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果: (error) WRONGTYPE</span></span><br></pre></td></tr></table></figure><h2><span id="zset-相关指令汇总表">Zset 相关指令汇总表</span></h2><table><thead><tr><th>命令</th><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>基本操作</strong></td><td></td><td></td></tr><tr><td><code>ZADD key score member [score member ...]</code></td><td>O(k * log(n))</td><td>k是添加&#x2F;更新的成员个数，n是集合当前元素总数</td></tr><tr><td><code>ZCARD key</code></td><td>O(1)</td><td>获取有序集合的基数（成员数量）</td></tr><tr><td><code>ZSCORE key member</code></td><td>O(1)</td><td>获取指定成员的分数值</td></tr><tr><td><strong>排名查询</strong></td><td></td><td></td></tr><tr><td><code>ZRANK key member</code></td><td>O(log(n))</td><td>获取成员升序排名（从0开始计）</td></tr><tr><td><code>ZREVRANK key member</code></td><td>O(log(n))</td><td>获取成员降序排名</td></tr><tr><td><strong>增删操作</strong></td><td></td><td></td></tr><tr><td><code>ZREM key member [member ...]</code></td><td>O(k * log(n))</td><td>k是删除的成员个数</td></tr><tr><td><code>ZINCRBY key increment member</code></td><td>O(log(n))</td><td>对成员分数进行增量操作（原子性）</td></tr><tr><td><strong>范围查询</strong></td><td></td><td></td></tr><tr><td><code>ZRANGE key start end [WITHSCORES]</code></td><td>O(log(n) + k)</td><td>k是返回的成员个数（原图公式顺序有误，已修正）</td></tr><tr><td><code>ZREVRANGE key start end [WITHSCORES]</code></td><td>O(log(n) + k)</td><td>降序版的ZRANGE</td></tr><tr><td><code>ZRANGEBYSCORE key min max [WITHSCORES]</code></td><td>O(log(n) + k)</td><td>按分数区间升序查询</td></tr><tr><td><code>ZREVRANGEBYSCORE key max min [WITHSCORES]</code></td><td>O(log(n) + k)</td><td>按分数区间降序查询</td></tr><tr><td><strong>统计操作</strong></td><td></td><td></td></tr><tr><td><code>ZCOUNT key min max</code></td><td>O(log(n))</td><td>统计分数区间内的成员数量</td></tr><tr><td><strong>批量删除</strong></td><td></td><td></td></tr><tr><td><code>ZREMRANGEBYRANK key start end</code></td><td>O(log(n) + k)</td><td>按排名区间删除成员</td></tr><tr><td><code>ZREMRANGEBYSCORE key min max</code></td><td>O(log(n) + k)</td><td>按分数区间删除成员</td></tr><tr><td><strong>集合运算</strong></td><td></td><td></td></tr><tr><td><code>ZINTERSTORE dest numkeys key [key ...]</code></td><td>O(n<em>k) + O(m</em>log(m))</td><td>n是最小输入集合大小，k是集合数，m是结果集大小</td></tr><tr><td><code>ZUNIONSTORE dest numkeys key [key ...]</code></td><td>O(n) + O(m*log(m))</td><td>n是输入集合总大小，m是结果集大小</td></tr></tbody></table><h2><span id="内部编码">内部编码</span></h2><p>以下是整理后的Markdown格式内容：</p><p>有序集合类型的内部编码有两种：</p><h4><span id="1-ziplist压缩列表">1. ziplist（压缩列表）</span></h4><ul><li><strong>使用条件</strong>：<ul><li>元素个数 &lt; <code>zset-max-ziplist-entries</code>（默认128）</li><li>每个元素值大小 &lt; <code>zset-max-ziplist-value</code>（默认64字节）</li></ul></li><li><strong>优势</strong>：有效减少内存使用</li><li><strong>示例</strong>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zsetkey 50 e1 60 e2 30 e3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding zsetkey</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure><h4><span id="2-skiplist跳表">2. skiplist（跳表）</span></h4><ul><li><strong>使用条件</strong>：当不满足ziplist条件时自动切换</li><li><strong>原因</strong>：元素过多或过大时，ziplist操作效率会下降</li><li><strong>示例1（元素数量超过限制）</strong>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zsetkey 50 e1 60 e2 30 e3 ... e129</span><br><span class="line">(integer) 129</span><br><span class="line">127.0.0.1:6379&gt; object encoding zsetkey</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>示例2（元素大小超过限制）</strong>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zsetkey 50 &quot;超长字符串...(超过64字节)...&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zsetkey</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure><h4><span id="配置参数">配置参数</span></h4><table><thead><tr><th>参数名</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>zset-max-ziplist-entries</code></td><td>128</td><td>使用ziplist的最大元素个数</td></tr><tr><td><code>zset-max-ziplist-value</code></td><td>64</td><td>使用ziplist的单个元素最大字节数</td></tr></tbody></table><h2><span id="应用场景">应用场景</span></h2><h3><span id="1-实时排行榜系统">1. 实时排行榜系统</span></h3><h4><span id="游戏积分排行榜">游戏积分排行榜</span></h4><ul><li>使用 <code>ZADD</code> 添加玩家分数</li><li><code>ZREVRANGE</code> 获取前N名玩家</li><li><code>ZINCRBY</code> 实时更新玩家分数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD game_leaderboard 1500 &quot;player1&quot; 2000 &quot;player2&quot; 1800 &quot;player3&quot;</span><br><span class="line">ZREVRANGE game_leaderboard 0 9 WITHSCORES  # 获取TOP10</span><br><span class="line">ZINCRBY game_leaderboard 50 &quot;player1&quot;      # 玩家1增加50分</span><br></pre></td></tr></table></figure><h4><span id="微博热搜榜">微博热搜榜</span></h4><ul><li>使用 <code>ZINCRBY</code> 增加话题热度</li><li><code>ZREVRANGE</code> 获取实时热搜</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY weibo_trending 1000000 &quot;#世界杯决赛#&quot;</span><br><span class="line">ZINCRBY weibo_trending 500000 &quot;#元旦假期安排#&quot;</span><br><span class="line">ZREVRANGE weibo_trending 0 4 WITHSCORES  # 获取TOP5热搜</span><br></pre></td></tr></table></figure><h3><span id="2-延迟队列系统">2. 延迟队列系统</span></h3><h4><span id="订单超时处理">订单超时处理</span></h4><ul><li>使用分数存储执行时间戳</li><li>定时任务获取到期订单</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZADD delay_queue 1672531200 &quot;order_123&quot;  # 2023-01-01 00:00:00执行</span><br><span class="line">ZRANGEBYSCORE delay_queue 0 1672531200  # 获取到期订单</span><br></pre></td></tr></table></figure><h3><span id="3-滑动窗口限流">3. 滑动窗口限流</span></h3><h4><span id="api访问频率控制">API访问频率控制</span></h4><ul><li>使用时间戳作为分数</li><li>统计窗口内请求数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZADD api_limit 1672500000 &quot;req_1&quot;</span><br><span class="line">ZADD api_limit 1672500001 &quot;req_2&quot;</span><br><span class="line">ZREMRANGEBYSCORE api_limit 0 1672500000  # 清理1秒前的请求</span><br><span class="line">ZCARD api_limit                          # 获取当前秒内请求数</span><br></pre></td></tr></table></figure><h3><span id="4-带权重的投票系统">4. 带权重的投票系统</span></h3><h4><span id="热门内容评选">热门内容评选</span></h4><ul><li>不同用户投票权重不同</li><li>实时计算内容得分</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD content_votes 5 &quot;article_123&quot;  # 初始5票</span><br><span class="line">ZINCRBY content_votes 2 &quot;article_123&quot;  # VIP用户投票权重为2</span><br><span class="line">ZREVRANGE content_votes 0 9 WITHSCORES  # 获取TOP10内容</span><br></pre></td></tr></table></figure><h3><span id="5-时间线排序">5. 时间线排序</span></h3><h4><span id="朋友圈动态">朋友圈动态</span></h4><ul><li>使用发布时间戳作为分数</li><li>获取最新动态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZADD friend_timeline 1672500000 &quot;post_123&quot;  # 发布动态</span><br><span class="line">ZREVRANGE friend_timeline 0 19  # 获取最新20条动态</span><br></pre></td></tr></table></figure><h3><span id="6-多维度排序">6. 多维度排序</span></h3><h4><span id="商品综合排序">商品综合排序</span></h4><ul><li>使用加权分数计算综合评分</li><li>销量、好评率、价格等多维度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZADD product_rank 85 &quot;product_123&quot;  # 初始综合分85</span><br><span class="line">ZINCRBY product_rank 5 &quot;product_123&quot;  # 销量增加提升排名</span><br></pre></td></tr></table></figure><h3><span id="7-实时竞赛系统">7. 实时竞赛系统</span></h3><h4><span id="在线编程比赛">在线编程比赛</span></h4><ul><li>实时更新选手得分</li><li>获取实时排名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD coding_contest 3 &quot;user_123&quot;  # 3道题正确</span><br><span class="line">ZINCRBY coding_contest 1 &quot;user_123&quot;  # 又解决1题</span><br><span class="line">ZREVRANK coding_contest &quot;user_123&quot;  # 获取用户排名</span><br></pre></td></tr></table></figure><h3><span id="8-热点数据缓存">8. 热点数据缓存</span></h3><h4><span id="新闻点击排行">新闻点击排行</span></h4><ul><li>记录点击事件</li><li>实时统计热点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD news_clicks 1500 &quot;news_123&quot;  # 初始点击量</span><br><span class="line">ZINCRBY news_clicks 1 &quot;news_123&quot;  # 用户点击+1</span><br><span class="line">ZREVRANGE news_clicks 0 9  # 获取TOP10热点新闻</span><br></pre></td></tr></table></figure><p>ZSet的这些特性使其成为处理需要实时排序和加权计算场景的理想选择，性能优异且实现简洁。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 键值对 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常见数据类型-Set 类型</title>
      <link href="/2025/07/09/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Set/"/>
      <url>/2025/07/09/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Set/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B">类型简介</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">相关指令</a><ul><li><a href="#sadd">sadd</a></li><li><a href="#smembers">smembers</a></li><li><a href="#sismember">sismember</a></li><li><a href="#scard">scard</a></li><li><a href="#spop">spop</a></li><li><a href="#smove">smove</a></li><li><a href="#srem">srem</a></li></ul></li><li><a href="#%E9%9B%86%E5%90%88%E9%97%B4%E6%93%8D%E4%BD%9C">集合间操作</a><ul><li><a href="#sinter">sinter</a></li><li><a href="#sinterstore">sinterstore</a></li><li><a href="#sunion-sunionstore-sdiff-sdiffstore">sunion、sunionstore、sdiff、sdiffstore</a></li></ul></li><li><a href="#set-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB%E8%A1%A8">set 相关指令汇总表</a></li><li><a href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81">内部编码</a><ul><li><a href="#254-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81">2.5.4 内部编码</a></li></ul></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a><ul><li><a href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%9C%A8%E6%A0%87%E7%AD%BE%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">集合类型在标签系统中的应用</a></li></ul></li></ul><!-- tocstop --><h2><span id="类型简介">类型简介</span></h2><p>集合类型也是保存多个字符串类型的元素的，但和列表类型不同的是，集合中 1）元素之间是⽆序的 2）元素不允许重复，<br>⼀个集合中最多可以存储 $2^{32}$ - 1 个元素。Redis 除了⽀持集合内的增删查改操作，同时还⽀持多个集合取交集、并集、差集，合理<br>地使⽤好集合类型，能在实际开发中解决很多问题</p><p>相关指令如下：</p><h2><span id="相关指令">相关指令</span></h2><h3><span id="sadd">sadd</span></h3><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><p>将一个或多个元素添加到 set 中，重复定义的元素是无法添加到 set 中的</p><p>时间复杂度：O(1)</p><p>返回值：本次添加成功的个数</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预期添加 5 个元素</span></span><br><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 3 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">元素3被重复添加，只能添加一个</span></span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers k1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3><span id="smembers">smembers</span></h3><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><p>获取—个 set 中的所有元素，<strong>元素间的顺序是无序的</strong></p><p>时间复杂度：O(N)</p><p>返回值：所有元素的列表</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers k1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3><span id="sismember">sismember</span></h3><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>判断一个元素是否在 set 中</p><p>时间复杂度：O(1)</p><p>返回值：1表示存在，0表示不存在</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询元素 2 存在</span></span><br><span class="line">127.0.0.1:6379&gt; sismember k1 2</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询元素 5 不存在</span></span><br><span class="line">127.0.0.1:6379&gt; sismember k1 5</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3><span id="scard">scard</span></h3><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure><p>获取一个 set 的基数，即 set 中的元素个数</p><p>时间复杂度：O(1)</p><p>返回值：set 中元素的个数</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; scard k1</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h3><span id="spop">spop</span></h3><p>从set 中删除并返回—个或者多个元素。注意，由于 set 内的元素是无序的，所以取出哪个元素实际是<br>未定义行为，即可以看作随机的</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N) n表示count</p><p>返回值：取出的元素</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认删除一个随机元素</span></span><br><span class="line">127.0.0.1:6379&gt; spop k1</span><br><span class="line">&quot;5&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除两个随机元素</span></span><br><span class="line">127.0.0.1:6379&gt; spop k1 2</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;6&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">剩余元素</span></span><br><span class="line">127.0.0.1:6379&gt; smembers k1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure><h3><span id="smove">smove</span></h3><p>将一个元素从源 set 取出并放到目的 set 中</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><p>返回值：1表示移动成功，0表示移动失败</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">依次将 k1 中的所有元素移动到 k2 中</span></span><br><span class="line">127.0.0.1:6379&gt; smove k1 k2 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smove k1 k2 4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smove k1 k2 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smove k1 k2 1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k1 中的元素都被移动到 k2 中</span></span><br><span class="line">127.0.0.1:6379&gt; smembers k1</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; smembers k2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd k1 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smove k1 k2 1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移动相同的元素到 k2 中虽然移动成功，但因为 k2 中已经有该元素了，故 k2 无变化</span></span><br><span class="line">127.0.0.1:6379&gt; smembers k2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3><span id="srem">srem</span></h3><p>该指令用于将指定元素从 set 中删除</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N)，N 表示要删除的元素个数</p><p>返回值：本次操作被删除的元素个数</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 4 5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; srem k1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; srem k1 4 4 4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem k1 6 7</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h2><span id="集合间操作">集合间操作</span></h2><h3><span id="sinter">sinter</span></h3><p>该指令用于获取给定 set 的交集中的元素</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N * M), N 是最小的集合元素个数. M 是集合个数.</p><p>返回值：交集的元素</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd k2 2 3 4 5</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd k3 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sinter k1 k2 k3</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>下面是针对该时间复杂度的讨论：</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <p>Redis 的 <code>SINTER</code> 指令用于计算多个集合的交集，其时间复杂度为 <strong>O(N * M)</strong>，其中：</p><ul><li><strong>N</strong> 是最小集合的基数（元素个数）</li><li><strong>M</strong> 是参与计算的集合数量</li></ul><h4><span id="原因分析">原因分析</span></h4><ol><li><p><strong>遍历最小集合</strong>：</p><p>Redis 会优先选择<strong>元素最少的集合</strong>作为基准（假设为集合 A），遍历其中的每个元素。这一步的时间复杂度为 O(N)（N 是集合 A 的元素数量）。</p></li><li><p><strong>检查其他集合</strong>：</p><p>对于集合 A 中的每个元素，需要检查它是否存在于其他 <strong>M-1 个集合</strong>中。每次检查的时间复杂度为 O(1)（Redis 的集合底层是哈希表，支持常数时间查找）。<br>因此，总检查次数为 <strong>N × (M-1)</strong> ≈ O(N * M)。</p></li><li><p><strong>最坏情况</strong>：</p><p>当所有集合大小相近时，时间复杂度趋近于 O(N * M)。若某个集合为空，则直接返回空结果（O(1)）。</p></li></ol><h4><span id="示例">示例</span></h4><p>假设有三个集合：</p><ul><li><code>key1 = {a, b, c}</code>（N&#x3D;3）</li><li><code>key2 = {a, c, d, e}</code></li><li><code>key3 = {a, c, f}</code>（M&#x3D;3）</li></ul><p>Redis 会遍历最小的 <code>key1</code>（3 个元素），并对每个元素检查是否同时在 <code>key2</code> 和 <code>key3</code> 中，总操作次数为 3 × 2 &#x3D; 6 次。</p>    </div></div><h3><span id="sinterstore">sinterstore</span></h3><p>该指令用于获取给定 set 的交集中的元素并保存到目标 set 中</p><p>指令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N * M), N 是最小的集合元素个数. M 是集合个数.</p><p>返回值：交集的元素个数</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd k2 2 3 4 5</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd k3 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sinterstore k4 k1 k2 k3</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers k4</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3><span id="sunion-sunionstore-sdiff-sdiffstore">sunion、sunionstore、sdiff、sdiffstore</span></h3><p>这四个命令和上面的 sinter 和 sinterstore 指令类似，union 用于求并集，diff 用于求差集，故不再赘述</p><h2><span id="set-相关指令汇总表">set 相关指令汇总表</span></h2><table><thead><tr><th>命令</th><th>时间复杂度</th></tr></thead><tbody><tr><td>sadd key element [element …]</td><td>O(k)，k 是元素个数</td></tr><tr><td>srem key element [element …]</td><td>O(k)，k 是元素个数</td></tr><tr><td>scard key</td><td>O(1)</td></tr><tr><td>sismember key element</td><td>O(1)</td></tr><tr><td>srandmember key [count]</td><td>O(n)，n 是 count</td></tr><tr><td>spop key [count]</td><td>O(n)，n 是 count</td></tr><tr><td>smembers key</td><td>O(k)，k 是元素个数</td></tr><tr><td>sinter key [key …] &#x2F; sinterstore</td><td>O(m * k)，k 是几个集合中元素最小的个数，m 是键个数</td></tr><tr><td>sunion key [key …] &#x2F; sunionstore</td><td>O(k)，k 是多个集合的元素个数总和</td></tr><tr><td>sdiff key [key …] &#x2F; sdiffstore</td><td>O(k)，k 是多个集合的元素个数总和</td></tr></tbody></table><h2><span id="内部编码">内部编码</span></h2><h3><span id="254-内部编码">2.5.4 内部编码</span></h3><p>集合类型的内部编码有两种：</p><ul><li><strong>intset（整数集合）：</strong> 当集合中的元素都是整数并且元素的个数小于 <code>set-max-intset-entries</code> 配置（默认 512 个）时，Redis 会选用 <code>intset</code> 来作为集合的内部实现，从而减少内存的使用。  </li><li><strong>hashtable（哈希表）：</strong> 当集合类型无法满足 <code>intset</code> 的条件时，Redis 会使用 <code>hashtable</code> 作为集合的内部实现。</li></ul><h4><span id="示例">示例</span></h4><ol><li><strong>当元素个数较少并且都为整数时，内部编码为 <code>intset</code>：</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd setkey 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding setkey</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>当元素个数超过 512 个，内部编码为 <code>hashtable</code>：</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd setkey 1 2 3 4 ... 513</span><br><span class="line">(integer) 513</span><br><span class="line">127.0.0.1:6379&gt; object encoding setkey</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>当存在元素不是整数时，内部编码为 <code>hashtable</code>：</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd setkey a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding setkey</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><h2><span id="应用场景">应用场景</span></h2><h3><span id="集合类型在标签系统中的应用">集合类型在标签系统中的应用</span></h3><p>集合类型在标签(tag)系统中有着典型的使用场景，例如：</p><ul><li>用户兴趣标签（娱乐、体育、历史、新闻等）</li><li>基于标签的用户分析（共同兴趣、个性化推荐）</li><li>电子商务的个性化产品推荐</li></ul><h4><span id="实现标签功能的redis命令演示">实现标签功能的Redis命令演示</span></h4><h5><span id="1-给用户添加标签">1. 给用户添加标签</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag5</span><br><span class="line">sadd user:2:tags tag2 tag3 tag5</span><br><span class="line">...</span><br><span class="line">sadd user:k:tags tag1 tag2 tag4</span><br></pre></td></tr></table></figure><h5><span id="2-给标签添加用户">2. 给标签添加用户</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd tag1:users user:1 user:3</span><br><span class="line">sadd tag2:users user:1 user:2 user:3</span><br><span class="line">...</span><br><span class="line">sadd tagk:users user:1 user:4 user:9 user:28</span><br></pre></td></tr></table></figure><h5><span id="3-删除用户下的标签">3. 删除用户下的标签</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem user:1:tags tag1 tag5</span><br></pre></td></tr></table></figure><h5><span id="4-删除标签下的用户">4. 删除标签下的用户</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srem tag1:users user:1</span><br><span class="line">srem tag5:users user:1</span><br></pre></td></tr></table></figure><h5><span id="5-计算用户的共同兴趣标签">5. 计算用户的共同兴趣标签</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure><h4><span id="应用价值">应用价值</span></h4><p>这种实现方式可以：</p><ol><li>发现喜欢同一标签的用户群体</li><li>分析用户的共同兴趣标签</li><li>为个性化推荐系统提供数据支持</li><li>增强用户体验和用户黏度</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 键值对 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常见数据类型-List 类型</title>
      <link href="/2025/07/09/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/List/"/>
      <url>/2025/07/09/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/List/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B">类型简介</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">相关指令</a><ul><li><a href="#lpush">lpush</a></li><li><a href="#lrange">lrange</a></li><li><a href="#lpushx">lpushx</a></li><li><a href="#rpush-rpushx">rpush、rpushx</a></li><li><a href="#lpop-rpop">lpop、rpop</a></li><li><a href="#lindex">lindex</a></li><li><a href="#linsert">linsert</a></li><li><a href="#lrem">lrem</a></li><li><a href="#llen">llen</a></li></ul></li><li><a href="#%E9%98%BB%E5%A1%9E%E7%89%88%E6%9C%AC%E6%8C%87%E4%BB%A4">阻塞版本指令</a><ul><li><a href="#redis-%E9%98%BB%E5%A1%9E%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9Cblpop-%E5%92%8C-brpop">Redis 阻塞列表操作：BLPOP 和 BRPOP</a></li><li><a href="#1-%E6%97%B6%E5%BA%8F%E5%9B%BE%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E-redis-%E7%9A%84%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B">1. 时序图：客户端与 Redis 的交互过程</a></li><li><a href="#2-%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%93%8D%E4%BD%9C%E9%80%BB%E8%BE%91%E5%AF%B9%E6%AF%94">2. 流程图：操作逻辑对比</a></li><li><a href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA">关键结论</a></li><li><a href="#blpop-%E6%8C%87%E4%BB%A4%E8%AE%B2%E8%A7%A3">blpop 指令讲解</a></li></ul></li><li><a href="#list-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB%E8%A1%A8">list 相关指令汇总表</a></li><li><a href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81">内部编码</a><ul><li><a href="#redis-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0">Redis 列表类型的内部编码实现</a></li></ul></li><li><a href="#%E5%85%B8%E5%9E%8B%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF">典型业务场景</a><ul><li><a href="#%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD">缓存功能</a></li><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li><li><a href="#redis-%E5%AE%9E%E7%8E%B0%E5%BE%AE%E5%8D%9A-timeline-%E6%96%B9%E6%A1%88">Redis 实现微博 Timeline 方案</a></li></ul></li></ul><!-- tocstop --><h2><span id="类型简介">类型简介</span></h2><p>列表类型是⽤来存储多个有序的字符串，如图1所⽰，a、b、c、d、e 五个元素从左到右组成了⼀个有序的列表，列表中的每个<br>字符串称为元素（element），⼀个列表最多可以存储 2 − 32 1 个元素。在 Redis 中，可以对列表两端插⼊（push）和弹出（pop），<br>还可以获取指定范围的元素列表、获取指定索引下标的元素等（如图1和图2所⽰）。列表是⼀种⽐较灵活的数据结构，它可以<br>充当栈和队列的⻆⾊，在实际开发上有很多应⽤场景</p><p>列表类型的特点：<br>第⼀、列表中的元素是有序的，这意味着可以通过索引下标获取某个元素或者某个范围的元素列表，<br>例如要获取图 1 的第 5 个元素，可以执⾏ lindex user:1:messages 4 或者倒数第 1 个元素，lindex<br>user:1:messages -1 就可以得到元素 e。<br>第⼆、区分获取和删除的区别，例如图2中的 lrem 1 b 是从列表中把从左数遇到的前 1 个 b 元素删<br>除，这个操作会导致列表的⻓度从 5 变成 4；但是执⾏ lindex 4 只会获取元素，但列表⻓度是不会变化<br>的。<br>第三、列表中的元素是允许重复的，例如图2中的列表中是包含了两个 a 元素的。</p><p>列表两端插入和弹出操作概念图（图1）：</p><p><img src="/img/Redis/data_type/List/push.png" alt="List"></p><p>列表的获取、删除等操作概念图（图2）：</p><p><img src="/img/Redis/data_type/List/rem.png" alt="List"></p><h2><span id="相关指令">相关指令</span></h2><h3><span id="lpush">lpush</span></h3><p>该指令用于将⼀个或者多个元素从左侧放⼊（头插）到 list 中</p><p>语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]</span><br></pre></td></tr></table></figure><p>时间复杂度：只插⼊⼀个元素为 O(1), 插⼊多个元素为 O(N), N 为插⼊元素个数</p><p>返回值：插⼊后 list 的⻓度</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lpush k1 5 6 7 8</span><br><span class="line">(integer) 8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list 范围查询指令，后面会讲到，这里用于查询整个 list 的数据</span></span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line">1) &quot;8&quot;</span><br><span class="line">2) &quot;7&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">5) &quot;4&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>需要注意的是每个 value 前面的序号并不是下标，只是起到序号的作用，用来表示第几个数据</p><h3><span id="lrange">lrange</span></h3><p>为了方便讲解，这里先将 lrange 指令介绍一下：</p><p>该指令用于获取从 start 到 end 区间的所有元素，左闭右闭，下表可以用负数表示，表示倒数第几个数据</p><p>时间复杂度：O(N)</p><p>返回值：指定区间的元素</p><h4><span id="针对不合法范围的处理">针对不合法范围的处理</span></h4><p>(1) 索引超出实际范围<br>Redis 会 自动修正为最接近的有效索引：<br>如果 start 超出列表右边界（start &gt;&#x3D; N），返回空列表 []。<br>如果 end 超出列表右边界（end &gt;&#x3D; N），自动修正为 N-1（列表最后一个元素）。<br>如果 start 超出左边界（start &lt; -N），自动修正为 0（第一个元素）。<br>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列表: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]（索引 0~4）</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 10 15</span><br><span class="line">(empty array)  # start &gt;= N，返回空列表</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 2 100</span><br><span class="line">1) &quot;c&quot;                # end 超出，修正为 N-1=4</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">3) &quot;e&quot;</span><br></pre></td></tr></table></figure><p>(2) start &gt; end<br>直接返回空列表 []，因为范围无效。<br>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE mylist 3 1</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><p>(3) 负数索引<br>负数索引是合法的，表示从列表末尾开始计算（-1 是最后一个元素，-2 是倒数第二个，依此类推）。<br>如果负数索引超出左边界（如 -100），会修正为 0。<br>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE mylist -3 -1  # 最后三个元素</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">3) &quot;e&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist -100 2 # start 超出左边界，修正为 0</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br></pre></td></tr></table></figure><p>总结如下：</p><table><thead><tr><th>场景</th><th>Redis 行为</th><th>示例（列表长度&#x3D;5）</th></tr></thead><tbody><tr><td><code>start</code> 超出右边界</td><td>返回空列表 <code>[]</code></td><td><code>LRANGE key 10 15</code> → <code>[]</code></td></tr><tr><td><code>end</code> 超出右边界</td><td>修正为 <code>N-1</code></td><td><code>LRANGE key 2 100</code> → <code>[c,d,e]</code></td></tr><tr><td><code>start</code> 超出左边界</td><td>修正为 <code>0</code></td><td><code>LRANGE key -100 1</code> → <code>[a,b]</code></td></tr><tr><td><code>start &gt; end</code></td><td>返回空列表 <code>[]</code></td><td><code>LRANGE key 3 1</code> → <code>[]</code></td></tr><tr><td>负数索引合法</td><td>正常返回对应元素</td><td><code>LRANGE key -2 -1</code> → <code>[d,e]</code></td></tr></tbody></table><p>当然，这种范围不合法的处理方式太过柔性，导致程序猿很难检查出问题，因此在编程时建议采用<strong>防御性编程</strong>，在代码中显式检查索引范围，避免依赖 Redis 的自动修正。</p><p>下面是针对 Redis 不合法访问处理的讨论</p><div class="spoiler collapsed">    <div class="spoiler-title">            </div>    <div class="spoiler-content">        <p>Redis 采用 <strong>柔性修正</strong>（自动调整非法范围为合法范围）的设计，主要基于以下几个核心考虑，尽管它可能增加调试难度，但整体上利大于弊：</p><hr><ol><li>设计哲学：简单性与容错性</li></ol><ul><li><p><strong>减少用户的心智负担</strong><br>Redis 的设计目标之一是 <strong>“简单、直观”</strong>。柔性修正让用户无需预先检查列表长度或计算精确的索引范围，尤其适合快速原型开发或脚本场景。</p><ul><li><em>示例</em>：<code>LRANGE mylist 0 100</code> 直接返回所有元素，而不需要先调用 <code>LLEN</code> 查询长度。</li></ul></li><li><p><strong>符合自然直觉</strong><br>类似 Python 的切片操作（如 <code>list[10:20]</code> 超出范围时返回空列表），Redis 的行为符合大多数开发者对”范围操作”的预期。</p></li></ul><hr><ol start="2"><li>性能优化</li></ol><ul><li><p><strong>减少往返操作（Round Trips）</strong><br>如果强制要求索引严格合法，用户必须 <strong>先查询列表长度（<code>LLEN</code>）</strong>，再计算有效范围，这会增加一次网络请求，降低性能（尤其在分布式环境中）。</p><ul><li><em>对比</em>：柔性修正允许用户直接发起 <code>LRANGE</code>，由 Redis 内部处理边界。</li></ul></li><li><p><strong>降低计算开销</strong><br>Redis 是单线程模型，避免额外的 <code>LLEN</code> 查询能减少 CPU 和内存压力。</p></li></ul><hr><ol start="3"><li>实际应用场景的需求</li></ol><ul><li><p><strong>动态变化的列表</strong><br>列表长度可能随时变化（如消息队列），柔性修正能保证命令 <strong>始终有确定的行为</strong>，而非因并发修改抛出错误。</p><ul><li><em>示例</em>：在 <code>LRANGE</code> 执行瞬间，列表被其他客户端缩短，修正机制仍能安全返回部分数据。</li></ul></li><li><p><strong>批量处理的友好性</strong><br>在分页查询等场景中，用户可能用固定步长（如每次查 10 条），柔性修正避免因最后一页不足 10 条而报错。</p></li></ul><hr><ol start="4"><li>调试问题的权衡</li></ol><p>虽然柔性修正可能掩盖某些错误，但 Redis 通过其他方式降低调试难度：</p><ul><li><strong>显式返回空列表</strong><br>当 <code>start &gt; end</code> 或 <code>start</code> 超出右边界时返回 <code>[]</code>，这是一种明确的”无数据”信号，而非隐式忽略错误。</li><li><strong>文档清晰说明行为</strong><br><a href="https://redis.io/commands/lrange">Redis 官方文档</a> 明确描述了索引超界时的修正逻辑，减少歧义。</li></ul><hr><ol start="5"><li>对比其他数据库的设计</li></ol><table><thead><tr><th>系统</th><th>范围处理策略</th><th>优缺点</th></tr></thead><tbody><tr><td><strong>Redis</strong></td><td>柔性修正（自动调整）</td><td>简单高效，但需注意边界逻辑</td></tr><tr><td><strong>SQL</strong></td><td>严格报错（如 <code>OFFSET</code> 超限）</td><td>更精确，但需要额外处理错误</td></tr><tr><td><strong>Python</strong></td><td>切片自动调整</td><td>类似 Redis，符合开发者直觉</td></tr></tbody></table><hr><p>如何避免潜在问题？</p><ol><li><strong>代码层面防御</strong><br>在业务逻辑中显式检查范围合法性（如先 <code>LLEN</code>），而非依赖 Redis 修正。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_len = redis.llen(key)</span><br><span class="line">start = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(start, list_len - <span class="number">1</span>))</span><br><span class="line">end = <span class="built_in">min</span>(end, list_len - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>监控与日志</strong><br>对频繁返回空列表的 <code>LRANGE</code> 操作打日志，帮助发现潜在逻辑错误。</p></li><li><p><strong>使用 Lua 脚本</strong><br>在脚本中封装严格的索引检查逻辑，保持原子性。</p></li></ol><hr><p>总结</p><p>Redis 选择柔性修正的核心原因是 <strong>在性能、简单性和实用性之间取得平衡</strong>。虽然可能增加调试复杂度，但通过良好的代码规范和文档学习，可以规避大部分问题。这种设计符合 Redis 作为 <strong>高性能、轻量级缓存&#x2F;队列</strong> 的定位，而非强一致性的关系型数据库。</p>    </div></div><h3><span id="lpushx">lpushx</span></h3><p>在key 存在时，将⼀个或者多个元素从左侧放⼊（头插）到 list 中。不存在，直接返回</p><p>时间复杂度：只插⼊—个元素为 O(1), 插⼊多个元素为 O(N), N 为插⼊元素个数<br>返回值：插⼊后 list 的⻓度</p><p>语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key element [element ...]</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k1 不存在，故无法 push</span></span><br><span class="line">127.0.0.1:6379&gt; lpushx k1 1 2 3 4</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可通过 lpush 创建新的 list</span></span><br><span class="line">127.0.0.1:6379&gt; lpush k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lpush 创建后 list k1 存在，可利用 lpushx 继续插入新值</span></span><br><span class="line">127.0.0.1:6379&gt; lpushx k1 5 6 7 8</span><br><span class="line">(integer) 8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看被插入 list 的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line">1) &quot;8&quot;</span><br><span class="line">2) &quot;7&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">5) &quot;4&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><h3><span id="rpush-rpushx">rpush、rpushx</span></h3><p>用法和 lpush 和 lpushx 相同，只不过变成了尾插，这里不再过多赘述</p><p>下面是使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接使用 rpushx 插入不存在的 list 失败</span></span><br><span class="line">127.0.0.1:6379&gt; rpushx k1 1 2 3 4</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先用 rpush 创建新的 list</span></span><br><span class="line">127.0.0.1:6379&gt; rpush k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再用 rpushx 插入新值成功</span></span><br><span class="line">127.0.0.1:6379&gt; rpushx k1 5 6 7 8</span><br><span class="line">(integer) 8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 k1 中所有的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure><h3><span id="lpop-rpop">lpop、rpop</span></h3><p>lpop 指令用于从 list 左侧取出元素（即头删）</p><p>rpop 指令用于从 list 右侧取出元素（即尾删）</p><p>时间复杂度：O(1)</p><p>语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br><span class="line">RPOP key</span><br></pre></td></tr></table></figure><p>返回值：取出的元素或者 nil。</p><p>下面是使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前 list 中元素为 &#123;1,2,3,4&#125;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">头删获得元素1</span></span><br><span class="line">127.0.0.1:6379&gt; lpop k1</span><br><span class="line">&quot;1&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尾删获得元素4</span></span><br><span class="line">127.0.0.1:6379&gt; rpop k1</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop k1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop k1</span><br><span class="line">&quot;2&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list 中所有元素都被取完了，返回 nil</span></span><br><span class="line">127.0.0.1:6379&gt; rpop k1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3><span id="lindex">lindex</span></h3><p>该指令用于获取从左数第 index 位置的元素</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N)</p><p>返回值：取出的元素或者 nil</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入元素 1 2 3 4 到 list k1 中</span></span><br><span class="line">127.0.0.1:6379&gt; rpush k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取下标为 3 的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lindex k1 3</span><br><span class="line">&quot;4&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取下标为 0 的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lindex k1 0</span><br><span class="line">&quot;1&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">支持负数下标访问（表示获取倒数第几个元素）</span></span><br><span class="line">127.0.0.1:6379&gt; lindex k1 -1</span><br><span class="line">&quot;4&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">越界访问返回 nil</span></span><br><span class="line">127.0.0.1:6379&gt; lindex k1 6</span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">负数越界同理</span></span><br><span class="line">127.0.0.1:6379&gt; lindex k1 -5</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3><span id="linsert">linsert</span></h3><p>该指令用于在特定位置插⼊元素</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key &lt;BEFORE | AFTER&gt; pivot element</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N)</p><p>返回值：插⼊后的 list ⻓度</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成一个新的 list 插入 1</span></span><br><span class="line">127.0.0.1:6379&gt; lpush k1 1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在元素 1 的前面插入 2</span></span><br><span class="line">127.0.0.1:6379&gt; linsert k1 before 1 2</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在元素 2 的后面插入 3</span></span><br><span class="line">127.0.0.1:6379&gt; linsert k1 after 1 3</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看插入是否符合预期</span></span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure><h3><span id="lrem">lrem</span></h3><p>该指令用于删除前指定个数的元素</p><p>时间复杂度：O(N)</p><p>返回值：被成功删除的元素个数</p><p>指令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count element</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush k1 1 2 3 4 4 4 5 6 7 4 4 4</span><br><span class="line">(integer) 12</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试删除4个2，但因为只有一个故返回1</span></span><br><span class="line">127.0.0.1:6379&gt; lrem k1 4 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line"> 1) &quot;1&quot;</span><br><span class="line"> 2) &quot;3&quot;</span><br><span class="line"> 3) &quot;4&quot;</span><br><span class="line"> 4) &quot;4&quot;</span><br><span class="line"> 5) &quot;4&quot;</span><br><span class="line"> 6) &quot;5&quot;</span><br><span class="line"> 7) &quot;6&quot;</span><br><span class="line"> 8) &quot;7&quot;</span><br><span class="line"> 9) &quot;4&quot;</span><br><span class="line">10) &quot;4&quot;</span><br><span class="line">11) &quot;4&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试删除2个4，成功将前面两个4给删除了</span></span><br><span class="line">127.0.0.1:6379&gt; lrem k1 2 4</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange k1 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;4&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">5) &quot;6&quot;</span><br><span class="line">6) &quot;7&quot;</span><br><span class="line">7) &quot;4&quot;</span><br><span class="line">8) &quot;4&quot;</span><br><span class="line">9) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3><span id="llen">llen</span></h3><p>该指令用于获取 list 的长度</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><p>返回值：list 的⻓度</p><p>使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个长度为 4 的 list</span></span><br><span class="line">127.0.0.1:6379&gt; lpush k1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen k1</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看不存在的 list 的长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen k2</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个 非 list 的 k2</span></span><br><span class="line">127.0.0.1:6379&gt; hset k2 f1 v1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因类型不匹配报错</span></span><br><span class="line">127.0.0.1:6379&gt; llen k2</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><h2><span id="阻塞版本指令">阻塞版本指令</span></h2><h3><span id="redis-阻塞列表操作blpop-和-brpop">Redis 阻塞列表操作：BLPOP 和 BRPOP</span></h3><p><code>BLPOP</code> 和 <code>BRPOP</code> 是 <code>LPOP</code> 和 <code>RPOP</code> 的阻塞版本，它们的基本功能与非阻塞版本类似，但有以下关键区别：</p><h4><span id="主要特性">主要特性</span></h4><ol><li><p><strong>阻塞行为</strong>  </p><ul><li><strong>有元素时</strong>：行为与非阻塞版本一致。  </li><li><strong>无元素时</strong>：  <ul><li>非阻塞版本会立即返回 <code>nil</code>。  </li><li>阻塞版本会根据 <code>timeout</code> 参数阻塞一段时间（期间 Redis 可处理其他命令，但客户端表现为阻塞状态。</li></ul></li></ul></li><li><p><strong>多键操作</strong>  </p><ul><li>如果命令中设置了多个键，会按<strong>从左到右顺序遍历键列表</strong>，一旦某个键对应的列表可弹出元素，命令立即返回。</li></ul></li><li><p><strong>并发竞争</strong>  </p><ul><li>多个客户端同时对同一个键执行阻塞弹出操作时，<strong>最先执行命令的客户端</strong>会成功获取元素。</li></ul></li></ol><hr><h3><span id="1-时序图客户端与-redis-的交互过程">1. 时序图：客户端与 Redis 的交互过程</span></h3><h4><span id="场景1列表不为空时">场景1：列表不为空时</span></h4><pre class="mermaid">sequenceDiagram    participant Client    participant Redis    Note over Redis: user:1:messages = [x, z, y]    Client->>Redis: LPOP user:1:messages    Redis-->>Client: x    Client->>Redis: BLPOP user:1:messages 5    Redis-->>Client: x    Note left of Redis: 有元素时行为完全一致</pre><h4><span id="场景2空列表且无新元素5秒超时">场景2：空列表且无新元素（5秒超时）</span></h4><pre class="mermaid">sequenceDiagram    participant Client    participant Redis    Note over Redis: user:1:messages = []    Client->>Redis: LPOP user:1:messages    Redis-->>Client: nil (立即)    Client->>Redis: BLPOP user:1:messages 5    loop 5秒检查        Redis->>Redis: 检查列表    end    Redis-->>Client: nil (5秒后)    Note left of Redis: 无元素时LPOP立即返回，<br>BLPOP阻塞等待</pre><h4><span id="场景3空列表但5秒内加入新元素">场景3：空列表但5秒内加入新元素</span></h4><pre class="mermaid">sequenceDiagram    participant ClientA    participant ClientB    participant Redis    Note over Redis: user:1:messages = []    ClientA->>Redis: LPOP user:1:messages    Redis-->>ClientA: nil (立即)    par 并行事件        ClientA->>Redis: BLPOP user:1:messages 5    and        ClientB->>Redis: LPUSH user:1:messages x        Redis-->>ClientA: x (中断等待)    end    Note right of ClientB: BLPOP在等待期间<br>捕获到新元素</pre><hr><h3><span id="2-流程图操作逻辑对比">2. 流程图：操作逻辑对比</span></h3><pre class="mermaid">flowchart TD    A[开始] --> B{列表是否为空?}    B -- 否 --> C[LPOP/BLPOP弹出首元素]    B -- 是 --> D{操作类型}    D -- LPOP --> E[立即返回nil]    D -- BLPOP --> F[启动超时计时器]    F --> G{期间有新元素?}    G -- 是 --> H[立即返回新元素]    G -- 否 --> I[超时后返回nil]    style C fill:#d4edda,stroke:#28a745    style E fill:#f8d7da,stroke:#dc3545    style H fill:#d4edda,stroke:#28a745    style I fill:#fff3cd,stroke:#ffc107</pre><hr><h3><span id="关键结论">关键结论</span></h3><table><thead><tr><th>场景</th><th>LPOP (非阻塞)</th><th>BLPOP (阻塞)</th></tr></thead><tbody><tr><td>列表有元素</td><td>立即返回元素</td><td>立即返回元素</td></tr><tr><td>空列表且无新元素</td><td>立即返回<code>nil</code></td><td>阻塞至超时后返回<code>nil</code></td></tr><tr><td>空列表但新元素到达</td><td>需再次调用才获取</td><td>在等待期内直接捕获新元素</td></tr></tbody></table><p>下面只正对指令 blpop 进行讨论， brpop 同理</p><h3><span id="blpop-指令讲解">blpop 指令讲解</span></h3><p>blpop 指令可以同时阻塞等待多个 list，当某个 list 中有元素则会取出该 list 中的元素并停止阻塞</p><p>语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br></pre></td></tr></table></figure><p>使用示例：</p><p>场景1：等待一个 list</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端 1 阻塞等待一个 list 最多 100s</span></span><br><span class="line">127.0.0.1:6379&gt; blpop k1 100</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">(9.94s)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端 2 给 k1 头插元素 1</span></span><br><span class="line">127.0.0.1:6379&gt; lpush k1 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>场景2：等待多个 list</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端 1 阻塞等待多个 list 最多 100s</span></span><br><span class="line">127.0.0.1:6379&gt; blpop k1 k2 k3 k4 100</span><br><span class="line">1) &quot;k3&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">(5.52s)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端 2 给 k3 头插元素 1</span>  </span><br><span class="line">127.0.0.1:6379&gt; lpush k3 100</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h2><span id="list-相关指令汇总表">list 相关指令汇总表</span></h2><table><thead><tr><th>操作类型</th><th>命令</th><th>时间复杂度</th></tr></thead><tbody><tr><td>添加</td><td><code>rpush key value [value ...]</code></td><td>O(k)，k 是元素个数</td></tr><tr><td></td><td><code>lpush key value [value ...]</code></td><td>O(k)，k 是元素个数</td></tr><tr><td></td><td><code>linsert key before|after pivot value</code></td><td>O(n)，n 是 pivot 距离头尾的距离</td></tr><tr><td>查找</td><td><code>lrange key start end</code></td><td>O(s+n)，s 是 start 偏移量，n 是范围</td></tr><tr><td></td><td><code>lindex key index</code></td><td>O(n)，n 是索引的偏移量</td></tr><tr><td></td><td><code>llen key</code></td><td>O(1)</td></tr><tr><td>删除</td><td><code>lpop key</code></td><td>O(1)</td></tr><tr><td></td><td><code>rpop key</code></td><td>O(1)</td></tr><tr><td></td><td><code>lrem key count value</code></td><td>O(k)，k 是元素个数</td></tr><tr><td></td><td><code>ltrim key start end</code></td><td>O(k)，k 是元素个数</td></tr><tr><td>修改</td><td><code>lset key index value</code></td><td>O(n)，n 是索引的偏移量</td></tr><tr><td>阻塞操作</td><td><code>blpop</code> <code>brpop</code></td><td>O(1)</td></tr></tbody></table><h2><span id="内部编码">内部编码</span></h2><h3><span id="redis-列表类型的内部编码实现">Redis 列表类型的内部编码实现</span></h3><p>Redis 列表类型的内部编码有两种，根据元素数量和大小自动选择：</p><h4><span id="内部编码类型">内部编码类型</span></h4><ul><li><p><strong>ziplist (压缩列表)</strong>：</p><ul><li><strong>触发条件</strong>：<ul><li>元素个数 &lt; <code>list-max-ziplist-entries</code> (默认 512)</li><li>每个元素长度 &lt; <code>list-max-ziplist-value</code> (默认 64 字节)</li></ul></li><li><strong>优点</strong>：内存连续存储，减少内存碎片</li></ul></li><li><p><strong>linkedlist (链表)</strong>：</p><ul><li><strong>触发条件</strong>：不满足 ziplist 的任一条件时</li><li><strong>特点</strong>：双向链表实现，适合存储大量或大元素数据</li></ul></li></ul><h4><span id="配置参数">配置参数</span></h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis.conf 配置示例</span></span><br><span class="line">list-max-ziplist-entries 512  <span class="comment"># 最大元素个数阈值</span></span><br><span class="line">list-max-ziplist-value 64     <span class="comment"># 单个元素最大字节阈值</span></span><br></pre></td></tr></table></figure><h4><span id="示例演示">示例演示</span></h4><h5><span id="1-使用-ziplist-编码满足两个条件">1. 使用 ziplist 编码（满足两个条件）</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; RPUSH listkey e1 e2 e3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING listkey</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure><h5><span id="2-元素数量超限转为-linkedlist">2. 元素数量超限转为 linkedlist</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; RPUSH listkey e1 e2 ... e512 e513  # 插入513个元素</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING listkey</span><br><span class="line">&quot;linkedlist&quot;</span><br></pre></td></tr></table></figure><h5><span id="3-元素大小超限转为-linkedlist">3. 元素大小超限转为 linkedlist</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; RPUSH listkey &quot;超过64字节的长字符串XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING listkey</span><br><span class="line">&quot;linkedlist&quot;</span><br></pre></td></tr></table></figure><h4><span id="性能建议">性能建议</span></h4><ol><li>需要大量小元素存储时 → 保持默认 ziplist 配置</li><li>需要存储大元素时 → 适当调大 <code>list-max-ziplist-value</code></li><li>元素数量波动大时 → 可调整 <code>list-max-ziplist-entries</code></li></ol><h2><span id="典型业务场景">典型业务场景</span></h2><h3><span id="缓存功能">缓存功能</span></h3><p>下面以学生列表为例展开说明：</p><h4><span id="数据结构设计">数据结构设计</span></h4><p>使用 Redis List 存储班级学生信息，每个班级对应一个 List，学生ID&#x2F;姓名作为元素：</p><pre class="mermaid">flowchart LR    classList["班级列表"] --> class1["class:1:students"]    classList --> class2["class:2:students"]    class1 -->|"元素"| stu1["stu_001"]    class1 -->|"元素"| stu2["stu_002"]    class1 -->|"..."| stun["stu_999"]</pre><h4><span id="核心操作命令">核心操作命令</span></h4><h5><span id="1-初始化班级学生列表">1. 初始化班级学生列表</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加学生到班级1（尾部插入）</span></span><br><span class="line">RPUSH class:1:students stu_001 stu_002 stu_003</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加学生到班级2（头部插入）</span></span><br><span class="line">LPUSH class:2:students stu_101 stu_102</span><br></pre></td></tr></table></figure><h5><span id="2-查询学生列表">2. 查询学生列表</span></h5><pre class="mermaid">sequenceDiagram    participant Client    participant Redis    Client->>Redis: LRANGE class:1:students 0 -1    Redis-->>Client: ["stu_001", "stu_002", "stu_003"]</pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取班级1全部学生（0表示起始索引，-1表示末尾）</span></span><br><span class="line">LRANGE class:1:students 0 -1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取前5名学生</span></span><br><span class="line">LRANGE class:1:students 0 4</span><br></pre></td></tr></table></figure><h5><span id="3-学生变动操作">3. 学生变动操作</span></h5><pre class="mermaid">gantt    title 学生名单变更流程    dateFormat  YYYY-MM-DD    section 班级1    新生入学      :2023-09-01, 1d    学生转出      :2023-09-05, 1d</pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">学生转入（尾部添加）</span></span><br><span class="line">RPUSH class:1:students stu_004</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">学生转出（头部移除）</span></span><br><span class="line">LPOP class:1:students</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定学生</span></span><br><span class="line">LREM class:1:students 1 stu_002</span><br></pre></td></tr></table></figure><h4><span id="性能优化建议">性能优化建议</span></h4><table><thead><tr><th>场景</th><th>优化方案</th><th>命令示例</th></tr></thead><tbody><tr><td>高频新增</td><td>使用 Pipeline 批量操作</td><td><code>RPUSH + MULTI/EXEC</code></td></tr><tr><td>大规模名单查询</td><td>分页获取</td><td><code>LRANGE class:1 0 49</code></td></tr><tr><td>需要保证顺序</td><td>配合 SORT 命令</td><td><code>SORT class:1 ALPHA</code></td></tr><tr><td>防止重复</td><td>结合 SET 去重</td><td><code>SADD class:1:set stu_001</code></td></tr></tbody></table><h4><span id="完整示例流程">完整示例流程</span></h4><pre class="mermaid">sequenceDiagram    participant Teacher    participant Redis    Note over Teacher: 新学期开始    Teacher->>Redis: RPUSH class:2023:students Alice Bob Charlie    Redis-->>Teacher: (integer) 3    Teacher->>Redis: LRANGE class:2023:students 0 -1    Redis-->>Teacher: 1) "Alice" 2) "Bob" 3) "Charlie"    Note over Teacher: 学生David转入    Teacher->>Redis: RPUSH class:2023:students David    Redis-->>Teacher: (integer) 4    Note over Teacher: 学生Bob转出    Teacher->>Redis: LREM class:2023:students 1 Bob    Redis-->>Teacher: (integer) 1</pre><h4><span id="注意事项">注意事项</span></h4><ol><li>当学生数量 &gt; 512 或名字长度 &gt; 64字节时，Redis 会自动将 ziplist 转为 linkedlist</li><li>重要数据建议持久化：<code>BGSAVE</code></li><li>可配合 Hash 存储学生详细信息：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET student:stu_001 name &quot;Alice&quot; age 12 gender F</span><br></pre></td></tr></table></figure><h3><span id="消息队列">消息队列</span></h3><h4><span id="1-基础阻塞消息队列模型">1. 基础阻塞消息队列模型</span></h4><pre class="mermaid">sequenceDiagram    participant Producer    participant Redis as Redis Server    participant Consumer1    participant Consumer2    participant Consumer3    Note over Producer: 生产者客户端    Note over Consumer1,Consumer3: 消费者客户端集群        Producer->>Redis: LPUSH queue_msg "消息1"    loop BRPOP 阻塞等待        Consumer1->>Redis: BRPOP queue_msg 30        Consumer2->>Redis: BRPOP queue_msg 30        Consumer3->>Redis: BRPOP queue_msg 30    end    Redis-->>Consumer2: 返回"消息1" (只有一个消费者抢到)</pre><p><strong>实现方式</strong>：</p><ul><li>生产者：<code>LPUSH key element [element...]</code>  </li><li>消费者：<code>BRPOP key [key...] timeout</code>  </li><li><strong>特点</strong>：<ul><li>自动阻塞等待</li><li>多消费者负载均衡</li><li>保证消息不重复消费</li></ul></li></ul><h4><span id="2-分频道消息队列模型">2. 分频道消息队列模型</span></h4><pre class="mermaid">flowchart TB    subgraph Redis服务器        queue1[(queue:1)]        queue2[(queue:2)]        queue3[(queue:3)]    end    Producer -->|LPUSH queue:1| queue1    Producer -->|LPUSH queue:2| queue2    Producer -->|LPUSH queue:3| queue3    queue1 --> ConsumerA(ConsumerA:<br>BRPOP queue:1)    queue1 --> ConsumerB(ConsumerB:<br>BRPOP queue:1)    queue1 --> ConsumerC(ConsumerC:<br>BRPOP queue:1,queue:2)    queue2 --> ConsumerC    queue2 --> ConsumerD(ConsumerD:<br>BRPOP queue:2,queue:3)    queue3 --> ConsumerD</pre><p><strong>频道订阅模式</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生产者发布消息到不同频道</span></span><br><span class="line">LPUSH channel:news &quot;最新消息&quot;</span><br><span class="line">LPUSH channel:alert &quot;系统警报&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">消费者订阅不同组合：</span></span><br><span class="line">BRPOP channel:news 30      # 只订阅新闻频道</span><br><span class="line">BRPOP channel:news channel:alert 30  # 多频道监听</span><br></pre></td></tr></table></figure><h4><span id="两种模型对比">两种模型对比</span></h4><table><thead><tr><th>特性</th><th>基础模型</th><th>分频道模型</th></tr></thead><tbody><tr><td>消息类型</td><td>单一类型</td><td>多频道分类</td></tr><tr><td>消费者竞争范围</td><td>全局竞争</td><td>频道内竞争</td></tr><tr><td>命令示例</td><td><code>BRPOP queue 30</code></td><td><code>BRPOP chan1 chan2 30</code></td></tr><tr><td>适用场景</td><td>单一业务流</td><td>多业务分类处理</td></tr><tr><td>吞吐量</td><td>所有消费者共享</td><td>分频道并行处理</td></tr></tbody></table><h3><span id="redis-实现微博-timeline-方案">Redis 实现微博 Timeline 方案</span></h3><h4><span id="数据结构设计">数据结构设计</span></h4><pre class="mermaid">flowchart LR    user1["user:1:mblogs"] --> mblog1["mblog:1"]    user1 --> mblog3["mblog:3"]    userk["user:k:mblogs"] --> mblog9["mblog:9"]        mblog1 -->|HASH| content1["title: xx\ntimestamp: 1476536196\ncontent: xxxxx"]    mblog3 -->|HASH| content3["title: yy\ntimestamp: 1476536197\ncontent: yyyyy"]    mblog9 -->|HASH| content9["title: zz\ntimestamp: 1476536198\ncontent: zzzzz"]</pre><h4><span id="核心操作实现">核心操作实现</span></h4><h5><span id="1-微博存储hash结构">1. 微博存储（Hash结构）</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 存储单篇微博</span><br><span class="line">HMSET mblog:1 title &quot;Redis实战&quot; timestamp 1476536196 content &quot;使用List实现Timeline...&quot;</span><br><span class="line"></span><br><span class="line"># 批量存储示例</span><br><span class="line">MULTI</span><br><span class="line">HMSET mblog:2 title &quot;Redis优化&quot; timestamp 1476536197 content &quot;Pipeline使用技巧&quot;</span><br><span class="line">HMSET mblog:3 title &quot;Mermaid教程&quot; timestamp 1476536198 content &quot;图表绘制指南&quot;</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><h5><span id="2-timeline更新list操作">2. Timeline更新（List操作）</span></h5><pre class="mermaid">sequenceDiagram    participant 客户端    participant Redis    客户端->>Redis: LPUSH user:1:mblogs mblog:1 mblog:3    Redis-->>客户端: (integer) 2    客户端->>Redis: LPUSH user:1:mblogs mblog:9    Redis-->>客户端: (integer) 3</pre><h5><span id="3-分页查询方案">3. 分页查询方案</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 获取第一页（10条）</span><br><span class="line">LRANGE user:1:mblogs 0 9</span><br><span class="line">--&gt; [&quot;mblog:9&quot;, &quot;mblog:3&quot;, &quot;mblog:1&quot;, ...]</span><br><span class="line"></span><br><span class="line"># 配合Pipeline获取详情</span><br><span class="line">MULTI</span><br><span class="line">HGETALL mblog:9</span><br><span class="line">HGETALL mblog:3</span><br><span class="line">HGETALL mblog:1</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><h4><span id="性能优化方案">性能优化方案</span></h4><h5><span id="问题11n-查询问题">问题1：1+N 查询问题</span></h5><table><thead><tr><th>方案</th><th>实现方式</th><th>优缺点对比</th></tr></thead><tbody><tr><td>Pipeline批量查询</td><td><code>MULTI</code> + <code>HGETALL</code> + <code>EXEC</code></td><td>减少网络往返，但代码复杂度增加</td></tr><tr><td>字符串序列化存储</td><td><code>SET</code> + <code>MGET</code></td><td>读取高效，但更新灵活性降低</td></tr></tbody></table><h5><span id="问题2中间元素访问性能">问题2：中间元素访问性能</span></h5><pre class="mermaid">flowchart TB    subgraph 大列表拆分方案        original["user:1:mblogs (超大列表)"]        split1["user:1:mblogs:part1"]        split2["user:1:mblogs:part2"]        split3["user:1:mblogs:part3"]    end</pre><p><strong>拆分策略</strong>：</p><ol><li><p>按时间分片：<code>user:&lt;uid&gt;:mblogs:&lt;year-month&gt;</code></p></li><li><p>按数量分片：每1000条微博一个子列表</p></li></ol><h4><span id="数据结构选型建议">数据结构选型建议</span></h4><table><thead><tr><th>操作模式</th><th>命令组合</th><th>适用场景</th></tr></thead><tbody><tr><td>栈模式</td><td><code>LPUSH</code> + <code>LPOP</code></td><td>最新微博优先展示</td></tr><tr><td>队列模式</td><td><code>LPUSH</code> + <code>RPOP</code></td><td>时间线严格按序展示</td></tr><tr><td>双向存取</td><td><code>LPUSH</code> + <code>BRPOP</code></td><td>消息队列场景</td></tr></tbody></table><h4><span id="生产环境注意事项">生产环境注意事项</span></h4><ol><li><strong>内存控制</strong>：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限制单个用户Timeline长度</span></span><br><span class="line">LTRIM user:1:mblogs 0 999</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>性能监控</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --latency -h 127.0.0.1</span><br><span class="line">INFO memory</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>异常处理</strong>：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_timeline_page</span>(<span class="params">uid, page, size=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start = (page-<span class="number">1</span>)*size</span><br><span class="line">        keys = redis.lrange(<span class="string">f&quot;user:<span class="subst">&#123;uid&#125;</span>:mblogs&quot;</span>, start, start+size-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> redis.pipeline().hgetall(*keys).execute()</span><br><span class="line">    <span class="keyword">except</span> RedisError <span class="keyword">as</span> e:</span><br><span class="line">        log_error(<span class="string">f&quot;Timeline query failed: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 键值对 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常见数据类型-Hash 类型</title>
      <link href="/2025/07/08/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Hash/"/>
      <url>/2025/07/08/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Hash/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B">类型简介</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">相关指令</a><ul><li><a href="#1-hset-%E6%8C%87%E4%BB%A4">1、hset 指令</a></li><li><a href="#2-hget-%E6%8C%87%E4%BB%A4">2、hget 指令</a></li><li><a href="#3-hexists">3、hexists</a></li><li><a href="#4-hdel">4、hdel</a></li><li><a href="#5-hkeys-hvals-hgetall">5、hkeys、hvals、hgetall</a></li><li><a href="#6-hmget">6、hmget</a></li><li><a href="#7-hlen">7、hlen</a></li><li><a href="#8-hsetnx">8、hsetnx</a></li><li><a href="#9-hincrby-hincrbyfloat">9、hincrby、hincrbyfloat</a></li></ul></li><li><a href="#hash-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB%E8%A1%A8">hash 相关指令汇总表</a></li><li><a href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81">内部编码</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%BC%93%E5%AD%98">使用场景：缓存</a></li><li><a href="#%E4%B8%8D%E5%90%8C%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83">不同缓存方式之间的比较</a><ul><li><a href="#%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%AF%8F%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%80%E4%B8%AA%E9%94%AE">原生字符串类型⸺使⽤字符串类型，每个属性⼀个键</a></li><li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E4%BE%8B%E5%A6%82-json-%E6%A0%BC%E5%BC%8F">序列化字符串类型，例如 JSON 格式</a></li><li><a href="#%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B">哈希类型</a></li></ul></li></ul><!-- tocstop --><h2><span id="类型简介">类型简介</span></h2><p>⼏乎所有的主流编程语⾔都提供了哈希（hash）类型，它们的叫法可能是哈希、字典、关联数组、映射。在 Redis 中，哈希类型是指值本⾝<br>⼜是⼀个键值对结构，形如 key &#x3D; “key”，value &#x3D; { {field1, value1 }, …, {fieldN, valueN } }，Redis 键值对和哈希类型⼆<br>者的关系可以⽤下面这张图来表⽰</p><pre class="mermaid">flowchart TD    subgraph String_Storage        A[key: user:1:name] --> B[value: James]        C[key: user:1:age] --> D[value: 28]    end    subgraph Hash_Storage        E[key: user:1] --> F[field: name]        F --> G[value: James]        E --> H[field: age]        H --> I[value: 28]    end</pre><h2><span id="相关指令">相关指令</span></h2><p>不同于以往的 set 和 get，Hash 会采用专门的指令来设置 Hash 或获取 Hash 中特定 field 所对应的 value</p><h3><span id="1-hset-指令">1、hset 指令</span></h3><p>语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value [field value ...]</span><br></pre></td></tr></table></figure><p>和 String 类型一样，利用该命令可同时生成多组键值对（field-value），其中返回值对应的是成功添加的字段的个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成含有一个键值对的 <span class="built_in">hash</span> 数据</span></span><br><span class="line">127.0.0.1:6379&gt; hset k1 f1 v1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成含有多个键值对的 <span class="built_in">hash</span> 数据</span></span><br><span class="line">127.0.0.1:6379&gt; hset k2 f1 v1 f2 v2 f3 v3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h3><span id="2-hget-指令">2、hget 指令</span></h3><p>该指令用于获取 hash 中指定字段的值</p><p>语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></table></figure><p>返回值：若字段存在则返回字段所对应的值，否则返回 nil</p><p>使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 k1 中 f1 所对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; hget k1 f1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询不存在的值（返回nil）</span></span><br><span class="line">127.0.0.1:6379&gt; hget k1 f2</span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 k2 中 f3 所对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; hget k2 f3</span><br><span class="line">&quot;v3&quot;</span><br></pre></td></tr></table></figure><h3><span id="3-hexists">3、hexists</span></h3><p>该指令用于判断 hash 中某个字段是否存在</p><p>语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p>返回值：1 表示存在，0 表示不存在</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists k1 f1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists k1 f2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3><span id="4-hdel">4、hdel</span></h3><p>该指令用于删除 hash 中某个字段</p><p>返回值：本次操作删除的字段个数</p><p>语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure><p>若一个 hash 值中的所有字段都被删除了，那么其 hash 也会被删除</p><p>使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个字段</span></span><br><span class="line">127.0.0.1:6379&gt; hdel k2 f2</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除两个字段，因为 f2 字段刚刚已经被删掉了</span></span><br><span class="line">127.0.0.1:6379&gt; hdel k2 f1 f2 f3</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k2 已经被删除</span></span><br><span class="line">127.0.0.1:6379&gt; exists k2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>注意：不要混淆 exists 和 hexists 以及 del 和 hdel，前者是用来操作 key 值的，而后者是用来操作 key 中指定字段的</strong><br>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">之前的 k2 已经被删除，直接生成一个字符串类型 k2</span></span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exists 和 del 不管用户给的是什么数据类型，直接操控和访问的是 key</span></span><br><span class="line">127.0.0.1:6379&gt; exists k1 k2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; del k1 k2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3><span id="5-hkeys-hvals-hgetall">5、hkeys、hvals、hgetall</span></h3><ul><li>hkeys 用于查询指定的 hash 中的所有字段</li><li>hvals 用于查询指定的 hash 中的所有字段所对应的值</li><li>hgetall 综合了 hkeys 和 hvals 两者，返回指定的 hash 中的所有字段及字段所对应的值</li></ul><p>格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hkeys</span></span><br><span class="line">HKEYS key</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hvals</span></span><br><span class="line">HVALS key</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hgetall</span></span><br><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset key f1 v1 f2 v2 f3 v3</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hkeys</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys key</span><br><span class="line">1) &quot;f1&quot;</span><br><span class="line">2) &quot;f2&quot;</span><br><span class="line">3) &quot;f3&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hvals</span></span><br><span class="line">127.0.0.1:6379&gt; hvals key</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hgetall</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall key</span><br><span class="line">1) &quot;f1&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;f2&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;f3&quot;</span><br><span class="line">6) &quot;v3&quot;</span><br></pre></td></tr></table></figure><h3><span id="6-hmget">6、hmget</span></h3><p>相较于 hget，该指令可以一次获取多个值</p><p>格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure><p>用法和 hget 类似，下面是使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">书接上回</span></span><br><span class="line">127.0.0.1:6379&gt; hmget key f1 f2 f3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br></pre></td></tr></table></figure><h3><span id="7-hlen">7、hlen</span></h3><p>顾名思义，这个命令是用来获取 hash 中字段个数的，格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">书接上回</span></span><br><span class="line">127.0.0.1:6379&gt; hlen key</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h3><span id="8-hsetnx">8、hsetnx</span></h3><p>该命令用于在字段不存在的情况下，设置 hash 中的字段和值,格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></table></figure><p>返回值：1 表示成功，0 表示失败</p><p>用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成功</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx k1 f1 v1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成功</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx k1 f2 v2</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">失败</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx k1 f2 v2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3><span id="9-hincrby-hincrbyfloat">9、hincrby、hincrbyfloat</span></h3><p>hincrby 用于整数进行加减运算，而 hincrbyfloat 用于浮点数运算</p><p>返回值：计算之后的结果</p><p>格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hincrby</span></span><br><span class="line">HINCRBY key field increment</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hincrbyfloat</span></span><br><span class="line">HINCRBYFLOAT key field increment</span><br></pre></td></tr></table></figure><p>需要注意的是，hincrby 操作时 value 必须是 int 类型，但若通过 hincrbyfloat 对 int 类型进行操作后，<br>即便操作的是整数的加减，也会导致 value 变成非 int 类型</p><p>使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset k1 f1 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby k1 f1 6</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat k1 f1 6</span><br><span class="line">&quot;17&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat k1 f1 6.5</span><br><span class="line">&quot;23.5&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat k1 f1 3.3</span><br><span class="line">&quot;26.8&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat k1 f1 -4.4</span><br><span class="line">&quot;22.4&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">value 已不再是 int 类型，无法使用 hincrby 进行操作</span></span><br><span class="line">127.0.0.1:6379&gt; hincrby k1 f1 -6</span><br><span class="line">(error) ERR hash value is not an integer</span><br></pre></td></tr></table></figure><h2><span id="hash-相关指令汇总表">hash 相关指令汇总表</span></h2><table><thead><tr><th>命令</th><th>执行效果</th><th>时间复杂度</th></tr></thead><tbody><tr><td>hset key field value</td><td>设置值</td><td>O(1)</td></tr><tr><td>hget key field</td><td>获取值</td><td>O(1)</td></tr><tr><td>hdel key field [field …]</td><td>删除 field</td><td>O(k), k 是 field 个数</td></tr><tr><td>hlen key</td><td>计算 field 个数</td><td>O(1)</td></tr><tr><td>hgetall key</td><td>获取所有的 field-value</td><td>O(k), k 是 field 个数</td></tr><tr><td>hmget field [field …]</td><td>批量获取 field-value</td><td>O(k), k 是 field 个数</td></tr><tr><td>hmset field value [field …]</td><td>批量设置 field-value</td><td>O(k), k 是 field 个数</td></tr><tr><td>hexists key field</td><td>判断 field 是否存在</td><td>O(1)</td></tr><tr><td>hkeys key</td><td>获取所有的 field</td><td>O(k), k 是 field 个数</td></tr><tr><td>hvals key</td><td>获取所有的 value</td><td>O(k), k 是 field 个数</td></tr><tr><td>hsetnx key field value</td><td>设置值，但必须在 field 不存在时才能设置成功</td><td>O(1)</td></tr><tr><td>hincrby key field n</td><td>对应 field-value +n</td><td>O(1)</td></tr><tr><td>hincrbyfloat key field n</td><td>对应 field-value +n</td><td>O(1)</td></tr><tr><td>hstrlen key field</td><td>计算 value 的字符串长度</td><td>O(1)</td></tr></tbody></table><h2><span id="内部编码">内部编码</span></h2><p>哈希的内部编码有两种：</p><ul><li><p>ziplist（压缩列表）：当哈希类型元素个数⼩于 hash-max-ziplist-entries 配置（默认 512 个）、同时所有值都<br>⼩于 hash-max-ziplist-value 配置（默认 64 字节）时，Redis 会使⽤ ziplist 作为哈希的内部实现，ziplist 使<br>⽤更加紧凑的结构实现多个元素的连续存储，所以在节省内存⽅⾯⽐ hashtable 更加优秀。</p></li><li><p>hashtable（哈希表）：当哈希类型⽆法满⾜ ziplist 的条件时，Redis 会使⽤ hashtable 作为哈希<br>的内部实现，因为此时 ziplist 的读写效率会下降，⽽ hashtable 的读写时间复杂度为 O(1)。</p></li></ul><p>若哈希中字段数量过多或者 value 过长都会使得存储方式变为 hashtable，而具体数值是可以在 conf 文件中被配置的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="line"># threshold. These thresholds can be configured using the following directives.</span><br><span class="line">hash-max-listpack-entries 512</span><br><span class="line">hash-max-listpack-value 64</span><br></pre></td></tr></table></figure><p>下面是不同长度的 value 存储方式的区别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset k1 f1 v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING k1</span><br><span class="line">&quot;listpack&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset k1 f2 vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv22222222222222222222222222222222222222222222222222222222</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">value 太长，类型变为 hashtable</span></span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING k1</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><h2><span id="使用场景缓存">使用场景：缓存</span></h2><p>在关系型数据库当中，数据的存储是必须争对每一列属性都有对应的值的，而通过哈希表的方式存储，可以按需插入数据，且看起来更加直观，并且<br>更新起数据更加灵活。</p><p>二者各有各的好处，若使用关系型数据库进行数据的存储，虽然会消耗更多的空间，但相对于着可以进行更多复杂的操作，若使用哈希进行数据的操作，<br>操作可行性更低（能做的操作更加有限），当然，好处就是哈希所消耗的空间更少。因此，具体使用哪种方式得根据具体实际去讨论。当然，这两者并<br>不冲突，因为哈希是用作缓存的，而关系型数据库是直接用于存储的，很多时候是两者相结合着一起使用，对于复杂的表操作固然选择使用关系型数据库<br>进行操作，而对于一些简单数据操作，则选择直接对缓存进行操作，因此，我们对这两者的比较并不是为了分出胜负来，因为我们正是因为它们各有优劣<br>才选择将两者结合起来使用的，不要忘了我们的初衷，Redis 更多是为了帮助忙不过来的关系型数据库服务的。</p><p>关系型数据表保存用户信息：</p><table><thead><tr><th>uid</th><th>name</th><th>age</th><th>city</th></tr></thead><tbody><tr><td>1</td><td>James</td><td>28</td><td>Beijing</td></tr><tr><td>2</td><td>Johnathan</td><td>30</td><td>Xian</td></tr></tbody></table><p>映射关系表示用户信息</p><table><thead><tr><th>key</th><th>field</th><th>value</th></tr></thead><tbody><tr><td>user:1</td><td>uid</td><td>1</td></tr><tr><td></td><td>name</td><td>James</td></tr><tr><td></td><td>age</td><td>28</td></tr><tr><td></td><td>city</td><td>Beijing</td></tr><tr><td>user:2</td><td>uid</td><td>2</td></tr><tr><td></td><td>name</td><td>Johnathan</td></tr><tr><td></td><td>age</td><td>30</td></tr><tr><td></td><td>city</td><td>Xian</td></tr></tbody></table><h2><span id="不同缓存方式之间的比较">不同缓存方式之间的比较</span></h2><p>下面我们需要讨论三种不同的缓存方式：</p><h3><span id="原生字符串类型使用字符串类型每个属性一个键">原生字符串类型⸺使⽤字符串类型，每个属性⼀个键</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name James</span><br><span class="line">set user:1:age 23</span><br><span class="line">set user:1:city Beijing</span><br></pre></td></tr></table></figure><p>优点：实现简单，针对个别属性变更也很灵活。<br>缺点：占⽤过多的键，内存占⽤量较⼤，同时⽤⼾信息在 Redis 中⽐较分散，缺少内聚性，所以这种<br>⽅案基本没有实⽤性。</p><h3><span id="序列化字符串类型例如-json-格式">序列化字符串类型，例如 JSON 格式</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:1 经过序列化后的⽤⼾对象字符串</span><br></pre></td></tr></table></figure><p>优点：针对总是以整体作为操作的信息⽐较合适，编程也简单。同时，如果序列化⽅案选择合适，内<br>存的使⽤效率很⾼。<br>缺点：本⾝序列化和反序列需要⼀定开销，同时如果总是操作个别属性则⾮常不灵活。</p><h3><span id="哈希类型">哈希类型</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name James age 23 city Beijin</span><br></pre></td></tr></table></figure><p>优点：简单、直观、灵活。尤其是针对信息的局部变更或者获取操作。<br>缺点：需要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，可能会造成内存的较⼤消耗。</p><p>相⽐于使⽤ JSON 格式的字符串缓存⽤⼾信息，哈希类型变得更加直观，并且在更新操作上变得更灵活。可以将每个⽤⼾的 id 定义<br>为键后缀，多对 field-value 对应⽤⼾的各个属性，类似如下伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户ID获取用户信息（缓存优先）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uid 用户ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户信息对象，未找到时返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UserInfo <span class="title function_">getUserInfo</span><span class="params">(<span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 构建Redis键</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:&quot;</span> + uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试从Redis获取缓存数据</span></span><br><span class="line">    Map&lt;String, String&gt; userInfoMap = Redis执行命令：hgetall key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 缓存命中处理</span></span><br><span class="line">    <span class="keyword">if</span> (userInfoMap != <span class="literal">null</span> &amp;&amp; !userInfoMap.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将Redis哈希数据转换为UserInfo对象</span></span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> 利用映射关系构建对象(userInfoMap);</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 缓存未命中，查询数据库</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> MySQL执行SQL：select * from user_info <span class="type">where</span> <span class="variable">uid</span> <span class="operator">=</span> &lt;uid&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 处理未找到用户的情况</span></span><br><span class="line">    <span class="keyword">if</span> (userInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录日志或响应404</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 写入Redis缓存</span></span><br><span class="line">    Redis执行命令：hmset key </span><br><span class="line">        name userInfo.name </span><br><span class="line">        age userInfo.age </span><br><span class="line">        city userInfo.city;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 设置缓存过期时间（1小时）</span></span><br><span class="line">    Redis执行命令：expire key <span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 返回用户信息</span></span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 键值对 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常见数据类型-String 类型</title>
      <link href="/2025/07/07/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/"/>
      <url>/2025/07/07/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B">类型简介</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">相关指令</a><ul><li><a href="#1-setex-%E6%8C%87%E4%BB%A4">1、setex 指令</a></li><li><a href="#2-psetex-%E6%8C%87%E4%BB%A4">2、psetex 指令</a></li><li><a href="#3-setnx-%E6%8C%87%E4%BB%A4">3、setnx 指令</a></li><li><a href="#4-incr-%E5%8F%8A-incrby-%E6%8C%87%E4%BB%A4">4、incr 及 incrby 指令</a></li><li><a href="#5-decr-%E5%8F%8A-decrby-%E6%8C%87%E4%BB%A4">5、decr 及 decrby 指令</a></li><li><a href="#6-append-%E6%8C%87%E4%BB%A4">6、append 指令</a></li><li><a href="#7-getrange-%E6%8C%87%E4%BB%A4">7、getrange 指令</a></li><li><a href="#8-setrange-%E6%8C%87%E4%BB%A4">8、setrange 指令</a></li><li><a href="#9-strlen-%E6%8C%87%E4%BB%A4">9、strlen 指令</a></li></ul></li><li><a href="#string-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB%E8%A1%A8">String 相关指令汇总表</a><ul><li><a href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99">内部编码规则</a></li></ul></li><li><a href="#%E5%85%B8%E5%9E%8B%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF">典型业务场景</a><ul><li><a href="#%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD">缓存功能</a></li><li><a href="#%E8%AE%A1%E6%95%B0%E5%8A%9F%E8%83%BD">计数功能</a></li><li><a href="#%E4%BC%9A%E8%AF%9D%E5%8A%9F%E8%83%BD">会话功能</a></li><li><a href="#%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81">手机验证码</a></li></ul></li></ul><!-- tocstop --><h2><span id="类型简介">类型简介</span></h2><p>不同于 cpp 里面的 String，Redis 中的 String 更像是一种比特数组，也就是说，Redis 中的 String 是直接将用户输入的数据按照比特的方式存放到数组中的，<br>在 Redis 中，这些比特的编码方式不会像 MySQL 那样存在所谓的编码转化，用户在写入数据时使用的是哪种编码方式，在 Redis 中同样也会采用对应的编码方式，从而<br>避免了频繁的编码方式转化所带来的不必要的开销</p><h2><span id="相关指令">相关指令</span></h2><p>针对 String， 有着专门的设置和查询指令，即 set 和 get，首先我们都知道，Redis 中的 key 都是 String 类型的，而通过 set 命令可以设置一个 key 所对应的 String 类型<br>的 value 值，通过 get 也可以查询到 String 类型的 value，因此，若通过 get 命令查询一个类型不是 String 的value，就会报错，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush k2 11 22 33</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>当然，除此之外，还有一些专门针对 String 类型的便捷指令：</p><h3><span id="1-setex-指令">1、setex 指令</span></h3><p>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br></pre></td></tr></table></figure><p>该指令其实可以直接通过 set 指令直接实现，但通过 setex 实现会更加简洁便利，下面是两个代码的对比：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 123 ex 5</span><br><span class="line">127.0.0.1:6379&gt; setex key1 5 123</span><br></pre></td></tr></table></figure><p>使用 setex 命令可以避免写 ex 来表示附加过期时间设置，而且这种命令看起来非常直白，一看就能知道这个命令的用法是什么</p><h3><span id="2-psetex-指令">2、psetex 指令</span></h3><p>与之对应的就是 psetex，没错，相信你看到这个命令就已经知道这个命令是用来干什么的了，这不就多了一个 p 嘛，那这个指令肯定就是以 ms 为单位来设置过期时间的了</p><h3><span id="3-setnx-指令">3、setnx 指令</span></h3><p>该指令是用来设置不存在的键值对的，存在的键值是无法修改的，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure><p>具体例子如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx key1 value1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3><span id="4-incr-及-incrby-指令">4、incr 及 incrby 指令</span></h3><p>String 类型若存放一个64位以内的整数，这个数就会在底层被以 int 类型存储，而这时就可以通过 incr 指令来对某个数进行加一操作了，同样的，通过incrby就可以给一个数<br>加上一个特定的值，当然也可以是一个负数，同时，它们两者可以对一个不存在的键值对进行操作，会将这个值设定为0，语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">incrby key increment</span><br></pre></td></tr></table></figure><p>下面是使用举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置一个已经存在的 key 值 key1</span></span><br><span class="line">127.0.0.1:6379&gt; set key1 1</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让 key1 自增</span> </span><br><span class="line">127.0.0.1:6379&gt; incr key1</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让不存在的 key2 自增</span></span><br><span class="line">127.0.0.1:6379&gt; incr key2</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对存在的 key1 加10</span></span><br><span class="line">127.0.0.1:6379&gt; incrby key1 10</span><br><span class="line">(integer) 12</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对不存在的 key3 加20</span></span><br><span class="line">127.0.0.1:6379&gt; incrby key3 20</span><br><span class="line">(integer) 20</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对 key3 加-10（减10）</span></span><br><span class="line">127.0.0.1:6379&gt; incrby key3 -10</span><br><span class="line">(integer) 10</span><br></pre></td></tr></table></figure><h3><span id="5-decr-及-decrby-指令">5、decr 及 decrby 指令</span></h3><p>这个指令用法和 incr、incrby 完全一致，你们可能会疑惑，incr 和 incrby 已经可以处理减法操作了，那为啥还要有减法指令呢？道理很简单，假如说<br>你去银行取100块钱，银行跟你说已存钱-100块，你听着舒服吗，这样设计是为了让命令用起来更加人性化，当然，decr一类指令也可以通过减负数来实现<br>加法运算，下面是使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decr key1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; decr key2</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; decrby key1 10</span><br><span class="line">(integer) -10</span><br><span class="line">127.0.0.1:6379&gt; decrby key3 20</span><br><span class="line">(integer) -20</span><br><span class="line">127.0.0.1:6379&gt; decrby key3 -10</span><br><span class="line">(integer) -10</span><br></pre></td></tr></table></figure><h3><span id="6-append-指令">6、append 指令</span></h3><p>如果 key 已经存在并且是⼀个 string，命令会将 value 追加到原有 string 的后边。如果 key 不存在，则效果等同于 SET 命令。</p><p>该命令的时间复杂度为O(1)，追加的字符串⼀般⻓度较短, 可以视为 O(1)，其返回值为追加完成之后 string 的⻓度，下面是使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给一个不存在的 key 值使用 append 指令，效果等同于 <span class="built_in">set</span> 指令</span></span><br><span class="line">127.0.0.1:6379&gt; append k1 hello</span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追加字符串 world</span></span><br><span class="line">127.0.0.1:6379&gt; append k1 world</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;helloworld&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追加带有空格的字符串（使用引号） <span class="string">&#x27; world&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; append k1 &#x27; world&#x27;</span><br><span class="line">(integer) 16</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;helloworld world&quot;</span><br></pre></td></tr></table></figure><h3><span id="7-getrange-指令">7、getrange 指令</span></h3><p>返回 key 对应的 string 的⼦串，由 start 和 end 确定（左闭右闭）。可以使⽤负数表⽰倒数。-1 代表倒数第⼀个字符，-2 代表<br>倒数第⼆个，其他的与此类似。超过范围的偏移量会根据 string 的⻓度调整成正确的值</p><p>使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key aaabbbcccddd</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">截取从下标1到下标3的字符串</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key 1 3</span><br><span class="line">&quot;aab&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">截取从下标1到倒数第一个的字符串</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key 1 -1</span><br><span class="line">&quot;aabbbcccddd&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">非正常操作，范围不可能前面大后面小</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key -1 -3</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key -3 -1</span><br><span class="line">&quot;ddd&quot;</span><br></pre></td></tr></table></figure><h3><span id="8-setrange-指令">8、setrange 指令</span></h3><p>该指令可以从指定偏移量开始覆盖字符串，其返回值为覆盖后字符串的长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 aaabbbcccddd</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从0开始覆盖写入 eee</span></span><br><span class="line">127.0.0.1:6379&gt; setrange k1 0 eee</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;eeebbbcccddd&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">偏移量不能采用负数表示</span></span><br><span class="line">127.0.0.1:6379&gt; setrange k1 -1 fff</span><br><span class="line">(error) ERR offset is out of range</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入字符串末尾，实现效果和 append 指令相同</span></span><br><span class="line">127.0.0.1:6379&gt; setrange k1 12 fff</span><br><span class="line">(integer) 15</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;eeebbbcccdddfff&quot;</span><br></pre></td></tr></table></figure><p>对于不存在的键值，利用该指令覆盖字符串，偏移量前面会用\x00来表示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setrange k2 3 aaaaaa</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;\x00\x00\x00aaaaaa&quot;</span><br></pre></td></tr></table></figure><h3><span id="9-strlen-指令">9、strlen 指令</span></h3><p>该指令用于计算字符串的长度（按字节计算）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 aaabbbccc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen k1</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; set k2 你好</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen k2</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><h2><span id="string-相关指令汇总表">String 相关指令汇总表</span></h2><table><thead><tr><th>命令</th><th>执行效果</th><th>时间复杂度</th></tr></thead><tbody><tr><td>set key value [key value…]</td><td>设置 key 的值是 value</td><td>O(k), k 是键个数</td></tr><tr><td>get key</td><td>获取 key 的值</td><td>O(1)</td></tr><tr><td>del key [key …]</td><td>删除指定的 key</td><td>O(k), k 是键个数</td></tr><tr><td>mset key value [key value …]</td><td>批量设置指定的 key 和 value</td><td>O(k), k 是键个数</td></tr><tr><td>mget key [key …]</td><td>批量获取 key 的值</td><td>O(k), k 是键个数</td></tr><tr><td>incr key</td><td>指定的 key 的值 +1</td><td>O(1)</td></tr><tr><td>decr key</td><td>指定的 key 的值 -1</td><td>O(1)</td></tr><tr><td>incrby key n</td><td>指定的 key 的值 +n</td><td>O(1)</td></tr><tr><td>decrby key n</td><td>指定的 key 的值 -n</td><td>O(1)</td></tr><tr><td>incrbyfloat key n</td><td>指定的 key 的值 +n</td><td>O(1)</td></tr><tr><td>append key value</td><td>指定的 key 的值追加 value</td><td>O(1)</td></tr><tr><td>strlen key</td><td>获取指定 key 的值的长度</td><td>O(1)</td></tr><tr><td>setrange key offset value</td><td>覆盖指定 key 的从 offset 开始的部分值</td><td>O(n), n 是字符串长度, 通常视为 O(1)</td></tr><tr><td>getrange key start end</td><td>获取指定 key 的从 start 到 end 的部分值</td><td>O(n), n 是字符串长度, 通常视为 O(1)</td></tr></tbody></table><h3><span id="内部编码规则">内部编码规则</span></h3><p>字符串类型的内部编码有 3 种：</p><ul><li>int：8 个字节的⻓整型</li><li>embstr：⼩于等于 39 个字节的字符串</li><li>raw：⼤于 39 个字节的字符串</li></ul><p>39这个数字并不是固定的，众所周知，Redis 是开源的。你若想要修改这个数值是完全没有问题的，在 Redis 高版本数值也是不一样的<br>，因此我们重点需要知道的是这两种编码方式的区别（下面以高版本 Redis 为例进行讲解）：</p><ol><li>embstr vs raw<table><thead><tr><th>特性</th><th><code>embstr</code> (嵌入式字符串)</th><th><code>raw</code> (原始字符串)</th></tr></thead><tbody><tr><td><strong>适用长度</strong></td><td>≤ <strong>44字节</strong>（Redis 5+）</td><td>&gt; 44字节</td></tr><tr><td><strong>内存分配</strong></td><td><strong>单次分配</strong>（连续内存）</td><td><strong>两次分配</strong>（<code>redisObject</code> + <code>SDS</code>）</td></tr><tr><td><strong>内存局部性</strong></td><td><strong>更好</strong>（CPU缓存友好）</td><td><strong>稍差</strong>（可能内存碎片）</td></tr><tr><td><strong>访问速度</strong></td><td><strong>稍快</strong>（减少指针跳转）</td><td><strong>稍慢</strong>（需解引用）</td></tr><tr><td><strong>修改时的行为</strong></td><td>修改时会转为 <code>raw</code></td><td>直接修改</td></tr></tbody></table></li><li>为什么短字符串用 embstr？<br>（1）内存效率更高<br>embstr 将 Redis对象头（redisObject） 和 字符串数据（SDS，Simple Dynamic String） 存储在 一块连续内存 中，减少内存碎片。<br>raw 需要分别分配 redisObject 和 SDS，占用更多内存，且可能产生内存碎片。<br>（2）CPU缓存友好<br>embstr 的数据在内存中是连续的，CPU 缓存命中率更高，访问速度更快。<br>raw 需要额外解引用指针，可能触发 CPU 缓存未命中（Cache Miss）。<br>（3）减少内存分配次数<br>embstr 只需 1次内存分配，而 raw 需要 2次（先分配 redisObject，再分配 SDS）。</li><li>为什么长字符串用 raw？<br>（1）避免大块连续内存分配<br>Redis 的 jemalloc 内存分配器对 小内存块（≤64字节） 有优化，但大内存块分配效率较低。<br>如果长字符串也用 embstr，会导致 大块连续内存请求，可能引发内存碎片问题。<br>（2）修改时不需转换<br>embstr 是 只读的，如果修改它，Redis 会先将其转为 raw 再修改。<br>长字符串更可能被修改（如 APPEND 操作），直接用 raw 避免转换开销。</li></ol><p>下面我们利用命令来查看一下不同的字符串存储方式的不同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 123456789</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding k1</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; set k2 abc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding k2</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set k3 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding k3</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure><h2><span id="典型业务场景">典型业务场景</span></h2><h3><span id="缓存功能">缓存功能</span></h3><p>String 在 Redis 缓存中的典型流程如下：</p><pre class="mermaid">sequenceDiagram    participant 用户    participant 业务层    participant Redis缓存    participant MySQL    用户->>业务层: 请求数据    业务层->>Redis缓存: 查询缓存（GET key）    alt 缓存命中        Redis缓存-->>业务层: 返回数据（String 反序列化）        业务层-->>用户: 返回数据    else 缓存未命中        业务层->>MySQL: 查询数据库        MySQL-->>业务层: 返回数据        业务层->>Redis缓存: 写入缓存（SET key 序列化后的String）        业务层-->>用户: 返回数据    end</pre><p>Redis 一般处理的是网络通信，因此在发送信息或接受信息的时候序列化和反序列化是必要的，因此最终在网络中传输的数据本质上就是 Redis 中的 String</p><p>缓存一般分为两步：</p><ul><li>缓存查询（GET）</li></ul><p>Redis 返回的是 序列化后的 String（如 JSON、Protocol Buffers、MessagePack 等格式）。<br>业务层需要 反序列化 后才能使用（例如 JSON.parse()）。</p><ul><li>缓存写入（SET）</li></ul><p>业务层从 MySQL 获取数据后，需先 序列化成 String（如 JSON.stringify()），再存入 Redis。<br>如果数据较大，Redis 会使用 raw 编码存储。</p><p>缓存实现方案示例：基于Redis和MySQL的用户信息查询优化</p><p>1、业务需求<br>根据用户uid获取用户信息<br>接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserInfo <span class="title function_">getUserInfo</span><span class="params">(<span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、从Redis获取用户信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据uid生成Redis键</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:info:&quot;</span> + uid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从Redis获取值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Redis执行命令: get key;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存命中处理</span></span><br><span class="line"><span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 反序列化JSON格式的用户信息</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> JSON反序列化(value);</span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、 缓存未命中时从MySQL获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存未命中处理</span></span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 从数据库查询</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> MySQL执行SQL: select * from user_info <span class="type">where</span> <span class="variable">uid</span> <span class="operator">=</span> &lt;uid&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户不存在处理</span></span><br><span class="line">    <span class="keyword">if</span> (userInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        响应<span class="number">404</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> JSON序列化(userInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入Redis并设置1小时(3600秒)过期时间</span></span><br><span class="line">    Redis执行命令: set key value ex <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回用户信息</span></span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的优化，理想情况下，每个用户信息每小时只会有1次MySQL查询，显著提升了查询效率，且有效降低了MySQL访问压力<br><strong>注意：在 Redis 中命名需要言简意赅，为了提高内存访问速度，在保证业务正常运转的前提下，字符串长度肯定是越短越好，因此有时候可以利用缩写来代替全名</strong></p><h3><span id="计数功能">计数功能</span></h3><p>String 类型不仅能作为缓存，还能通过其原子性操作（如 <code>INCR</code>、<code>INCRBY</code>）和高性能内存读写实现计数功能</p><h4><span id="redis-string-在计数场景的优势">Redis String 在计数场景的优势</span></h4><p>1、原子性操作</p><ul><li>Redis 的 <code>INCR</code>、<code>INCRBY</code> 是 原子操作，无需加锁即可避免并发冲突。<br>2、超高吞吐量</li><li>Redis 单机可支持 <strong>10万+ QPS</strong> 的写入，适合高频计数（如热门视频的播放量统计）。</li><li>对比 MySQL：<ul><li>MySQL 的 <code>UPDATE counters SET value=value+1 WHERE id=123</code> 在高并发下可能成为瓶颈。</li><li>Redis 的 <code>INCR</code> 直接操作内存，性能碾压。</li></ul></li></ul><p>3、灵活过期控制<br>我们可以利用 expire 命令设置过期时间（如按天统计）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCR daily:uv:20240501  <span class="comment"># 记录2025年7月8日的UV</span></span><br><span class="line">EXPIRE daily:uv:20240501 86400  <span class="comment"># 1天后自动删除</span></span><br></pre></td></tr></table></figure><h4><span id="技术场景中的典型示例">技术场景中的典型示例</span></h4><p>视频播放量统计</p><pre class="mermaid">sequenceDiagram    participant 用户    participant 业务层    participant Redis    participant 消息队列    participant MySQL    用户->>业务层: 请求播放视频ID=123    业务层->>Redis: INCR video:views:123    Redis-->>业务层: 返回当前播放量（如42）    业务层-->>用户: 返回视频数据+播放量    loop 异步持久化        Redis->>消息队列: 定时推送增量数据（如video:123 +1）        消息队列->>MySQL: 消费并更新数据库    end</pre><p>当然，实际中要开发⼀个成熟、稳定的真实计数系统，要⾯临的挑战远不⽌如此简单：防作弊、按<br>照不同维度计数、避免单点问题、数据持久化到底层数据源等。</p><h3><span id="会话功能">会话功能</span></h3><p>一个分布式 Web 服务将⽤⼾的 Session 信息（例如⽤⼾登录信息）保存在各⾃的服务器中，但这样会造成⼀个问题：出于负载均衡的考虑，<br>分布式服务会将⽤⼾的访问请求均衡到不同的服务器上，并且通常⽆法保证⽤⼾每次请求都会被均衡到同⼀台服务器上，这样当⽤⼾刷新⼀<br>次访问是可能会发现需要重新登录，这个问题是⽤⼾⽆法容忍的。</p><p>为了解决这个问题，可以使⽤ Redis 将⽤⼾的 Session 信息进⾏集中管理，在这种模式下，只要保证 Redis 是⾼可⽤和可扩展性的，⽆论⽤⼾<br>被均衡到哪台 Web 服务器上，都集中从Redis 中查询、更新 Session 信息：</p><h4><span id="redis-集中式会话管理基于-string-数据类型">Redis 集中式会话管理（基于 String 数据类型）</span></h4><pre class="mermaid">graph TD    A[用户] --> B[负载均衡器]    B --> C[Web 服务器 1]    B --> D[Web 服务器 2]    B --> E[Web 服务器 N]    C --> F[Redis]    D --> F    E --> F        subgraph 会话存储    F[("Redis (String 数据类型)")]    end</pre><h3><span id="手机验证码">手机验证码</span></h3><p>许多应⽤出于安全考虑，会在每次进⾏登录时，让⽤⼾输⼊⼿机号并且配合给⼿机发送验证码，然后让⽤⼾再次输⼊收到的验证码<br>并进⾏验证，从⽽确定是否是⽤⼾本⼈。为了短信接⼝不会频繁访问，会限制⽤⼾每分钟获取验证码的频率，实现的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">String 发送验证码(phoneNumber) &#123;</span><br><span class="line">    key = <span class="string">&quot;shortMsg:limit:&quot;</span> + phoneNumber;</span><br><span class="line">    <span class="comment">// 设置过期时间为 1 分钟（60 秒）</span></span><br><span class="line">    <span class="comment">// 使⽤ NX，只在不存在 key 时才能设置成功</span></span><br><span class="line">    <span class="type">bool</span> <span class="variable">r</span> <span class="operator">=</span> Redis 执⾏命令：set key <span class="number">1</span> ex <span class="number">60</span> nx</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(r == <span class="literal">false</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 说明之前设置过该⼿机的验证码了</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> Redis 执⾏命令：incr key</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(c &gt; <span class="number">5</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 说明超过了⼀分钟 5 次的限制了</span></span><br><span class="line">            <span class="comment">// 限制发送</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 说明要么之前没有设置过⼿机的验证码；要么次数没有超过 5 次</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">validationCode</span> <span class="operator">=</span> ⽣成随机的 <span class="number">6</span> 位数的验证码();</span><br><span class="line">  </span><br><span class="line">    validationKey = <span class="string">&quot;validation:&quot;</span> + phoneNumber;</span><br><span class="line">    <span class="comment">// 验证码 5 分钟（300 秒）内有效</span></span><br><span class="line">    Redis 执⾏命令：set validationKey validationCode ex <span class="number">300</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回验证码，随后通过⼿机短信发送给⽤⼾</span></span><br><span class="line">    <span class="keyword">return</span> validationCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证⽤⼾输⼊的验证码是否正确</span></span><br><span class="line">bool 验证验证码(phoneNumber, validationCode) &#123;</span><br><span class="line">    validationKey = <span class="string">&quot;validation:&quot;</span> + phoneNumber;</span><br><span class="line">  </span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Redis 执⾏命令：get validationKey;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明没有这个⼿机的验证码记录，验证失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (value == validationCode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Redis 中字符串数据类型的应用场景还远不止于此，这里介绍的是几个非常典型的应用场景</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 键值对 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口通信</title>
      <link href="/2025/07/05/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/07/05/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%A1%AC%E4%BB%B6%E4%B8%8A%E7%9A%84%E4%BF%AE%E6%94%B9">硬件上的修改</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0">软件上的实现</a></li><li><a href="#%E8%B6%85%E9%A2%91">超频</a></li></ul><!-- tocstop --><p>设计概要如下：</p><p>在前述“简易8位通用CPU设计”的基础上扩充UART异步串行通信收发器硬件，实现以特定波特率与PC完成串口通信的功能，并以通用CPU嵌入式系统<br>程序（机器语言或者汇编语言）完成与实际PC串口的通信。</p><p>你说你不知道简易8位通用CPU设计？自觉跳转：<a href="https://liujiaxuan69.github.io/2025/06/25/8%E4%BD%8DCPU%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/" title="跳转到8位通用CPU设计">8位通用CPU设计</a></p><h3><span id="硬件上的修改">硬件上的修改</span></h3><p>首先要说明的是，本题使用的是波特率为9600的 uart 通信，因此我们需要每隔 1s &#x2F;9600 执行一次数据读取或者发送，而我们的开发板频率是50MHz，故我们<br>需要计算执行一次数据发送或者数据接收：</p><p>1分频时执行一次数据处理所需指令周期 &#x3D; 50,000,000 &#x2F; 9600 &#x2F; 6 &#x3D; 868<br>2分频时执行一次数据处理所需指令周期 &#x3D; 50,000,000 &#x2F; 9600 &#x2F; 6 &#x2F; 2 &#x3D; 434<br>4分频时执行一次数据处理所需指令周期 &#x3D; 50,000,000 &#x2F; 9600 &#x2F; 6 &#x2F; 4 &#x3D; 217</p><p>说明一下，只有四分频才能保证 CPU 在处理数据的时候不会出现数据访问冲突，但这并不意味着我们需要采用4分频，因为指令处理频率越高数据帧读取出差错可能性越小<br>具体采用几分频，得测试哪种方式下数据帧接收错误率最低。因此我们需要一个计数器，用于计数，868和434显然是不能用8为存储下去的，但不管我们采用几分频，都可以采用<br>217为一个周期计数，比如说我们采用1分频，，那么我们可以让计数每隔4个指令周期才加一，示例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (~x) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (~xx)</span><br><span class="line">        cnt &lt;= next_cnt;</span><br><span class="line">        xx = ~xx;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x = ~x;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上一题的基础上，需要添加两个新指令 in 和 out，用于串口通信的输入和输出：</p><ul><li>指令编码表：</li></ul><table><thead><tr><th align="center">编号</th><th align="left">编码(二进制)</th><th align="left">汇编指令</th><th align="left">操作</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">0</td><td align="left"><code>0000xxyy</code></td><td align="left">mov rx, ry</td><td align="left">ry   &lt;&#x3D; rx</td><td align="center"></td></tr><tr><td align="center">1</td><td align="left"><code>0001xxyy</code></td><td align="left">mov rx, (ry)</td><td align="left">(ry) &lt;&#x3D; rx</td><td align="center"></td></tr><tr><td align="center">2</td><td align="left"><code>001000yy</code> <code>iiiiiiii</code></td><td align="left">mov i, ry</td><td align="left">ry   &lt;&#x3D; i</td><td align="center"></td></tr><tr><td align="center">3</td><td align="left"><code>010000rr</code></td><td align="left">jmp r</td><td align="left">PC   &lt;&#x3D; r</td><td align="center">无条件跳转</td></tr><tr><td align="center">4</td><td align="left"><code>010001rr</code></td><td align="left">jc r</td><td align="left">PC   &lt;&#x3D; r</td><td align="center">进位时跳转</td></tr><tr><td align="center">5</td><td align="left"><code>010010rr</code></td><td align="left">jz r</td><td align="left">PC   &lt;&#x3D; r</td><td align="center">结果为0时跳转</td></tr><tr><td align="center">6</td><td align="left"><code>010100yy</code></td><td align="left">in ry</td><td align="left">ry   &lt;&#x3D; uart receive</td><td align="center">将uart的rx线的值输入到指定寄存器的最高位</td></tr><tr><td align="center">7</td><td align="left"><code>010101yy</code></td><td align="left">out ry</td><td align="left">uart send &lt;&#x3D; ry</td><td align="center">将指定寄存器的最低位输出到uart的tx线</td></tr><tr><td align="center">8</td><td align="left"><code>0110xxyy</code></td><td align="left">mov (rx), ry</td><td align="left">ry   &lt;&#x3D; (rx)</td><td align="center"></td></tr><tr><td align="center">9</td><td align="left"><code>01110000</code></td><td align="left">rtn</td><td align="left">PC   &lt;&#x3D; 0</td><td align="center"></td></tr><tr><td align="center">10</td><td align="left"><code>1000xxyy</code></td><td align="left">and rx, ry</td><td align="left">ry   &lt;&#x3D; rx &amp; ry</td><td align="center"></td></tr><tr><td align="center">11</td><td align="left"><code>1001xxyy</code></td><td align="left">or  rx, ry</td><td align="left">ry   &lt;&#x3D; rx | ry</td><td align="center"></td></tr><tr><td align="center">12</td><td align="left"><code>101000xx</code></td><td align="left">not rx</td><td align="left">rx   &lt;&#x3D; ~rx</td><td align="center"></td></tr><tr><td align="center">13</td><td align="left"><code>1011xxyy</code></td><td align="left">xor rx, ry</td><td align="left">ry   &lt;&#x3D; rx ^ ry</td><td align="center"></td></tr><tr><td align="center">14</td><td align="left"><code>1100xxyy</code></td><td align="left">shl rx, ry</td><td align="left">ry   &lt;&#x3D; ry &lt;&lt; rx</td><td align="center"></td></tr><tr><td align="center">15</td><td align="left"><code>1101xxyy</code></td><td align="left">add rx, ry</td><td align="left">ry   &lt;&#x3D; ry + rx</td><td align="center"></td></tr><tr><td align="center">16</td><td align="left"><code>1110xxyy</code></td><td align="left">shr rx, ry</td><td align="left">ry   &lt;&#x3D; ry &gt;&gt; rx</td><td align="center"></td></tr><tr><td align="center">17</td><td align="left"><code>1111xxyy</code></td><td align="left">sub rx, ry</td><td align="left">ry   &lt;&#x3D; ry - rx</td><td align="center"></td></tr></tbody></table><p>010100yy 对应的是 in 指令，用于将接受到的数据存到指定寄存器的最高位</p><p>010101yy 对应的是 out 指令，用于发送指定寄存器的最低位（将寄存器最低位传到 tx）</p><p>首先说一说怎么实现串口通信吧，基本原理如下：</p><p><img src="/img/HD/serial_port_communication/spc1.png" alt="serial_port_communication"></p><p>呐，这张图上面的61引脚和62引脚分别对应的是 rxd32 和 txd32，也就是发送引脚和输出引脚，假设我们顶层模块中设置的发送端口为rx，接收端口<br>位tx，那么就需要将这两个端口分别连接到61号引脚以及62号引脚（在.qsf配置文件中加上如下配置）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_location_assignment PIN_61 -to rx    <span class="comment">// 将61号引脚与 rx 端口连接作为接收端口</span></span><br><span class="line">set_location_assignment PIN_62 -to tx    <span class="comment">// 将62号引脚与 rx 端口连接作为发送端口</span></span><br></pre></td></tr></table></figure><h4><span id="添加-in-指令和-out-指令">添加 in 指令和 out 指令</span></h4><p>其中 in 指令和 out 指令的实现如下：</p><p>首先，需要添加几个新的信号：</p><p>output reg reg_bus_in,    &#x2F;&#x2F; 寄存器组输入,将需要存入指定寄存器最高位的数据写进去，若 reg_en_in 为高电平，则会将该数据写入指定寄存器的最高位（人话：ry[7] &lt;&#x3D; reg_bus_in）<br>output reg reg_en_in,     &#x2F;&#x2F; 寄存器组输入使能，配合上面那玩意使用的<br>input  reg_bus_out,       &#x2F;&#x2F; 寄存器组输出，将需要发送的指定寄存器最低位的数据（reg_bus_out）写出去，若 reg_en_out 为高电平，则会将该数据写入 tx 等待发送（人话<br>：reg_bus_out &lt;&#x3D; ry[0]）<br>output reg reg_en_out     &#x2F;&#x2F; 寄存器组输出使能，配合上面那玩意使用的</p><p>因此，寄存器除了判断总线仲裁是否选择了它，更需要判断是否需要它配合实现 uart 通信，因此，寄存器组需要被改装：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> reg_file(</span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="keyword">input</span>       rst,</span><br><span class="line">    <span class="comment">// 双地址总线接口</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">2</span>:<span class="number">0</span>]  t_addrbus,    <span class="comment">// 目标地址总线</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">2</span>:<span class="number">0</span>]  s_addrbus,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus0, <span class="comment">// 双向数据总线（dMDR与寄存器组之间交互线）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus1, <span class="comment">// 双向数据总线（dMDR与寄存器组之间交互线）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus2, <span class="comment">// 双向数据总线（dMDR与寄存器组之间交互线）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus3, <span class="comment">// 双向数据总线（dMDR与寄存器组之间交互线）</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  inbus,  <span class="comment">// 输入数据总线（来自ALU或其他模块）</span></span><br><span class="line">    <span class="comment">// 控制信号</span></span><br><span class="line">    <span class="keyword">input</span> cur_reg_bus_in, <span class="comment">// 控制单元寄存器组输出</span></span><br><span class="line">    <span class="keyword">input</span> cur_reg_en_in, <span class="comment">// 控制单元寄存器组使能信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> cur_reg_bus_out, <span class="comment">// 当前寄存器组输出</span></span><br><span class="line">    <span class="keyword">input</span> cur_reg_en_out, <span class="comment">// 当前寄存器组使能信号</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] r3dbg</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> r3dbg = databus3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------------------------------------</span></span><br><span class="line">    <span class="comment">// 同步写逻辑</span></span><br><span class="line">    <span class="comment">//------------------------------------------</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 目标寄存器写入（地址有效时）</span></span><br><span class="line">        <span class="keyword">if</span> (cur_reg_en_in) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span> (t_addrbus[<span class="number">1</span>:<span class="number">0</span>]) <span class="comment">// 低2位选择寄存器</span></span><br><span class="line">                <span class="number">2&#x27;d0</span>: databus0[<span class="number">7</span>] &lt;= cur_reg_bus_in; <span class="comment">// R0</span></span><br><span class="line">                <span class="number">2&#x27;d1</span>: databus1[<span class="number">7</span>] &lt;= cur_reg_bus_in; <span class="comment">// R1</span></span><br><span class="line">                <span class="number">2&#x27;d2</span>: databus2[<span class="number">7</span>] &lt;= cur_reg_bus_in; <span class="comment">// R2</span></span><br><span class="line">                <span class="number">2&#x27;d3</span>: databus3[<span class="number">7</span>] &lt;= cur_reg_bus_in; <span class="comment">// R3</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur_reg_en_out) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(s_addrbus[<span class="number">1</span>:<span class="number">0</span>]) <span class="comment">// 低2位选择寄存器</span></span><br><span class="line">                <span class="number">2&#x27;d0</span>: cur_reg_bus_out &lt;= databus0[<span class="number">0</span>]; <span class="comment">// R0</span></span><br><span class="line">                <span class="number">2&#x27;d1</span>: cur_reg_bus_out &lt;= databus1[<span class="number">0</span>]; <span class="comment">// R1</span></span><br><span class="line">                <span class="number">2&#x27;d2</span>: cur_reg_bus_out &lt;= databus2[<span class="number">0</span>]; <span class="comment">// R2</span></span><br><span class="line">                <span class="number">2&#x27;d3</span>: cur_reg_bus_out &lt;= databus3[<span class="number">0</span>]; <span class="comment">// R3</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t_addrbus[<span class="number">2</span>] == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span>  <span class="comment">// 最高位=0时有效</span></span><br><span class="line">            <span class="keyword">case</span> (t_addrbus[<span class="number">1</span>:<span class="number">0</span>]) <span class="comment">// 低2位选择寄存器</span></span><br><span class="line">                <span class="number">2&#x27;d0</span>: databus0 &lt;= inbus; <span class="comment">// R0</span></span><br><span class="line">                <span class="number">2&#x27;d1</span>: databus1 &lt;= inbus; <span class="comment">// R1</span></span><br><span class="line">                <span class="number">2&#x27;d2</span>: databus2 &lt;= inbus; <span class="comment">// R2</span></span><br><span class="line">                <span class="number">2&#x27;d3</span>: databus3 &lt;= inbus; <span class="comment">// R3</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 全部寄存器复位为0</span></span><br><span class="line">            databus0 &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">            databus1 &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">            databus2 &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">            databus3 &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 always 控制块中，添加了两个使能信号的判断（cur_reg_en_in 和 cur_reg_en_out），当信号有效时，就会将指定寄存器最低位的数据写到 cur_reg_bus_out，或者<br>将 cur_reg_bus_in 写到指定寄存器的最高位，而 这两个使能信号是由 CU 控制单元去控制生效的，当 CU 将这两个信号任意一个使能后，寄存器组就会将对于的工作处理完，<br>而后 CU 就可以利用 cur_reg_bus_in 和 cur_reg_bus_out 来处理接受和发送了，下面是 CU 中 in 指令和 out 指令的处理：</p><h5><span id="执行阶段1operand高两位用于判断指令为-in-指令还是-out-指令00-则为-in-指令01-则为-out-指令">执行阶段1：operand高两位用于判断指令为 in 指令还是 out 指令，00 则为 in 指令，01 则为 out 指令</span></h5><ul><li>in指令逻辑：</li></ul><p>让指定寄存器最高位接受数据，并将 rx 中的数据接收到 reg_bus_in 中，寄存器组将会利用 reg_bus_in 存储数据，当然最重要的一步，让 reg_en_in 为1</p><ul><li>out指令逻辑：</li></ul><p>让指定寄存器最低位发送数据，让 reg_en_in 为1，这一步后指定寄存器会将最低为存储到 reg_bus_out 当中，下一步将会利用到该数据</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EXEC1</span></span><br><span class="line"><span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(operand[<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">        <span class="comment">// in ry // ry &lt;= uart receive</span></span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">            reg_bus_in &lt;= rx;               <span class="comment">// 寄存器组输入</span></span><br><span class="line">            reg_en_in &lt;= <span class="number">1</span>;                 <span class="comment">// 寄存器组输入使能信号</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// out ry // uart send</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">            s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">            reg_en_out &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5><span id="执行阶段2">执行阶段2</span></h5><ul><li>in指令逻辑：</li></ul><p>寄存器组停止输入，且停止使能信号输出</p><ul><li>out指令逻辑：</li></ul><p>寄存器组停止输出，且停止使能信号输出</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EXEC2</span></span><br><span class="line"><span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(operand[<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">        <span class="comment">// in ry step2(in)</span></span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止寄存器组输入</span></span><br><span class="line">            reg_en_in &lt;= <span class="number">0</span>;                     <span class="comment">// 寄存器组输入使能信</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>:<span class="keyword">begin</span></span><br><span class="line">            s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止寄存器组输出</span></span><br><span class="line">            reg_en_out &lt;= <span class="number">0</span>;                    <span class="comment">// 寄存器组输出使能信</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可能会有人问了，out 指令不是还要将数据写入到 tx 当中吗，这咋感觉像是两个指令都完成了，要做收尾工作了呢？你别急，你考虑过的我肯定也考虑过了，<br>若此时 out 指令直接将数据输出到 tx，很有可能寄存器还没有将数据写入到 reg_bus_out 当中，此时就有可能将错误数据写入到 tx 当中</p><h5><span id="执行阶段3独属于-out-指令的阶段">执行阶段3（独属于 out 指令的阶段）</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(operand[<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">            <span class="number">2&#x27;b01</span>:<span class="keyword">begin</span></span><br><span class="line">        tx &lt;= reg_bus_out;               <span class="comment">// 寄存器组输出使能</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在第三阶段再将数据写入 tx， 就肯定不会出问题了</p><p>相信细心的观众肯定发现了，我的立即数指令变化了，这是因为串口通信的确需要8位立即数的计算：</p><h4><span id="cu-立即数-mov-指令逻辑修改">CU 立即数 mov 指令逻辑修改</span></h4><p>当然，立即数只能存下8位数据，那么我们要怎么做才能保证传送8位数据呢，再怎么样操作数只有4位，一个指令码应该很难实现吧？</p><p>对了，那就使用两个指令码来处理立即数 mov 操作，这意味着该指令会让 pc 自增两次，因为需要读取两个指令码，下面是指令的实现：</p><p>之前 IR 发送到总线的数据是指令码的低五位，通过这种方式就需要 IR 直接将指令码八位全部发送到总线上去：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 指令加载阶段</span></span><br><span class="line">    <span class="keyword">if</span> (ir_in) <span class="keyword">begin</span></span><br><span class="line">        databus &lt;= inbus;    <span class="comment">// 锁存总线数据(被修改部分)</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5><span id="执行阶段1">执行阶段1</span></h5><p>虽然我们要读取两个指令码，但是实际上我们执行的逻辑是第一个指令码的逻辑，第二个指令码是一个完全的操作数，因此在 pc 自增后，我们要记住上一条是 mov 命令：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> imm_get_en;    <span class="comment">// 立即数获取使能（若为1，则继续执行 mov i ry指令）</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] imm_reg; <span class="comment">// 立即数寄存器(因为在 pc 自增后会丢失 mov 指令数据，因此需要提前将指定寄存器的编号锁存下来)</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EXEC1</span></span><br><span class="line">    <span class="number">4&#x27;b0010</span>: <span class="keyword">begin</span></span><br><span class="line">        imm_reg &lt;= operand[<span class="number">1</span>:<span class="number">0</span>];         <span class="comment">// 锁存立即数读取的寄存器编号</span></span><br><span class="line">        pc_out &lt;= <span class="number">1</span>;                     <span class="comment">// PC输出至数据总线</span></span><br><span class="line">        s_addrbus &lt;= <span class="number">3&#x27;b110</span>;             <span class="comment">// 指令存储器读取指令</span></span><br><span class="line">        imm_get_en &lt;= <span class="number">1</span>;                 <span class="comment">// 立即数获取使能</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>首先让 imm_reg 锁存指定寄存器的编号，然后让 PC 输出下一条指令的编号，将 imm_get_en 信号使能设置为1，后面的执行阶段中会先<br>特判 imm_get_en 是否为1，若为1则执行 mov i ry 指令的逻辑</p><h5><span id="执行阶段2">执行阶段2</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (imm_get_en) <span class="keyword">begin</span></span><br><span class="line">    pc_out &lt;= <span class="number">0</span>;                       <span class="comment">// PC停止输出</span></span><br><span class="line">    pc_inc &lt;= <span class="number">1</span>;                       <span class="comment">// PC自增</span></span><br><span class="line">    s_addrbus &lt;= <span class="number">3&#x27;b111</span>;               <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">    iMDRout &lt;= <span class="number">1</span>;                      <span class="comment">// 指令数据存储器输出数据至总线</span></span><br><span class="line">    ir_in &lt;= <span class="number">1</span>;                        <span class="comment">// 指令寄存器从总线中读取指令</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>执行阶段1已经将 imm_get_en 设置为1了，进入执行阶段2后就直接进入该逻辑部分了，此时让 pc 自增，为后面的阶段做准备，让指令存储器输出数据到总线，<br>同时让指令寄存器从总线读取指令（准确来说是立即数）</p><h5><span id="执行阶段3">执行阶段3</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (imm_get_en) <span class="keyword">begin</span></span><br><span class="line">    pc_inc &lt;= <span class="number">0</span>;                       <span class="comment">// PC停止自增</span></span><br><span class="line">    iMDRout &lt;= <span class="number">0</span>;                      <span class="comment">// 指令数据存储器停止输出数据至总线</span></span><br><span class="line">    ir_in &lt;= <span class="number">0</span>;                        <span class="comment">// 指令寄存器停止读取指令</span></span><br><span class="line">    imm_out &lt;= <span class="number">1</span>;                      <span class="comment">// 立即数输出使能</span></span><br><span class="line">    t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, imm_reg&#125;;      <span class="comment">// 立即数写入寄存器</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下来就是立即数输出使能了，让指定寄存器读取数据，需要被写入的寄存器之前已经被锁存了，当时若不锁存，这个时候就无法获取到寄存器编号了，因为 pc 已经自增了</p><h5><span id="执行阶段4">执行阶段4</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (imm_get_en) <span class="keyword">begin</span></span><br><span class="line">    imm_out &lt;= <span class="number">0</span>; <span class="comment">// 立即数输出停止</span></span><br><span class="line">    imm_get_en &lt;= <span class="number">0</span>; <span class="comment">// 立即数获取使能复位</span></span><br><span class="line">    t_addrbus &lt;= <span class="number">3&#x27;b111</span>; <span class="comment">// 停止目标地址接受数据</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这一阶段没什么好说的，将之前被激活的信号关掉</p><p>CU单元算是一个大改，最终代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> CU (</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="keyword">input</span>         rst,          <span class="comment">// 全局复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令接口</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]  opcode,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]  operand,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序地址总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>      pc_reset,       <span class="comment">// PC清零</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        pc_out,         <span class="comment">// PC地址输出使能</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        pc_inc,         <span class="comment">// PC自增</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        pc_jump,        <span class="comment">// PC跳转</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令寄存器总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        iMDRout,        <span class="comment">// iMDR写入总线</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寄存器组总线控制</span></span><br><span class="line">    <span class="comment">// ALU总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUAin,         <span class="comment">// ALU数据A输入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUBin,         <span class="comment">// ALU数据B输入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUout,         <span class="comment">// ALU数据输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  ALUop,          <span class="comment">// ALU操作选择</span></span><br><span class="line">    <span class="keyword">input</span>             cf,             <span class="comment">// 进位标志（CF）</span></span><br><span class="line">    <span class="keyword">input</span>             zf,             <span class="comment">// 零标志（ZF）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据存储器总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        dmdr_iin,       <span class="comment">// dMDR和总线输入使能</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        dmdr_iout,      <span class="comment">// dMDR和总线输出使能（数据总线输出）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        mem_as_target,  <span class="comment">// 数据存储器作为目标地址总线</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        mem_as_source,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ir_in,          <span class="comment">// 从总线加载指令（上升沿有效）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        imm_out,        <span class="comment">// 立即数输出（低五位）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  s_addrbus,      <span class="comment">// 源地址选择</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  t_addrbus,      <span class="comment">// 目标地址选择</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  cnt,</span><br><span class="line">    <span class="keyword">output</span>     [<span class="number">7</span>:<span class="number">0</span>]  next_cnt,</span><br><span class="line">    <span class="keyword">input</span>      rx, <span class="comment">// UART接收线（可选）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> tx, <span class="comment">// UART发送线（可选）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> reg_bus_in, <span class="comment">// 寄存器组输入（R0-R3）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> reg_en_in, <span class="comment">// 寄存器组输入使能（R0-R3）</span></span><br><span class="line">    <span class="keyword">input</span>  reg_bus_out, <span class="comment">// 寄存器组输出（R0-R3）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> reg_en_out <span class="comment">// 寄存器组输出使能（R0-R3）</span></span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> imm_get_en; <span class="comment">// 立即数获取使能</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cur_sta;</span><br><span class="line">    <span class="keyword">reg</span> fetch1_wait; <span class="comment">// 等待信号</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] imm_reg; <span class="comment">// 立即数寄存器</span></span><br><span class="line">    <span class="keyword">parameter</span> </span><br><span class="line">        FETCH1   = <span class="number">3&#x27;b000</span>,</span><br><span class="line">        FETCH2   = <span class="number">3&#x27;b001</span>,</span><br><span class="line">        EXEC1    = <span class="number">3&#x27;b010</span>,</span><br><span class="line">        EXEC2    = <span class="number">3&#x27;b011</span>,</span><br><span class="line">        EXEC3    = <span class="number">3&#x27;b100</span>,</span><br><span class="line">        EXEC4    = <span class="number">3&#x27;b101</span>;</span><br><span class="line"></span><br><span class="line">    Incrementer cnt_inc(</span><br><span class="line">        <span class="variable">.op</span>(cnt),</span><br><span class="line">        <span class="variable">.next_op</span>(next_cnt)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (cur_sta)</span><br><span class="line">            <span class="comment">// 取指阶段</span></span><br><span class="line">            FETCH1: <span class="keyword">begin</span></span><br><span class="line">                pc_out &lt;= <span class="number">1</span>;            <span class="comment">// PC输出至数据总线</span></span><br><span class="line">                s_addrbus &lt;= <span class="number">3&#x27;b110</span>;    <span class="comment">// 指令存储器读取指令</span></span><br><span class="line">                t_addrbus &lt;= <span class="number">3&#x27;b111</span>;    <span class="comment">// 无目标地址</span></span><br><span class="line">                <span class="keyword">if</span> (fetch1_wait) <span class="keyword">begin</span></span><br><span class="line">                    fetch1_wait &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 取指等待信号复位</span></span><br><span class="line">                    cur_sta &lt;= FETCH1; <span class="comment">// 保持在FETCH1状态</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cur_sta &lt;= FETCH2;    <span class="comment">// 状态转移到FETCH2</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            FETCH2: <span class="keyword">begin</span></span><br><span class="line">                pc_out &lt;= <span class="number">0</span>;            <span class="comment">// PC停止总线输出</span></span><br><span class="line">                s_addrbus &lt;= <span class="number">3&#x27;b111</span>;    <span class="comment">// 停止指令存储器读取指令</span></span><br><span class="line">                iMDRout &lt;= <span class="number">1</span>;           <span class="comment">// 指令数据存储器输出数据至总线</span></span><br><span class="line">                ir_in &lt;= <span class="number">1</span>;             <span class="comment">// 指令寄存器从总线中读取指令</span></span><br><span class="line">                pc_inc &lt;= <span class="number">1</span>;            <span class="comment">// PC自增</span></span><br><span class="line">                cur_sta &lt;= EXEC1;    <span class="comment">// 状态转移到EXEC1</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC1: <span class="keyword">begin</span></span><br><span class="line">                pc_inc &lt;= <span class="number">0</span>;            <span class="comment">// PC停止自增</span></span><br><span class="line">                iMDRout &lt;= <span class="number">0</span>;           <span class="comment">// 指令数据存储器停止输出数据至总线</span></span><br><span class="line">                ir_in &lt;= <span class="number">0</span>;             <span class="comment">// 指令寄存器停止读取指令</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Start</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, ry step1(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx发送数据信息至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;   <span class="comment">// ry接受数据总线上的数据信息</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move rx, (ry) step1(间接寻址)</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx发送数据信息至数据总线</span></span><br><span class="line">                        dmdr_iin &lt;= <span class="number">1</span>;                        <span class="comment">// MDR接收总线数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move i ry</span></span><br><span class="line">                    <span class="number">4&#x27;b0010</span>: <span class="keyword">begin</span></span><br><span class="line">                        imm_reg &lt;= operand[<span class="number">1</span>:<span class="number">0</span>]; <span class="comment">// 锁存立即数读取的寄存器编号</span></span><br><span class="line">                        pc_out &lt;= <span class="number">1</span>;                     <span class="comment">// PC输出至数据总线</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b110</span>;             <span class="comment">// 指令存储器读取指令</span></span><br><span class="line">                        imm_get_en &lt;= <span class="number">1</span>;              <span class="comment">// 立即数获取使能</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// jump</span></span><br><span class="line">                    <span class="number">4&#x27;b0100</span>: <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span> (operand[<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">                            <span class="comment">// ry</span></span><br><span class="line">                            <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                                pc_jump &lt;= <span class="number">1</span>;               <span class="comment">// PC跳转</span></span><br><span class="line">                                s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;; <span class="comment">// 直接跳转到地址</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                            <span class="comment">// jc ry</span></span><br><span class="line">                            <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                                <span class="keyword">if</span> (cf) <span class="keyword">begin</span></span><br><span class="line">                                    pc_jump &lt;= <span class="number">1</span>;           <span class="comment">// PC跳转</span></span><br><span class="line">                                    s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;; <span class="comment">// 直接跳转到地址</span></span><br><span class="line">                                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                                    pc_jump &lt;= <span class="number">0</span>;           <span class="comment">// PC不跳转</span></span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                            <span class="comment">// jz ry</span></span><br><span class="line">                            <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                                <span class="keyword">if</span> (zf) <span class="keyword">begin</span></span><br><span class="line">                                    pc_jump &lt;= <span class="number">1</span>;           <span class="comment">// PC跳转</span></span><br><span class="line">                                    s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;; <span class="comment">// 直接跳转到地址</span></span><br><span class="line">                                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                                    pc_jump &lt;= <span class="number">0</span>;           <span class="comment">// PC不跳转</span></span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(operand[<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">                        <span class="comment">// in ry // ry &lt;= uart receive</span></span><br><span class="line">                        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                            t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                            reg_bus_in &lt;= rx;               <span class="comment">// 寄存器组输入</span></span><br><span class="line">                            reg_en_in &lt;= <span class="number">1</span>;                 <span class="comment">// 寄存器组输入使能信号</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="comment">// out ry // uart send</span></span><br><span class="line">                        <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                            s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                            reg_en_out &lt;= <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry step1(间接寻址)</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx输出地址数据至数据总线</span></span><br><span class="line">                        mem_as_source &lt;= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// rtn step1(rtn)</span></span><br><span class="line">                    <span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">                        pc_reset &lt;= <span class="number">1</span>;                       <span class="comment">// PC清零</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and/or/xor/add/sub/shl/shr rx ry step1(alua &lt;= rx)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                cur_sta &lt;= EXEC2;    <span class="comment">// 状态转移到EXEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (imm_get_en) <span class="keyword">begin</span></span><br><span class="line">                    pc_out &lt;= <span class="number">0</span>;                       <span class="comment">// PC停止输出</span></span><br><span class="line">                    pc_inc &lt;= <span class="number">1</span>;                       <span class="comment">// PC自增</span></span><br><span class="line">                    s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">                    iMDRout &lt;= <span class="number">1</span>;                  <span class="comment">// 指令数据存储器输出数据至总线</span></span><br><span class="line">                    ir_in &lt;= <span class="number">1</span>;                     <span class="comment">// 指令寄存器从总线中读取指令</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, ry endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move rx, (ry) step2(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iin &lt;= <span class="number">0</span>;                        <span class="comment">// MDR停止接收总线数据</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;    <span class="comment">// ry发送地址信息至数据总线</span></span><br><span class="line">                        <span class="comment">// t_addrbus &lt;= 3&#x27;b100;                 // 通过总线数据地址信息将对应内存数据存至dMDR</span></span><br><span class="line">                        mem_as_target &lt;= <span class="number">1</span>;                <span class="comment">// 数据存储器作为目标地址总线</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// jump step2(jump)</span></span><br><span class="line">                    <span class="number">4&#x27;b0100</span>: <span class="keyword">begin</span></span><br><span class="line">                        pc_jump &lt;= <span class="number">0</span>;                       <span class="comment">// PC停止跳转</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止目标地址接受数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(operand[<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">                        <span class="comment">// in ry step2(in)</span></span><br><span class="line">                        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                            t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止寄存器组输入</span></span><br><span class="line">                            reg_en_in &lt;= <span class="number">0</span>;                     <span class="comment">// 寄存器组输入使能信</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="number">2&#x27;b01</span>:<span class="keyword">begin</span></span><br><span class="line">                            s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止寄存器组输出</span></span><br><span class="line">                            reg_en_out &lt;= <span class="number">0</span>;                    <span class="comment">// 寄存器组输出使能信</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry step2(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        mem_as_source &lt;= <span class="number">0</span>;</span><br><span class="line">                        dmdr_iout &lt;= <span class="number">1</span>;                         <span class="comment">// dMDR输出数据至数据总线</span></span><br><span class="line">                        <span class="comment">// s_addrbus &lt;= 3&#x27;b100;                    // 主存根据地址数据总线访存</span></span><br><span class="line">                        t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;; <span class="comment">// ry接受数据总线上的数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// rtn endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">                        pc_reset &lt;= <span class="number">0</span>;                          <span class="comment">// PC停止清零</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b100</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// or rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b101</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// xor rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1011</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// not ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1010</span>:  <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b110</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// shl rx, ry (alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1100</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b010</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1101</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// shr rx ry(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b011</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// sub rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1111</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b001</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">// 状态转移到EXEC3</span></span><br><span class="line">                cur_sta &lt;= EXEC3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC3: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (imm_get_en) <span class="keyword">begin</span></span><br><span class="line">                    pc_inc &lt;= <span class="number">0</span>;                       <span class="comment">// PC停止自增</span></span><br><span class="line">                    iMDRout &lt;= <span class="number">0</span>;                  <span class="comment">// 指令数据存储器停止输出数据至总线</span></span><br><span class="line">                    ir_in &lt;= <span class="number">0</span>;                     <span class="comment">// 指令寄存器停止读取指令</span></span><br><span class="line">                    imm_out &lt;= <span class="number">1</span>;                  <span class="comment">// 立即数输出使能</span></span><br><span class="line">                    t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, imm_reg&#125;; <span class="comment">// 立即数写入寄存器</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, (ry) endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                      <span class="comment">// 停止源地址发送数据  </span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                 <span class="comment">// 停止目标地址接受数据</span></span><br><span class="line">                        mem_as_target &lt;= <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(operand[<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">                        <span class="number">2&#x27;b01</span>:<span class="keyword">begin</span></span><br><span class="line">                            tx &lt;= reg_bus_out;               <span class="comment">// 寄存器组输出使能</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iout &lt;= <span class="number">0</span>;                          <span class="comment">// dMDR停止输出数据至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// ry停止接受数据总线上的数据</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and/or/xor/add/sub/shl/shr rx ry step3 (result &lt;= databus)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1010</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        <span class="comment">//clear</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//operate</span></span><br><span class="line">                        ALUout &lt;= <span class="number">1</span>;                         </span><br><span class="line">                        t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;        <span class="comment">// 计算结果写入ry</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="comment">// 状态转移到EXEC4</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                cur_sta &lt;= EXEC4;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC4: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (imm_get_en) <span class="keyword">begin</span></span><br><span class="line">                    imm_out &lt;= <span class="number">0</span>; <span class="comment">// 立即数输出停止</span></span><br><span class="line">                    imm_get_en &lt;= <span class="number">0</span>; <span class="comment">// 立即数获取使能复位</span></span><br><span class="line">                    t_addrbus &lt;= <span class="number">3&#x27;b111</span>; <span class="comment">// 停止目标地址接受数据</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// (and/or/not/xor/add/sub/shl/shr rx ry) / add/sub i endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1010</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1110</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        ALUout &lt;= <span class="number">0</span>;                         </span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">// 状态转移到FETCH1</span></span><br><span class="line">                cur_sta &lt;= FETCH1;</span><br><span class="line">                <span class="keyword">if</span>(cnt[<span class="number">3</span>] &amp; cnt[<span class="number">4</span>] &amp; cnt[<span class="number">6</span>] &amp; cnt[<span class="number">7</span>]) cnt &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// if(cnt == 19) cnt &lt;= 0;</span></span><br><span class="line">                <span class="comment">// if (cnt[0]) cnt &lt;= 0;</span></span><br><span class="line">                <span class="comment">// 这一部分后面会讲到，这里先不用关心</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~x) <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">if</span> (~xx)</span><br><span class="line">                            cnt &lt;= next_cnt;</span><br><span class="line">                        xx = ~xx;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    x = ~x;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: cur_sta &lt;= FETCH1;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">            cur_sta &lt;= FETCH1; <span class="comment">// 复位时状态机回到FETCH1</span></span><br><span class="line">            pc_reset &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            pc_out &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// PC输出停止</span></span><br><span class="line">            pc_inc &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// PC自增停止</span></span><br><span class="line">            iMDRout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 指令存储器输出停止</span></span><br><span class="line">            ALUAin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU A输入停止</span></span><br><span class="line">            ALUBin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU B输入停止</span></span><br><span class="line">            ALUout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU输出停止</span></span><br><span class="line">            ALUop &lt;= <span class="number">3&#x27;b000</span>; <span class="comment">// ALU操作码清零</span></span><br><span class="line">            dmdr_iin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 数据存储器输入停止</span></span><br><span class="line">            dmdr_iout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 数据存储器输出停止</span></span><br><span class="line">            ir_in &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 指令寄存器输入停止</span></span><br><span class="line">            imm_out &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 立即数输出停止</span></span><br><span class="line">            s_addrbus &lt;= <span class="number">3&#x27;b111</span>; <span class="comment">// 源地址总线置空</span></span><br><span class="line">            t_addrbus &lt;= <span class="number">3&#x27;b111</span>; <span class="comment">// 目标地址总线置空</span></span><br><span class="line">            fetch1_wait &lt;= <span class="number">1&#x27;b1</span>; <span class="comment">// 清除等待状态</span></span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">            tx &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> xx = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h4><span id="主存配合-uart-通信所必需的要求">主存配合 uart 通信所必需的要求</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 总线输入到MDR</span></span><br><span class="line">    <span class="keyword">if</span> (dmdr_iin)</span><br><span class="line">        databus &lt;= inbus;</span><br><span class="line">    <span class="comment">// MDR写到内存</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mem_as_target)</span><br><span class="line">        memory[mem_addr[<span class="number">2</span>:<span class="number">0</span>]] &lt;= databus;</span><br><span class="line">    <span class="comment">// 内存读到MDR</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mem_as_source)</span><br><span class="line">        databus &lt;= memory[mem_addr[<span class="number">2</span>:<span class="number">0</span>]];</span><br><span class="line">    <span class="comment">// new part</span></span><br><span class="line">    <span class="keyword">if</span> (memory[<span class="number">6</span>] == memory[<span class="number">7</span>]) <span class="keyword">begin</span> <span class="comment">// 14和15寄存器相等时，输出PWM调光信号</span></span><br><span class="line">        memory[<span class="number">5</span>][<span class="number">0</span>] &lt;= <span class="number">1&#x27;b1</span>; <span class="comment">// 13寄存器最低位为1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    memory[<span class="number">7</span>] &lt;= cnt;</span><br><span class="line">    <span class="comment">// new part end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> mem_addr = inbus;</span><br></pre></td></tr></table></figure><p>其中 memory[7] 会一直存储当前所处的周期计数，而 memory[6] 用于存放 uart 通信中期望接收数据或发送数据所达到的周期，因此，memory[5][0] 就用来存放<br>两个内存中数据是否相同的判断，当判断为1，uart 就会接受1 bit 数据。</p><h3><span id="软件上的实现">软件上的实现</span></h3><p>下面开始详解汇编代码的编写：</p><ul><li>Part 1：检测起始信号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">L0:</span><br><span class="line">    xor r3, r3              // 00 | 10111111</span><br><span class="line">    not r3                  // 01 | 10100011</span><br><span class="line">    in r0                   // 02 | 01010000</span><br><span class="line">    // 下降沿后， and 指令会设置一个零标志</span><br><span class="line">    and r0, r3              // 03 | 10000011</span><br><span class="line"></span><br><span class="line">    // 零标志时跳转至 recv_pre</span><br><span class="line">    mov recv_pre, r0        // 04 | 00100000</span><br><span class="line">                            // 05 | 00001000 : recv_pre</span><br><span class="line">    jz r0                   // 06 | 01001000</span><br><span class="line"></span><br><span class="line">    // 不跳转回到开头继续等待</span><br><span class="line">    rtn                     // 07 | 01110000</span><br></pre></td></tr></table></figure><p>刚开始，我们需要循环检测低电平，在 uart 协议当中，起始位为低电平，我们不断地通过 in 指令读取数据至 r0 寄存器的最高位，而 r3 在刚开始时被清零并取反，<br>r3 变成全1，当收到信号为高电平时零标志位为0，就会触发 rtn 指令，回到开头继续循环，信号变成低电平后零标志位为1，将 recv_pre 指令地址起始地址存到 r0，并跳转到<br>该地址</p><ul><li>Part 2：计时器取中值</li></ul><p>我们要做到在发送信号后的中间时刻取数，这样才能保证数据不会取偏。我将解释全部放到代码当中，方便理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 第一个下降沿后，计算采样点的计数（当前计数+108）</span><br><span class="line">// 可直接存储立即数（自己实现，我不敢改了，反正能跑）</span><br><span class="line">recv_pre:                   // 08</span><br><span class="line">    // r3=108 （以下的步骤全都是在给r3 赋值108，其实我上面已经改成了8位立即数存储，但当时写这个汇编代码的时候并不支持，后期修改后反而还跑不了了，所以就索性不改了）</span><br><span class="line">    mov 5, r0               // 08 | 00100000</span><br><span class="line">                            // 09 | 00000101</span><br><span class="line">    mov 3, r3               // 0a | 00100011</span><br><span class="line">                            // 0b | 00000011</span><br><span class="line">    shl r0, r3              // 0c | 11000011</span><br><span class="line">    mov 0xc, r0             // 0d | 00100000</span><br><span class="line">                            // 0e | 00001100</span><br><span class="line">    add r0, r3              // 0f | 11010011</span><br><span class="line">    // 计数器  上面说过，主存的最后一块地址用于存储当前的周期计数，因此这里的操作是将数据拿出来，以此为基准，在相对于这个时间点后的108个指令周期接受一次数据</span><br><span class="line">    // r1 = ucnt - 108</span><br><span class="line">    mov ucnt, r0            // 10 | 00100000</span><br><span class="line">                            // 11 | 00000111 : ucnt</span><br><span class="line"></span><br><span class="line">    mov (r0), r1            // 12 | 01100001</span><br><span class="line">    sub r3, r1              // 13 | 11111101</span><br><span class="line"></span><br><span class="line">    // if (r1 &lt; 0) r1 = r1 + 216</span><br><span class="line">    // 可直接使用 jc 判断（你知道我想说什么的）</span><br><span class="line">    // 这里是通过判断减后最高位是不是1来判断 r1 是否小于0，若是1，说明建成了一个负数，需要加上216补全</span><br><span class="line">    mov 7, r2               // 14 | 00100010</span><br><span class="line">                            // 15 | 00000111</span><br><span class="line">    mov 1, r0               // 16 | 00100000</span><br><span class="line">                            // 17 | 00000001</span><br><span class="line">    shl r2, r0              // 18 | 11001000</span><br><span class="line">    and r0, r1              // 19 | 10000001</span><br><span class="line">    mov 1f, r0              // 1a | 00100000</span><br><span class="line">                            // 1b | 00100001 : 1f</span><br><span class="line">    jz r0                   // 1c | 01001000</span><br><span class="line">    mov 1, r0               // 1d | 00100000</span><br><span class="line">                            // 1e | 00000001</span><br><span class="line">    // r3 &lt;&lt; 1 (r3 = 216)</span><br><span class="line">    // 跑这里来说明就是 r1 &lt; 0 了，得加216补全</span><br><span class="line">    shl r0, r3              // 1f | 11000011</span><br><span class="line">    add r3, r1              // 20 | 11011101</span><br><span class="line">    1:                      // 21</span><br><span class="line"></span><br><span class="line">    // (testpoint) = r1</span><br><span class="line">    // 将期望接受数据的周期数存储到测试点（内存地址6）当中，在硬件逻辑中当检测到内存6和内存7单元相同时会把地址7变为1</span><br><span class="line">    mov testpoint, r0       // 21 | 00100000</span><br><span class="line">                            // 22 | 00000110 : testpoint</span><br><span class="line">    mov r1, (r0)            // 23 | 00010100</span><br><span class="line">    // (attp) = 0，先将 r1 清零，将 attp 内存地址存放的数据变为0（因为这里是起始位，需要等过去，不能执行数据接收）（起始位不是真正的数据，下一个比特才是）</span><br><span class="line">    xor r1, r1              // 24 | 10110101</span><br><span class="line">    mov attp, r0            // 25 | 00100000</span><br><span class="line">                            // 26 | 00000101 : attp</span><br><span class="line">    mov r1, (r0)            // 27 | 00010100</span><br><span class="line"></span><br><span class="line">    // 8个采样周期，作为循环计数</span><br><span class="line">    // (recv_bcnt) = 8</span><br><span class="line">    // 内存地址0用于存放数据接收剩余周期数（一共8个周期，因为总共需要接收8个数据位）</span><br><span class="line">    mov 8, r1               // 28 | 00100001</span><br><span class="line">                            // 29 | 00001000</span><br><span class="line">    mov recv_bcnt, r0       // 2a | 00100000</span><br><span class="line">                            // 2b | 00000000 : recv_bcnt</span><br><span class="line">    mov r1, (r0)            // 2c | 00010100</span><br></pre></td></tr></table></figure><ul><li>Part 3：数据接收决策点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1.5个周期后是第一个采样点，所以先跳过一个采样点</span><br><span class="line">// 因为指令读取 attp 的行为对于时钟计数有延迟，这也是为什么需要让指令执行频率尽量高，因为我们需要让所谓的1.5个周期足够的小</span><br><span class="line">// 实际上有很小的概率把第一个采样点跳过，导致数据错误</span><br><span class="line">L2:                         // 2d</span><br><span class="line">    // 检测内存5是不是1，是的话就说明可以接收数据了</span><br><span class="line">    mov attp, r0            // 2d | 00100000</span><br><span class="line">                            // 2e | 00000101 : attp</span><br><span class="line">    mov (r0), r1            // 2f | 01100001</span><br><span class="line">    mov 1, r0               // 30 | 00100000</span><br><span class="line">                            // 31 | 00000001</span><br><span class="line">    and r0, r1              // 32 | 10000001</span><br><span class="line">    mov L2, r0              // 33 | 00100000</span><br><span class="line">                            // 34 | 00101101 : L2</span><br><span class="line">    // 不是1，继续等待</span><br><span class="line">    jz r0                   // 35 | 01001000</span><br><span class="line">    // 是1，进入数据接收Part，顺手把r0清零（养成好习惯，后面每一bit数据都要检测attp，因为硬件上内存只有给attp赋值位1的权限，所以attp清零必须依靠汇编代码）</span><br><span class="line">    xor r1, r1              // 36 | 10110101</span><br><span class="line">    mov attp, r0            // 37 | 00100000</span><br><span class="line">                            // 38 | 00000101</span><br><span class="line">    mov r1, (r0)            // 39 | 00010100</span><br></pre></td></tr></table></figure><ul><li>Part 4：数据接收</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">recv:                       // 3a</span><br><span class="line">    // attp 在 ucnt 到达 testpoint 时会自动设为1</span><br><span class="line">    // 检测 attp 即可得知是否到达当前采样点</span><br><span class="line">    mov attp, r0            // 3a | 00100000</span><br><span class="line">                            // 3b | 00000101 : attp</span><br><span class="line">    mov (r0), r1            // 3c | 01100001</span><br><span class="line">    mov 1, r0               // 3d | 00100000</span><br><span class="line">                            // 3e | 00000001</span><br><span class="line">    and r0, r1              // 3f | 10000001</span><br><span class="line">    // 没到采样点时跳转回recv</span><br><span class="line">    mov recv, r0            // 40 | 00100000</span><br><span class="line">                            // 41 | 00111010 : recv</span><br><span class="line">    jz r0                   // 42 | 01001000</span><br><span class="line"></span><br><span class="line">    // 否则开始采样，先右移将上次采样结果保留</span><br><span class="line">    // 再使用 in 指令将这次的接收线的值存下来</span><br><span class="line">    mov 1, r0               // 43 | 00100000</span><br><span class="line">                            // 44 | 00000001</span><br><span class="line">    shr r0, r3              // 45 | 11100011</span><br><span class="line">    in r3                   // 46 | 01010011</span><br><span class="line"></span><br><span class="line">    // 将 attp 置 0，以等待下次的采样点到达</span><br><span class="line">    xor r1, r1              // 47 | 10110101</span><br><span class="line">    mov attp, r0            // 48 | 00100000</span><br><span class="line">                            // 49 | 00000101 : attp</span><br><span class="line">    mov r1, (r0)            // 4a | 00010100</span><br><span class="line"></span><br><span class="line">    // 循环计数减1</span><br><span class="line">    mov recv_bcnt, r0       // 4b | 00100000</span><br><span class="line">                            // 4c | 00000000 : recv_bcnt</span><br><span class="line">    mov (r0), r1            // 4d | 01100001</span><br><span class="line">    mov 1, r0               // 4e | 00100000</span><br><span class="line">                            // 4f | 00000001</span><br><span class="line">    sub r0, r1              // 50 | 11110001</span><br><span class="line">    mov recv_bcnt, r0       // 51 | 00100000</span><br><span class="line">                            // 52 | 00000000 : recv_bcnt</span><br><span class="line">    mov r1, (r0)            // 53 | 00010100</span><br><span class="line">    mov 0xff, r0            // 54 | 00100000</span><br><span class="line">                            // 55 | 11111111</span><br><span class="line">    and r0, r1              // 56 | 10000001</span><br><span class="line"></span><br><span class="line">    // 循环计数为0时进入发送阶段</span><br><span class="line">    mov send_pre, r0        // 57 | 00100000</span><br><span class="line">                            // 58 | 01011101 : send_pre</span><br><span class="line">    jz r0                   // 59 | 01001000</span><br><span class="line"></span><br><span class="line">    // 否则跳回recv</span><br><span class="line">    mov recv, r0            // 5a | 00100000</span><br><span class="line">                            // 5b | 00111010 : recv</span><br><span class="line">    jmp r0                  // 5c | 01000000</span><br></pre></td></tr></table></figure><p>此时 r3 寄存器的值为接收到的数据帧的8个数据位，结束位直接忽略</p><ul><li>Part5 数据发送准备</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 发送准备阶段</span><br><span class="line">send_pre:                   // 5d</span><br><span class="line">    xor r1, r1              // 5d | 10110101</span><br><span class="line"></span><br><span class="line">    // 因为是发送，采样点简单设为0就行，不需要特殊计算</span><br><span class="line">    mov testpoint, r0       // 5e | 00100000</span><br><span class="line">                            // 5f | 00000110 : testpoint</span><br><span class="line">    mov r1, (r0)            // 60 | 00010100</span><br><span class="line"></span><br><span class="line">    mov attp, r0            // 61 | 00100000</span><br><span class="line">                            // 62 | 00000101 : attp</span><br><span class="line">    mov r1, (r0)            // 63 | 00010100</span><br><span class="line"></span><br><span class="line">    // 8个采样周期，作为循环计数，这里懒得改符号名了，所以还是 recv_bcnt</span><br><span class="line">    // (recv_bcnt) = 8</span><br><span class="line">    mov 8, r1               // 64 | 00100001</span><br><span class="line">                            // 65 | 00001000</span><br><span class="line">    mov recv_bcnt, r0       // 66 | 00100000</span><br><span class="line">                            // 67 | 00000000 : recv_bcnt</span><br><span class="line">    mov r1, (r0)            // 68 | 00010100</span><br></pre></td></tr></table></figure><ul><li>Part6 数据发送</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 加载起始位</span><br><span class="line">L1:                         // 69</span><br><span class="line">    mov attp, r0            // 69 | 00100000</span><br><span class="line">                            // 6a | 00000101 : attp</span><br><span class="line">    mov (r0), r1            // 6b | 01100001</span><br><span class="line">    mov 1, r0               // 6c | 00100000</span><br><span class="line">                            // 6d | 00000001</span><br><span class="line">    and r0, r1              // 6e | 10000001</span><br><span class="line">    mov L1, r0              // 6f | 00100000</span><br><span class="line">                            // 70 | 01101001 : L1</span><br><span class="line">    jz r0                   // 71 | 01001000</span><br><span class="line"></span><br><span class="line">    // r0 归零，并输出 r0</span><br><span class="line">    xor r0, r0              // 72 | 10110000</span><br><span class="line">    out r0                  // 73 | 01010100</span><br><span class="line"></span><br><span class="line">    // 将 attp 置 0，以等待下次的采样点到达</span><br><span class="line">    xor r1, r1              // 74 | 10110101</span><br><span class="line">    mov attp, r0            // 75 | 00100000</span><br><span class="line">                            // 76 | 00000101 : attp</span><br><span class="line">    mov r1, (r0)            // 77 | 00010100</span><br><span class="line"></span><br><span class="line">// 发送8个数据位</span><br><span class="line">send:                       // 78</span><br><span class="line">    mov attp, r0            // 78 | 00100000</span><br><span class="line">                            // 79 | 00000101 : attp</span><br><span class="line">    mov (r0), r1            // 7a | 01100001</span><br><span class="line">    mov 1, r0               // 7b | 00100000</span><br><span class="line">                            // 7c | 00000001</span><br><span class="line">    and r0, r1              // 7d | 10000001</span><br><span class="line"></span><br><span class="line">    // 没到采样点时跳回 send</span><br><span class="line">    mov send, r0            // 7e | 00100000</span><br><span class="line">                            // 7f | 01111000 : send</span><br><span class="line">    jz r0                   // 80 | 01001000</span><br><span class="line"></span><br><span class="line">    // 先输出 r3 ，再将 r3 右移，这样下次再执行到这里时，输出的最低位依然是要发送的位</span><br><span class="line">    out r3                  // 81 | 01010111</span><br><span class="line">    mov 1, r0               // 82 | 00100000</span><br><span class="line">                            // 83 | 00000001</span><br><span class="line">    shr r0, r3              // 84 | 11100011</span><br><span class="line"></span><br><span class="line">    // attp 置 0，不再重复说明</span><br><span class="line">    xor r1, r1              // 85 | 10110101</span><br><span class="line">    mov attp, r0            // 86 | 00100000</span><br><span class="line">                            // 87 | 00000101 : attp</span><br><span class="line">    mov r1, (r0)            // 88 | 00010100</span><br><span class="line"></span><br><span class="line">    // 循环计数减1</span><br><span class="line">    mov recv_bcnt, r0       // 89 | 00100000</span><br><span class="line">                            // 8a | 00000000 : recv_bcnt</span><br><span class="line">    mov (r0), r1            // 8b | 01100001</span><br><span class="line">    mov 1, r0               // 8c | 00100000</span><br><span class="line">                            // 8d | 00000001</span><br><span class="line">    sub r0, r1              // 8e | 11110001</span><br><span class="line">    mov recv_bcnt, r0       // 8f | 00100000</span><br><span class="line">                            // 90 | 00000000 : recv_bcnt</span><br><span class="line">    mov r1, (r0)            // 91 | 00010100</span><br><span class="line">    mov 0xf, r0             // 92 | 00100000</span><br><span class="line">                            // 93 | 00001111</span><br><span class="line">    and r0, r1              // 94 | 10000001</span><br><span class="line"></span><br><span class="line">    // 循环计数为0时发送完成，即将发送结束位</span><br><span class="line">    mov tr_end, r0          // 95 | 00100000</span><br><span class="line">                            // 96 | 10011011 : tr_end</span><br><span class="line">    jz r0                   // 97 | 01001000</span><br><span class="line"></span><br><span class="line">    // 否则回到 send，发送下一位</span><br><span class="line">    mov send, r0            // 98 | 00100000</span><br><span class="line">                            // 99 | 01111000 : send</span><br><span class="line">    jmp r0                  // 9a | 01000000</span><br></pre></td></tr></table></figure><p>发送逻辑和接收逻辑相似，因此解释会少很多</p><ul><li>Part7 结束位发送</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 传输完成，发送结束位</span><br><span class="line">tr_end:                     // 9b</span><br><span class="line">    mov attp, r0            // 9b | 00100000</span><br><span class="line">                            // 9c | 00000101 : attp</span><br><span class="line">    mov (r0), r1            // 9d | 01100001</span><br><span class="line">    mov 1, r0               // 9e | 00100000</span><br><span class="line">                            // 9f | 00000001</span><br><span class="line">    and r0, r1              // a0 | 10000001</span><br><span class="line"></span><br><span class="line">    // 同样读取 attp ，没到采样点时跳回 tr_end</span><br><span class="line">    mov tr_end, r0          // a1 | 00100000</span><br><span class="line">                            // a2 | 10011011 : tr_end</span><br><span class="line">    jz r0                   // a3 | 01001000</span><br><span class="line"></span><br><span class="line">    // 加载结束位</span><br><span class="line">    mov 1, r0               // a4 | 00100000</span><br><span class="line">                            // a5 | 00000001</span><br><span class="line">    out r0                  // a6 | 01010100</span><br><span class="line"></span><br><span class="line">    // 回到开头接收下一个字节</span><br><span class="line">    rtn                     // a7 | 01110000</span><br></pre></td></tr></table></figure><p>汇编代码完整版：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">section text</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待第一个下降沿</span></span><br><span class="line">L0:</span><br><span class="line">    <span class="keyword">xor</span> r3, r3              <span class="comment">// 00 | 10111111</span></span><br><span class="line">    <span class="keyword">not</span> r3                  <span class="comment">// 01 | 10100011</span></span><br><span class="line">    in r0                   <span class="comment">// 02 | 01010000</span></span><br><span class="line">    <span class="comment">// 下降沿后， and 指令会设置一个零标志</span></span><br><span class="line">    <span class="keyword">and</span> r0, r3              <span class="comment">// 03 | 10000011</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 零标志时跳转至 recv_pre</span></span><br><span class="line">    mov recv_pre, r0        <span class="comment">// 04 | 00100000</span></span><br><span class="line">                            <span class="comment">// 05 | 00001000 : recv_pre</span></span><br><span class="line">    jz r0                   <span class="comment">// 06 | 01001000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不跳转回到开头继续等待</span></span><br><span class="line">    rtn                     <span class="comment">// 07 | 01110000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个下降沿后，计算采样点的计数（当前计数+108）          // 可直接存储立即数</span></span><br><span class="line">recv_pre:                   <span class="comment">// 08</span></span><br><span class="line">    <span class="comment">// r3=108</span></span><br><span class="line">    mov <span class="number">5</span>, r0               <span class="comment">// 08 | 00100000</span></span><br><span class="line">                            <span class="comment">// 09 | 00000101</span></span><br><span class="line">    mov <span class="number">3</span>, r3               <span class="comment">// 0a | 00100011</span></span><br><span class="line">                            <span class="comment">// 0b | 00000011</span></span><br><span class="line">    shl r0, r3              <span class="comment">// 0c | 11000011</span></span><br><span class="line">    mov <span class="number">0</span>xc, r0             <span class="comment">// 0d | 00100000</span></span><br><span class="line">                            <span class="comment">// 0e | 00001100</span></span><br><span class="line">    add r0, r3              <span class="comment">// 0f | 11010011</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// r1 = ucnt - 108</span></span><br><span class="line">    mov ucnt, r0            <span class="comment">// 10 | 00100000</span></span><br><span class="line">                            <span class="comment">// 11 | 00000111 : ucnt</span></span><br><span class="line"></span><br><span class="line">    mov (r0), r1            <span class="comment">// 12 | 01100001</span></span><br><span class="line">    sub r3, r1              <span class="comment">// 13 | 11111101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (r1 &lt; 0) r1 = r1 + 216                         // 可直接使用 jc 判断</span></span><br><span class="line">    mov <span class="number">7</span>, r2               <span class="comment">// 14 | 00100010</span></span><br><span class="line">                            <span class="comment">// 15 | 00000111</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 16 | 00100000</span></span><br><span class="line">                            <span class="comment">// 17 | 00000001</span></span><br><span class="line">    shl r2, r0              <span class="comment">// 18 | 11001000</span></span><br><span class="line">    <span class="keyword">and</span> r0, r1              <span class="comment">// 19 | 10000001</span></span><br><span class="line">    mov <span class="number">1</span>f, r0              <span class="comment">// 1a | 00100000</span></span><br><span class="line">                            <span class="comment">// 1b | 00100001 : 1f</span></span><br><span class="line">    jz r0                   <span class="comment">// 1c | 01001000</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 1d | 00100000</span></span><br><span class="line">                            <span class="comment">// 1e | 00000001</span></span><br><span class="line">    <span class="comment">// r3 &lt;&lt; 1 (r3 = 216)</span></span><br><span class="line">    shl r0, r3              <span class="comment">// 1f | 11000011</span></span><br><span class="line">    add r3, r1              <span class="comment">// 20 | 11011101</span></span><br><span class="line">    <span class="number">1</span>:                      <span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (testpoint) = r1</span></span><br><span class="line">    mov testpoint, r0       <span class="comment">// 21 | 00100000</span></span><br><span class="line">                            <span class="comment">// 22 | 00000110 : testpoint</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 23 | 00010100</span></span><br><span class="line">    <span class="comment">// (attp) = 0</span></span><br><span class="line">    <span class="keyword">xor</span> r1, r1              <span class="comment">// 24 | 10110101</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 25 | 00100000</span></span><br><span class="line">                            <span class="comment">// 26 | 00000101 : attp</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 27 | 00010100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8个采样周期，作为循环计数</span></span><br><span class="line">    <span class="comment">// (recv_bcnt) = 8</span></span><br><span class="line">    mov <span class="number">8</span>, r1               <span class="comment">// 28 | 00100001</span></span><br><span class="line">                            <span class="comment">// 29 | 00001000</span></span><br><span class="line">    mov recv_bcnt, r0       <span class="comment">// 2a | 00100000</span></span><br><span class="line">                            <span class="comment">// 2b | 00000000 : recv_bcnt</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 2c | 00010100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.5个周期后是第一个采样点，所以先跳过一个采样点</span></span><br><span class="line"><span class="comment">// 因为指令读取 attp 的行为对于时钟计数有延迟，</span></span><br><span class="line"><span class="comment">// 实际上有很小的概率把第一个采样点跳过，导致数据错误</span></span><br><span class="line">L2:                         <span class="comment">// 2d</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 2d | 00100000</span></span><br><span class="line">                            <span class="comment">// 2e | 00000101 : attp</span></span><br><span class="line">    mov (r0), r1            <span class="comment">// 2f | 01100001</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 30 | 00100000</span></span><br><span class="line">                            <span class="comment">// 31 | 00000001</span></span><br><span class="line">    <span class="keyword">and</span> r0, r1              <span class="comment">// 32 | 10000001</span></span><br><span class="line">    mov L2, r0              <span class="comment">// 33 | 00100000</span></span><br><span class="line">                            <span class="comment">// 34 | 00101101 : L2</span></span><br><span class="line">    jz r0                   <span class="comment">// 35 | 01001000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">xor</span> r1, r1              <span class="comment">// 36 | 10110101</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 37 | 00100000</span></span><br><span class="line">                            <span class="comment">// 38 | 00000101</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 39 | 00010100</span></span><br><span class="line"></span><br><span class="line">recv:                       <span class="comment">// 3a</span></span><br><span class="line">    <span class="comment">// attp 在 ucnt 到达 testpoint 时会自动设为1</span></span><br><span class="line">    <span class="comment">// 检测 attp 即可得知是否到达当前采样点</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 3a | 00100000</span></span><br><span class="line">                            <span class="comment">// 3b | 00000101 : attp</span></span><br><span class="line">    mov (r0), r1            <span class="comment">// 3c | 01100001</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 3d | 00100000</span></span><br><span class="line">                            <span class="comment">// 3e | 00000001</span></span><br><span class="line">    <span class="keyword">and</span> r0, r1              <span class="comment">// 3f | 10000001</span></span><br><span class="line">    <span class="comment">// 没到采样点时跳转回recv</span></span><br><span class="line">    mov recv, r0            <span class="comment">// 40 | 00100000</span></span><br><span class="line">                            <span class="comment">// 41 | 00111010 : recv</span></span><br><span class="line">    jz r0                   <span class="comment">// 42 | 01001000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则开始采样，先右移将上次采样结果保留</span></span><br><span class="line">    <span class="comment">// 再使用 in 指令将这次的接收线的值存下来</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 43 | 00100000</span></span><br><span class="line">                            <span class="comment">// 44 | 00000001</span></span><br><span class="line">    shr r0, r3              <span class="comment">// 45 | 11100011</span></span><br><span class="line">    in r3                   <span class="comment">// 46 | 01010011</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 attp 置 0，以等待下次的采样点到达</span></span><br><span class="line">    <span class="keyword">xor</span> r1, r1              <span class="comment">// 47 | 10110101</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 48 | 00100000</span></span><br><span class="line">                            <span class="comment">// 49 | 00000101 : attp</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 4a | 00010100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环计数减1</span></span><br><span class="line">    mov recv_bcnt, r0       <span class="comment">// 4b | 00100000</span></span><br><span class="line">                            <span class="comment">// 4c | 00000000 : recv_bcnt</span></span><br><span class="line">    mov (r0), r1            <span class="comment">// 4d | 01100001</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 4e | 00100000</span></span><br><span class="line">                            <span class="comment">// 4f | 00000001</span></span><br><span class="line">    sub r0, r1              <span class="comment">// 50 | 11110001</span></span><br><span class="line">    mov recv_bcnt, r0       <span class="comment">// 51 | 00100000</span></span><br><span class="line">                            <span class="comment">// 52 | 00000000 : recv_bcnt</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 53 | 00010100</span></span><br><span class="line">    mov <span class="number">0</span>xff, r0            <span class="comment">// 54 | 00100000</span></span><br><span class="line">                            <span class="comment">// 55 | 11111111</span></span><br><span class="line">    <span class="keyword">and</span> r0, r1              <span class="comment">// 56 | 10000001</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环计数为0时进入发送阶段</span></span><br><span class="line">    mov send_pre, r0        <span class="comment">// 57 | 00100000</span></span><br><span class="line">                            <span class="comment">// 58 | 01011101 : send_pre</span></span><br><span class="line">    jz r0                   <span class="comment">// 59 | 01001000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则跳回recv</span></span><br><span class="line">    mov recv, r0            <span class="comment">// 5a | 00100000</span></span><br><span class="line">                            <span class="comment">// 5b | 00111010 : recv</span></span><br><span class="line">    jmp r0                  <span class="comment">// 5c | 01000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送准备阶段</span></span><br><span class="line">send_pre:                   <span class="comment">// 5d</span></span><br><span class="line">    <span class="keyword">xor</span> r1, r1              <span class="comment">// 5d | 10110101</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为是发送，采样点简单设为0就行，不需要特殊计算</span></span><br><span class="line">    mov testpoint, r0       <span class="comment">// 5e | 00100000</span></span><br><span class="line">                            <span class="comment">// 5f | 00000110 : testpoint</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 60 | 00010100</span></span><br><span class="line"></span><br><span class="line">    mov attp, r0            <span class="comment">// 61 | 00100000</span></span><br><span class="line">                            <span class="comment">// 62 | 00000101 : attp</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 63 | 00010100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8个采样周期，作为循环计数，这里懒得改符号名了，所以还是 recv_bcnt</span></span><br><span class="line">    <span class="comment">// (recv_bcnt) = 8</span></span><br><span class="line">    mov <span class="number">8</span>, r1               <span class="comment">// 64 | 00100001</span></span><br><span class="line">                            <span class="comment">// 65 | 00001000</span></span><br><span class="line">    mov recv_bcnt, r0       <span class="comment">// 66 | 00100000</span></span><br><span class="line">                            <span class="comment">// 67 | 00000000 : recv_bcnt</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 68 | 00010100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载起始位</span></span><br><span class="line">L1:                         <span class="comment">// 69</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 69 | 00100000</span></span><br><span class="line">                            <span class="comment">// 6a | 00000101 : attp</span></span><br><span class="line">    mov (r0), r1            <span class="comment">// 6b | 01100001</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 6c | 00100000</span></span><br><span class="line">                            <span class="comment">// 6d | 00000001</span></span><br><span class="line">    <span class="keyword">and</span> r0, r1              <span class="comment">// 6e | 10000001</span></span><br><span class="line">    mov L1, r0              <span class="comment">// 6f | 00100000</span></span><br><span class="line">                            <span class="comment">// 70 | 01101001 : L1</span></span><br><span class="line">    jz r0                   <span class="comment">// 71 | 01001000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// r0 归零，并输出 r0</span></span><br><span class="line">    <span class="keyword">xor</span> r0, r0              <span class="comment">// 72 | 10110000</span></span><br><span class="line">    out r0                  <span class="comment">// 73 | 01010100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 attp 置 0，以等待下次的采样点到达</span></span><br><span class="line">    <span class="keyword">xor</span> r1, r1              <span class="comment">// 74 | 10110101</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 75 | 00100000</span></span><br><span class="line">                            <span class="comment">// 76 | 00000101 : attp</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 77 | 00010100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送8个数据位</span></span><br><span class="line">send:                       <span class="comment">// 78</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 78 | 00100000</span></span><br><span class="line">                            <span class="comment">// 79 | 00000101 : attp</span></span><br><span class="line">    mov (r0), r1            <span class="comment">// 7a | 01100001</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 7b | 00100000</span></span><br><span class="line">                            <span class="comment">// 7c | 00000001</span></span><br><span class="line">    <span class="keyword">and</span> r0, r1              <span class="comment">// 7d | 10000001</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没到采样点时跳回 send</span></span><br><span class="line">    mov send, r0            <span class="comment">// 7e | 00100000</span></span><br><span class="line">                            <span class="comment">// 7f | 01111000 : send</span></span><br><span class="line">    jz r0                   <span class="comment">// 80 | 01001000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先输出 r3 ，再将 r3 右移，这样下次再执行到这里时，输出的最低位依然是要发送的位</span></span><br><span class="line">    out r3                  <span class="comment">// 81 | 01010111</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 82 | 00100000</span></span><br><span class="line">                            <span class="comment">// 83 | 00000001</span></span><br><span class="line">    shr r0, r3              <span class="comment">// 84 | 11100011</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// attp 置 0，不再重复说明</span></span><br><span class="line">    <span class="keyword">xor</span> r1, r1              <span class="comment">// 85 | 10110101</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 86 | 00100000</span></span><br><span class="line">                            <span class="comment">// 87 | 00000101 : attp</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 88 | 00010100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环计数减1</span></span><br><span class="line">    mov recv_bcnt, r0       <span class="comment">// 89 | 00100000</span></span><br><span class="line">                            <span class="comment">// 8a | 00000000 : recv_bcnt</span></span><br><span class="line">    mov (r0), r1            <span class="comment">// 8b | 01100001</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 8c | 00100000</span></span><br><span class="line">                            <span class="comment">// 8d | 00000001</span></span><br><span class="line">    sub r0, r1              <span class="comment">// 8e | 11110001</span></span><br><span class="line">    mov recv_bcnt, r0       <span class="comment">// 8f | 00100000</span></span><br><span class="line">                            <span class="comment">// 90 | 00000000 : recv_bcnt</span></span><br><span class="line">    mov r1, (r0)            <span class="comment">// 91 | 00010100</span></span><br><span class="line">    mov <span class="number">0</span>xf, r0             <span class="comment">// 92 | 00100000</span></span><br><span class="line">                            <span class="comment">// 93 | 00001111</span></span><br><span class="line">    <span class="keyword">and</span> r0, r1              <span class="comment">// 94 | 10000001</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环计数为0时发送完成，即将发送结束位</span></span><br><span class="line">    mov tr_end, r0          <span class="comment">// 95 | 00100000</span></span><br><span class="line">                            <span class="comment">// 96 | 10011011 : tr_end</span></span><br><span class="line">    jz r0                   <span class="comment">// 97 | 01001000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则回到 send，发送下一位</span></span><br><span class="line">    mov send, r0            <span class="comment">// 98 | 00100000</span></span><br><span class="line">                            <span class="comment">// 99 | 01111000 : send</span></span><br><span class="line">    jmp r0                  <span class="comment">// 9a | 01000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输完成，发送结束位</span></span><br><span class="line">tr_end:                     <span class="comment">// 9b</span></span><br><span class="line">    mov attp, r0            <span class="comment">// 9b | 00100000</span></span><br><span class="line">                            <span class="comment">// 9c | 00000101 : attp</span></span><br><span class="line">    mov (r0), r1            <span class="comment">// 9d | 01100001</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// 9e | 00100000</span></span><br><span class="line">                            <span class="comment">// 9f | 00000001</span></span><br><span class="line">    <span class="keyword">and</span> r0, r1              <span class="comment">// a0 | 10000001</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样读取 attp ，没到采样点时跳回 tr_end</span></span><br><span class="line">    mov tr_end, r0          <span class="comment">// a1 | 00100000</span></span><br><span class="line">                            <span class="comment">// a2 | 10011011 : tr_end</span></span><br><span class="line">    jz r0                   <span class="comment">// a3 | 01001000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载结束位</span></span><br><span class="line">    mov <span class="number">1</span>, r0               <span class="comment">// a4 | 00100000</span></span><br><span class="line">                            <span class="comment">// a5 | 00000001</span></span><br><span class="line">    out r0                  <span class="comment">// a6 | 01010100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回到开头接收下一个字节</span></span><br><span class="line">    rtn                     <span class="comment">// a7 | 01110000</span></span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line"></span><br><span class="line">recv_bcnt: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">preserved: resb <span class="number">5</span> - .</span><br><span class="line"></span><br><span class="line">attp: <span class="number">0</span></span><br><span class="line">testpoint: <span class="number">0</span></span><br><span class="line">ucnt:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>汇编代码完成，没写汇编器，靠人编的（见汇编代码右侧注释），然后利用一个简单的程序将该汇编代码中的所有8位指令码提取出来，相信各位的软件能力，简单demo呈现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;  <span class="comment">// 全局计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">extractor</span><span class="params">(<span class="type">const</span> std::string&amp; input)</span> </span>&#123;</span><br><span class="line">    std::string result;</span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">find</span>(<span class="string">&quot;(replaced)&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 如果没有 &quot;(replaced)&quot;，直接返回原始字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sz = input.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sz - <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i + j] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; input[i + j] &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;  <span class="comment">// 如果有非数字字符，标记为true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;  <span class="comment">// 如果没有非数字字符</span></span><br><span class="line">            result += input.<span class="built_in">substr</span>(i, <span class="number">8</span>);  <span class="comment">// 提取8个字符</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Extracted: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;  <span class="comment">// 输出提取的字符串</span></span><br><span class="line">            ++cnt;  <span class="comment">// 增加计数器</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 如果没有找到符合条件的字符串，返回空字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processFile</span><span class="params">(<span class="type">const</span> std::string&amp; inputFilename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造输出文件名</span></span><br><span class="line">    <span class="type">size_t</span> dotPos = inputFilename.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    std::string outputFilename = inputFilename.<span class="built_in">substr</span>(<span class="number">0</span>, dotPos) + <span class="string">&quot;_ic.hex&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(inputFilename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Could not open input file &quot;</span> &lt;&lt; inputFilename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(outputFilename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Could not create output file &quot;</span> &lt;&lt; outputFilename &lt;&lt; std::endl;</span><br><span class="line">        inputFile.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐行处理文件</span></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inputFile, line)) &#123;</span><br><span class="line">        std::string result = <span class="built_in">extractor</span>(line);</span><br><span class="line">        <span class="keyword">if</span> (!result.<span class="built_in">empty</span>()) &#123;  <span class="comment">// 只有结果非空时才写入</span></span><br><span class="line">            outputFile &lt;&lt; result &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    inputFile.<span class="built_in">close</span>();</span><br><span class="line">    outputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing completed. Results written to &quot;</span> &lt;&lt; outputFilename &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;input_file.xxx&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string inputFilename = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">processFile</span>(inputFilename);</span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(inputFilename.substr(<span class="number">0</span>, inputFilename.find_last_of(<span class="string">&#x27;.&#x27;</span>)) + <span class="string">&quot;_ic.hex&quot;</span>, std::ios::app)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        outputFile &lt;&lt; <span class="string">&quot;00000000\n&quot;</span>;  <span class="comment">// 填充空行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./[可执行程序名称] [文件名]</span><br></pre></td></tr></table></figure><p>比如说我的可执行程序时 icex.exe，需要提取8位指令码的文件为 uart.asm，那么我就输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./icex.exe uart.asm</span><br></pre></td></tr></table></figure><h3><span id="超频">超频</span></h3><p>感兴趣的可以看看，结论先放出来，不分配是最好的<br>接下来我们需要决策一下使用几分频：</p><p>首先试一试四分频（数据传输安全，但帧率低）：</p><p><img src="/img/HD/serial_port_communication/result_clk4.png" alt="serial_port_communication"></p><p>然后试试二分频（数据传输不太安全，但帧率变高）：</p><p><img src="/img/HD/serial_port_communication/result_clk2.png" alt="serial_port_communication"></p><p>最后试一试不分频（数据传输没有保障，但帧率极高）：</p><p><img src="/img/HD/serial_port_communication/result_clk.png" alt="serial_port_communication"></p><p>那么，我们该如何计算正确率呢，没错，再写一个小demo：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculater</span><span class="params">(<span class="type">const</span> std::string &amp;inputFilename, <span class="type">const</span> std::string &amp;compare_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(inputFilename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Could not open input file &quot;</span> &lt;&lt; inputFilename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> total_num = <span class="number">0</span>, true_num = <span class="number">0</span>;</span><br><span class="line">    std::string word;</span><br><span class="line">    <span class="keyword">while</span>(inputFile &gt;&gt; word)</span><br><span class="line">    &#123;</span><br><span class="line">        ++total_num;</span><br><span class="line">        <span class="keyword">if</span>(word == compare_num) ++true_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)(true_num) / total_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;input_file.xxx&gt;&quot;</span> &lt;&lt; <span class="string">&quot;compare_str&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string inputFilename = argv[<span class="number">1</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">calculater</span>(inputFilename, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测正确率如下，从上至下分别是四分频，二分频以及不分频：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\altera\90\quartus\project\core8&gt; ./acc.exe check.txt 8A</span><br><span class="line">0.807823</span><br><span class="line">PS C:\altera\90\quartus\project\core8&gt; ./acc.exe check.txt 8A</span><br><span class="line">0.880952</span><br><span class="line">PS C:\altera\90\quartus\project\core8&gt; ./acc.exe check.txt 8A</span><br><span class="line">0.955782</span><br></pre></td></tr></table></figure><p>最后把所有的代码（适配uart版本）呈现给大家：</p><p>适配 uart 的 CPU 代码<br><a href="/demo/serial_port_communication/core8.v">core8.v</a><br>uart 汇编代码<br><a href="/demo/serial_port_communication/uart.asm">uart.asm</a><br>辅助\测试工具 demo<br><a href="/demo/serial_port_communication/icex.cpp">icex.cpp</a><br><a href="/demo/serial_port_communication/accurancy.cpp">accurancy.cpp</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 硬件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quartus2 </tag>
            
            <tag> 性能 </tag>
            
            <tag> CPU </tag>
            
            <tag> 8bit </tag>
            
            <tag> 通信 </tag>
            
            <tag> uarp协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8位CPU硬件设计</title>
      <link href="/2025/06/25/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/8%E4%BD%8DCPU%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/06/25/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/8%E4%BD%8DCPU%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0">设计概述</a></li><li><a href="#%E5%9F%BA%E4%BA%8E%E8%BF%99%E4%B8%AA%E6%A1%86%E6%9E%B6%E5%9B%BE%E6%88%91%E4%BB%AC%E5%B0%86%E4%BE%9D%E6%AC%A1%E8%AE%BE%E8%AE%A1%E5%90%84%E4%B8%AA%E9%83%A8%E4%BB%B6%E7%9A%84%E6%A8%A1%E5%9D%97%E9%80%BB%E8%BE%91"><strong>基于这个框架图，我们将依次设计各个部件的模块逻辑</strong></a><ul><li><a href="#%E4%B8%80-pc%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">一、PC模块设计</a></li><li><a href="#%E4%BA%8C-alu%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">二、ALU模块设计</a></li><li><a href="#%E4%B8%89-%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">三、寄存器组模块设计</a></li><li><a href="#%E5%9B%9B-%E6%8C%87%E4%BB%A4%E5%AD%98%E5%82%A8%E5%99%A8%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">四、指令存储器模块设计</a></li><li><a href="#%E4%BA%94-%E4%B8%BB%E5%AD%98%E6%A8%A1%E5%9D%97">五、主存模块</a></li><li><a href="#%E5%85%AD-%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9D%97">六、指令寄存器模块</a></li><li><a href="#%E4%B8%83-cu%E6%A8%A1%E5%9D%97">七、CU模块</a></li></ul></li><li><a href="#%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97">顶层模块</a></li></ul><!-- tocstop --><p>合作方：<a href="https://github.com/pointertobios/" title="跳转到ptb">pointer-to-bios</a></p><p>设计概要如下：</p><p>设计要求：<br>1、通用寄存器8位，ALU 8位，内部数据总线8位。<br>2、支持4个8位通用寄存器R0、R1、R2和R3。<br>3、标志寄存器（FLAGS或者PSW）应至少有CF和ZF标志位。<br>4、指令长度8位（指令操作码4位，指令操作数合计4位），指令寄存器IR 8位，程序（指令）计数器PC 8位。<br>5、至少支持下列指令：MOV、ADD、SUB、AND、OR、NOT、XOR和RTN，其中RTN指令用于将PC清零，即返回程序第一条指令重新开始执行。<br>6、设计SHL、SHR等移位指令。<br>7、设计LD、ST等内存数据读写指令。<br>8、可选设计JMP、JZ、JNZ等跳转指令。<br>9、可以具备基本的通用寄存器监控功能用于调试程序。<br>10、考虑与硬件外设连接的扩展设计能力。</p><p>在设计一个通用8位 CPU 之前，首先需要考虑的是如何设计一个 CPU 物理结构图，这里我们先建设一个简易的物理逻辑框架出来：</p><p><img src="/img/HD/CPU_8bit/8bit_CPU.png" alt="CPU_8bit"></p><h2><span id="设计概述">设计概述</span></h2><ol><li>地址总线</li></ol><p>地址总线实际上是CU输出的控制信号，为了降低CU的复杂度，将部分仅有输入&#x2F;输出语义控制信号的模块编址，形成3位目标&#x2F;源地址总线对，大大减少CU的控制信号数量。</p><ol start="2"><li>数据总线的实现</li></ol><p>本CPU在FPGA平台 Quartus2 上实现，结构图中的所有输出到总线的信号线通过多路复用实现，否则综合器有可能将全部模块都优化掉。</p><ol start="3"><li>锁相环</li></ol><p>由于本CPU最终将运行在物理芯片中，需要使用锁相环将芯片的全局时钟频率调整到CPU时序延迟允许之内。</p><h2><span id="基于这个框架图我们将依次设计各个部件的模块逻辑"><strong>基于这个框架图，我们将依次设计各个部件的模块逻辑</strong></span></h2><h3><span id="一-pc模块设计">一、PC模块设计</span></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> PC(</span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="keyword">input</span>         pc_inc,       <span class="comment">// PC是否自增</span></span><br><span class="line">    <span class="keyword">input</span>         reset,</span><br><span class="line">    (* keep, preserve *)<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] databus       <span class="comment">// 统一数据总线</span></span><br><span class="line">);</span><br><span class="line">    <span class="comment">// reg [7:0] cur_pc;     // 当前程序计数器值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//PC自增寄存器</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] next_pc;</span><br><span class="line">    <span class="keyword">wire</span> co;</span><br><span class="line">    <span class="comment">// 三态总线驱动（完全由外部控制）</span></span><br><span class="line">    Adder PCInc(</span><br><span class="line">        <span class="variable">.op1</span>(databus),</span><br><span class="line">        <span class="variable">.op2</span>(<span class="number">8&#x27;h01</span>),</span><br><span class="line">        <span class="variable">.suben</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="variable">.sum</span>(next_pc),</span><br><span class="line">        <span class="variable">.co</span>(co)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 输出到总线</span></span><br><span class="line">    <span class="comment">// assign databus = cur_pc; // 当pc_out为1时，输出当前PC值，否则为高阻态</span></span><br><span class="line">    <span class="comment">// PC核心逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset)              <span class="comment">// PC置零</span></span><br><span class="line">            databus &lt;= <span class="number">8&#x27;h00</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pc_inc)        <span class="comment">// PC自增</span></span><br><span class="line">            databus &lt;= next_pc;</span><br><span class="line">        <span class="keyword">else</span> databus &lt;= databus;  <span class="comment">// PC不变（无信号）</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>PC信号指示图：<br><img src="/img/HD/CPU_8bit/PC_1.png" alt="PC"></p><p>输入端有时钟信号，而通过 PC 逻辑图我们可以看出，PC 需要两个（出去输出信号），一个是控制 PC 自增的信号，一个是让 PC 计数器清零的信号，这两个信号均有CU模块控制</p><p>而在 PC 内部，PC 模块需要有一个 add 模块用于计算 PC 自增后的下一个数是多少，这个加法逻辑单元直接复用 ALU 模块中的加法器即可</p><p>PC 的信号输出由 always 模块去控制，当到达时钟上升沿或者 reset 信号上升沿（reset变为1）的时候，就会触发 PC 内部值的改变，若遇到 reset 信号，则将输出总线数据置零，若<br>遇到 pc_inc 信号为1，则将 PC 早已算好的 next_pc 传给 总线输出单元，PC 单元的值会再次传递给加法器 Adder 的输入，因为 Adder 为组合电路，因此，几乎在同一时刻 PC 的next_pc会<br>再次计算好，等待 PC 接收到下一个 pc_inc 信号</p><h3><span id="二-alu模块设计">二、ALU模块设计</span></h3><p>代码总体设计如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU(databus,inbus,clk,alua_in,alub_in,sel,cf);</span><br><span class="line">  (* keep, preserve *)<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] databus;       <span class="comment">// 统一数据总线</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] inbus;</span><br><span class="line">  <span class="keyword">input</span> clk;</span><br><span class="line">  <span class="keyword">input</span> alua_in;</span><br><span class="line">  <span class="keyword">input</span> alub_in;</span><br><span class="line">  <span class="keyword">input</span>[<span class="number">2</span>:<span class="number">0</span>] sel;</span><br><span class="line">  <span class="keyword">output</span> cf;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] op1;</span><br><span class="line">  <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] op2;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] result;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  OPReg A(clk,alua_in,inbus,op1);</span><br><span class="line">    OPReg B(clk, alub_in,inbus,op2);</span><br><span class="line">  ALUCore u1(op1,op2,sel,result,cf);</span><br><span class="line">  <span class="comment">// OutputBufReg R(clk,result,alu_out,databus);</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">      databus&lt;=result;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> OPReg(clk,we,din,dout);</span><br><span class="line">  <span class="keyword">input</span> clk;</span><br><span class="line">  <span class="keyword">input</span> we;</span><br><span class="line">  <span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] din;</span><br><span class="line">  <span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] dout;</span><br><span class="line">  <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] dout;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(we==<span class="number">1&#x27;b1</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      dout &lt;= din;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ALUCore(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  op1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  op2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>]  sel,    <span class="comment">// 扩展为3位操作码</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] result,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>       cf</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法器接口</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] adder_op1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] adder_op2;</span><br><span class="line">    <span class="keyword">reg</span> suben;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] adder_sum;</span><br><span class="line">    <span class="keyword">wire</span> adder_cout;</span><br><span class="line">    </span><br><span class="line">    Adder u1(adder_op2, adder_op1, suben, adder_sum, adder_cout);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">            <span class="comment">// 算术运算</span></span><br><span class="line">            <span class="number">3&#x27;b000</span>, <span class="number">3&#x27;b001</span>: <span class="keyword">begin</span>  <span class="comment">// 加法/减法</span></span><br><span class="line">                <span class="comment">// 汇编代码其实是左源右目标，所以反过来放</span></span><br><span class="line">                adder_op1 = op1;</span><br><span class="line">                adder_op2 = op2;</span><br><span class="line">                suben = sel[<span class="number">0</span>];</span><br><span class="line">                result = adder_sum;</span><br><span class="line">                cf = adder_cout;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b010</span>: <span class="keyword">begin</span>  <span class="comment">// 左移</span></span><br><span class="line">                adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>; <span class="comment">// 左移不需要减法</span></span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>; <span class="comment">// 左移不产生进位</span></span><br><span class="line">                <span class="comment">// if(adder_op1[7] | adder_op1[6] | adder_op1[5] | adder_op1[4] | adder_op1[3]) begin</span></span><br><span class="line">                <span class="comment">//     result = 8&#x27;b0; // 左移后全零</span></span><br><span class="line">                <span class="comment">// end else begin</span></span><br><span class="line">                result = op2 &lt;&lt; op1;</span><br><span class="line">                <span class="comment">// end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b011</span>: <span class="keyword">begin</span>  <span class="comment">// 右移</span></span><br><span class="line">                adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>; <span class="comment">// 左移不需要减法</span></span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>; <span class="comment">// 左移不产生进位</span></span><br><span class="line">                <span class="comment">// if(adder_op1[7] | adder_op1[6] | adder_op1[5] | adder_op1[4] | adder_op1[3]) begin</span></span><br><span class="line">                <span class="comment">//     result = 8&#x27;b0; // 右移后全零</span></span><br><span class="line">                <span class="comment">// end else begin</span></span><br><span class="line">                result = op2 &gt;&gt; op1;</span><br><span class="line">                <span class="comment">// end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// 逻辑运算</span></span><br><span class="line">            <span class="number">3&#x27;b100</span>: <span class="keyword">begin</span>  <span class="comment">// 与（AND）</span></span><br><span class="line">        adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                result = op1 &amp; op2;</span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>;  <span class="comment">// 逻辑运算清零CF</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b101</span>: <span class="keyword">begin</span>  <span class="comment">// 或（OR）</span></span><br><span class="line">        adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                result = op1 | op2;</span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b110</span>: <span class="keyword">begin</span>  <span class="comment">// 与非（NAND）</span></span><br><span class="line">        adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                result = ~(op1 &amp; op2);</span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b111</span>: <span class="keyword">begin</span>  <span class="comment">// 异或（XOR）</span></span><br><span class="line">        adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                result = op1 ^ op2;</span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Adder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  op1,     <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  op2,     <span class="comment">// 操作数2</span></span><br><span class="line">    <span class="keyword">input</span>        suben,   <span class="comment">// 减法使能（1=减法）</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] sum,     <span class="comment">// 和/差结果</span></span><br><span class="line">    <span class="keyword">output</span>       co       <span class="comment">// 进位/借位</span></span><br><span class="line">);</span><br><span class="line">    <span class="comment">// 减法转换为补码加法</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] adj_op2 = op2 ^ &#123;<span class="number">8</span>&#123;suben&#125;&#125;;</span><br><span class="line">    <span class="keyword">wire</span> cin = suben;     <span class="comment">// 减法时cin=1（补码+1）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成位（Generate）和传播位（Propagate）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] G = op1 &amp; adj_op2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] P = op1 ^ adj_op2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超前进位计算（分组优化）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] C;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = cin;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4位组间进位（关键优化点）</span></span><br><span class="line">    <span class="keyword">wire</span> C4 = G[<span class="number">3</span>] | (P[<span class="number">3</span>] &amp; G[<span class="number">2</span>]) | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | </span><br><span class="line">              (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">4</span>] = C4;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">5</span>] = G[<span class="number">4</span>] | (P[<span class="number">4</span>] &amp; C4);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">6</span>] = G[<span class="number">5</span>] | (P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">7</span>] = G[<span class="number">6</span>] | (P[<span class="number">6</span>] &amp; G[<span class="number">5</span>]) | (P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终进位和结果</span></span><br><span class="line">    <span class="keyword">assign</span> co = suben ^ (G[<span class="number">7</span>] | (P[<span class="number">7</span>] &amp; G[<span class="number">6</span>]) | (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; G[<span class="number">5</span>]) | </span><br><span class="line">                (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4));</span><br><span class="line">    <span class="keyword">assign</span> sum = P ^ C;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>ALU信号指示图：<br><img src="/img/HD/CPU_8bit/ALU_1.png" alt="ALU"></p><p>• <strong>ALU总体顶部模块实现</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU(databus,inbus,clk,alua_in,alub_in,sel,cf);</span><br><span class="line">  (* keep, preserve *)<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] databus;       <span class="comment">// 统一数据总线</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] inbus;</span><br><span class="line">  <span class="keyword">input</span> clk;</span><br><span class="line">  <span class="keyword">input</span> alua_in;</span><br><span class="line">  <span class="keyword">input</span> alub_in;</span><br><span class="line">  <span class="keyword">input</span>[<span class="number">2</span>:<span class="number">0</span>] sel;</span><br><span class="line">  <span class="keyword">output</span> cf;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] op1;</span><br><span class="line">  <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] op2;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] result;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  OPReg A(clk,alua_in,inbus,op1);</span><br><span class="line">    OPReg B(clk, alub_in,inbus,op2);</span><br><span class="line">  ALUCore u1(op1,op2,sel,result,cf);</span><br><span class="line">  <span class="comment">// OutputBufReg R(clk,result,alu_out,databus);</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">      databus&lt;=result;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>输入端口包含如下：<br>inbus：用于接受数据总线上面的数据，与 alua_in、alub_in、sel 信号配合使用<br>alua_in：用于接受数据总线上面的操作数 a 的数据（四位操作数）<br>alub_in：用于接受数据总线上面的操作数 b 的数据（四位操作数）<br>sel：用于接受数据总线上面的操作符 sel 的数据（3为操作码）<br>cf：进位标识符，若想扩展进位信号，只需要新建一个寄存器将输入与 cf 连接即可</p><p>输出端口包含如下：<br>op1：输入缓冲寄存器（OPReg A）接受数据后将数据输出给计算核心（ALUCore）的输出线路<br>op2：输入缓冲寄存器（OPReg B）接受数据后将数据输出给计算核心（ALUCore）的输出线路<br>result：计算核心（ALUCore）计算结果后的输出线路</p><p>• <strong>ALU输入缓冲寄存器</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> OPReg(clk,we,din,dout);</span><br><span class="line">  <span class="keyword">input</span> clk;</span><br><span class="line">  <span class="keyword">input</span> we;</span><br><span class="line">  <span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] din;</span><br><span class="line">  <span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] dout;</span><br><span class="line">  <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] dout;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(we==<span class="number">1&#x27;b1</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      dout &lt;= din;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>当 we 使能信号为有效时，将总线上面的数据锁存起来，结构较为简单，不再赘述</p><p>• <strong>加法器实现</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Adder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  op1,     <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  op2,     <span class="comment">// 操作数2</span></span><br><span class="line">    <span class="keyword">input</span>        suben,   <span class="comment">// 减法使能（1=减法）</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] sum,     <span class="comment">// 和/差结果</span></span><br><span class="line">    <span class="keyword">output</span>       co       <span class="comment">// 进位/借位</span></span><br><span class="line">);</span><br><span class="line">    <span class="comment">// 减法转换为补码加法</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] adj_op2 = op2 ^ &#123;<span class="number">8</span>&#123;suben&#125;&#125;;</span><br><span class="line">    <span class="keyword">wire</span> cin = suben;     <span class="comment">// 减法时cin=1（补码+1）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成位（Generate）和传播位（Propagate）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] G = op1 &amp; adj_op2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] P = op1 ^ adj_op2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超前进位计算（分组优化）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] C;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = cin;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4位组间进位（关键优化点）</span></span><br><span class="line">    <span class="keyword">wire</span> C4 = G[<span class="number">3</span>] | (P[<span class="number">3</span>] &amp; G[<span class="number">2</span>]) | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | </span><br><span class="line">              (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">4</span>] = C4;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">5</span>] = G[<span class="number">4</span>] | (P[<span class="number">4</span>] &amp; C4);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">6</span>] = G[<span class="number">5</span>] | (P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">7</span>] = G[<span class="number">6</span>] | (P[<span class="number">6</span>] &amp; G[<span class="number">5</span>]) | (P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终进位和结果</span></span><br><span class="line">    <span class="keyword">assign</span> co = suben ^ (G[<span class="number">7</span>] | (P[<span class="number">7</span>] &amp; G[<span class="number">6</span>]) | (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; G[<span class="number">5</span>]) | </span><br><span class="line">                (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4));</span><br><span class="line">    <span class="keyword">assign</span> sum = P ^ C;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>输入输出如注释所示，下面介绍一下该加法器的加减二路选择功能以及串并联混用逻辑：</p><p>超前进位计算技术介绍：</p><p>若我们在加法计算中每一位都通过上一位的数据以及是否需要进位来判断下一位是否需要进位，那么我们所设计的电路就是8路串行，串行效率是不如并行的，首先串行代码应当如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> C[<span class="number">0</span>] = cin;</span><br><span class="line"><span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; cin);       <span class="comment">// 第0位进位</span></span><br><span class="line"><span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; C[<span class="number">0</span>]);      <span class="comment">// 第1位进位</span></span><br><span class="line"><span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; C[<span class="number">1</span>]);      <span class="comment">// 第2位进位</span></span><br><span class="line"><span class="keyword">assign</span> C[<span class="number">4</span>] = G[<span class="number">3</span>] | (P[<span class="number">3</span>] &amp; C[<span class="number">2</span>]);      <span class="comment">// 第3位进位</span></span><br><span class="line"><span class="keyword">assign</span> C[<span class="number">5</span>] = G[<span class="number">4</span>] | (P[<span class="number">4</span>] &amp; C[<span class="number">3</span>]);      <span class="comment">// 第4位进位</span></span><br><span class="line"><span class="keyword">assign</span> C[<span class="number">6</span>] = G[<span class="number">5</span>] | (P[<span class="number">5</span>] &amp; C[<span class="number">4</span>]);      <span class="comment">// 第5位进位</span></span><br><span class="line"><span class="keyword">assign</span> C[<span class="number">7</span>] = G[<span class="number">6</span>] | (P[<span class="number">6</span>] &amp; C[<span class="number">5</span>]);      <span class="comment">// 第6位进位</span></span><br><span class="line"><span class="keyword">assign</span> co = G[<span class="number">7</span>] | (P[<span class="number">7</span>] &amp; C[<span class="number">6</span>]);      <span class="comment">// 第7位进位</span></span><br></pre></td></tr></table></figure><p><strong>（注意）：C[i]表示的是第i位是否需要进位</strong></p><p>显然，我们是可以将 C[i] 的内容直接套到 C[i + 1] 里面去的，这样就不需要在知道 C[i] 后才能知道，当然，也不可能说八个电路全都用并联法去连接，咱的逻辑单元本来就不富裕，要是<br>到后期发现逻辑单元不够用了将其改成8路串联甚至是一种优化</p><p>因此我们将电路改为4路并联2路串联，就变成了一下这种形式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] C;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = cin;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4位组间进位（关键优化点）</span></span><br><span class="line">    <span class="keyword">wire</span> C4 = G[<span class="number">3</span>] | (P[<span class="number">3</span>] &amp; G[<span class="number">2</span>]) | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | </span><br><span class="line">              (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; C[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">4</span>] = C4;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">5</span>] = G[<span class="number">4</span>] | (P[<span class="number">4</span>] &amp; C4);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">6</span>] = G[<span class="number">5</span>] | (P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">7</span>] = G[<span class="number">6</span>] | (P[<span class="number">6</span>] &amp; G[<span class="number">5</span>]) | (P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终进位和结果</span></span><br><span class="line">    <span class="keyword">assign</span> co = suben ^ (G[<span class="number">7</span>] | (P[<span class="number">7</span>] &amp; G[<span class="number">6</span>]) | (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; G[<span class="number">5</span>]) | </span><br><span class="line">                (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; G[<span class="number">4</span>]) | (P[<span class="number">7</span>] &amp; P[<span class="number">6</span>] &amp; P[<span class="number">5</span>] &amp; P[<span class="number">4</span>] &amp; C4));</span><br></pre></td></tr></table></figure><p>至于这个加法器是如何兼顾减法操作的，若不清楚建议跳转至这篇文章，查看最下面的<br>部分，有详细解答：<a href="https://liujiaxuan69.github.io/2025/06/23/simulated_vending_machine/" title="跳转到自动售货机">自动售货机</a></p><p>• <strong>算数核心实现</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALUCore(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  op1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  op2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>]  sel,    <span class="comment">// 扩展为3位操作码</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] result,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>       cf</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法器接口</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] adder_op1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] adder_op2;</span><br><span class="line">    <span class="keyword">reg</span> suben;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] adder_sum;</span><br><span class="line">    <span class="keyword">wire</span> adder_cout;</span><br><span class="line">    </span><br><span class="line">    Adder u1(adder_op2, adder_op1, suben, adder_sum, adder_cout);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">            <span class="comment">// 算术运算</span></span><br><span class="line">            <span class="number">3&#x27;b000</span>, <span class="number">3&#x27;b001</span>: <span class="keyword">begin</span>  <span class="comment">// 加法/减法</span></span><br><span class="line">                <span class="comment">// 汇编代码其实是左源右目标，所以反过来放</span></span><br><span class="line">                adder_op1 = op1;</span><br><span class="line">                adder_op2 = op2;</span><br><span class="line">                suben = sel[<span class="number">0</span>];</span><br><span class="line">                result = adder_sum;</span><br><span class="line">                cf = adder_cout;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b010</span>: <span class="keyword">begin</span>  <span class="comment">// 左移</span></span><br><span class="line">                adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>; <span class="comment">// 左移不需要减法</span></span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>; <span class="comment">// 左移不产生进位</span></span><br><span class="line">                <span class="comment">// if(adder_op1[7] | adder_op1[6] | adder_op1[5] | adder_op1[4] | adder_op1[3]) begin</span></span><br><span class="line">                <span class="comment">//     result = 8&#x27;b0; // 左移后全零</span></span><br><span class="line">                <span class="comment">// end else begin</span></span><br><span class="line">                result = op2 &lt;&lt; op1;</span><br><span class="line">                <span class="comment">// end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b011</span>: <span class="keyword">begin</span>  <span class="comment">// 右移</span></span><br><span class="line">                adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>; <span class="comment">// 左移不需要减法</span></span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>; <span class="comment">// 左移不产生进位</span></span><br><span class="line">                <span class="comment">// if(adder_op1[7] | adder_op1[6] | adder_op1[5] | adder_op1[4] | adder_op1[3]) begin</span></span><br><span class="line">                <span class="comment">//     result = 8&#x27;b0; // 右移后全零</span></span><br><span class="line">                <span class="comment">// end else begin</span></span><br><span class="line">                result = op2 &gt;&gt; op1;</span><br><span class="line">                <span class="comment">// end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// 逻辑运算</span></span><br><span class="line">            <span class="number">3&#x27;b100</span>: <span class="keyword">begin</span>  <span class="comment">// 与（AND）</span></span><br><span class="line">        adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                result = op1 &amp; op2;</span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>;  <span class="comment">// 逻辑运算清零CF</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b101</span>: <span class="keyword">begin</span>  <span class="comment">// 或（OR）</span></span><br><span class="line">        adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                result = op1 | op2;</span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b110</span>: <span class="keyword">begin</span>  <span class="comment">// 非（NOT）</span></span><br><span class="line">                adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                result = op2 ^ <span class="number">8&#x27;hFF</span>; <span class="comment">// 取反</span></span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b111</span>: <span class="keyword">begin</span>  <span class="comment">// 异或（XOR）</span></span><br><span class="line">        adder_op1 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                adder_op2 = <span class="number">8&#x27;b0</span>;</span><br><span class="line">                suben = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                result = op1 ^ op2;</span><br><span class="line">                cf = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>功能表如下：</p><table><thead><tr><th>操作码 (sel)</th><th>运算类型</th><th>功能描述</th><th>操作数处理 (<code>op1</code>, <code>op2</code>)</th><th>结果 (<code>result</code>)</th><th>进位标志 (<code>cf</code>)</th><th>备注</th></tr></thead><tbody><tr><td><code>3&#39;b000</code></td><td>算术运算</td><td>加法 (<code>op1 + op2</code>)</td><td><code>adder_op1 = op1</code><br><code>adder_op2 = op2</code></td><td><code>adder_sum</code></td><td><code>adder_cout</code></td><td>直接调用加法器</td></tr><tr><td><code>3&#39;b001</code></td><td>算术运算</td><td>减法 (<code>op1 - op2</code>)</td><td><code>adder_op1 = op1</code><br><code>adder_op2 = op2</code><br><code>suben = 1</code></td><td><code>adder_sum</code></td><td><code>suben ^ adder_cout</code></td><td>补码减法，借位取反</td></tr><tr><td><code>3&#39;b010</code></td><td>移位运算</td><td>左移 (<code>op2 &lt;&lt; op1</code>)</td><td>忽略加法器输入</td><td><code>op2 &lt;&lt; op1</code></td><td><code>1&#39;b0</code></td><td>移位位数由 <code>op1</code> 指定</td></tr><tr><td><code>3&#39;b011</code></td><td>移位运算</td><td>右移 (<code>op2 &gt;&gt; op1</code>)</td><td>忽略加法器输入</td><td><code>op2 &gt;&gt; op1</code></td><td><code>1&#39;b0</code></td><td>逻辑右移</td></tr><tr><td><code>3&#39;b100</code></td><td>逻辑运算</td><td>与 (<code>op1 &amp; op2</code>)</td><td>忽略加法器输入</td><td><code>op1 &amp; op2</code></td><td><code>1&#39;b0</code></td><td>按位与</td></tr><tr><td><code>3&#39;b101</code></td><td>逻辑运算</td><td>或 (<code>op1 | op2</code>)</td><td>忽略加法器输入</td><td><code>op1 | op2</code></td><td><code>1&#39;b0</code></td><td>按位或</td></tr><tr><td><code>3&#39;b110</code></td><td>逻辑运算</td><td>非 (<code>~op1</code>)</td><td>忽略加法器输入</td><td><code>~op1</code></td><td><code>1&#39;b0</code></td><td>按位与非</td></tr><tr><td><code>3&#39;b111</code></td><td>逻辑运算</td><td>异或 (<code>op1 ^ op2</code>)</td><td>忽略加法器输入</td><td><code>op1 ^ op2</code></td><td><code>1&#39;b0</code></td><td>按位异或</td></tr></tbody></table><p>加法和减法运算使用的是加法器实现的，因此，也只有这两个命令是需要传递 adder_op1 和 adder_op2 以及 cf 进位标识的，其他情况直接使用 传进来的 op 计算即可，但需要<br>注意的是，其他逻辑运算虽然不需要操控 cf、adder_op1 以及 adder_op2 了，但仍然需要给他们赋值，不然模块会将这些无法实时确定的单元设置为寄存器单元，会导致组合电路<br>时序化</p><h3><span id="三-寄存器组模块设计">三、寄存器组模块设计</span></h3><h4><span id="模块设计">模块设计</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> reg_file(</span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="comment">// 双地址总线接口</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">2</span>:<span class="number">0</span>]  t_addrbus,    <span class="comment">// 目标地址总线</span></span><br><span class="line">  </span><br><span class="line">    (* keep, preserve *)<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus0, <span class="comment">// 双向数据总线（dMDR与寄存器组之间交互线）</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus1, <span class="comment">// 双向数据总线（dMDR与寄存器组之间交互线）</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus2, <span class="comment">// 双向数据总线（dMDR与寄存器组之间交互线）</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus3, <span class="comment">// 双向数据总线（dMDR与寄存器组之间交互线）</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]  inbus <span class="comment">// 输入数据总线（来自ALU或其他模块）</span></span><br><span class="line">);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//------------------------------------------</span></span><br><span class="line">    <span class="comment">// 同步写逻辑</span></span><br><span class="line">    <span class="comment">//------------------------------------------</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 目标寄存器写入（地址有效时）</span></span><br><span class="line">        <span class="keyword">if</span> (t_addrbus[<span class="number">2</span>] == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span>  <span class="comment">// 最高位=0时有效</span></span><br><span class="line">            <span class="keyword">case</span> (t_addrbus[<span class="number">1</span>:<span class="number">0</span>]) <span class="comment">// 低2位选择寄存器</span></span><br><span class="line">                <span class="number">2&#x27;d0</span>: databus0 &lt;= inbus; <span class="comment">// R0</span></span><br><span class="line">                <span class="number">2&#x27;d1</span>: databus1 &lt;= inbus; <span class="comment">// R1</span></span><br><span class="line">                <span class="number">2&#x27;d2</span>: databus2 &lt;= inbus; <span class="comment">// R2</span></span><br><span class="line">                <span class="number">2&#x27;d3</span>: databus3 &lt;= inbus; <span class="comment">// R3</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h4><span id="工作原理">工作原理</span></h4><p>寄存器组模块包含4个8位通用寄存器(R0-R3)，采用多总线架构设计：</p><ol><li><p><strong>输入接口</strong>：</p><ul><li><code>inbus</code>：8位输入数据总线，接收来自ALU或其他模块的数据</li><li><code>t_addrbus</code>：3位目标地址总线，用于选择要写入的寄存器</li></ul></li><li><p><strong>输出接口</strong>：</p><ul><li><code>databus0-3</code>：4个8位双向数据总线，分别对应R0-R3寄存器的输出</li></ul></li><li><p><strong>核心逻辑</strong>：</p><ul><li>寄存器写入操作在时钟下降沿(<code>negedge clk</code>)触发</li><li>地址解码规则：<ul><li><code>t_addrbus[2]</code>为地址有效标志(0&#x3D;有效)</li><li><code>t_addrbus[1:0]</code>选择具体寄存器：<ul><li><code>2&#39;b00</code>：R0</li><li><code>2&#39;b01</code>：R1</li><li><code>2&#39;b10</code>：R2</li><li><code>2&#39;b11</code>：R3</li></ul></li></ul></li></ul></li><li><p><strong>数据流向</strong>：</p><ul><li>写入时：<code>inbus</code>数据在时钟下降沿写入选定寄存器</li><li>读取时：寄存器值持续输出到对应的<code>databus</code>上</li></ul></li></ol><h3><span id="四-指令存储器模块设计">四、指令存储器模块设计</span></h3><h4><span id="模块设计">模块设计</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> inst_mem(</span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]  pc_addr,       <span class="comment">// 程序计数器地址输入</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  databus       <span class="comment">// 数据总线输出</span></span><br><span class="line">);</span><br><span class="line">    <span class="comment">// 存储器配置 - 明确为ROM</span></span><br><span class="line">    (* preserve *)(* romstyle = <span class="string">&quot;M9K&quot;</span> *) <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory [<span class="number">0</span>:<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$readmemb</span>(<span class="string">&quot;program.hex&quot;</span>, memory); <span class="comment">// 覆盖初始化</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同步读取</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        databus &lt;= memory[pc_addr]; <span class="comment">// 输出到总线</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h4><span id="工作原理">工作原理</span></h4><p>指令存储器模块是一个256×8位的只读存储器(ROM)，用于存储程序指令：</p><ol><li><p><strong>输入接口</strong>：</p><ul><li><code>pc_addr</code>：8位地址输入，来自程序计数器(PC)</li><li><code>clk</code>：系统时钟信号</li></ul></li><li><p><strong>输出接口</strong>：</p><ul><li><code>databus</code>：8位数据输出总线，输出当前地址对应的指令</li></ul></li><li><p><strong>核心逻辑</strong>：</p><ul><li>存储器在时钟上升沿(<code>posedge clk</code>)同步读取数据</li><li>根据<code>pc_addr</code>的值从ROM中取出对应地址的指令</li><li>取出的指令通过<code>databus</code>输出</li></ul></li><li><p><strong>初始化方式</strong>：</p><ul><li>使用<code>$readmemb</code>系统任务从”program.hex”文件加载程序</li><li>存储器被综合为FPGA的M9K存储块</li></ul></li></ol><h3><span id="五-主存模块">五、主存模块</span></h3><h4><span id="整体架构">整体架构</span></h4><p>主存系统采用分层设计，由外层包装模块(DataMemoryWrap)和内层存储核心(DataMemory)组成，实现了一个16×8位的RAM存储器系统，具有双地址总线接口和灵活的数据通路控制。</p><h4><span id="外层包装模块datamemorywrap">外层包装模块(DataMemoryWrap)</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DataMemoryWrap(</span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="comment">// 双地址总线接口</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">2</span>:<span class="number">0</span>]  s_addrbus,    <span class="comment">// 源地址总线</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">2</span>:<span class="number">0</span>]  t_addrbus,    <span class="comment">// 目标地址总线</span></span><br><span class="line">    (* keep, preserve *) <span class="keyword">output</span> <span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]  databus,      <span class="comment">// 双向数据总线</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] inbus, <span class="comment">// 输入数据总线</span></span><br><span class="line">    <span class="comment">// 控制信号</span></span><br><span class="line">    <span class="keyword">input</span>       dmdr_iin     <span class="comment">// dMDR输入使能</span></span><br><span class="line">);</span><br><span class="line">    <span class="comment">// [内部信号和DataMemory实例化]</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h5><span id="功能特点">功能特点</span></h5><ol><li><p><strong>双地址总线接口</strong>：</p><ul><li><code>s_addrbus</code>：源地址总线(3位)</li><li><code>t_addrbus</code>：目标地址总线(3位)</li><li>地址<code>3&#39;b100</code>专用于内存访问</li></ul></li><li><p><strong>数据通路控制</strong>：</p><ul><li><code>databus</code>：双向数据总线(8位)，作为内存数据寄存器(MDR)</li><li><code>inbus</code>：输入数据总线(8位)，来自ALU或其他模块</li></ul></li><li><p><strong>控制信号</strong>：</p><ul><li><code>dmdr_iin</code>：MDR输入使能信号，控制数据加载</li></ul></li></ol><h5><span id="工作原理">工作原理</span></h5><ol><li><p><strong>内存访问识别</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> mem_as_target = (t_addrbus == <span class="number">3&#x27;b100</span>); <span class="comment">// 内存作为写入目标</span></span><br><span class="line"><span class="keyword">wire</span> mem_as_source = (s_addrbus == <span class="number">3&#x27;b100</span>); <span class="comment">// 内存作为读取源</span></span><br></pre></td></tr></table></figure></li><li><p><strong>内存接口连接</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> mem_addr = inbus; <span class="comment">// 地址来自输入总线</span></span><br><span class="line"><span class="keyword">assign</span> mem_we = mem_as_target; <span class="comment">// 写使能信号</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数据流控制</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (dmdr_iin)</span><br><span class="line">        databus &lt;= inbus; <span class="comment">// 从总线加载到MDR</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mem_as_source &amp;&amp; ~mem_we)</span><br><span class="line">        databus &lt;= mem_dout; <span class="comment">// 从内存读取到MDR</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><h4><span id="内层存储核心datamemory">内层存储核心(DataMemory)</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DataMemory(</span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]  addr,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]  din,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]  dout,</span><br><span class="line">    <span class="keyword">input</span>         we</span><br><span class="line">);</span><br><span class="line">    (* ramstyle = <span class="string">&quot;no_rw_check, logic&quot;</span> *)</span><br><span class="line">    (* keep, preserve *)<span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory [<span class="number">0</span>:<span class="number">15</span>];</span><br><span class="line">    <span class="comment">// [初始化与读写逻辑]</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h5><span id="存储结构">存储结构</span></h5><ol><li><p><strong>存储容量</strong>：</p><ul><li>16×8位RAM存储器</li><li>使用FPGA逻辑单元实现(<code>ramstyle</code>属性指定)</li></ul></li><li><p><strong>初始化方式</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$readmemb</span>(<span class="string">&quot;data.hex&quot;</span>, memory); <span class="comment">// 从文件加载初始数据</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><h5><span id="读写操作">读写操作</span></h5><ol><li><p><strong>写入时序</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (we) <span class="keyword">begin</span></span><br><span class="line">        memory[addr[<span class="number">3</span>:<span class="number">0</span>]] &lt;= din; <span class="comment">// 同步写入</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><strong>读取特性</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> dout = memory[addr[<span class="number">3</span>:<span class="number">0</span>]]; <span class="comment">// 异步读取</span></span><br></pre></td></tr></table></figure></li></ol><h4><span id="系统协作流程">系统协作流程</span></h4><ol><li><p><strong>内存写入操作</strong>：</p><ul><li>CU设置<code>t_addrbus=3&#39;b100</code>标识内存为目标</li><li>地址通过<code>inbus</code>送入<code>mem_addr</code></li><li>数据通过<code>databus</code>送入内存</li><li>时钟上升沿完成写入</li></ul></li><li><p><strong>内存读取操作</strong>：</p><ul><li>CU设置<code>s_addrbus=3&#39;b100</code>标识内存为源</li><li>地址通过<code>inbus</code>送入<code>mem_addr</code></li><li>数据在下一个时钟下降沿锁存到<code>databus</code></li></ul></li><li><p><strong>MDR加载操作</strong>：</p><ul><li>当<code>dmdr_iin</code>有效时，<code>inbus</code>数据在时钟下降沿加载到<code>databus</code></li></ul></li></ol><h3><span id="六-指令寄存器模块">六、指令寄存器模块</span></h3><h4><span id="模块设计">模块设计</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> IR (</span><br><span class="line">    <span class="comment">// 系统信号</span></span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 双向数据总线接口</span></span><br><span class="line">    (* keep, preserve *) <span class="keyword">output</span> <span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]  databus,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]  inbus,        <span class="comment">// 输入数据总线（来自ALU或其他模块）</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 控制信号</span></span><br><span class="line">    <span class="keyword">input</span>         ir_in,        <span class="comment">// 从总线加载指令（上升沿有效）</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 译码输出</span></span><br><span class="line">    (* keep *)<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]  opcode,       <span class="comment">// 高4位操作码 -&gt; CU（存在3位操作码）</span></span><br><span class="line">    (* keep *)<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]  operand       <span class="comment">// 低4位操作数 -&gt; CU（存在5位操作数为立即数）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4><span id="工作原理">工作原理</span></h4><p>指令寄存器(IR)是CPU中用于暂存当前执行指令的关键组件，具有指令锁存和译码输出功能：</p><ol><li><p><strong>输入接口</strong>：</p><ul><li><code>inbus</code>：8位输入数据总线，接收来自指令存储器的指令</li><li><code>ir_in</code>：控制信号，上升沿有效时加载新指令</li></ul></li><li><p><strong>输出接口</strong>：</p><ul><li><code>databus</code>：8位双向数据总线，可输出当前指令</li><li><code>opcode</code>：4位操作码输出（指令高4位）</li><li><code>operand</code>：4位操作数输出（指令低4位）</li></ul></li><li><p><strong>核心逻辑</strong>：</p><ul><li>在<code>ir_in</code>信号的上升沿将<code>inbus</code>上的指令锁存到内部寄存器</li><li>锁存的指令持续输出到<code>opcode</code>和<code>operand</code>供控制单元(CU)译码</li><li>当前指令可通过<code>databus</code>输出到数据总线</li></ul></li></ol><h4><span id="关键特性">关键特性</span></h4><ol><li><p><strong>指令锁存</strong>：严格在控制信号上升沿锁存指令，确保指令稳定性</p></li><li><p><strong>实时译码</strong>：持续输出操作码和操作数字段，减少控制单元译码延迟</p></li><li><p><strong>双向接口</strong>：既可从总线加载指令，也可将当前指令输出到总线</p></li><li><p><strong>位宽优化</strong>：支持4位操作码和4位操作数输出，满足基本指令集需求</p></li></ol><h4><span id="典型工作流程">典型工作流程</span></h4><ol><li><p><strong>取指阶段</strong>：</p><ul><li>指令存储器将指令送至<code>inbus</code></li><li>CU发出<code>ir_in</code>脉冲信号</li><li>在<code>ir_in</code>上升沿，指令被锁存到IR</li></ul></li><li><p><strong>译码阶段</strong>：</p><ul><li>锁存的指令自动分离为<code>opcode</code>和<code>operand</code></li><li>控制单元根据<code>opcode</code>生成控制信号</li><li><code>operand</code>直接用于执行单元或地址计算</li></ul></li><li><p><strong>指令输出</strong>：</p><ul><li>当需要重新发送当前指令时，IR通过<code>databus</code>输出</li></ul></li></ol><h4><span id="信号时序说明">信号时序说明</span></h4><table><thead><tr><th>信号</th><th>触发条件</th><th>功能描述</th></tr></thead><tbody><tr><td>ir_in</td><td>上升沿</td><td>锁存新指令到IR</td></tr><tr><td>opcode</td><td>持续输出</td><td>当前指令的高4位操作码</td></tr><tr><td>operand</td><td>持续输出</td><td>当前指令的低4位操作数</td></tr><tr><td>databus</td><td>由外部控制</td><td>输出当前指令内容</td></tr></tbody></table><h4><span id="设计特点">设计特点</span></h4><ol><li><p><strong>同步加载</strong>：所有指令加载操作严格同步于控制信号上升沿</p></li><li><p><strong>低延迟译码</strong>：操作码和操作数字段持续输出，无需额外时钟周期</p></li><li><p><strong>灵活接口</strong>：支持指令回读功能，便于实现复杂指令流程</p></li><li><p><strong>资源优化</strong>：仅实现必要功能，保持硬件实现简洁高效</p></li></ol><h3><span id="七-cu模块">七、CU模块</span></h3><p>这个模块应该是整个 CPU 中最重要的模块了，需要根据指令表来译码，其中指令表如下：</p><table><thead><tr><th align="center">编号</th><th align="left">编码(二进制)</th><th align="left">汇编指令</th><th align="left">操作</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">0</td><td align="left"><code>0000xxyy</code></td><td align="left">mov rx, ry</td><td align="left">ry   &lt;&#x3D; rx</td><td align="center"></td></tr><tr><td align="center">1</td><td align="left"><code>0001xxyy</code></td><td align="left">mov rx, (ry)</td><td align="left">(ry) &lt;&#x3D; rx</td><td align="center"></td></tr><tr><td align="center">2</td><td align="left"><code>001iiiii</code></td><td align="left">mov i</td><td align="left">r0   &lt;&#x3D; i</td><td align="center">隐含目的操作数<code>r0</code>，i的高3位补0</td></tr><tr><td align="center">3</td><td align="left"><code>010iiiii</code></td><td align="left">mov (i)</td><td align="left">r0   &lt;&#x3D; (i)</td><td align="center">隐含目的操作数<code>r0</code>，i的高3位补0</td></tr><tr><td align="center">4</td><td align="left"><code>0110xxyy</code></td><td align="left">mov (rx), ry</td><td align="left">ry   &lt;&#x3D; (rx)</td><td align="center"></td></tr><tr><td align="center">5</td><td align="left"><code>01110000</code></td><td align="left">rtn</td><td align="left">PC   &lt;&#x3D; 0</td><td align="center"></td></tr><tr><td align="center">6</td><td align="left"><code>1000xxyy</code></td><td align="left">and rx, ry</td><td align="left">ry   &lt;&#x3D; rx &amp; ry</td><td align="center"></td></tr><tr><td align="center">7</td><td align="left"><code>1001xxyy</code></td><td align="left">or  rx, ry</td><td align="left">ry   &lt;&#x3D; rx | ry</td><td align="center"></td></tr><tr><td align="center">8</td><td align="left"><code>101000xx</code></td><td align="left">not rx</td><td align="left">rx   &lt;&#x3D; ~rx</td><td align="center"></td></tr><tr><td align="center">9</td><td align="left"><code>1011xxyy</code></td><td align="left">xor rx, ry</td><td align="left">ry   &lt;&#x3D; rx ^ ry</td><td align="center"></td></tr><tr><td align="center">13</td><td align="left"><code>1100xxyy</code></td><td align="left">shl rx, ry</td><td align="left">ry &lt;&#x3D; ry &lt;&lt; rx</td><td align="center"></td></tr><tr><td align="center">11</td><td align="left"><code>1101xxyy</code></td><td align="left">add rx, ry</td><td align="left">ry &lt;&#x3D; ry + rx</td><td align="center"></td></tr><tr><td align="center">12</td><td align="left"><code>1110xxyy</code></td><td align="left">shr rx, ry</td><td align="left">ry &lt;&#x3D; ry &gt;&gt; rx</td><td align="center"></td></tr><tr><td align="center">12</td><td align="left"><code>1111xxyy</code></td><td align="left">sub rx, ry</td><td align="left">ry &lt;&#x3D; ry - rx</td><td align="center"></td></tr></tbody></table><p>模块实现如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> CU (</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="keyword">input</span>         rst,          <span class="comment">// 全局复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令接口</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]  opcode,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]  operand,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序地址总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>      pc_reset,       <span class="comment">// PC清零</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        pc_out,         <span class="comment">// PC地址输出使能</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        pc_inc,         <span class="comment">// PC自增</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令寄存器总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        iMDRout,        <span class="comment">// iMDR写入总线</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寄存器组总线控制</span></span><br><span class="line">    <span class="comment">// ALU总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUAin,         <span class="comment">// ALU数据A输入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUBin,         <span class="comment">// ALU数据B输入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUout,         <span class="comment">// ALU数据输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  ALUop,          <span class="comment">// ALU操作选择</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据存储器总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        dmdr_iin,       <span class="comment">// dMDR和总线输入使能</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        dmdr_iout,      <span class="comment">// dMDR和总线输出使能（数据总线输出）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ir_in,          <span class="comment">// 从总线加载指令（上升沿有效）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        imm_out,        <span class="comment">// 立即数输出（低五位）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  s_addrbus,      <span class="comment">// 源地址选择</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  t_addrbus       <span class="comment">// 目标地址选择</span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cur_sta;</span><br><span class="line">    <span class="keyword">reg</span> fetch1_wait; <span class="comment">// 等待信号</span></span><br><span class="line">    <span class="keyword">parameter</span> </span><br><span class="line">        FETCH1   = <span class="number">3&#x27;b000</span>,</span><br><span class="line">        FETCH2   = <span class="number">3&#x27;b001</span>,</span><br><span class="line">        EXEC1    = <span class="number">3&#x27;b010</span>,</span><br><span class="line">        EXEC2    = <span class="number">3&#x27;b011</span>,</span><br><span class="line">        EXEC3    = <span class="number">3&#x27;b100</span>,</span><br><span class="line">        EXEC4    = <span class="number">3&#x27;b101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reg double_clk;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// always @(posedge clk) begin</span></span><br><span class="line">    <span class="comment">//     double_clk &lt;= ~double_clk;</span></span><br><span class="line">    <span class="comment">// end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (cur_sta)</span><br><span class="line">            <span class="comment">// 取指阶段</span></span><br><span class="line">            FETCH1: <span class="keyword">begin</span></span><br><span class="line">                pc_out &lt;= <span class="number">1</span>;            <span class="comment">// PC输出至数据总线</span></span><br><span class="line">                s_addrbus &lt;= <span class="number">3&#x27;b110</span>;    <span class="comment">// 指令存储器读取指令</span></span><br><span class="line">                t_addrbus &lt;= <span class="number">3&#x27;b111</span>;    <span class="comment">// 无目标地址</span></span><br><span class="line">                <span class="keyword">if</span> (fetch1_wait) <span class="keyword">begin</span></span><br><span class="line">                    fetch1_wait &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 取指等待信号复位</span></span><br><span class="line">                    cur_sta &lt;= FETCH1; <span class="comment">// 保持在FETCH1状态</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cur_sta &lt;= FETCH2;    <span class="comment">// 状态转移到FETCH2</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            FETCH2: <span class="keyword">begin</span></span><br><span class="line">                pc_out &lt;= <span class="number">0</span>;            <span class="comment">// PC停止总线输出</span></span><br><span class="line">                s_addrbus &lt;= <span class="number">3&#x27;b111</span>;    <span class="comment">// 停止指令存储器读取指令</span></span><br><span class="line">                iMDRout &lt;= <span class="number">1</span>;           <span class="comment">// 指令数据存储器输出数据至总线</span></span><br><span class="line">                ir_in &lt;= <span class="number">1</span>;             <span class="comment">// 指令寄存器从总线中读取指令</span></span><br><span class="line">                pc_inc &lt;= <span class="number">1</span>;            <span class="comment">// PC自增</span></span><br><span class="line">                cur_sta &lt;= EXEC1;    <span class="comment">// 状态转移到EXEC1</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC1: <span class="keyword">begin</span></span><br><span class="line">                pc_inc &lt;= <span class="number">0</span>;            <span class="comment">// PC停止自增</span></span><br><span class="line">                iMDRout &lt;= <span class="number">0</span>;           <span class="comment">// 指令数据存储器停止输出数据至总线</span></span><br><span class="line">                ir_in &lt;= <span class="number">0</span>;             <span class="comment">// 指令寄存器停止读取指令</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Start</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, ry step1(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx发送数据信息至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;   <span class="comment">// ry接受数据总线上的数据信息</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move rx, (ry) step1(间接寻址)</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx发送数据信息至数据总线</span></span><br><span class="line">                        dmdr_iin &lt;= <span class="number">1</span>;                        <span class="comment">// MDR接收总线数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move i step1(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0010</span>, <span class="number">4&#x27;b0011</span>: <span class="keyword">begin</span></span><br><span class="line">                        imm_out &lt;= <span class="number">1</span>;                        <span class="comment">// IR输出立即数至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b000</span>;                 <span class="comment">// R0存储立即数</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (i) step1(间接寻址)</span></span><br><span class="line">                    <span class="number">4&#x27;b0100</span>, <span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">                        imm_out &lt;= <span class="number">1</span>;                        <span class="comment">// 立即数写入数据总线</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b100</span>;                 <span class="comment">// 主存根据立即数访存</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry step1(间接寻址)</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx输出地址数据至数据总线</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// rtn step1(rtn)</span></span><br><span class="line">                    <span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">                        pc_reset &lt;= <span class="number">1</span>;                       <span class="comment">// PC清零</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and/or/xor/add/sub/shl/shr rx ry step1(alua &lt;= rx)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                cur_sta &lt;= EXEC2;    <span class="comment">// 状态转移到EXEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, ry endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move rx, (ry) step2(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iin &lt;= <span class="number">0</span>;                        <span class="comment">// MDR停止接收总线数据</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;    <span class="comment">// ry发送地址信息至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b100</span>;                 <span class="comment">// 通过总线数据地址信息将对应内存数据存至dMDR</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move i endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0010</span>, <span class="number">4&#x27;b0011</span>: <span class="keyword">begin</span></span><br><span class="line">                        imm_out &lt;= <span class="number">0</span>;                        <span class="comment">// IR停止输出立即数至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                 <span class="comment">// R0停止存储立即数</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (i) step2(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0100</span>, <span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">                        imm_out &lt;= <span class="number">0</span>;                        <span class="comment">// 停止立即数输出</span></span><br><span class="line">                        dmdr_iout &lt;= <span class="number">1</span>;                      <span class="comment">// 主存输出数据至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b000</span>;                 <span class="comment">// R0接受数据总线上的数据</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b100</span>;                 <span class="comment">// 停止主存地址发送数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry step2(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iout &lt;= <span class="number">1</span>;                      <span class="comment">// dMDR输出数据至数据总线</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 主存根据地址数据总线访存</span></span><br><span class="line">                        t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;; <span class="comment">// ry接受数据总线上的数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// rtn endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">                        pc_reset &lt;= <span class="number">0</span>;                       <span class="comment">// PC停止清零</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b100</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// or rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b101</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// xor rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1011</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// not ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1010</span>:  <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b110</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// shl rx, ry (alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1100</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b010</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1101</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// shr rx ry(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b011</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// sub rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1111</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b001</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                <span class="comment">// 状态转移到EXEC3</span></span><br><span class="line">                cur_sta &lt;= EXEC3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC3: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, (ry) endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                      <span class="comment">// 停止源地址发送数据  </span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                 <span class="comment">// 停止目标地址接受数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (i) endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0100</span>, <span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iout &lt;= <span class="number">0</span>;                          <span class="comment">// 主存停止输出数据至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// R0停止接受数据总线上的数据</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iout &lt;= <span class="number">0</span>;                          <span class="comment">// dMDR停止输出数据至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// ry停止接受数据总线上的数据</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and/or/xor/add/sub/shl/shr rx ry step3 (result &lt;= databus)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1010</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        <span class="comment">//clear</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//operate</span></span><br><span class="line">                        ALUout &lt;= <span class="number">1</span>;                         </span><br><span class="line">                        t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;        <span class="comment">// 计算结果写入ry</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="comment">// 状态转移到EXEC4</span></span><br><span class="line">                cur_sta &lt;= EXEC4;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC4: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span> (opcode)</span><br><span class="line">            <span class="comment">// (and/or/not/xor/add/sub/shl/shr rx ry) / add/sub i endstep</span></span><br><span class="line">            <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1010</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1110</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                ALUout &lt;= <span class="number">0</span>;                         </span><br><span class="line">                t_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="comment">// 状态转移到FETCH1</span></span><br><span class="line">            cur_sta &lt;= FETCH1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">            cur_sta &lt;= FETCH1; <span class="comment">// 复位时状态机回到FETCH1</span></span><br><span class="line">            pc_reset &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            pc_out &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// PC输出停止</span></span><br><span class="line">            pc_inc &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// PC自增停止</span></span><br><span class="line">            iMDRout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 指令存储器输出停止</span></span><br><span class="line">            ALUAin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU A输入停止</span></span><br><span class="line">            ALUBin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU B输入停止</span></span><br><span class="line">            ALUout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU输出停止</span></span><br><span class="line">            ALUop &lt;= <span class="number">3&#x27;b000</span>; <span class="comment">// ALU操作码清零</span></span><br><span class="line">            dmdr_iin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 数据存储器输入停止</span></span><br><span class="line">            dmdr_iout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 数据存储器输出停止</span></span><br><span class="line">            ir_in &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 指令寄存器输入停止</span></span><br><span class="line">            imm_out &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 立即数输出停止</span></span><br><span class="line">            s_addrbus &lt;= <span class="number">3&#x27;b111</span>; <span class="comment">// 源地址总线置空</span></span><br><span class="line">            t_addrbus &lt;= <span class="number">3&#x27;b111</span>; <span class="comment">// 目标地址总线置空</span></span><br><span class="line">            fetch1_wait &lt;= <span class="number">1&#x27;b1</span>; <span class="comment">// 清除等待状态</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>CU模块进行节拍控制，一个周期分为6个节拍，第一个节拍和第二个节拍用于取址，后面的节拍则用于指令处理</p><p>CU以输出信号为主，下面是对于每个信号的介绍，其中每一个信号在上面都介绍过，只不过在其他模块是作为输入信号来使用的，而<br>在CU模块中是作为输出信号来使用的，这个也是毋庸置疑的，因为正是 CU 模块来控制各个单元工作</p><p>其中 cur_sta 用于控制当前处于的节拍状态，一共有6个节拍状态，分别为 FETCH1，FETCH2，EXEC1，EXEC2，EXEC3，EXEC4</p><table><thead><tr><th>节拍状态</th><th>功能描述</th></tr></thead><tbody><tr><td>FETCH1</td><td>取指阶段1：PC输出指令地址到总线</td></tr><tr><td>FETCH2</td><td>取指阶段2：指令存储器输出指令到总线并加载到IR</td></tr><tr><td>EXEC1</td><td>执行阶段1：指令译码并准备操作数</td></tr><tr><td>EXEC2</td><td>执行阶段2：执行指令核心操作</td></tr><tr><td>EXEC3</td><td>执行阶段3：处理指令结果</td></tr><tr><td>EXEC4</td><td>执行阶段4：清理状态准备下一条指令</td></tr></tbody></table><p>每个节拍详解如下：</p><table><thead><tr><th>指令类型</th><th>FETCH1</th><th>FETCH2</th><th>EXEC1</th><th>EXEC2</th><th>EXEC3</th><th>EXEC4</th></tr></thead><tbody><tr><td><strong>move rx, ry</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>rx输出到总线<br>ry作为目标</td><td>无操作</td><td>无操作</td><td>无操作</td></tr><tr><td><strong>move rx, (ry)</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>rx输出到总线<br>MDR接收数据</td><td>ry输出地址<br>内存作为目标</td><td>清理总线信号</td><td>无操作</td></tr><tr><td><strong>move i (立即数)</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>立即数输出到总线<br>R0作为目标</td><td>无操作</td><td>无操作</td><td>无操作</td></tr><tr><td><strong>move (i) (内存间接)</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>立即数输出到总线<br>内存作为源</td><td>内存数据输出到总线<br>R0作为目标</td><td>清理总线信号</td><td>无操作</td></tr><tr><td><strong>move (rx), ry</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>rx输出地址到总线</td><td>内存数据输出到总线<br>ry作为目标</td><td>清理总线信号</td><td>无操作</td></tr><tr><td><strong>rtn</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>PC清零</td><td>无操作</td><td>无操作</td><td>无操作</td></tr><tr><td><strong>and&#x2F;or&#x2F;xor rx, ry</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>rx输出到ALU A输入</td><td>ry输出到ALU B输入<br>设置ALU操作码</td><td>ALU结果输出到总线<br>ry作为目标</td><td>清理ALU输出</td></tr><tr><td><strong>not ry</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>无操作</td><td>ry输出到ALU B输入<br>设置ALU操作码</td><td>ALU结果输出到总线<br>ry作为目标</td><td>清理ALU输出</td></tr><tr><td><strong>add&#x2F;sub rx, ry</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>rx输出到ALU A输入</td><td>ry输出到ALU B输入<br>设置ALU操作码</td><td>ALU结果输出到总线<br>ry作为目标</td><td>清理ALU输出</td></tr><tr><td><strong>shl&#x2F;shr rx, ry</strong></td><td>PC输出地址<br>s_addrbus&#x3D;110</td><td>加载指令到IR<br>PC自增</td><td>rx输出到ALU A输入</td><td>ry输出到ALU B输入<br>设置ALU操作码</td><td>ALU结果输出到总线<br>ry作为目标</td><td>清理ALU输出</td></tr></tbody></table><h4><span id="关键控制信号变化">关键控制信号变化</span></h4><h5><span id="取指阶段fetch1-fetch2">取指阶段(FETCH1-FETCH2)</span></h5><table><thead><tr><th>信号</th><th>FETCH1</th><th>FETCH2</th></tr></thead><tbody><tr><td>pc_out</td><td>1</td><td>0</td></tr><tr><td>s_addrbus</td><td>110(指令存储器)</td><td>111(无)</td></tr><tr><td>iMDRout</td><td>0</td><td>1</td></tr><tr><td>ir_in</td><td>0</td><td>1</td></tr><tr><td>pc_inc</td><td>0</td><td>1</td></tr></tbody></table><h5><span id="通用执行阶段exec1-exec4">通用执行阶段(EXEC1-EXEC4)</span></h5><table><thead><tr><th>信号</th><th>EXEC1</th><th>EXEC2</th><th>EXEC3</th><th>EXEC4</th></tr></thead><tbody><tr><td>ALUAin</td><td>算术指令:1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>ALUBin</td><td>0</td><td>算术指令:1</td><td>0</td><td>0</td></tr><tr><td>ALUout</td><td>0</td><td>0</td><td>算术指令:1</td><td>0</td></tr><tr><td>dmdr_iin</td><td>内存指令:1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>dmdr_iout</td><td>0</td><td>内存指令:1</td><td>0</td><td>0</td></tr></tbody></table><h4><span id="指令执行特点">指令执行特点</span></h4><ol><li><strong>统一取指周期</strong>：所有指令共享相同的FETCH1和FETCH2阶段</li><li><strong>内存访问优化</strong>：内存操作需要额外节拍处理地址和数据</li><li><strong>算术指令标准化</strong>：所有算术逻辑指令采用相同的三节拍执行流程</li><li><strong>立即数处理</strong>：立即数移动指令可在两个节拍内完成</li></ol><h2><span id="顶层模块">顶层模块</span></h2><p>最后的任务就是将所有的模块联系起来，放在顶层模块：</p><p>代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> core8(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> n_rst,</span><br><span class="line">    <span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] databus, <span class="comment">// 统一数据总线</span></span><br><span class="line">    (* keep, preserve *) <span class="comment">// 保持信号，防止优化掉</span></span><br><span class="line">    <span class="keyword">output</span> r00,</span><br><span class="line">    <span class="keyword">output</span> r01,</span><br><span class="line">    <span class="keyword">output</span> r02,</span><br><span class="line">    <span class="keyword">output</span> r03,</span><br><span class="line">    <span class="keyword">output</span> r04,</span><br><span class="line">    <span class="keyword">output</span> r05,</span><br><span class="line">    <span class="keyword">output</span> r06,</span><br><span class="line">    <span class="keyword">output</span> r07,</span><br><span class="line">    <span class="comment">// 串口通信接口</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">input</span> rx, <span class="comment">// 串口接收</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">output</span> tx = <span class="number">1</span> <span class="comment">// 串口发送</span></span><br><span class="line">);</span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> rst = ~n_rst; <span class="comment">// 低电平复位信号</span></span><br><span class="line">    </span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> alua_in;</span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> alub_in;</span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> alu_out;</span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span>[<span class="number">2</span>:<span class="number">0</span>] sel;</span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> cf;</span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> zf;</span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> pc_inc; <span class="comment">// 程序计数器自增</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> pc_jump; <span class="comment">// 程序计数器跳转</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> pc_out; <span class="comment">// 程序计数器输出到总线</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> pc_reset; <span class="comment">// 程序计数器复位</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span>[<span class="number">2</span>:<span class="number">0</span>] s_addrbus; <span class="comment">// 源寄存器地址总线</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span>[<span class="number">2</span>:<span class="number">0</span>] t_addrbus; <span class="comment">// 目标寄存器地址总线 </span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> iMDRout;</span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> dmdr_iin; <span class="comment">// 数据存储器输入</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> dmdr_iout; <span class="comment">// 数据存储器输出、</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> ir_in; <span class="comment">// 指令寄存器输入</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span> imm_out; <span class="comment">// 立即数输出</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] opcode; <span class="comment">// 操作码</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] operand; <span class="comment">// 操作数</span></span><br><span class="line">    (* keep, preserve *)<span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> clk_2 = <span class="number">1</span>; <span class="comment">// 二分频时钟输出</span></span><br><span class="line">    <span class="keyword">reg</span> clk_4 = <span class="number">1</span>; <span class="comment">// 四分频时钟输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 各部件数据总线</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] alu_bus;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] pc_bus;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] ir_bus;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] reg_bus[<span class="number">0</span>:<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] imem_bus;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] dmem_bus;</span><br><span class="line">    (* keep, preserve *)<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cur_send_sta = <span class="number">4&#x27;b0000</span>; <span class="comment">// 当前发送状态寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四分频</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        clk_2 &lt;= ~clk_2; <span class="comment">// 反转时钟信号实现二分频</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_2)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        clk_4 &lt;= ~clk_4; <span class="comment">// 反转时钟信号实现四分频</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 对databus多路复用</span></span><br><span class="line">    <span class="keyword">assign</span> databus = </span><br><span class="line">        (pc_out) ? pc_bus :          <span class="comment">// 程序计数器输出</span></span><br><span class="line">        (iMDRout) ? imem_bus :      <span class="comment">// 指令存储器输出</span></span><br><span class="line">        (dmdr_iout) ? dmem_bus :    <span class="comment">// 数据存储器输出</span></span><br><span class="line">        (imm_out) ? ir_bus :          <span class="comment">// 指令寄存器输入</span></span><br><span class="line">        (alu_out) ? alu_bus :       <span class="comment">// ALU输出</span></span><br><span class="line">        s_addrbus[<span class="number">2</span>] == <span class="number">1&#x27;b0</span> ? reg_bus[&#123;s_addrbus[<span class="number">1</span>:<span class="number">0</span>]&#125;] : <span class="comment">// 源寄存器组输出</span></span><br><span class="line">        <span class="number">8&#x27;bzzzz_zzzz</span>;                    <span class="comment">// 寄存器组输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate ALU</span></span><br><span class="line">    ALU alu_inst(</span><br><span class="line">        <span class="variable">.databus</span>(alu_bus),</span><br><span class="line">        <span class="variable">.inbus</span>(databus),</span><br><span class="line">        <span class="variable">.clk</span>(clk_4),</span><br><span class="line">        <span class="variable">.alua_in</span>(alua_in),</span><br><span class="line">        <span class="variable">.alub_in</span>(alub_in),</span><br><span class="line">        <span class="variable">.sel</span>(sel),</span><br><span class="line">        <span class="variable">.cf</span>(cf),</span><br><span class="line">        <span class="variable">.zf</span>(zf) <span class="comment">// 零标志（ZF）</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assign</span> r00 = reg_bus[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> r01 = reg_bus[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> r02 = reg_bus[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">assign</span> r03 = reg_bus[<span class="number">0</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> r04 = reg_bus[<span class="number">0</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">assign</span> r05 = reg_bus[<span class="number">0</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">assign</span> r06 = reg_bus[<span class="number">0</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">assign</span> r07 = reg_bus[<span class="number">0</span>][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------</span></span><br><span class="line">    <span class="comment">// 子模块实例化</span></span><br><span class="line">    <span class="comment">//----------------------------------</span></span><br><span class="line">    <span class="comment">// 程序计数器</span></span><br><span class="line">    PC u_PC (</span><br><span class="line">        <span class="variable">.clk</span>(clk_4),</span><br><span class="line">        <span class="variable">.pc_inc</span>(pc_inc),</span><br><span class="line">        <span class="variable">.pc_jump</span>(pc_jump),</span><br><span class="line">        <span class="variable">.databus</span>(pc_bus),</span><br><span class="line">        <span class="variable">.inbus</span>(databus), <span class="comment">// 输入数据总线（来自ALU或其他模块）</span></span><br><span class="line">        <span class="variable">.reset</span>(pc_reset | rst)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 通用寄存器</span></span><br><span class="line">    reg_file u_reg_file (</span><br><span class="line">        <span class="variable">.clk</span>(clk_4),</span><br><span class="line">        <span class="variable">.t_addrbus</span>(t_addrbus),</span><br><span class="line">        <span class="variable">.databus0</span>(reg_bus[<span class="number">0</span>]),</span><br><span class="line">        <span class="variable">.databus1</span>(reg_bus[<span class="number">1</span>]),</span><br><span class="line">        <span class="variable">.databus2</span>(reg_bus[<span class="number">2</span>]),</span><br><span class="line">        <span class="variable">.databus3</span>(reg_bus[<span class="number">3</span>]),</span><br><span class="line">        <span class="variable">.inbus</span>(databus) </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指令存储器</span></span><br><span class="line">    inst_mem u_inst_mem (</span><br><span class="line">        <span class="variable">.clk</span>(clk_4),</span><br><span class="line">        <span class="variable">.pc_addr</span>(databus),      <span class="comment">// 从总线获取地址</span></span><br><span class="line">        <span class="variable">.databus</span>(imem_bus)      <span class="comment">// 输出到总线</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据存储器</span></span><br><span class="line">    DataMemoryWrap u_data_memory (</span><br><span class="line">        <span class="variable">.clk</span>(clk_4),</span><br><span class="line">        <span class="variable">.s_addrbus</span>(s_addrbus),  <span class="comment">// 源地址总线</span></span><br><span class="line">        <span class="variable">.t_addrbus</span>(t_addrbus),  <span class="comment">// 目标地址总线</span></span><br><span class="line">        <span class="variable">.databus</span>(dmem_bus),      <span class="comment">// 数据总线</span></span><br><span class="line">        <span class="variable">.inbus</span>(databus), <span class="comment">// 输入数据总线（来自ALU或其他模块）</span></span><br><span class="line">        <span class="variable">.dmdr_iin</span>(dmdr_iin)    <span class="comment">// 输入使能</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指令寄存器</span></span><br><span class="line">    IR u_IR (</span><br><span class="line">        <span class="variable">.clk</span>(clk_4),</span><br><span class="line">        <span class="variable">.databus</span>(ir_bus),</span><br><span class="line">        <span class="variable">.inbus</span>(databus), <span class="comment">// 输入数据总线（来自ALU或其他模块）</span></span><br><span class="line">        <span class="variable">.ir_in</span>(ir_in),</span><br><span class="line">        <span class="variable">.opcode</span>(opcode),              <span class="comment">// 内部连接至CU</span></span><br><span class="line">        <span class="variable">.operand</span>(operand)              <span class="comment">// 内部连接至CU</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 控制单元</span></span><br><span class="line">    CU u_CU (</span><br><span class="line">        <span class="variable">.clk</span>(clk_4),</span><br><span class="line">        <span class="variable">.rst</span>(rst),         <span class="comment">// 全局复位信号</span></span><br><span class="line">        <span class="variable">.opcode</span>(opcode),   <span class="comment">// 直接连接IR内部信号</span></span><br><span class="line">        <span class="variable">.operand</span>(operand),</span><br><span class="line">        <span class="variable">.pc_reset</span>(pc_reset),       <span class="comment">// 共用复位</span></span><br><span class="line">        <span class="variable">.pc_out</span>(pc_out),</span><br><span class="line">        <span class="variable">.pc_inc</span>(pc_inc),</span><br><span class="line">        <span class="variable">.pc_jump</span>(pc_jump), <span class="comment">// PC跳转</span></span><br><span class="line">        <span class="variable">.iMDRout</span>(iMDRout),</span><br><span class="line">        <span class="variable">.ALUAin</span>(alua_in),</span><br><span class="line">        <span class="variable">.ALUBin</span>(alub_in),</span><br><span class="line">        <span class="variable">.ALUout</span>(alu_out),</span><br><span class="line">        <span class="variable">.ALUop</span>(sel),</span><br><span class="line">        <span class="variable">.cf</span>(cf),</span><br><span class="line">        <span class="variable">.zf</span>(zf), <span class="comment">// 零标志（ZF）</span></span><br><span class="line">        <span class="variable">.dmdr_iin</span>(dmdr_iin),</span><br><span class="line">        <span class="variable">.dmdr_iout</span>(dmdr_iout),</span><br><span class="line">        <span class="variable">.ir_in</span>(ir_in),</span><br><span class="line">        <span class="variable">.imm_out</span>(imm_out),</span><br><span class="line">        <span class="variable">.s_addrbus</span>(s_addrbus),</span><br><span class="line">        <span class="variable">.t_addrbus</span>(t_addrbus),</span><br><span class="line">        <span class="variable">.cnt</span>(cnt)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h4><span id="模块架构概述">模块架构概述</span></h4><p>core8模块是整个8位CPU的顶层封装，负责协调所有子模块的工作，并通过统一的数据总线实现各组件间的通信。该设计采用剑桥架构，指令和数据使用不同的储存器，访存指令仅能访问数据储存器。</p><h4><span id="主要接口信号">主要接口信号</span></h4><table><thead><tr><th>信号类别</th><th>信号名称</th><th>位宽</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>系统信号</td><td>clk</td><td>1</td><td>输入</td><td>系统时钟</td></tr><tr><td></td><td>rst</td><td>1</td><td>输入</td><td>全局复位</td></tr><tr><td>数据总线</td><td>databus</td><td>8</td><td>双向</td><td>统一数据总线</td></tr><tr><td>调试输出</td><td>r00-r07</td><td>1</td><td>输出</td><td>R0寄存器各位状态</td></tr></tbody></table><h4><span id="地址总线仲裁逻辑">地址总线仲裁逻辑</span></h4><h5><span id="源地址总线s_addrbus控制">源地址总线(s_addrbus)控制</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] reg_bus[<span class="number">0</span>:<span class="number">3</span>]; <span class="comment">// 寄存器组输出总线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器组输出选择</span></span><br><span class="line"><span class="keyword">assign</span> databus = ... s_addrbus[<span class="number">2</span>] == <span class="number">1&#x27;b0</span> ? reg_bus[&#123;s_addrbus[<span class="number">1</span>:<span class="number">0</span>]&#125;] : ...</span><br></pre></td></tr></table></figure><p>源地址编码表：</p><table><thead><tr><th>s_addrbus[2:0]</th><th>选择的源设备</th></tr></thead><tbody><tr><td>000-011</td><td>寄存器R0-R3</td></tr><tr><td>100</td><td>数据存储器</td></tr><tr><td>110</td><td>指令存储器</td></tr><tr><td>其他</td><td>无源设备</td></tr></tbody></table><h5><span id="目标地址总线t_addrbus控制">目标地址总线(t_addrbus)控制</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在reg_file模块中实现</span></span><br><span class="line"><span class="keyword">if</span> (t_addrbus[<span class="number">2</span>] == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span> <span class="comment">// 目标地址有效</span></span><br><span class="line">    <span class="keyword">case</span> (t_addrbus[<span class="number">1</span>:<span class="number">0</span>])</span><br><span class="line">        <span class="number">2&#x27;d0</span>: databus0 &lt;= inbus; <span class="comment">// R0</span></span><br><span class="line">        <span class="number">2&#x27;d1</span>: databus1 &lt;= inbus; <span class="comment">// R1</span></span><br><span class="line">        <span class="number">2&#x27;d2</span>: databus2 &lt;= inbus; <span class="comment">// R2</span></span><br><span class="line">        <span class="number">2&#x27;d3</span>: databus3 &lt;= inbus; <span class="comment">// R3</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>目标地址编码表：</p><table><thead><tr><th>t_addrbus[2:0]</th><th>选择的目标设备</th></tr></thead><tbody><tr><td>000-011</td><td>寄存器R0-R3</td></tr><tr><td>100</td><td>数据存储器</td></tr><tr><td>其他</td><td>无目标设备</td></tr></tbody></table><h4><span id="数据总线仲裁逻辑">数据总线仲裁逻辑</span></h4><h5><span id="总线多路复用器设计">总线多路复用器设计</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> databus = </span><br><span class="line">    (pc_out) ? pc_bus :          <span class="comment">// 程序计数器输出</span></span><br><span class="line">    (iMDRout) ? imem_bus :       <span class="comment">// 指令存储器输出</span></span><br><span class="line">    (dmdr_iout) ? dmem_bus :     <span class="comment">// 数据存储器输出</span></span><br><span class="line">    (imm_out) ? ir_bus :         <span class="comment">// 指令寄存器立即数输出</span></span><br><span class="line">    (alu_out) ? alu_bus :        <span class="comment">// ALU输出</span></span><br><span class="line">    s_addrbus[<span class="number">2</span>] == <span class="number">1&#x27;b0</span> ? reg_bus[&#123;s_addrbus[<span class="number">1</span>:<span class="number">0</span>]&#125;] : <span class="comment">// 寄存器组输出</span></span><br><span class="line">    <span class="number">8&#x27;bzzzz_zzzz</span>;                <span class="comment">// 高阻态</span></span><br></pre></td></tr></table></figure><h5><span id="总线优先级顺序">总线优先级顺序</span></h5><ol><li><strong>程序计数器输出</strong>(pc_out)</li><li><strong>指令存储器输出</strong>(iMDRout)</li><li><strong>数据存储器输出</strong>(dmdr_iout)</li><li><strong>立即数输出</strong>(imm_out)</li><li><strong>ALU输出</strong>(alu_out)</li><li><strong>寄存器组输出</strong>(s_addrbus选择)</li><li><strong>高阻态</strong>(无设备驱动)</li></ol><h4><span id="关键子模块交互">关键子模块交互</span></h4><h5><span id="取指周期数据流">取指周期数据流</span></h5><ol><li>CU置pc_out&#x3D;1，PC地址输出到databus</li><li>指令存储器读取databus上的地址</li><li>CU置iMDRout&#x3D;1，指令数据输出到databus</li><li>CU置ir_in&#x3D;1，指令锁存到IR</li></ol><h5><span id="执行周期数据流示例mov-r0-r1">执行周期数据流示例(MOV R0, R1)</span></h5><ol><li>CU设置s_addrbus&#x3D;001(选择R1)</li><li>R1数据自动输出到databus</li><li>CU设置t_addrbus&#x3D;000(目标R0)</li><li>数据在时钟下降沿写入R0</li></ol><h4><span id="设计特点">设计特点</span></h4><ol><li><strong>统一总线架构</strong>：所有数据传输通过共享的8位databus完成</li><li><strong>严格时序控制</strong>：由CU精确控制各设备的输出使能</li><li><strong>优先级仲裁</strong>：避免总线冲突，确保关键数据优先传输</li><li><strong>同步设计</strong>：所有状态变化发生在时钟边沿</li><li><strong>调试支持</strong>：提供R0寄存器各位状态输出</li></ol><h4><span id="典型工作流程">典型工作流程</span></h4><pre class="mermaid">sequenceDiagram    participant CU    participant PC    participant IMEM    participant IR    participant REG    participant ALU    participant DMEM      CU->>PC: pc_out=1    PC->>databus: 地址    CU->>IMEM: iMDRout=1    IMEM->>databus: 指令    CU->>IR: ir_in=1    IR->>CU: opcode/operand    CU->>REG: s_addrbus=src    REG->>databus: 数据    CU->>ALU: alua_in=1    ALU->>databus: 结果    CU->>REG: t_addrbus=dst</pre><p>该设计通过精心设计的总线仲裁机制，在有限的硬件资源下实现了高效的指令流水线执行。</p><p>最后进行综合测试：</p><p>测试数据如下：</p><table><thead><tr><th>地址</th><th>二进制指令</th><th>操作码</th><th>操作数</th><th>汇编指令</th><th>功能描述</th></tr></thead><tbody><tr><td>0x00</td><td>01001010</td><td>0100</td><td>1010</td><td>mov (i)</td><td>R0 &lt;&#x3D; (0x0A)</td></tr><tr><td>0x01</td><td>01000000</td><td>0100</td><td>0000</td><td>mov (i)</td><td>R0 &lt;&#x3D; (0x00)</td></tr><tr><td>0x02</td><td>00000001</td><td>0000</td><td>0001</td><td>mov r0, r1</td><td>R1 &lt;&#x3D; R0</td></tr><tr><td>0x03</td><td>00100010</td><td>0010</td><td>0010</td><td>mov i</td><td>R0 &lt;&#x3D; 0x02</td></tr><tr><td>0x04</td><td>11110001</td><td>1111</td><td>0001</td><td>sub r0, r1</td><td>R1 &lt;&#x3D; R1 - R0</td></tr><tr><td>0x05</td><td>00100011</td><td>0010</td><td>0011</td><td>mov i</td><td>R0 &lt;&#x3D; 0x03</td></tr><tr><td>0x06</td><td>11010001</td><td>1101</td><td>0001</td><td>add r0, r1</td><td>R1 &lt;&#x3D; R1 + R0</td></tr><tr><td>0x07</td><td>11000001</td><td>1100</td><td>0001</td><td>shl r0, r1</td><td>R1 &lt;&#x3D; R1 &lt;&lt; R0</td></tr><tr><td>0x08</td><td>11100001</td><td>1110</td><td>0001</td><td>shr r0, r1</td><td>R1 &lt;&#x3D; R1 &gt;&gt; R0</td></tr><tr><td>0x09</td><td>01001010</td><td>0100</td><td>1010</td><td>mov (i)</td><td>R0 &lt;&#x3D; (0x0A)</td></tr></tbody></table><p>测试结果如下（Quartus仿真）：</p><p><img src="/img/HD/CPU_8bit/8bit_CPU_test1.png" alt="CPU"></p><p>MedelSim仿真：</p><p><img src="/img/HD/CPU_8bit/8bit_CPU_test2.png" alt="CPU"></p><p>两者仿真结果一样，注意到 Quartus 仿真时出现了bug：</p><p><img src="/img/HD/CPU_8bit/8bit_CPU_test_bug1.png" alt="CPU"></p><p>展开数据可以看到结果应当为48，无需在意</p><p><strong>附录</strong><br>注意，因为第四问需要使用到移位指令以及跳转指令，CU 模块中对部分指令进行了修改，详细修改如下：</p><p>指令表：  </p><table><thead><tr><th align="center">编号</th><th align="left">编码(二进制)</th><th align="left">汇编指令</th><th align="left">操作</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">0</td><td align="left"><code>0000xxyy</code></td><td align="left">mov rx, ry</td><td align="left">ry   &lt;&#x3D; rx</td><td align="center"></td></tr><tr><td align="center">1</td><td align="left"><code>0001xxyy</code></td><td align="left">mov rx, (ry)</td><td align="left">(ry) &lt;&#x3D; rx</td><td align="center"></td></tr><tr><td align="center">2</td><td align="left"><code>001iiiii</code></td><td align="left">mov i</td><td align="left">r0   &lt;&#x3D; i</td><td align="center">隐含目的操作数<code>r0</code>，i的高3位补0</td></tr><tr><td align="center">3</td><td align="left"><code>010000yy</code></td><td align="left">jmp ry</td><td align="left">PC   &lt;&#x3D; ry</td><td align="center">无条件跳转</td></tr><tr><td align="center">3</td><td align="left"><code>010001yy</code></td><td align="left">jc  ry</td><td align="left">PC   &lt;&#x3D; ry</td><td align="center">进位时跳转</td></tr><tr><td align="center">3</td><td align="left"><code>010010yy</code></td><td align="left">jz  ry</td><td align="left">PC   &lt;&#x3D; ry</td><td align="center">结果为0时跳转</td></tr><tr><td align="center">4</td><td align="left"><code>0110xxyy</code></td><td align="left">mov (rx), ry</td><td align="left">ry   &lt;&#x3D; (rx)</td><td align="center"></td></tr><tr><td align="center">5</td><td align="left"><code>01110000</code></td><td align="left">rtn</td><td align="left">PC   &lt;&#x3D; 0</td><td align="center"></td></tr><tr><td align="center">6</td><td align="left"><code>1000xxyy</code></td><td align="left">and rx, ry</td><td align="left">ry   &lt;&#x3D; rx &amp; ry</td><td align="center"></td></tr><tr><td align="center">7</td><td align="left"><code>1001xxyy</code></td><td align="left">or  rx, ry</td><td align="left">ry   &lt;&#x3D; rx | ry</td><td align="center"></td></tr><tr><td align="center">8</td><td align="left"><code>101000xx</code></td><td align="left">not rx</td><td align="left">rx   &lt;&#x3D; ~rx</td><td align="center"></td></tr><tr><td align="center">9</td><td align="left"><code>1011xxyy</code></td><td align="left">xor rx, ry</td><td align="left">ry   &lt;&#x3D; rx ^ ry</td><td align="center"></td></tr><tr><td align="center">13</td><td align="left"><code>1100xxyy</code></td><td align="left">shl rx, ry</td><td align="left">ry &lt;&#x3D; ry &lt;&lt; rx</td><td align="center"></td></tr><tr><td align="center">11</td><td align="left"><code>1101xxyy</code></td><td align="left">add rx, ry</td><td align="left">ry &lt;&#x3D; ry + rx</td><td align="center"></td></tr><tr><td align="center">12</td><td align="left"><code>1110xxyy</code></td><td align="left">shr rx, ry</td><td align="left">ry &lt;&#x3D; ry &gt;&gt; rx</td><td align="center"></td></tr><tr><td align="center">12</td><td align="left"><code>1111xxyy</code></td><td align="left">sub rx, ry</td><td align="left">ry &lt;&#x3D; ry - rx</td><td align="center"></td></tr></tbody></table><p>CU 部分代码修改后如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> CU (</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="keyword">input</span>         rst,          <span class="comment">// 全局复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令接口</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]  opcode,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]  operand,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序地址总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>      pc_reset,       <span class="comment">// PC清零</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        pc_out,         <span class="comment">// PC地址输出使能</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        pc_inc,         <span class="comment">// PC自增</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        pc_jump,        <span class="comment">// PC跳转</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令寄存器总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        iMDRout,        <span class="comment">// iMDR写入总线</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寄存器组总线控制</span></span><br><span class="line">    <span class="comment">// ALU总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUAin,         <span class="comment">// ALU数据A输入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUBin,         <span class="comment">// ALU数据B输入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ALUout,         <span class="comment">// ALU数据输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  ALUop,          <span class="comment">// ALU操作选择</span></span><br><span class="line">    <span class="keyword">input</span>             cf,             <span class="comment">// 进位标志（CF）</span></span><br><span class="line">    <span class="keyword">input</span>             zf,             <span class="comment">// 零标志（ZF）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据存储器总线控制</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        dmdr_iin,       <span class="comment">// dMDR和总线输入使能</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        dmdr_iout,      <span class="comment">// dMDR和总线输出使能（数据总线输出）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        ir_in,          <span class="comment">// 从总线加载指令（上升沿有效）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>        imm_out,        <span class="comment">// 立即数输出（低五位）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  s_addrbus,      <span class="comment">// 源地址选择</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]  t_addrbus,      <span class="comment">// 目标地址选择</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]  cnt,</span><br><span class="line">    <span class="keyword">output</span>     [<span class="number">7</span>:<span class="number">0</span>]  next_cnt    </span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cur_sta;</span><br><span class="line">    <span class="keyword">reg</span> fetch1_wait; <span class="comment">// 等待信号</span></span><br><span class="line">    <span class="keyword">parameter</span> </span><br><span class="line">        FETCH1   = <span class="number">3&#x27;b000</span>,</span><br><span class="line">        FETCH2   = <span class="number">3&#x27;b001</span>,</span><br><span class="line">        EXEC1    = <span class="number">3&#x27;b010</span>,</span><br><span class="line">        EXEC2    = <span class="number">3&#x27;b011</span>,</span><br><span class="line">        EXEC3    = <span class="number">3&#x27;b100</span>,</span><br><span class="line">        EXEC4    = <span class="number">3&#x27;b101</span>;</span><br><span class="line"></span><br><span class="line">    Incrementer cnt_inc(</span><br><span class="line">        <span class="variable">.op</span>(cnt),</span><br><span class="line">        <span class="variable">.next_op</span>(next_cnt)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (cur_sta)</span><br><span class="line">            <span class="comment">// 取指阶段</span></span><br><span class="line">            FETCH1: <span class="keyword">begin</span></span><br><span class="line">                pc_out &lt;= <span class="number">1</span>;            <span class="comment">// PC输出至数据总线</span></span><br><span class="line">                s_addrbus &lt;= <span class="number">3&#x27;b110</span>;    <span class="comment">// 指令存储器读取指令</span></span><br><span class="line">                t_addrbus &lt;= <span class="number">3&#x27;b111</span>;    <span class="comment">// 无目标地址</span></span><br><span class="line">                <span class="keyword">if</span> (fetch1_wait) <span class="keyword">begin</span></span><br><span class="line">                    fetch1_wait &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 取指等待信号复位</span></span><br><span class="line">                    cur_sta &lt;= FETCH1; <span class="comment">// 保持在FETCH1状态</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cur_sta &lt;= FETCH2;    <span class="comment">// 状态转移到FETCH2</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            FETCH2: <span class="keyword">begin</span></span><br><span class="line">                pc_out &lt;= <span class="number">0</span>;            <span class="comment">// PC停止总线输出</span></span><br><span class="line">                s_addrbus &lt;= <span class="number">3&#x27;b111</span>;    <span class="comment">// 停止指令存储器读取指令</span></span><br><span class="line">                iMDRout &lt;= <span class="number">1</span>;           <span class="comment">// 指令数据存储器输出数据至总线</span></span><br><span class="line">                ir_in &lt;= <span class="number">1</span>;             <span class="comment">// 指令寄存器从总线中读取指令</span></span><br><span class="line">                pc_inc &lt;= <span class="number">1</span>;            <span class="comment">// PC自增</span></span><br><span class="line">                cur_sta &lt;= EXEC1;    <span class="comment">// 状态转移到EXEC1</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC1: <span class="keyword">begin</span></span><br><span class="line">                pc_inc &lt;= <span class="number">0</span>;            <span class="comment">// PC停止自增</span></span><br><span class="line">                iMDRout &lt;= <span class="number">0</span>;           <span class="comment">// 指令数据存储器停止输出数据至总线</span></span><br><span class="line">                ir_in &lt;= <span class="number">0</span>;             <span class="comment">// 指令寄存器停止读取指令</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Start</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, ry step1(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx发送数据信息至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;   <span class="comment">// ry接受数据总线上的数据信息</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move rx, (ry) step1(间接寻址)</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx发送数据信息至数据总线</span></span><br><span class="line">                        dmdr_iin &lt;= <span class="number">1</span>;                        <span class="comment">// MDR接收总线数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move i step1(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0010</span>, <span class="number">4&#x27;b0011</span>: <span class="keyword">begin</span></span><br><span class="line">                        imm_out &lt;= <span class="number">1</span>;                        <span class="comment">// IR输出立即数至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b000</span>;                 <span class="comment">// R0存储立即数</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// jump</span></span><br><span class="line">                    <span class="number">4&#x27;b0100</span>: <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span> (operand[<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">                            <span class="comment">// ry</span></span><br><span class="line">                            <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                                pc_jump &lt;= <span class="number">1</span>;               <span class="comment">// PC跳转</span></span><br><span class="line">                                s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;; <span class="comment">// 直接跳转到地址</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                            <span class="comment">// jc ry</span></span><br><span class="line">                            <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                                <span class="keyword">if</span> (cf) <span class="keyword">begin</span></span><br><span class="line">                                    pc_jump &lt;= <span class="number">1</span>;           <span class="comment">// PC跳转</span></span><br><span class="line">                                    s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;; <span class="comment">// 直接跳转到地址</span></span><br><span class="line">                                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                                    pc_jump &lt;= <span class="number">0</span>;           <span class="comment">// PC不跳转</span></span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                            <span class="comment">// jz ry</span></span><br><span class="line">                            <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                                <span class="keyword">if</span> (zf) <span class="keyword">begin</span></span><br><span class="line">                                    pc_jump &lt;= <span class="number">1</span>;           <span class="comment">// PC跳转</span></span><br><span class="line">                                    s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;; <span class="comment">// 直接跳转到地址</span></span><br><span class="line">                                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                                    pc_jump &lt;= <span class="number">0</span>;           <span class="comment">// PC不跳转</span></span><br><span class="line">                                <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry step1(间接寻址)</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;    <span class="comment">// rx输出地址数据至数据总线</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// rtn step1(rtn)</span></span><br><span class="line">                    <span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">                        pc_reset &lt;= <span class="number">1</span>;                       <span class="comment">// PC清零</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and/or/xor/add/sub/shl/shr rx ry step1(alua &lt;= rx)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">3</span>:<span class="number">2</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                cur_sta &lt;= EXEC2;    <span class="comment">// 状态转移到EXEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, ry endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move rx, (ry) step2(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iin &lt;= <span class="number">0</span>;                        <span class="comment">// MDR停止接收总线数据</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;    <span class="comment">// ry发送地址信息至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b100</span>;                 <span class="comment">// 通过总线数据地址信息将对应内存数据存至dMDR</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move i endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0010</span>, <span class="number">4&#x27;b0011</span>: <span class="keyword">begin</span></span><br><span class="line">                        imm_out &lt;= <span class="number">0</span>;                        <span class="comment">// IR停止输出立即数至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                 <span class="comment">// R0停止存储立即数</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// jump step2(jump)</span></span><br><span class="line">                    <span class="number">4&#x27;b0100</span>: <span class="keyword">begin</span></span><br><span class="line">                        pc_jump &lt;= <span class="number">0</span>;                       <span class="comment">// PC停止跳转</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                <span class="comment">// 停止目标地址接受数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry step2(move)</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iout &lt;= <span class="number">1</span>;                      <span class="comment">// dMDR输出数据至数据总线</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 主存根据地址数据总线访存</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// rtn endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">                        pc_reset &lt;= <span class="number">0</span>;                       <span class="comment">// PC停止清零</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b100</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// or rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b101</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// xor rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1011</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// not ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1010</span>:  <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b110</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// shl rx, ry (alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1100</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b010</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1101</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// shr rx ry(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b011</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// sub rx ry step2(alub &lt;= ry)</span></span><br><span class="line">                    <span class="number">4&#x27;b1111</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                        ALUAin &lt;= <span class="number">0</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">1</span>;</span><br><span class="line">                        ALUop  &lt;= <span class="number">3&#x27;b001</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                <span class="comment">// 状态转移到EXEC3</span></span><br><span class="line">                cur_sta &lt;= EXEC3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC3: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span> (opcode)</span><br><span class="line">                    <span class="comment">// move rx, (ry) endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0001</span>: <span class="keyword">begin</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                      <span class="comment">// 停止源地址发送数据  </span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                 <span class="comment">// 停止目标地址接受数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (i) endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0100</span>, <span class="number">4&#x27;b0101</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iout &lt;= <span class="number">0</span>;                          <span class="comment">// 主存停止输出数据至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// R0停止接受数据总线上的数据</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// move (rx), ry endstep</span></span><br><span class="line">                    <span class="number">4&#x27;b0110</span>: <span class="keyword">begin</span></span><br><span class="line">                        dmdr_iout &lt;= <span class="number">0</span>;                          <span class="comment">// dMDR停止输出数据至数据总线</span></span><br><span class="line">                        t_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// ry停止接受数据总线上的数据</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;                     <span class="comment">// 停止源地址发送数据</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="comment">// and/or/xor/add/sub/shl/shr rx ry step3 (result &lt;= databus)</span></span><br><span class="line">                    <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1010</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                        <span class="comment">//clear</span></span><br><span class="line">                        s_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">                        ALUBin &lt;= <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//operate</span></span><br><span class="line">                        ALUout &lt;= <span class="number">1</span>;                         </span><br><span class="line">                        t_addrbus &lt;= &#123;<span class="number">1&#x27;b0</span>, operand[<span class="number">1</span>:<span class="number">0</span>]&#125;;        <span class="comment">// 计算结果写入ry</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="comment">// 状态转移到EXEC4</span></span><br><span class="line">                cur_sta &lt;= EXEC4;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            EXEC4: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span> (opcode)</span><br><span class="line">            <span class="comment">// (and/or/not/xor/add/sub/shl/shr rx ry) / add/sub i endstep</span></span><br><span class="line">            <span class="number">4&#x27;b1000</span>, <span class="number">4&#x27;b1001</span>, <span class="number">4&#x27;b1010</span>, <span class="number">4&#x27;b1011</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1101</span>, <span class="number">4&#x27;b1110</span>, <span class="number">4&#x27;b1111</span>, <span class="number">4&#x27;b1100</span>, <span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">                ALUout &lt;= <span class="number">0</span>;                         </span><br><span class="line">                t_addrbus &lt;= <span class="number">3&#x27;b111</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: cur_sta &lt;= cur_sta;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="comment">// 状态转移到FETCH1</span></span><br><span class="line">            cur_sta &lt;= FETCH1;</span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">3</span>] &amp; cnt[<span class="number">4</span>] &amp; cnt[<span class="number">6</span>] &amp; cnt[<span class="number">7</span>]) cnt &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> cnt &lt;= next_cnt;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">            cur_sta &lt;= FETCH1; <span class="comment">// 复位时状态机回到FETCH1</span></span><br><span class="line">            pc_reset &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            pc_out &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// PC输出停止</span></span><br><span class="line">            pc_inc &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// PC自增停止</span></span><br><span class="line">            iMDRout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 指令存储器输出停止</span></span><br><span class="line">            ALUAin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU A输入停止</span></span><br><span class="line">            ALUBin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU B输入停止</span></span><br><span class="line">            ALUout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// ALU输出停止</span></span><br><span class="line">            ALUop &lt;= <span class="number">3&#x27;b000</span>; <span class="comment">// ALU操作码清零</span></span><br><span class="line">            dmdr_iin &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 数据存储器输入停止</span></span><br><span class="line">            dmdr_iout &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 数据存储器输出停止</span></span><br><span class="line">            ir_in &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 指令寄存器输入停止</span></span><br><span class="line">            imm_out &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 立即数输出停止</span></span><br><span class="line">            s_addrbus &lt;= <span class="number">3&#x27;b111</span>; <span class="comment">// 源地址总线置空</span></span><br><span class="line">            t_addrbus &lt;= <span class="number">3&#x27;b111</span>; <span class="comment">// 目标地址总线置空</span></span><br><span class="line">            fetch1_wait &lt;= <span class="number">1&#x27;b1</span>; <span class="comment">// 清除等待状态</span></span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>经测试，需要80ns的时钟周期才能解决延迟导致的数据异常问题，因此顶层模块添加了一个四分频（默认时钟周期为20ns）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 四分频</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        clk_2 &lt;= ~clk_2; <span class="comment">// 反转时钟信号实现二分频</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_2)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        clk_4 &lt;= ~clk_4; <span class="comment">// 反转时钟信号实现四分频</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>将这部分代码加入到顶层模块，然后将各个部件的时钟信号传入换成clk_4即可</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 硬件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quartus2 </tag>
            
            <tag> 性能 </tag>
            
            <tag> CPU </tag>
            
            <tag> 8bit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4bit ALU verilog 设计</title>
      <link href="/2025/06/23/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/4bit_alu/"/>
      <url>/2025/06/23/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/4bit_alu/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%B8%80-%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E7%9A%84%E8%BF%90%E7%AE%97%E9%80%BB%E8%BE%91%E5%8C%85%E8%A3%85%E6%88%90%E5%BA%95%E5%B1%82%E6%A8%A1%E5%9D%97">一、实现所有的运算逻辑，包装成底层模块</a></li><li><a href="#%E4%BA%8C-%E9%A1%B6%E5%B1%82%E6%A8%A1%E5%9D%97%E5%A4%8D%E7%94%A8%E6%89%80%E6%9C%89%E5%AD%90%E6%A8%A1%E5%9D%97">二、顶层模块复用所有子模块</a></li><li><a href="#%E4%B8%89-%E7%BB%93%E6%9E%9C%E9%80%89%E6%8B%A9%E5%99%A8%E5%AE%9E%E7%8E%B0">三、结果选择器实现</a></li><li><a href="#%E5%9B%9B-d%E8%A7%A6%E5%8F%91%E5%99%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%9C%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0">四、D触发器存储结果数据实现</a></li><li><a href="#%E4%BA%94-%E6%9C%80%E7%BB%88%E8%BE%93%E5%87%BA">五、最终输出</a></li></ul><!-- tocstop --><p>设计概要如下：</p><p>CPU中简单的4位ALU（算术逻辑单元）<br>输入信号：第一4位操作数op0[3:0]、第二4位操作数op1[3:0]、功能选择s[2:0]、输出使能信号oe、时钟信号clk<br>输出信号：4位运算结果r[3:0]、进位标志cf<br>设计要求：<br>1、根据功能选择信号s[2:0]选择算术或者逻辑运算功能，s[2:0]值为3’b000（即二进制000B）时为加法运算，3’b001时为减法运算，3’b100时为与运算，3’b101时为或运算，3’b110时为非运算（注意非运算只使用第一4位操作数），3’b111时为异或（XOR）运算。<br>2、运算结果必须先存储在4位结果寄存器（使用D触发器实现）中，clk上升沿时运算结果存入4位结果寄存器，此功能必须实现。<br>3、如果加法发生向更高位进位（运算结果超过4位），则需要将进位存储在一个1位的进位寄存器（使用D触发器实现）中，发生进位存储1，反之存储0；如果减法发生向更高位借位，则需要将借位也存储在与加法相同的进位寄存器中，发生借位存储1，反之存储0；同样是clk上升沿时进位或者借位存入1位进位寄存器。此功能必须实现。<br>4、oe低电平有效，oe高电平时，r[3:0]和cf均为高阻态输出（相当于输出无效）；oe低电平时，r[3:0]等于4位结果寄存器（D触发器）的输出，cf等于1位进位寄存器（D触发器）的输出。</p><p>设计一个四位的ALU直接使用软件思维非常简单，直接疯狂的条件判断就完事了，但值得注意的一点是，我们需要将结果利用 D 触发器保存到寄存器中，然后将寄存器结果与<br>输出结果相连即可：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> alu(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] op0, <span class="comment">// operator0</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] op1, <span class="comment">// operator1</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] s,      <span class="comment">// functional option</span></span><br><span class="line">    <span class="keyword">input</span> clk,              <span class="comment">// clock</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> oe,          <span class="comment">// result enable</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] r,          <span class="comment">// result output</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> cf          <span class="comment">// carry</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] result_reg;    <span class="comment">// 4-bit result register</span></span><br><span class="line">    <span class="keyword">reg</span> cf_reg;              <span class="comment">// carry flag register</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] adder_result; <span class="comment">// output(include carry)</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] logic_result; <span class="comment">// logic calculated result</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] result_raw;   <span class="comment">// final result</span></span><br><span class="line">    <span class="keyword">wire</span>        cf_raw;         <span class="comment">// carry/borrow flag</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arithmetic operation module</span></span><br><span class="line">    <span class="keyword">assign</span> adder_result = (s == <span class="number">3&#x27;b000</span>) ? (op0 + op1) : <span class="comment">// add</span></span><br><span class="line">                        (s == <span class="number">3&#x27;b001</span>) ? (op0 + (~op1 + <span class="number">1</span>)) : <span class="comment">// sub</span></span><br><span class="line">                        <span class="number">5&#x27;b0</span>;</span><br><span class="line">                      </span><br><span class="line">    <span class="comment">// carry/borrow flag calculate</span></span><br><span class="line">    <span class="keyword">assign</span> cf_raw = s == <span class="number">3&#x27;b000</span> ? adder_result[<span class="number">4</span>]:  <span class="comment">// carry or borrow</span></span><br><span class="line">                    s == <span class="number">3&#x27;b001</span> ? (op0 &lt; op1) :</span><br><span class="line">                    <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">    <span class="comment">// logic operation module</span></span><br><span class="line">    <span class="keyword">assign</span> logic_result = (s == <span class="number">3&#x27;b100</span>) ? (op0 &amp; op1) : <span class="comment">// and</span></span><br><span class="line">                        (s == <span class="number">3&#x27;b101</span>) ? (op0 | op1) : <span class="comment">// or</span></span><br><span class="line">                        (s == <span class="number">3&#x27;b110</span>) ? (~op0):        <span class="comment">// not</span></span><br><span class="line">                        (s == <span class="number">3&#x27;b111</span>) ? (op0 ^ op1):  <span class="comment">// xor</span></span><br><span class="line">                        <span class="number">4&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final result choose</span></span><br><span class="line">    <span class="keyword">assign</span> result_raw = (s[<span class="number">2</span>] == <span class="number">1&#x27;b0</span>) ? adder_result[<span class="number">3</span>:<span class="number">0</span>] : <span class="comment">//arithmetic operation</span></span><br><span class="line">                        logic_result[<span class="number">3</span>:<span class="number">0</span>];                     <span class="comment">// logic operation</span></span><br><span class="line">                    </span><br><span class="line">    <span class="comment">// D trigger</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        result_reg &lt;= result_raw;</span><br><span class="line">        cf_reg &lt;= cf_raw;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output control</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!oe) <span class="keyword">begin</span></span><br><span class="line">            r &lt;= result_reg;</span><br><span class="line">            cf &lt;= cf_reg;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            r &lt;= <span class="number">4&#x27;bzzzz</span>;</span><br><span class="line">            cf &lt;= <span class="number">1&#x27;bz</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>是的，C语言咋写你就咋写，当然设计的核心在硬件思维的设计，下面我将基于这个 ALU 的软件思维的初版代码，设计一个纯硬件思维的电路出来</p><h3><span id="一-实现所有的运算逻辑包装成底层模块">一、实现所有的运算逻辑，包装成底层模块</span></h3><h4><span id="1-加减法模块">1、加减法模块</span></h4><p>还记得上一个实验吗，自动售货机，没错，直接把那边的四位加减法器ban过来即可：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FourBitAdder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">input</span> SubEn,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S,</span><br><span class="line">    <span class="keyword">output</span> CO</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] last_B = &#123;<span class="number">4</span>&#123;SubEn&#125;&#125; ^ B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P = last_B ^ A;  </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] G = A &amp; last_B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] C;</span><br><span class="line">    <span class="keyword">wire</span> CI = SubEn;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = CI;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> CO   = SubEn ^ (G[<span class="number">3</span>] | P[<span class="number">3</span>] &amp; C[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">assign</span> S = P ^ C;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>对的对的直接 ban 就可以了，要是不懂怎么实现的建议回去看一下上一篇文章<a href="https://liujiaxuan69.github.io/2025/06/23/simulated_vending_machine/" title="跳转到自动售货机">自动售货机</a></p><h4><span id="2-与x2f或x2f非x2f异或模块">2、与&#x2F;或&#x2F;非&#x2F;异或模块</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FourBitAnder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> S = A &amp; B;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitOrer(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> S = A | B;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitNoer(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> S = ~A;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitXorer(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> S = A ^ B;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>这个太简单了就不解释了，按理来说其实不需要给他们单独设置模块，但这样写更清晰一些</p><h3><span id="二-顶层模块复用所有子模块">二、顶层模块复用所有子模块</span></h3><p>房子造好了自己不会住我就帮不了了哈，首先我得说明一下这个 ALU 的全局逻辑，首先，这个 ALU 涉及6个运算逻辑，即加、减、与、或、非、异或，首先让<br>这些逻辑并行计算所有的结果，也就是所谓的<strong>全路径计算</strong>，流程图如下：</p><pre class="mermaid">graph LR    A[输入数A] --> B[并发数据传递]    C[输入数B] --> B    B --> E[加法器/减法器]    B --> F[与运算]    B --> O[或运算]    B --> P[非运算]    B --> Q[异或运算]    E & F & O & P & Q --> H[结果选择器]    H --> I[输出寄存器]    I --> X[最终输出]</pre><p>复用部分实现如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FourBitAdder add(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.B</span>(op1),</span><br><span class="line">        <span class="variable">.SubEn</span>(s[<span class="number">0</span>]),</span><br><span class="line">        <span class="variable">.S</span>(add_res),</span><br><span class="line">        <span class="variable">.CO</span>(cout)</span><br><span class="line">    );</span><br><span class="line">    FourBitAnder(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.B</span>(op1),</span><br><span class="line">        <span class="variable">.S</span>(and_res)</span><br><span class="line">    );</span><br><span class="line">    FourBitOrer(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.B</span>(op1),</span><br><span class="line">        <span class="variable">.S</span>(or_res)</span><br><span class="line">    );</span><br><span class="line">    FourBitNoer(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.S</span>(no_res)</span><br><span class="line">    );</span><br><span class="line">    FourBitXorer(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.B</span>(op1),</span><br><span class="line">        <span class="variable">.S</span>(xor_res)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4><span id="注意加法和减法使用的是同一个逻辑运算单元"><strong>注意：加法和减法使用的是同一个逻辑运算单元</strong></span></h4><h3><span id="三-结果选择器实现">三、结果选择器实现</span></h3><p>这样一来，我们就只剩下结果选择没有实现了，这里使用 case 语法即可简单实现：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(s)</span><br><span class="line">            <span class="number">3&#x27;b000</span>, <span class="number">3&#x27;b001</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = add_res;</span><br><span class="line">                cf_raw = cout;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b100</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = and_res;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b101</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = or_res;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b110</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = no_res;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b111</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = xor_res;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3><span id="四-d触发器存储结果数据实现">四、D触发器存储结果数据实现</span></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        result_reg &lt;= result_raw;</span><br><span class="line">        cf_reg &lt;= cf_raw;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个实现很简单，在每次上升沿将结果存储到寄存器中即可，利用D触发器作为数据缓冲，保证数据不会乱（消除毛刺）</p><h3><span id="五-最终输出">五、最终输出</span></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~oe) <span class="keyword">begin</span></span><br><span class="line">            r = result_reg;</span><br><span class="line">            cf = cf_reg;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            r = <span class="number">4&#x27;bzzzz</span>;</span><br><span class="line">            cf = <span class="number">1&#x27;bz</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>将寄存器中的值传到输出端，从而实现最终数据输出</p><p>最终代码实现如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> alu(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] op0, <span class="comment">// operator0</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] op1, <span class="comment">// operator1</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] s,      <span class="comment">// functional option</span></span><br><span class="line">    <span class="keyword">input</span> clk,              <span class="comment">// clock</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> oe,          <span class="comment">// result enable</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] r,          <span class="comment">// result output</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> cf          <span class="comment">// carry</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal register</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] result_reg;    <span class="comment">// 4-bit result register</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] add_res, and_res, or_res, no_res, xor_res;</span><br><span class="line">    <span class="keyword">wire</span> cout;</span><br><span class="line">    <span class="keyword">reg</span> cf_reg;              <span class="comment">// carry flag register</span></span><br><span class="line">    <span class="keyword">wire</span> adder_co;</span><br><span class="line">    <span class="keyword">reg</span> adder_op0, adder_op1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] result_raw;   <span class="comment">// final result</span></span><br><span class="line">    <span class="keyword">reg</span>       cf_raw;         <span class="comment">// carry/borrow flag</span></span><br><span class="line">    FourBitAdder add(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.B</span>(op1),</span><br><span class="line">        <span class="variable">.SubEn</span>(s[<span class="number">0</span>]),</span><br><span class="line">        <span class="variable">.S</span>(add_res),</span><br><span class="line">        <span class="variable">.CO</span>(cout)</span><br><span class="line">    );</span><br><span class="line">    FourBitAnder(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.B</span>(op1),</span><br><span class="line">        <span class="variable">.S</span>(and_res)</span><br><span class="line">    );</span><br><span class="line">    FourBitOrer(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.B</span>(op1),</span><br><span class="line">        <span class="variable">.S</span>(or_res)</span><br><span class="line">    );</span><br><span class="line">    FourBitNoer(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.S</span>(no_res)</span><br><span class="line">    );</span><br><span class="line">    FourBitXorer(</span><br><span class="line">        <span class="variable">.A</span>(op0),</span><br><span class="line">        <span class="variable">.B</span>(op1),</span><br><span class="line">        <span class="variable">.S</span>(xor_res)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(s)</span><br><span class="line">            <span class="number">3&#x27;b000</span>, <span class="number">3&#x27;b001</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = add_res;</span><br><span class="line">                cf_raw = cout;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b100</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = and_res;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b101</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = or_res;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b110</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = no_res;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">3&#x27;b111</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = xor_res;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                result_raw = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                cf_raw = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">                    </span><br><span class="line">    <span class="comment">// D trigger</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        result_reg &lt;= result_raw;</span><br><span class="line">        cf_reg &lt;= cf_raw;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output control</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~oe) <span class="keyword">begin</span></span><br><span class="line">            r = result_reg;</span><br><span class="line">            cf = cf_reg;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            r = <span class="number">4&#x27;bzzzz</span>;</span><br><span class="line">            cf = <span class="number">1&#x27;bz</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitAdder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">input</span> SubEn,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S,</span><br><span class="line">    <span class="keyword">output</span> CO</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] last_B = &#123;<span class="number">4</span>&#123;SubEn&#125;&#125; ^ B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P = last_B ^ A;  </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] G = A &amp; last_B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] C;</span><br><span class="line">    <span class="keyword">wire</span> CI = SubEn;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = CI;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> CO   = SubEn ^ (G[<span class="number">3</span>] | P[<span class="number">3</span>] &amp; C[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">assign</span> S = P ^ C;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitAnder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> S = A &amp; B;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitOrer(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> S = A | B;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitNoer(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> S = ~A;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitXorer(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> S = A ^ B;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 硬件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quartus2 </tag>
            
            <tag> ALU </tag>
            
            <tag> 性能 </tag>
            
            <tag> 4bit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟自动售货机（加法器）</title>
      <link href="/2025/06/23/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/simulated_vending_machine/"/>
      <url>/2025/06/23/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/simulated_vending_machine/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E9%A2%98%E7%9B%AE%E5%86%85%E5%AE%B9">题目内容</a></li><li><a href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1">硬件设计</a><ul><li><a href="#inscoin-%E8%BE%93%E5%85%A5%E5%AF%B9%E5%BA%94%E5%8A%A0%E6%95%B0-b-%E6%98%A0%E5%B0%84%E8%A1%A8"><code>inscoin</code> 输入对应加数 <code>B</code> 映射表</a></li></ul></li></ul><!-- tocstop --><h2><span id="题目内容">题目内容</span></h2><p>模拟自动售货机（加法器）<br>输入信号：投币信号inscoin[1:0]、商品价格信号d[3:0]、时钟信号clk<br>输出信号：余额信号q[3:0]、余额不足信号ib<br>设计要求：<br>1、以0.5元作为一个基本计价单位，商品价格和余额均为整数。<br>2、初始时，投币信号inscoin[1:0]值为2’b00（即二进制00B），商品价格信号d[3:0]值为4’b0000（即二进制0000B），余额信号q[3:0]值为4’b0000，余额不足信号ib为低电平。<br>3、投币信号inscoin[0]为高电平表示投入一个0.5元硬币，inscoin[1]为高电平表示投入一个1元硬币，inscoin[1]和inscoin[0]同时为低电平表示未投币，inscoin[1]和inscoin[0]同时为高电平则表示投币无效。<br>4、时钟信号clk有效时（可选用时钟脉冲的上升沿或者下降沿），余额先加上投币额，再试减去商品价格，如果余额足够，最终减去商品价格得到新的余额，余额不足信号为低电平，如果余额不足，则不减商品价格，余额不足信号为高电平。</p><h2><span id="硬件设计">硬件设计</span></h2><p>根据要求，可以先通过软件思维设计出来：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> auto_machine(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] inscoin,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] d,</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] q,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ib);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//额外添加了重置信号（可选）</span></span><br><span class="line">        <span class="keyword">if</span>(reset) <span class="keyword">begin</span></span><br><span class="line">            q = <span class="number">4&#x27;b0</span>;</span><br><span class="line">            ib = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//先判断投币信号，根据信号对余额进行修改</span></span><br><span class="line">            <span class="keyword">case</span>(inscoin)</span><br><span class="line">                <span class="number">2&#x27;b01</span>: q = q + <span class="number">1</span>; <span class="comment">// 0.5</span></span><br><span class="line">                <span class="number">2&#x27;b10</span>: q = q + <span class="number">2</span>; <span class="comment">// 1</span></span><br><span class="line">                <span class="keyword">default</span> q = q;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">    <span class="comment">//对余额处理完后紧接着检测硬币数量是否充足，若充足则扣款</span></span><br><span class="line">            <span class="keyword">if</span>(q &gt;= d) <span class="keyword">begin</span></span><br><span class="line">                q = q - d;</span><br><span class="line">                ib = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                ib = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>利用软件思维设计这道题很简单，波形图结果如下<br><img src="/img/HD/simulated_vending_machine/soft_error1.png" alt="error"><br>基本没有问题，但注意到，因为我们以0.5元作为基本单位，当商品价格为15个单位，而我们手里的余额为14个单位且下一次投币2个单位时，会导致余额先变为（14 + 2）% 16 &#x3D; 0，<br>再去检测就会发现余额不足，因此我们需要解决这种情况</p><p>方法很简单，将余额扩充至5位就可以了：  </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> auto_machine (</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">1</span>:<span class="number">0</span>] inscoin,  <span class="comment">// 投币输入：01=0.5元, 10=1元</span></span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">3</span>:<span class="number">0</span>] d,        <span class="comment">// 商品价格（0~15）</span></span><br><span class="line">    <span class="keyword">input</span>            clk,      <span class="comment">// 时钟</span></span><br><span class="line">    <span class="keyword">input</span>            reset,    <span class="comment">// 异步复位</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] q,        <span class="comment">// 当前余额（0~31）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>       ib        <span class="comment">// 出货标志：0=可出货，1=余额不足</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位初始化</span></span><br><span class="line">            q  = <span class="number">5&#x27;b0</span>;</span><br><span class="line">            ib = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 投币逻辑</span></span><br><span class="line">            <span class="keyword">case</span> (inscoin)</span><br><span class="line">                <span class="number">2&#x27;b01</span>   : q = q + <span class="number">1</span>;  <span class="comment">// 投币0.5元</span></span><br><span class="line">                <span class="number">2&#x27;b10</span>   : q = q + <span class="number">2</span>;  <span class="comment">// 投币1元</span></span><br><span class="line">                <span class="keyword">default</span> : q = q;      <span class="comment">// 无有效投币</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扣款判断</span></span><br><span class="line">            <span class="keyword">if</span> (q &gt;= d) <span class="keyword">begin</span></span><br><span class="line">                q  = q - d;  <span class="comment">// 扣款</span></span><br><span class="line">                ib = <span class="number">1&#x27;b0</span>;   <span class="comment">// 允许出货</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                ib = <span class="number">1&#x27;b1</span>;   <span class="comment">// 余额不足</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/img/HD/simulated_vending_machine/soft_success1.png" alt="success"></p><p>当然，这种软件思维设计逻辑结构会非常复杂:</p><p><img src="/img/HD/simulated_vending_machine/soft_struct1.png" alt="struct"></p><p>所以我们需要基于这一问题设计一个硬件思维的逻辑结构：</p><p><strong>首先实现一个四位加法器替换加法运算：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FourBitAdder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">input</span> CI,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S,</span><br><span class="line">    <span class="keyword">output</span> CO</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P = A ^ B;  </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] G = A &amp; B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = CI;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> CO   = G[<span class="number">3</span>] | P[<span class="number">3</span>] &amp; C[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> S = P ^ C;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>该加法器使用的是3位并联加一位串联，在唐朔飞的《计算机组成原理》第285面的6.23中可以看到实现原理，这里不再赘述，但我加了一个小改动，因为串联电路CO若也通过并联方式<br>来实现的话，那么对于CO而言电路就非常复杂了，实现代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> CO   = G[<span class="number">3</span>] | P[<span class="number">3</span>] &amp; G[<span class="number">2</span>] | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">3</span>] &amp; P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br></pre></td></tr></table></figure><p>会使用相当多的门电路，所以我单独把 CO 设置成了串联电路，即在 C[3] 计算出来后再利用 C[3] 计算 CO，不过经过测试，直接使用书上的格式效率差不多，所谓力大砖飞</p><p>加法器中加的这个数是根据inscoin来判断的，判断如下：</p><h3><span id="inscoin-输入对应加数-b-映射表"><code>inscoin</code> 输入对应加数 <code>B</code> 映射表</span></h3><table><thead><tr><th><code>inscoin</code> (二进制)</th><th>投币类型</th><th><code>B[3:0]</code> (二进制)</th><th><code>B</code> (十进制)</th><th>实际加钱金额</th><th>计算逻辑说明</th></tr></thead><tbody><tr><td><code>00</code></td><td>无效投币</td><td><code>0000</code></td><td>0</td><td>+0 元</td><td><code>B = &#123;2&#39;b00, 0&amp;~0, 0&amp;~0&#125;</code></td></tr><tr><td><code>01</code></td><td>投币0.5元</td><td><code>0001</code></td><td>1</td><td>+0.5 元</td><td><code>B = &#123;2&#39;b00, 0&amp;~1, 1&amp;~0&#125;</code></td></tr><tr><td><code>10</code></td><td>投币1元</td><td><code>0010</code></td><td>2</td><td>+1 元</td><td><code>B = &#123;2&#39;b00, 1&amp;~0, 0&amp;~1&#125;</code></td></tr><tr><td><code>11</code></td><td>无效投币</td><td><code>0000</code></td><td>0</td><td>+0 元</td><td><code>B = &#123;2&#39;b00, 1&amp;~1, 1&amp;~1&#125;</code></td></tr></tbody></table><h4><span id="计算公式">计算公式</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] B = &#123;<span class="number">2&#x27;b00</span>, inscoin[<span class="number">1</span>] &amp; ~inscoin[<span class="number">0</span>], inscoin[<span class="number">0</span>] &amp; ~inscoin[<span class="number">1</span>]&#125;;</span><br></pre></td></tr></table></figure><p>计算过程如下：<br>首先01和10两种情况加上的数就是0001和0010，因此这两种情况直接将 inscoin 的两位数作为最低数即可，而当遇到 inscoin 为00或11时加上得数应当为0，<br>因此，在 inscoin 两位异或为1时加数是有效的，否则为0，故：</p><p>B[1] &#x3D; inscoin[1] &amp; (inscoin[0] ^ inscoin[1]) &#x3D; inscoins[1] &amp; ~inscoin[0] (化简过程自己脑补)<br>B[0] &#x3D; inscoin[0] &amp; (inscoin[1] ^ inscoin[0]) &#x3D; inscoins[0] &amp; ~inscoin[1] (你知道我要说什么的)</p><p>还有一种方法，利用真值表，可以看到01时低位为1，10时高位为1，所以可以直接拼接出线路来，利用真值表更简单易懂</p><p>其次是溢出判断，显然，若出现溢出，一定是因为遇到了14+2的情况（15+1不可能，因为商品价格最高也就是15）此时的商品价格也就是15，因此这种情况特判直接将余额改为1<br>即可（14+2-15）</p><p>优化后代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> auto_machine (</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">1</span>:<span class="number">0</span>] inscoin,  <span class="comment">// 投币：01=0.5元, 10=1元</span></span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">3</span>:<span class="number">0</span>] d,        <span class="comment">// 商品价格（0~15，单位0.5元）</span></span><br><span class="line">    <span class="keyword">input</span>            clk,      <span class="comment">// 时钟</span></span><br><span class="line">    <span class="keyword">input</span>            reset,    <span class="comment">// 复位</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] q,        <span class="comment">// 余额（0~15，单位0.5元）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>       ib        <span class="comment">// 余额不足标志</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] B = &#123;<span class="number">2&#x27;b00</span>, inscoin[<span class="number">1</span>] &amp; ~inscoin[<span class="number">0</span>], inscoin[<span class="number">0</span>] &amp; ~inscoin[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化加法器</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] add_result;</span><br><span class="line">    <span class="keyword">wire</span> carry_out;</span><br><span class="line">    FourBitAdder adder (</span><br><span class="line">        <span class="variable">.A</span>(q),</span><br><span class="line">        <span class="variable">.B</span>(B),</span><br><span class="line">        <span class="variable">.CI</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">        <span class="variable">.S</span>(add_result),</span><br><span class="line">        <span class="variable">.CO</span>(carry_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            q  &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            ib &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 处理溢出特例</span></span><br><span class="line">            <span class="keyword">if</span> (carry_out) <span class="keyword">begin</span></span><br><span class="line">                q  &lt;= <span class="number">1</span>;  <span class="comment">// 16 - 15 = 1</span></span><br><span class="line">                ib &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            <span class="comment">// 正常情况（无溢出）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 先更新余额（仅当投币有效时）</span></span><br><span class="line">                <span class="keyword">if</span> (inscoin[<span class="number">1</span>] ^ inscoin[<span class="number">0</span>]) <span class="keyword">begin</span>  <span class="comment">// inscoin=01或10</span></span><br><span class="line">                    q &lt;= add_result;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">// 扣款判断</span></span><br><span class="line">                <span class="keyword">if</span> (add_result &gt;= d) <span class="keyword">begin</span></span><br><span class="line">                    q  &lt;= add_result - d;</span><br><span class="line">                    ib &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    ib &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitAdder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">input</span> CI,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S,</span><br><span class="line">    <span class="keyword">output</span> CO</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P = A ^ B;  </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] G = A &amp; B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] C;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = CI;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> CO   = G[<span class="number">3</span>] | (P[<span class="number">3</span>] &amp; C[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">assign</span> S    = P ^ C;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>再将减法操作改进为加法器实现，这里可以直接复用加法器实现减法器：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FourBitAdder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">input</span> SubEn,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S,</span><br><span class="line">    <span class="keyword">output</span> CO</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> CI = SubEn;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] last_B = &#123;<span class="number">4</span>&#123;SubEn&#125;&#125; ^ B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P = last_B ^ A;  </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] G = A &amp; last_B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] C;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = CI;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> CO   = SubEn ^ (G[<span class="number">3</span>] | (P[<span class="number">3</span>] &amp; C[<span class="number">3</span>]));</span><br><span class="line">    <span class="keyword">assign</span> S    = P ^ C;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加一个SubEn选项，用来决定做加法运算还是减法运算，而我们将SubEn利用 {} 符号作位扩展成4bit，然后分别与 B 异或，这样，减数相当于就会在 SubEn 为1的时候被取反（1异或任何数相当于取反），但是补码还要加一怎么办，很简单，给 CI 赋值 SubEn，这样 CI 就会在减法时变成1，相当于加一了，这样就将加减法综合成了一个芯片。</p><p>为什么最后的 CO 需要与 SubEn 异或呢？道理很简单：<br>设被减数是 a， 减数是 b，那么 a - b &#x3D; a + (~b + 1) &#x3D; a + (16 - b) &#x3D; a + 16 - b; 若 CO 位为1，说明a + 16 - b 溢出，也就说明a - b &gt; 0 &#x3D;&gt; a &gt; b<br>所以如果 CO 为1说明不需要借位，我们需要让 CO 表示是否需要借位，因此在减法运算的时候需要给 CO 取反，也就是将 SubEn 与 CO 异或</p><p>这样一来，比较器当然也可以优化掉，针对以下代码，我们可以根据减法的 CO 来判断减数是否比被减数大，若 CO 位为0，则说明被减数比减数大，此时可以售卖商品</p><p>因此，减法器的borrow_in对我们而言就至关重要，我们叫他is_enough，用于判断用户钱带没带够，将 if 判断中的 add_result &gt;&#x3D; d 修改为 is_enough 即可，最终代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> auto_machine (</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">1</span>:<span class="number">0</span>] inscoin,</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">3</span>:<span class="number">0</span>] d,</span><br><span class="line">    <span class="keyword">input</span>            clk,</span><br><span class="line">    <span class="keyword">input</span>            reset,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] q,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>       ib</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] B = &#123;<span class="number">2&#x27;b00</span>, inscoin[<span class="number">1</span>] &amp; ~inscoin[<span class="number">0</span>], inscoin[<span class="number">0</span>] &amp; ~inscoin[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] add_result, sub_result, comp_d;</span><br><span class="line">    <span class="keyword">wire</span> carry_out, is_enough, unuseful_co;</span><br><span class="line">    FourBitAdder adder (</span><br><span class="line">        <span class="variable">.A</span>(q),</span><br><span class="line">        <span class="variable">.B</span>(B),</span><br><span class="line">        <span class="variable">.SubEn</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">        <span class="variable">.S</span>(add_result),</span><br><span class="line">        <span class="variable">.CO</span>(carry_out)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    FourBitAdder suber (</span><br><span class="line">        <span class="variable">.A</span>(add_result),</span><br><span class="line">        <span class="variable">.B</span>(d),</span><br><span class="line">        <span class="variable">.SubEn</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">        <span class="variable">.S</span>(sub_result),</span><br><span class="line">        <span class="variable">.CO</span>(is_enough)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            q  &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            ib &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (carry_out) <span class="keyword">begin</span></span><br><span class="line">                q  &lt;= <span class="number">1</span>; </span><br><span class="line">                ib &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (inscoin[<span class="number">1</span>] ^ inscoin[<span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">                    q &lt;= add_result;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span> (~is_enough) <span class="keyword">begin</span></span><br><span class="line">                    q  &lt;= sub_result;</span><br><span class="line">                    ib &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    ib &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FourBitAdder(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A, B,</span><br><span class="line">    <span class="keyword">input</span> SubEn,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] S,</span><br><span class="line">    <span class="keyword">output</span> CO</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> CI = SubEn;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] last_B = &#123;<span class="number">4</span>&#123;SubEn&#125;&#125; ^ B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P = last_B ^ A;  </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] G = A &amp; last_B;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] C;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = CI;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">0</span>] | (P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">1</span>] | (P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">2</span>] | (P[<span class="number">2</span>] &amp; G[<span class="number">1</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; G[<span class="number">0</span>]) | (P[<span class="number">2</span>] &amp; P[<span class="number">1</span>] &amp; P[<span class="number">0</span>] &amp; CI);</span><br><span class="line">    <span class="keyword">assign</span> CO   = SubEn ^ (G[<span class="number">3</span>] | (P[<span class="number">3</span>] &amp; C[<span class="number">3</span>]));</span><br><span class="line">    <span class="keyword">assign</span> S    = P ^ C;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>这样就完全规避了加法器，减法器以及比较器，最小化了硬件开销，条件判断开销并不大（均为二路选择器），因此不做优化,测试后没有问题：</p><p><img src="/img/HD/simulated_vending_machine/soft_success2.png" alt="success"></p><p>结构图优化后如下：</p><p><img src="/img/HD/simulated_vending_machine/soft_struct2.png" alt="struct"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 硬件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quartus2 </tag>
            
            <tag> 性能 </tag>
            
            <tag> 加法器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Redis 单线程模型的探讨</title>
      <link href="/2025/06/19/Redis/redis_single_thread_model/"/>
      <url>/2025/06/19/Redis/redis_single_thread_model/</url>
      
        <content type="html"><![CDATA[<blockquote><p>众所周知，Redis 底层使用的是单线程结构，Redis 底层之所以选择这种结构肯定是有原因的，其中最重要的就莫过于多线程可能会出现线程安全的问题<br>（或者说一定吧，时间久了肯定会出事的，正因为这些原因，使用单线程在某种程度上就帮助我们从根源上直接解决了这个问题，在使用单线程结构的时候，<br>用户可能会并发发送多个请求过来，但这就好比学校中午放学，学生会成群结队跑向食堂，但最终肯定还是要排队的（毕竟食堂阿姨不能开多线程）</p></blockquote><p><strong>那么，在我们了解到Redis使用单线程处理任务后，我们该如何理解Redis为何用单线程还能高效地完成任务呢？</strong></p><p>首先得明确，Redis 的高效率是同其他数据库对比而言的<br>1、Redis 管理数据采用的是内存，内存的速度应该是无需多言的吧，对于每个数据处理请求都可以非常快速地完成<br>2、Redis 中的指令不像 MySQL 等关系型数据库，有着复杂的操作命令，如多表连接查询等等时间复杂度可以达到 O(N)以上，Redis中的命令都是简单明了的，不会有<br>高时间复杂度的查询或操作命令，因此也不会因为某些复杂的操作命令导致资源较长时间占用从而导致线程阻塞<br>3、Redis 采用的是单线程框架，它利用了内存访问快不太占用CPU资源的特性以及单线程不用担心线程安全问题的优点，大大提高了其访问效率<br>4、Redis 采用了IO多路转接技术，这种技术可以帮助 Redis 高效处理多客户端请求，通过IO多路转接技术避免了接受用户请求的忙等待，进而提高了效率</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 性能 </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 命令行使用指南</title>
      <link href="/2025/06/16/Redis/redis_command_line_user_guide/"/>
      <url>/2025/06/16/Redis/redis_command_line_user_guide/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#redis-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E5%91%BD%E4%BB%A4"><strong>Redis 命令行中的两个核心（最基础）的命令</strong></a><ul><li><a href="#1set%E5%91%BD%E4%BB%A4">1.set命令</a></li><li><a href="#2get%E5%91%BD%E4%BB%A4">2.get命令</a></li></ul></li><li><a href="#%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83%E7%9A%84%E5%91%BD%E4%BB%A4">全局环境的命令</a><ul><li><a href="#%E4%B8%80-keys">一、keys</a></li><li><a href="#%E4%BA%8C-exists">二、exists</a></li><li><a href="#%E4%B8%89-del">三、del</a></li><li><a href="#%E5%9B%9B-expire-%E5%92%8C-ttlpexpire-%E5%92%8C-pttl">四、expire 和 ttl（pexpire 和 pttl）</a></li><li><a href="#%E4%BA%94-type">五、type</a></li></ul></li></ul><!-- tocstop --><h2><span id="redis-命令行中的两个核心最基础的命令"><strong>Redis 命令行中的两个核心（最基础）的命令</strong></span></h2><h3><span id="1set命令">1.set命令</span></h3><p>基础用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set key value（设置键值对）</span><br><span class="line">example:</span><br><span class="line">127.0.0.1:6379&gt; set key1 value1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key2 value2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set &#x27;key3&#x27; &quot;value3&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>set命令后面的键值对（即key和value）都是字符串数据类型，但我们并不需要给这两个值刻意添加单引号或者双引号，但是添加了也是无伤大雅的</p><h3><span id="2get命令">2.get命令</span></h3><p>基础用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get key（通过键获取对应的值）</span><br><span class="line">example:</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line">&quot;value3&quot;</span><br></pre></td></tr></table></figure><p>但是若尝试访问一个并没有被set的key时，会返回nil(即空)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key4</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h2><span id="全局环境的命令">全局环境的命令</span></h2><h3><span id="一-keys">一、keys</span></h3><p>这个命令可以用来查找所有与查询要求相匹配的 key 值，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure><p>pattern 就是一个匹配条件了，匹配方式如下：<br>在举例之前，我们先插入几个新的键值对方便演示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hello 1</span><br><span class="line">127.0.0.1:6379&gt; set hallo 2</span><br><span class="line">127.0.0.1:6379&gt; set hcllo 3</span><br><span class="line">127.0.0.1:6379&gt; set hllo 4</span><br><span class="line">127.0.0.1:6379&gt; set heeeeeeeeeello 5</span><br></pre></td></tr></table></figure><h4><span id="1-精准匹配">1、精准匹配</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys hello</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys hlllo</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><p>这种匹配方式简单明了，你输入啥他就直接查询你所输入的键，他的作用可能就只能用来查询某个键是否存在了，不过与其这样，通过 exists 命令查询效率会更高</p><h4><span id="2-单字符模糊匹配">2、单字符模糊匹配</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys h?llo</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hcllo&quot;</span><br><span class="line">3) &quot;hallo&quot;</span><br></pre></td></tr></table></figure><p>问号处可以用任意字符替代，符合该要求的键就会被筛选出来</p><h4><span id="3-单字符指定匹配">3、单字符指定匹配</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys h[ac]llo</span><br><span class="line">1) &quot;hcllo&quot;</span><br><span class="line">2) &quot;hallo&quot;</span><br></pre></td></tr></table></figure><p>h和llo中间的字符只能是中括号中的任意一个字符，其余字符则不满足匹配要求</p><h4><span id="4-单字符范围指定匹配">4、单字符范围指定匹配</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys h[b-z]llo</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hcllo&quot;</span><br></pre></td></tr></table></figure><p>与单字符指定匹配相似，这种方式是通过指定某个范围内的字符均可以匹配，如b到z之间的字符都匹配</p><h4><span id="5-内容模糊匹配">5、内容模糊匹配</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys h*llo</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hllo&quot;</span><br><span class="line">3) &quot;heeeeeeeeeello&quot;</span><br><span class="line">4) &quot;hcllo&quot;</span><br><span class="line">5) &quot;hallo&quot;</span><br></pre></td></tr></table></figure><p>‘*’中的内容可以是空字符，也可以是一个字符，也可以是多个字符，只要符合条件都可以匹配</p><h4><span id="6-排斥匹配">6、排斥匹配</span></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys h[^ac]llo</span><br><span class="line">1) &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>上尖括号指的是除此之外的内容都适配，因此在这个示例中，只要中括号中的内容不是a和c，都可以匹配筛选出来排斥匹配可以和上面五中匹配方式自由搭配，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys h[^a-c]llo</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys ^*</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><p>当然，像 keys ^* 就确实是没啥意义了，把自己选择的键全都给排斥掉了，一般也不会有这么用吧（maybe）</p><p>当然呢，keys命令在生产环境当中是不鼓励高频率使用的，因为他的时间复杂度是O(N)，尤其是像 keys * 这样的命令更是不推荐使用，它会将所有的键全部都枚举出来，时间开销极大，肯定是不鼓励使用的，redis若在分布式环境中使用这条指令，是会导致redis的其他进程调度被阻塞住的，不利于生产环境</p><h3><span id="二-exists">二、exists</span></h3><p>这个命令是用来判断某个键值是否存在的，具体用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key [key ...]</span><br></pre></td></tr></table></figure><p>没错，这个命令可以一次查询多个键值是否存在，返回结果为输入的键值中有几个是存在的，示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists hello hbllo hllo</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>因为 hello 和 hllo 是存在的，而 hbllo 不存在，故返回2</p><p>那如果写成下面这种写法可以吗？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists hllo</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists hbllo</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>两种写法均可以查出这三个键值中有几个是存在的，看似两者的性能差不多，但是后者在实际生产环境中的效率肯定是更低的，要记住，redis 和 MySQL 一样，都是处理服务端与客户端之间交互的数据处理媒介，若对三个键值分别查询，就需要走三次网络通信，效率固然是不如一次性查询的，网络通信设计包的封装和分发，性能如何可想而知。当然，若需要知道某个指定的键值是否存在，那肯定是分别查询了</p><h3><span id="三-del">三、del</span></h3><p>这个命令是用来删除 redis 中的键值的，用法和 exists 类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key [key ...]</span><br></pre></td></tr></table></figure><p>同样，这个命令可以单独删除某个键，也可以一次删除多个键，返回值是被删除的键值的数量，用法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 1</span><br><span class="line">127.0.0.1:6379&gt; set k2 2</span><br><span class="line">127.0.0.1:6379&gt; set k3 3</span><br><span class="line">127.0.0.1:6379&gt; del k1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del k2 k3 k4</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>在 redis 中，删除命令就不会像 MySQL 那样风险极高了，因为 redis 一般是用来为 MySQL 分担压力的，对于热点数据，redis 会从 MySQL 中取出，利用内存的高性能从而解决大量的访问请求，若真的不小心删掉了，只需要从类似于 MySQL 这样的关系型数据库中再拿过来就行了，当然，对于某些对性能要求极高的商业场景，直接使用 redis 作为数据库，而不是作为一个中间介质，那误删带来的后果还是很大的</p><h3><span id="四-expire-和-ttlpexpire-和-pttl">四、expire 和 ttl（pexpire 和 pttl）</span></h3><p>expire 和 ttl命令通常是关联起来使用的，分别用来设置过期时间和查询剩余过期时间，单位为秒，而 pexpire 和 pttl 用法和 expire 以及 ttl一样，只不过时间单位是毫秒，因此这里我们只通过对 expire 和 ttl 的用法进行说明和举例，用法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">ttl key</span><br></pre></td></tr></table></figure><p>其中 expire 设置过期时间成功则返回1，否则返回0，而 ttl 正常则返回剩余过期时间，若返回-1则表明没有关联过期时间，若返回-2则表明 key 值不存在<br>下面是一个使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//k1 未被创建时查看 k1 剩余过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) -2</span><br><span class="line">//k1 未被创建时设置 k1 过期时间</span><br><span class="line">127.0.0.1:6379&gt; expire k1 20</span><br><span class="line">(integer) 0</span><br><span class="line">//设置键值 k1</span><br><span class="line">127.0.0.1:6379&gt; set k1 1</span><br><span class="line">OK</span><br><span class="line">//k1 未被设置过期时间时查询剩余过期时间</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) -1</span><br><span class="line">//设置 k1 过期时间</span><br><span class="line">127.0.0.1:6379&gt; expire k1 10</span><br><span class="line">(integer) 1</span><br><span class="line">//k1 距离过期剩余7秒</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 7</span><br><span class="line">//k1 距离过期剩余4秒</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 4</span><br><span class="line">//k1 距离过期剩余1秒</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 1</span><br><span class="line">//k1 已过期，因此查询不到 k1，返回-2</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) -2</span><br><span class="line">//验证 k1 是否已经过期</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>redis 是如何处理过期的key的？</strong><br>这是一个非常经典的面试题，redis 处理过期 key 的方法分为两个策略，分别为定期删除和惰性删除：  定期删除是每隔一段时间 redis 定期检查一部分 key 值是否过期，若过期则将他们删除  惰性删除则是在每次用户对 key 进行操作的时候检查该 key 时候过期，若过期则返回 nil  当然，几遍有了这两种策略，还是很难避免 redis 中有许多一直没有使用的残留 key 没有被及时清理，这就会导致内存有许多空间被不必要地占用了，因此，针对这种情况，redis 还提供了一系列的内存淘汰机制，通过这一套机制，可以基本保障过期 key 值不会对内存造成什么影响</p><p><strong>正如前面所说，Redis 是非常注重效率的，因此，Redis 针对 set 和 expire 这两个命令是做了集合的，也就是说，这两个命令是可以一起使用的</strong><br>命令格式如下；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [expiration EX seconds | PX milliseconds] [NX | XX]</span><br></pre></td></tr></table></figure><p>其中 NX 选项表示的是只有在当前不存在该键值的情况下才能创建对应的键值，也就是说加上了这个选项就无法通过 set 直接修改 key 所对应的 value 了  但通过 XX 选项只有在 key 值存在的情况下才可以修改 key 值，所以，XX 选项意味着 set 命令只能够修改某个 key 所对应的值，而无法创建一个新的键值对  使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 v1 ex 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k2 2 ex 10 XX</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; set k2 2 ex 10 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3><span id="五-type">五、type</span></h3><p>显而易见，这个命令是用来判断 key 所对应的value的类型的，返回值为对应类型，命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><p>下面是一个使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush k1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; type k1</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; set k2 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; type k2</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>综上，redis 中的一些基础命令就讲解完毕了</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 非关系型数据库 </category>
          
          <category> 后端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 命令指导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/05/29/Hello-World/"/>
      <url>/2025/05/29/Hello-World/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客网站</p><!-- ## Quick Start### Create a new post --><!-- ``` bash$ hexo new "My New Post"<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">More info: [Writing](https://hexo.io/docs/writing.html)</span><br><span class="line"></span><br><span class="line">### Run server</span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a> –&gt;</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>-->]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
